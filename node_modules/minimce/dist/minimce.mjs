import { isVue3 as pp, defineComponent as z6, h as ha, ref as Tk, computed as qS, watch as VN, onMounted as qU, unref as GN } from "vue-demi";
function KN(g) {
  const _ = Array.from(g);
  return _[0] = _[0].toUpperCase(), _.unshift("n"), _.unshift("o"), _.join("");
}
function VU(g, _ = []) {
  const D = {}, X = {}, _e = {}, Ae = {}, We = Array.isArray(_) ? _ : Object.keys(_);
  for (const Ke in g)
    if (Ke.startsWith("@")) {
      const Ee = Ke.substring(1);
      pp ? Ee.startsWith("vnode") ? Ae[KN(Ee)] = g[Ke] : _e[KN(Ee)] = g[Ke] : Ee.startsWith("hook:") ? Ae[Ee] = g[Ke] : _e[Ee] = g[Ke];
    } else
      We.includes(Ke) ? D[Ke] = g[Ke] : X[Ke] = g[Ke];
  return {
    props: D,
    attrs: X,
    listeners: _e,
    hooks: Ae
  };
}
var GU = typeof global == "object" && global && global.Object === Object && global;
const A6 = GU;
var KU = typeof self == "object" && self && self.Object === Object && self, YU = A6 || KU || Function("return this")();
const Vi = YU;
var XU = Vi.Symbol;
const Wi = XU;
var N6 = Object.prototype, ZU = N6.hasOwnProperty, QU = N6.toString, _h = Wi ? Wi.toStringTag : void 0;
function JU(g) {
  var _ = ZU.call(g, _h), D = g[_h];
  try {
    g[_h] = void 0;
    var X = !0;
  } catch {
  }
  var _e = QU.call(g);
  return X && (_ ? g[_h] = D : delete g[_h]), _e;
}
var eH = Object.prototype, tH = eH.toString;
function nH(g) {
  return tH.call(g);
}
var oH = "[object Null]", sH = "[object Undefined]", YN = Wi ? Wi.toStringTag : void 0;
function dd(g) {
  return g == null ? g === void 0 ? sH : oH : YN && YN in Object(g) ? JU(g) : nH(g);
}
function qi(g) {
  return g != null && typeof g == "object";
}
var rH = "[object Symbol]";
function rx(g) {
  return typeof g == "symbol" || qi(g) && dd(g) == rH;
}
function aH(g, _) {
  for (var D = -1, X = g == null ? 0 : g.length, _e = Array(X); ++D < X; )
    _e[D] = _(g[D], D, g);
  return _e;
}
var cH = Array.isArray;
const Cc = cH;
var iH = 1 / 0, XN = Wi ? Wi.prototype : void 0, ZN = XN ? XN.toString : void 0;
function R6(g) {
  if (typeof g == "string")
    return g;
  if (Cc(g))
    return aH(g, R6) + "";
  if (rx(g))
    return ZN ? ZN.call(g) : "";
  var _ = g + "";
  return _ == "0" && 1 / g == -iH ? "-0" : _;
}
function Gi(g) {
  var _ = typeof g;
  return g != null && (_ == "object" || _ == "function");
}
function ax(g) {
  return g;
}
var lH = "[object AsyncFunction]", uH = "[object Function]", fH = "[object GeneratorFunction]", dH = "[object Proxy]";
function cx(g) {
  if (!Gi(g))
    return !1;
  var _ = dd(g);
  return _ == uH || _ == fH || _ == lH || _ == dH;
}
var mH = Vi["__core-js_shared__"];
const VS = mH;
var QN = function() {
  var g = /[^.]+$/.exec(VS && VS.keys && VS.keys.IE_PROTO || "");
  return g ? "Symbol(src)_1." + g : "";
}();
function pH(g) {
  return !!QN && QN in g;
}
var gH = Function.prototype, hH = gH.toString;
function md(g) {
  if (g != null) {
    try {
      return hH.call(g);
    } catch {
    }
    try {
      return g + "";
    } catch {
    }
  }
  return "";
}
var yH = /[\\^$.*+?()[\]{}|]/g, bH = /^\[object .+?Constructor\]$/, kH = Function.prototype, wH = Object.prototype, _H = kH.toString, vH = wH.hasOwnProperty, CH = RegExp(
  "^" + _H.call(vH).replace(yH, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function SH(g) {
  if (!Gi(g) || pH(g))
    return !1;
  var _ = cx(g) ? CH : bH;
  return _.test(md(g));
}
function xH(g, _) {
  return g == null ? void 0 : g[_];
}
function pd(g, _) {
  var D = xH(g, _);
  return SH(D) ? D : void 0;
}
var EH = pd(Vi, "WeakMap");
const XS = EH;
var JN = Object.create, TH = function() {
  function g() {
  }
  return function(_) {
    if (!Gi(_))
      return {};
    if (JN)
      return JN(_);
    g.prototype = _;
    var D = new g();
    return g.prototype = void 0, D;
  };
}();
const zH = TH;
function AH(g, _, D) {
  switch (D.length) {
    case 0:
      return g.call(_);
    case 1:
      return g.call(_, D[0]);
    case 2:
      return g.call(_, D[0], D[1]);
    case 3:
      return g.call(_, D[0], D[1], D[2]);
  }
  return g.apply(_, D);
}
function D6(g, _) {
  var D = -1, X = g.length;
  for (_ || (_ = Array(X)); ++D < X; )
    _[D] = g[D];
  return _;
}
var NH = 800, RH = 16, DH = Date.now;
function OH(g) {
  var _ = 0, D = 0;
  return function() {
    var X = DH(), _e = RH - (X - D);
    if (D = X, _e > 0) {
      if (++_ >= NH)
        return arguments[0];
    } else
      _ = 0;
    return g.apply(void 0, arguments);
  };
}
function PH(g) {
  return function() {
    return g;
  };
}
var BH = function() {
  try {
    var g = pd(Object, "defineProperty");
    return g({}, "", {}), g;
  } catch {
  }
}();
const Ok = BH;
var $H = Ok ? function(g, _) {
  return Ok(g, "toString", {
    configurable: !0,
    enumerable: !1,
    value: PH(_),
    writable: !0
  });
} : ax;
const FH = $H;
var IH = OH(FH);
const LH = IH;
function MH(g, _) {
  for (var D = -1, X = g == null ? 0 : g.length; ++D < X && _(g[D], D, g) !== !1; )
    ;
  return g;
}
var jH = 9007199254740991, UH = /^(?:0|[1-9]\d*)$/;
function ix(g, _) {
  var D = typeof g;
  return _ = _ == null ? jH : _, !!_ && (D == "number" || D != "symbol" && UH.test(g)) && g > -1 && g % 1 == 0 && g < _;
}
function Lk(g, _, D) {
  _ == "__proto__" && Ok ? Ok(g, _, {
    configurable: !0,
    enumerable: !0,
    value: D,
    writable: !0
  }) : g[_] = D;
}
function zh(g, _) {
  return g === _ || g !== g && _ !== _;
}
var HH = Object.prototype, WH = HH.hasOwnProperty;
function O6(g, _, D) {
  var X = g[_];
  (!(WH.call(g, _) && zh(X, D)) || D === void 0 && !(_ in g)) && Lk(g, _, D);
}
function hp(g, _, D, X) {
  var _e = !D;
  D || (D = {});
  for (var Ae = -1, We = _.length; ++Ae < We; ) {
    var Ke = _[Ae], Ee = X ? X(D[Ke], g[Ke], Ke, D, g) : void 0;
    Ee === void 0 && (Ee = g[Ke]), _e ? Lk(D, Ke, Ee) : O6(D, Ke, Ee);
  }
  return D;
}
var e6 = Math.max;
function qH(g, _, D) {
  return _ = e6(_ === void 0 ? g.length - 1 : _, 0), function() {
    for (var X = arguments, _e = -1, Ae = e6(X.length - _, 0), We = Array(Ae); ++_e < Ae; )
      We[_e] = X[_ + _e];
    _e = -1;
    for (var Ke = Array(_ + 1); ++_e < _; )
      Ke[_e] = X[_e];
    return Ke[_] = D(We), AH(g, this, Ke);
  };
}
function VH(g, _) {
  return LH(qH(g, _, ax), g + "");
}
var GH = 9007199254740991;
function lx(g) {
  return typeof g == "number" && g > -1 && g % 1 == 0 && g <= GH;
}
function Mk(g) {
  return g != null && lx(g.length) && !cx(g);
}
function KH(g, _, D) {
  if (!Gi(D))
    return !1;
  var X = typeof _;
  return (X == "number" ? Mk(D) && ix(_, D.length) : X == "string" && _ in D) ? zh(D[_], g) : !1;
}
function P6(g) {
  return VH(function(_, D) {
    var X = -1, _e = D.length, Ae = _e > 1 ? D[_e - 1] : void 0, We = _e > 2 ? D[2] : void 0;
    for (Ae = g.length > 3 && typeof Ae == "function" ? (_e--, Ae) : void 0, We && KH(D[0], D[1], We) && (Ae = _e < 3 ? void 0 : Ae, _e = 1), _ = Object(_); ++X < _e; ) {
      var Ke = D[X];
      Ke && g(_, Ke, X, Ae);
    }
    return _;
  });
}
var YH = Object.prototype;
function ux(g) {
  var _ = g && g.constructor, D = typeof _ == "function" && _.prototype || YH;
  return g === D;
}
function XH(g, _) {
  for (var D = -1, X = Array(g); ++D < g; )
    X[D] = _(D);
  return X;
}
var ZH = "[object Arguments]";
function t6(g) {
  return qi(g) && dd(g) == ZH;
}
var B6 = Object.prototype, QH = B6.hasOwnProperty, JH = B6.propertyIsEnumerable, eW = t6(function() {
  return arguments;
}()) ? t6 : function(g) {
  return qi(g) && QH.call(g, "callee") && !JH.call(g, "callee");
};
const Pk = eW;
function tW() {
  return !1;
}
var $6 = typeof exports == "object" && exports && !exports.nodeType && exports, n6 = $6 && typeof module == "object" && module && !module.nodeType && module, nW = n6 && n6.exports === $6, o6 = nW ? Vi.Buffer : void 0, oW = o6 ? o6.isBuffer : void 0, sW = oW || tW;
const Sh = sW;
var rW = "[object Arguments]", aW = "[object Array]", cW = "[object Boolean]", iW = "[object Date]", lW = "[object Error]", uW = "[object Function]", fW = "[object Map]", dW = "[object Number]", mW = "[object Object]", pW = "[object RegExp]", gW = "[object Set]", hW = "[object String]", yW = "[object WeakMap]", bW = "[object ArrayBuffer]", kW = "[object DataView]", wW = "[object Float32Array]", _W = "[object Float64Array]", vW = "[object Int8Array]", CW = "[object Int16Array]", SW = "[object Int32Array]", xW = "[object Uint8Array]", EW = "[object Uint8ClampedArray]", TW = "[object Uint16Array]", zW = "[object Uint32Array]", Ss = {};
Ss[wW] = Ss[_W] = Ss[vW] = Ss[CW] = Ss[SW] = Ss[xW] = Ss[EW] = Ss[TW] = Ss[zW] = !0;
Ss[rW] = Ss[aW] = Ss[bW] = Ss[cW] = Ss[kW] = Ss[iW] = Ss[lW] = Ss[uW] = Ss[fW] = Ss[dW] = Ss[mW] = Ss[pW] = Ss[gW] = Ss[hW] = Ss[yW] = !1;
function AW(g) {
  return qi(g) && lx(g.length) && !!Ss[dd(g)];
}
function fx(g) {
  return function(_) {
    return g(_);
  };
}
var F6 = typeof exports == "object" && exports && !exports.nodeType && exports, Ch = F6 && typeof module == "object" && module && !module.nodeType && module, NW = Ch && Ch.exports === F6, GS = NW && A6.process, RW = function() {
  try {
    var g = Ch && Ch.require && Ch.require("util").types;
    return g || GS && GS.binding && GS.binding("util");
  } catch {
  }
}();
const gp = RW;
var s6 = gp && gp.isTypedArray, DW = s6 ? fx(s6) : AW;
const dx = DW;
var OW = Object.prototype, PW = OW.hasOwnProperty;
function I6(g, _) {
  var D = Cc(g), X = !D && Pk(g), _e = !D && !X && Sh(g), Ae = !D && !X && !_e && dx(g), We = D || X || _e || Ae, Ke = We ? XH(g.length, String) : [], Ee = Ke.length;
  for (var Ie in g)
    (_ || PW.call(g, Ie)) && !(We && (Ie == "length" || _e && (Ie == "offset" || Ie == "parent") || Ae && (Ie == "buffer" || Ie == "byteLength" || Ie == "byteOffset") || ix(Ie, Ee))) && Ke.push(Ie);
  return Ke;
}
function L6(g, _) {
  return function(D) {
    return g(_(D));
  };
}
var BW = L6(Object.keys, Object);
const $W = BW;
var FW = Object.prototype, IW = FW.hasOwnProperty;
function LW(g) {
  if (!ux(g))
    return $W(g);
  var _ = [];
  for (var D in Object(g))
    IW.call(g, D) && D != "constructor" && _.push(D);
  return _;
}
function Ah(g) {
  return Mk(g) ? I6(g) : LW(g);
}
function MW(g) {
  var _ = [];
  if (g != null)
    for (var D in Object(g))
      _.push(D);
  return _;
}
var jW = Object.prototype, UW = jW.hasOwnProperty;
function HW(g) {
  if (!Gi(g))
    return MW(g);
  var _ = ux(g), D = [];
  for (var X in g)
    X == "constructor" && (_ || !UW.call(g, X)) || D.push(X);
  return D;
}
function yp(g) {
  return Mk(g) ? I6(g, !0) : HW(g);
}
var WW = P6(function(g, _, D, X) {
  hp(_, yp(_), g, X);
});
const qW = WW;
var VW = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, GW = /^\w*$/;
function mx(g, _) {
  if (Cc(g))
    return !1;
  var D = typeof g;
  return D == "number" || D == "symbol" || D == "boolean" || g == null || rx(g) ? !0 : GW.test(g) || !VW.test(g) || _ != null && g in Object(_);
}
var KW = pd(Object, "create");
const xh = KW;
function YW() {
  this.__data__ = xh ? xh(null) : {}, this.size = 0;
}
function XW(g) {
  var _ = this.has(g) && delete this.__data__[g];
  return this.size -= _ ? 1 : 0, _;
}
var ZW = "__lodash_hash_undefined__", QW = Object.prototype, JW = QW.hasOwnProperty;
function eq(g) {
  var _ = this.__data__;
  if (xh) {
    var D = _[g];
    return D === ZW ? void 0 : D;
  }
  return JW.call(_, g) ? _[g] : void 0;
}
var tq = Object.prototype, nq = tq.hasOwnProperty;
function oq(g) {
  var _ = this.__data__;
  return xh ? _[g] !== void 0 : nq.call(_, g);
}
var sq = "__lodash_hash_undefined__";
function rq(g, _) {
  var D = this.__data__;
  return this.size += this.has(g) ? 0 : 1, D[g] = xh && _ === void 0 ? sq : _, this;
}
function fd(g) {
  var _ = -1, D = g == null ? 0 : g.length;
  for (this.clear(); ++_ < D; ) {
    var X = g[_];
    this.set(X[0], X[1]);
  }
}
fd.prototype.clear = YW;
fd.prototype.delete = XW;
fd.prototype.get = eq;
fd.prototype.has = oq;
fd.prototype.set = rq;
function aq() {
  this.__data__ = [], this.size = 0;
}
function jk(g, _) {
  for (var D = g.length; D--; )
    if (zh(g[D][0], _))
      return D;
  return -1;
}
var cq = Array.prototype, iq = cq.splice;
function lq(g) {
  var _ = this.__data__, D = jk(_, g);
  if (D < 0)
    return !1;
  var X = _.length - 1;
  return D == X ? _.pop() : iq.call(_, D, 1), --this.size, !0;
}
function uq(g) {
  var _ = this.__data__, D = jk(_, g);
  return D < 0 ? void 0 : _[D][1];
}
function fq(g) {
  return jk(this.__data__, g) > -1;
}
function dq(g, _) {
  var D = this.__data__, X = jk(D, g);
  return X < 0 ? (++this.size, D.push([g, _])) : D[X][1] = _, this;
}
function Hl(g) {
  var _ = -1, D = g == null ? 0 : g.length;
  for (this.clear(); ++_ < D; ) {
    var X = g[_];
    this.set(X[0], X[1]);
  }
}
Hl.prototype.clear = aq;
Hl.prototype.delete = lq;
Hl.prototype.get = uq;
Hl.prototype.has = fq;
Hl.prototype.set = dq;
var mq = pd(Vi, "Map");
const Eh = mq;
function pq() {
  this.size = 0, this.__data__ = {
    hash: new fd(),
    map: new (Eh || Hl)(),
    string: new fd()
  };
}
function gq(g) {
  var _ = typeof g;
  return _ == "string" || _ == "number" || _ == "symbol" || _ == "boolean" ? g !== "__proto__" : g === null;
}
function Uk(g, _) {
  var D = g.__data__;
  return gq(_) ? D[typeof _ == "string" ? "string" : "hash"] : D.map;
}
function hq(g) {
  var _ = Uk(this, g).delete(g);
  return this.size -= _ ? 1 : 0, _;
}
function yq(g) {
  return Uk(this, g).get(g);
}
function bq(g) {
  return Uk(this, g).has(g);
}
function kq(g, _) {
  var D = Uk(this, g), X = D.size;
  return D.set(g, _), this.size += D.size == X ? 0 : 1, this;
}
function Wl(g) {
  var _ = -1, D = g == null ? 0 : g.length;
  for (this.clear(); ++_ < D; ) {
    var X = g[_];
    this.set(X[0], X[1]);
  }
}
Wl.prototype.clear = pq;
Wl.prototype.delete = hq;
Wl.prototype.get = yq;
Wl.prototype.has = bq;
Wl.prototype.set = kq;
var wq = "Expected a function";
function px(g, _) {
  if (typeof g != "function" || _ != null && typeof _ != "function")
    throw new TypeError(wq);
  var D = function() {
    var X = arguments, _e = _ ? _.apply(this, X) : X[0], Ae = D.cache;
    if (Ae.has(_e))
      return Ae.get(_e);
    var We = g.apply(this, X);
    return D.cache = Ae.set(_e, We) || Ae, We;
  };
  return D.cache = new (px.Cache || Wl)(), D;
}
px.Cache = Wl;
var _q = 500;
function vq(g) {
  var _ = px(g, function(X) {
    return D.size === _q && D.clear(), X;
  }), D = _.cache;
  return _;
}
var Cq = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Sq = /\\(\\)?/g, xq = vq(function(g) {
  var _ = [];
  return g.charCodeAt(0) === 46 && _.push(""), g.replace(Cq, function(D, X, _e, Ae) {
    _.push(_e ? Ae.replace(Sq, "$1") : X || D);
  }), _;
});
const Eq = xq;
function Tq(g) {
  return g == null ? "" : R6(g);
}
function M6(g, _) {
  return Cc(g) ? g : mx(g, _) ? [g] : Eq(Tq(g));
}
var zq = 1 / 0;
function Hk(g) {
  if (typeof g == "string" || rx(g))
    return g;
  var _ = g + "";
  return _ == "0" && 1 / g == -zq ? "-0" : _;
}
function j6(g, _) {
  _ = M6(_, g);
  for (var D = 0, X = _.length; g != null && D < X; )
    g = g[Hk(_[D++])];
  return D && D == X ? g : void 0;
}
function Aq(g, _, D) {
  var X = g == null ? void 0 : j6(g, _);
  return X === void 0 ? D : X;
}
function U6(g, _) {
  for (var D = -1, X = _.length, _e = g.length; ++D < X; )
    g[_e + D] = _[D];
  return g;
}
var Nq = L6(Object.getPrototypeOf, Object);
const gx = Nq;
var Rq = "[object Object]", Dq = Function.prototype, Oq = Object.prototype, H6 = Dq.toString, Pq = Oq.hasOwnProperty, Bq = H6.call(Object);
function ZS(g) {
  if (!qi(g) || dd(g) != Rq)
    return !1;
  var _ = gx(g);
  if (_ === null)
    return !0;
  var D = Pq.call(_, "constructor") && _.constructor;
  return typeof D == "function" && D instanceof D && H6.call(D) == Bq;
}
function $q() {
  this.__data__ = new Hl(), this.size = 0;
}
function Fq(g) {
  var _ = this.__data__, D = _.delete(g);
  return this.size = _.size, D;
}
function Iq(g) {
  return this.__data__.get(g);
}
function Lq(g) {
  return this.__data__.has(g);
}
var Mq = 200;
function jq(g, _) {
  var D = this.__data__;
  if (D instanceof Hl) {
    var X = D.__data__;
    if (!Eh || X.length < Mq - 1)
      return X.push([g, _]), this.size = ++D.size, this;
    D = this.__data__ = new Wl(X);
  }
  return D.set(g, _), this.size = D.size, this;
}
function li(g) {
  var _ = this.__data__ = new Hl(g);
  this.size = _.size;
}
li.prototype.clear = $q;
li.prototype.delete = Fq;
li.prototype.get = Iq;
li.prototype.has = Lq;
li.prototype.set = jq;
function Uq(g, _) {
  return g && hp(_, Ah(_), g);
}
function Hq(g, _) {
  return g && hp(_, yp(_), g);
}
var W6 = typeof exports == "object" && exports && !exports.nodeType && exports, r6 = W6 && typeof module == "object" && module && !module.nodeType && module, Wq = r6 && r6.exports === W6, a6 = Wq ? Vi.Buffer : void 0, c6 = a6 ? a6.allocUnsafe : void 0;
function q6(g, _) {
  if (_)
    return g.slice();
  var D = g.length, X = c6 ? c6(D) : new g.constructor(D);
  return g.copy(X), X;
}
function qq(g, _) {
  for (var D = -1, X = g == null ? 0 : g.length, _e = 0, Ae = []; ++D < X; ) {
    var We = g[D];
    _(We, D, g) && (Ae[_e++] = We);
  }
  return Ae;
}
function V6() {
  return [];
}
var Vq = Object.prototype, Gq = Vq.propertyIsEnumerable, i6 = Object.getOwnPropertySymbols, Kq = i6 ? function(g) {
  return g == null ? [] : (g = Object(g), qq(i6(g), function(_) {
    return Gq.call(g, _);
  }));
} : V6;
const hx = Kq;
function Yq(g, _) {
  return hp(g, hx(g), _);
}
var Xq = Object.getOwnPropertySymbols, Zq = Xq ? function(g) {
  for (var _ = []; g; )
    U6(_, hx(g)), g = gx(g);
  return _;
} : V6;
const G6 = Zq;
function Qq(g, _) {
  return hp(g, G6(g), _);
}
function K6(g, _, D) {
  var X = _(g);
  return Cc(g) ? X : U6(X, D(g));
}
function QS(g) {
  return K6(g, Ah, hx);
}
function Jq(g) {
  return K6(g, yp, G6);
}
var eV = pd(Vi, "DataView");
const JS = eV;
var tV = pd(Vi, "Promise");
const ex = tV;
var nV = pd(Vi, "Set");
const tx = nV;
var l6 = "[object Map]", oV = "[object Object]", u6 = "[object Promise]", f6 = "[object Set]", d6 = "[object WeakMap]", m6 = "[object DataView]", sV = md(JS), rV = md(Eh), aV = md(ex), cV = md(tx), iV = md(XS), ud = dd;
(JS && ud(new JS(new ArrayBuffer(1))) != m6 || Eh && ud(new Eh()) != l6 || ex && ud(ex.resolve()) != u6 || tx && ud(new tx()) != f6 || XS && ud(new XS()) != d6) && (ud = function(g) {
  var _ = dd(g), D = _ == oV ? g.constructor : void 0, X = D ? md(D) : "";
  if (X)
    switch (X) {
      case sV:
        return m6;
      case rV:
        return l6;
      case aV:
        return u6;
      case cV:
        return f6;
      case iV:
        return d6;
    }
  return _;
});
const Th = ud;
var lV = Object.prototype, uV = lV.hasOwnProperty;
function fV(g) {
  var _ = g.length, D = new g.constructor(_);
  return _ && typeof g[0] == "string" && uV.call(g, "index") && (D.index = g.index, D.input = g.input), D;
}
var dV = Vi.Uint8Array;
const Bk = dV;
function yx(g) {
  var _ = new g.constructor(g.byteLength);
  return new Bk(_).set(new Bk(g)), _;
}
function mV(g, _) {
  var D = _ ? yx(g.buffer) : g.buffer;
  return new g.constructor(D, g.byteOffset, g.byteLength);
}
var pV = /\w*$/;
function gV(g) {
  var _ = new g.constructor(g.source, pV.exec(g));
  return _.lastIndex = g.lastIndex, _;
}
var p6 = Wi ? Wi.prototype : void 0, g6 = p6 ? p6.valueOf : void 0;
function hV(g) {
  return g6 ? Object(g6.call(g)) : {};
}
function Y6(g, _) {
  var D = _ ? yx(g.buffer) : g.buffer;
  return new g.constructor(D, g.byteOffset, g.length);
}
var yV = "[object Boolean]", bV = "[object Date]", kV = "[object Map]", wV = "[object Number]", _V = "[object RegExp]", vV = "[object Set]", CV = "[object String]", SV = "[object Symbol]", xV = "[object ArrayBuffer]", EV = "[object DataView]", TV = "[object Float32Array]", zV = "[object Float64Array]", AV = "[object Int8Array]", NV = "[object Int16Array]", RV = "[object Int32Array]", DV = "[object Uint8Array]", OV = "[object Uint8ClampedArray]", PV = "[object Uint16Array]", BV = "[object Uint32Array]";
function $V(g, _, D) {
  var X = g.constructor;
  switch (_) {
    case xV:
      return yx(g);
    case yV:
    case bV:
      return new X(+g);
    case EV:
      return mV(g, D);
    case TV:
    case zV:
    case AV:
    case NV:
    case RV:
    case DV:
    case OV:
    case PV:
    case BV:
      return Y6(g, D);
    case kV:
      return new X();
    case wV:
    case CV:
      return new X(g);
    case _V:
      return gV(g);
    case vV:
      return new X();
    case SV:
      return hV(g);
  }
}
function X6(g) {
  return typeof g.constructor == "function" && !ux(g) ? zH(gx(g)) : {};
}
var FV = "[object Map]";
function IV(g) {
  return qi(g) && Th(g) == FV;
}
var h6 = gp && gp.isMap, LV = h6 ? fx(h6) : IV;
const MV = LV;
var jV = "[object Set]";
function UV(g) {
  return qi(g) && Th(g) == jV;
}
var y6 = gp && gp.isSet, HV = y6 ? fx(y6) : UV;
const WV = HV;
var qV = 1, VV = 2, GV = 4, Z6 = "[object Arguments]", KV = "[object Array]", YV = "[object Boolean]", XV = "[object Date]", ZV = "[object Error]", Q6 = "[object Function]", QV = "[object GeneratorFunction]", JV = "[object Map]", eG = "[object Number]", J6 = "[object Object]", tG = "[object RegExp]", nG = "[object Set]", oG = "[object String]", sG = "[object Symbol]", rG = "[object WeakMap]", aG = "[object ArrayBuffer]", cG = "[object DataView]", iG = "[object Float32Array]", lG = "[object Float64Array]", uG = "[object Int8Array]", fG = "[object Int16Array]", dG = "[object Int32Array]", mG = "[object Uint8Array]", pG = "[object Uint8ClampedArray]", gG = "[object Uint16Array]", hG = "[object Uint32Array]", ys = {};
ys[Z6] = ys[KV] = ys[aG] = ys[cG] = ys[YV] = ys[XV] = ys[iG] = ys[lG] = ys[uG] = ys[fG] = ys[dG] = ys[JV] = ys[eG] = ys[J6] = ys[tG] = ys[nG] = ys[oG] = ys[sG] = ys[mG] = ys[pG] = ys[gG] = ys[hG] = !0;
ys[ZV] = ys[Q6] = ys[rG] = !1;
function Nk(g, _, D, X, _e, Ae) {
  var We, Ke = _ & qV, Ee = _ & VV, Ie = _ & GV;
  if (D && (We = _e ? D(g, X, _e, Ae) : D(g)), We !== void 0)
    return We;
  if (!Gi(g))
    return g;
  var pt = Cc(g);
  if (pt) {
    if (We = fV(g), !Ke)
      return D6(g, We);
  } else {
    var _t = Th(g), $e = _t == Q6 || _t == QV;
    if (Sh(g))
      return q6(g, Ke);
    if (_t == J6 || _t == Z6 || $e && !_e) {
      if (We = Ee || $e ? {} : X6(g), !Ke)
        return Ee ? Qq(g, Hq(We, g)) : Yq(g, Uq(We, g));
    } else {
      if (!ys[_t])
        return _e ? g : {};
      We = $V(g, _t, Ke);
    }
  }
  Ae || (Ae = new li());
  var Ne = Ae.get(g);
  if (Ne)
    return Ne;
  Ae.set(g, We), WV(g) ? g.forEach(function(rt) {
    We.add(Nk(rt, _, D, rt, g, Ae));
  }) : MV(g) && g.forEach(function(rt, ae) {
    We.set(ae, Nk(rt, _, D, ae, g, Ae));
  });
  var tt = Ie ? Ee ? Jq : QS : Ee ? yp : Ah, xe = pt ? void 0 : tt(g);
  return MH(xe || g, function(rt, ae) {
    xe && (ae = rt, rt = g[ae]), O6(We, ae, Nk(rt, _, D, ae, g, Ae));
  }), We;
}
var yG = 1, bG = 4;
function kG(g) {
  return Nk(g, yG | bG);
}
var wG = "__lodash_hash_undefined__";
function _G(g) {
  return this.__data__.set(g, wG), this;
}
function vG(g) {
  return this.__data__.has(g);
}
function $k(g) {
  var _ = -1, D = g == null ? 0 : g.length;
  for (this.__data__ = new Wl(); ++_ < D; )
    this.add(g[_]);
}
$k.prototype.add = $k.prototype.push = _G;
$k.prototype.has = vG;
function CG(g, _) {
  for (var D = -1, X = g == null ? 0 : g.length; ++D < X; )
    if (_(g[D], D, g))
      return !0;
  return !1;
}
function SG(g, _) {
  return g.has(_);
}
var xG = 1, EG = 2;
function eR(g, _, D, X, _e, Ae) {
  var We = D & xG, Ke = g.length, Ee = _.length;
  if (Ke != Ee && !(We && Ee > Ke))
    return !1;
  var Ie = Ae.get(g), pt = Ae.get(_);
  if (Ie && pt)
    return Ie == _ && pt == g;
  var _t = -1, $e = !0, Ne = D & EG ? new $k() : void 0;
  for (Ae.set(g, _), Ae.set(_, g); ++_t < Ke; ) {
    var tt = g[_t], xe = _[_t];
    if (X)
      var rt = We ? X(xe, tt, _t, _, g, Ae) : X(tt, xe, _t, g, _, Ae);
    if (rt !== void 0) {
      if (rt)
        continue;
      $e = !1;
      break;
    }
    if (Ne) {
      if (!CG(_, function(ae, ke) {
        if (!SG(Ne, ke) && (tt === ae || _e(tt, ae, D, X, Ae)))
          return Ne.push(ke);
      })) {
        $e = !1;
        break;
      }
    } else if (!(tt === xe || _e(tt, xe, D, X, Ae))) {
      $e = !1;
      break;
    }
  }
  return Ae.delete(g), Ae.delete(_), $e;
}
function TG(g) {
  var _ = -1, D = Array(g.size);
  return g.forEach(function(X, _e) {
    D[++_] = [_e, X];
  }), D;
}
function zG(g) {
  var _ = -1, D = Array(g.size);
  return g.forEach(function(X) {
    D[++_] = X;
  }), D;
}
var AG = 1, NG = 2, RG = "[object Boolean]", DG = "[object Date]", OG = "[object Error]", PG = "[object Map]", BG = "[object Number]", $G = "[object RegExp]", FG = "[object Set]", IG = "[object String]", LG = "[object Symbol]", MG = "[object ArrayBuffer]", jG = "[object DataView]", b6 = Wi ? Wi.prototype : void 0, KS = b6 ? b6.valueOf : void 0;
function UG(g, _, D, X, _e, Ae, We) {
  switch (D) {
    case jG:
      if (g.byteLength != _.byteLength || g.byteOffset != _.byteOffset)
        return !1;
      g = g.buffer, _ = _.buffer;
    case MG:
      return !(g.byteLength != _.byteLength || !Ae(new Bk(g), new Bk(_)));
    case RG:
    case DG:
    case BG:
      return zh(+g, +_);
    case OG:
      return g.name == _.name && g.message == _.message;
    case $G:
    case IG:
      return g == _ + "";
    case PG:
      var Ke = TG;
    case FG:
      var Ee = X & AG;
      if (Ke || (Ke = zG), g.size != _.size && !Ee)
        return !1;
      var Ie = We.get(g);
      if (Ie)
        return Ie == _;
      X |= NG, We.set(g, _);
      var pt = eR(Ke(g), Ke(_), X, _e, Ae, We);
      return We.delete(g), pt;
    case LG:
      if (KS)
        return KS.call(g) == KS.call(_);
  }
  return !1;
}
var HG = 1, WG = Object.prototype, qG = WG.hasOwnProperty;
function VG(g, _, D, X, _e, Ae) {
  var We = D & HG, Ke = QS(g), Ee = Ke.length, Ie = QS(_), pt = Ie.length;
  if (Ee != pt && !We)
    return !1;
  for (var _t = Ee; _t--; ) {
    var $e = Ke[_t];
    if (!(We ? $e in _ : qG.call(_, $e)))
      return !1;
  }
  var Ne = Ae.get(g), tt = Ae.get(_);
  if (Ne && tt)
    return Ne == _ && tt == g;
  var xe = !0;
  Ae.set(g, _), Ae.set(_, g);
  for (var rt = We; ++_t < Ee; ) {
    $e = Ke[_t];
    var ae = g[$e], ke = _[$e];
    if (X)
      var ge = We ? X(ke, ae, $e, _, g, Ae) : X(ae, ke, $e, g, _, Ae);
    if (!(ge === void 0 ? ae === ke || _e(ae, ke, D, X, Ae) : ge)) {
      xe = !1;
      break;
    }
    rt || (rt = $e == "constructor");
  }
  if (xe && !rt) {
    var zt = g.constructor, ot = _.constructor;
    zt != ot && "constructor" in g && "constructor" in _ && !(typeof zt == "function" && zt instanceof zt && typeof ot == "function" && ot instanceof ot) && (xe = !1);
  }
  return Ae.delete(g), Ae.delete(_), xe;
}
var GG = 1, k6 = "[object Arguments]", w6 = "[object Array]", zk = "[object Object]", KG = Object.prototype, _6 = KG.hasOwnProperty;
function YG(g, _, D, X, _e, Ae) {
  var We = Cc(g), Ke = Cc(_), Ee = We ? w6 : Th(g), Ie = Ke ? w6 : Th(_);
  Ee = Ee == k6 ? zk : Ee, Ie = Ie == k6 ? zk : Ie;
  var pt = Ee == zk, _t = Ie == zk, $e = Ee == Ie;
  if ($e && Sh(g)) {
    if (!Sh(_))
      return !1;
    We = !0, pt = !1;
  }
  if ($e && !pt)
    return Ae || (Ae = new li()), We || dx(g) ? eR(g, _, D, X, _e, Ae) : UG(g, _, Ee, D, X, _e, Ae);
  if (!(D & GG)) {
    var Ne = pt && _6.call(g, "__wrapped__"), tt = _t && _6.call(_, "__wrapped__");
    if (Ne || tt) {
      var xe = Ne ? g.value() : g, rt = tt ? _.value() : _;
      return Ae || (Ae = new li()), _e(xe, rt, D, X, Ae);
    }
  }
  return $e ? (Ae || (Ae = new li()), VG(g, _, D, X, _e, Ae)) : !1;
}
function bx(g, _, D, X, _e) {
  return g === _ ? !0 : g == null || _ == null || !qi(g) && !qi(_) ? g !== g && _ !== _ : YG(g, _, D, X, bx, _e);
}
var XG = 1, ZG = 2;
function QG(g, _, D, X) {
  var _e = D.length, Ae = _e, We = !X;
  if (g == null)
    return !Ae;
  for (g = Object(g); _e--; ) {
    var Ke = D[_e];
    if (We && Ke[2] ? Ke[1] !== g[Ke[0]] : !(Ke[0] in g))
      return !1;
  }
  for (; ++_e < Ae; ) {
    Ke = D[_e];
    var Ee = Ke[0], Ie = g[Ee], pt = Ke[1];
    if (We && Ke[2]) {
      if (Ie === void 0 && !(Ee in g))
        return !1;
    } else {
      var _t = new li();
      if (X)
        var $e = X(Ie, pt, Ee, g, _, _t);
      if (!($e === void 0 ? bx(pt, Ie, XG | ZG, X, _t) : $e))
        return !1;
    }
  }
  return !0;
}
function tR(g) {
  return g === g && !Gi(g);
}
function JG(g) {
  for (var _ = Ah(g), D = _.length; D--; ) {
    var X = _[D], _e = g[X];
    _[D] = [X, _e, tR(_e)];
  }
  return _;
}
function nR(g, _) {
  return function(D) {
    return D == null ? !1 : D[g] === _ && (_ !== void 0 || g in Object(D));
  };
}
function eK(g) {
  var _ = JG(g);
  return _.length == 1 && _[0][2] ? nR(_[0][0], _[0][1]) : function(D) {
    return D === g || QG(D, g, _);
  };
}
function tK(g, _) {
  return g != null && _ in Object(g);
}
function nK(g, _, D) {
  _ = M6(_, g);
  for (var X = -1, _e = _.length, Ae = !1; ++X < _e; ) {
    var We = Hk(_[X]);
    if (!(Ae = g != null && D(g, We)))
      break;
    g = g[We];
  }
  return Ae || ++X != _e ? Ae : (_e = g == null ? 0 : g.length, !!_e && lx(_e) && ix(We, _e) && (Cc(g) || Pk(g)));
}
function oK(g, _) {
  return g != null && nK(g, _, tK);
}
var sK = 1, rK = 2;
function aK(g, _) {
  return mx(g) && tR(_) ? nR(Hk(g), _) : function(D) {
    var X = Aq(D, g);
    return X === void 0 && X === _ ? oK(D, g) : bx(_, X, sK | rK);
  };
}
function cK(g) {
  return function(_) {
    return _ == null ? void 0 : _[g];
  };
}
function iK(g) {
  return function(_) {
    return j6(_, g);
  };
}
function lK(g) {
  return mx(g) ? cK(Hk(g)) : iK(g);
}
function uK(g) {
  return typeof g == "function" ? g : g == null ? ax : typeof g == "object" ? Cc(g) ? aK(g[0], g[1]) : eK(g) : lK(g);
}
function fK(g) {
  return function(_, D, X) {
    for (var _e = -1, Ae = Object(_), We = X(_), Ke = We.length; Ke--; ) {
      var Ee = We[g ? Ke : ++_e];
      if (D(Ae[Ee], Ee, Ae) === !1)
        break;
    }
    return _;
  };
}
var dK = fK();
const oR = dK;
function mK(g, _) {
  return g && oR(g, _, Ah);
}
function nx(g, _, D) {
  (D !== void 0 && !zh(g[_], D) || D === void 0 && !(_ in g)) && Lk(g, _, D);
}
function pK(g) {
  return qi(g) && Mk(g);
}
function ox(g, _) {
  if (!(_ === "constructor" && typeof g[_] == "function") && _ != "__proto__")
    return g[_];
}
function gK(g) {
  return hp(g, yp(g));
}
function hK(g, _, D, X, _e, Ae, We) {
  var Ke = ox(g, D), Ee = ox(_, D), Ie = We.get(Ee);
  if (Ie) {
    nx(g, D, Ie);
    return;
  }
  var pt = Ae ? Ae(Ke, Ee, D + "", g, _, We) : void 0, _t = pt === void 0;
  if (_t) {
    var $e = Cc(Ee), Ne = !$e && Sh(Ee), tt = !$e && !Ne && dx(Ee);
    pt = Ee, $e || Ne || tt ? Cc(Ke) ? pt = Ke : pK(Ke) ? pt = D6(Ke) : Ne ? (_t = !1, pt = q6(Ee, !0)) : tt ? (_t = !1, pt = Y6(Ee, !0)) : pt = [] : ZS(Ee) || Pk(Ee) ? (pt = Ke, Pk(Ke) ? pt = gK(Ke) : (!Gi(Ke) || cx(Ke)) && (pt = X6(Ee))) : _t = !1;
  }
  _t && (We.set(Ee, pt), _e(pt, Ee, X, Ae, We), We.delete(Ee)), nx(g, D, pt);
}
function sR(g, _, D, X, _e) {
  g !== _ && oR(_, function(Ae, We) {
    if (_e || (_e = new li()), Gi(Ae))
      hK(g, _, We, D, sR, X, _e);
    else {
      var Ke = X ? X(ox(g, We), Ae, We + "", g, _, _e) : void 0;
      Ke === void 0 && (Ke = Ae), nx(g, We, Ke);
    }
  }, yp);
}
var yK = P6(function(g, _, D, X) {
  sR(g, _, D, X);
});
const bK = yK;
function kK(g, _) {
  var D = {};
  return _ = uK(_), mK(g, function(X, _e, Ae) {
    Lk(D, _(X, _e, Ae), X);
  }), D;
}
var Fk = function() {
  return Fk = Object.assign || function(g) {
    for (var _, D = 1, X = arguments.length; D < X; D++) {
      _ = arguments[D];
      for (var _e in _)
        Object.prototype.hasOwnProperty.call(_, _e) && (g[_e] = _[_e]);
    }
    return g;
  }, Fk.apply(this, arguments);
};
function wK(g) {
  return g.toLowerCase();
}
var _K = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g], vK = /[^A-Z0-9]+/gi;
function CK(g, _) {
  _ === void 0 && (_ = {});
  for (var D = _.splitRegexp, X = D === void 0 ? _K : D, _e = _.stripRegexp, Ae = _e === void 0 ? vK : _e, We = _.transform, Ke = We === void 0 ? wK : We, Ee = _.delimiter, Ie = Ee === void 0 ? " " : Ee, pt = v6(v6(g, X, "$1\0$2"), Ae, "\0"), _t = 0, $e = pt.length; pt.charAt(_t) === "\0"; )
    _t++;
  for (; pt.charAt($e - 1) === "\0"; )
    $e--;
  return pt.slice(_t, $e).split("\0").map(Ke).join(Ie);
}
function v6(g, _, D) {
  return _ instanceof RegExp ? g.replace(_, D) : _.reduce(function(X, _e) {
    return X.replace(_e, D);
  }, g);
}
function rR(g, _) {
  var D = g.charAt(0), X = g.substr(1).toLowerCase();
  return _ > 0 && D >= "0" && D <= "9" ? "_" + D + X : "" + D.toUpperCase() + X;
}
function SK(g, _) {
  return _ === void 0 && (_ = {}), CK(g, Fk({ delimiter: "", transform: rR }, _));
}
function xK(g, _) {
  return _ === 0 ? g.toLowerCase() : rR(g, _);
}
function EK(g, _) {
  return _ === void 0 && (_ = {}), SK(g, Fk({ transform: xK }, _));
}
function TK(g, _) {
  const D = /* @__PURE__ */ Object.create(null), X = g.split(",");
  for (let _e = 0; _e < X.length; _e++)
    D[X[_e]] = !0;
  return _ ? (_e) => !!D[_e.toLowerCase()] : (_e) => !!D[_e];
}
const zK = /* @__PURE__ */ TK(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function AK(g) {
  const _ = g && g.toString().match(/^\s*function (\w+)/);
  return _ ? _[1] : g === null ? "null" : "";
}
function NK(g, _) {
  let D;
  const X = AK(_);
  if (zK(X)) {
    const _e = typeof g;
    D = _e === X.toLowerCase(), !D && _e === "object" && (D = g instanceof _);
  } else
    X === "Object" ? D = Gi(g) : X === "Array" ? D = Array.isArray(g) : X === "null" ? D = g === null : D = g instanceof _;
  return {
    valid: D,
    expectedType: X
  };
}
function RK({
  prop: g,
  type: _,
  validator: D
}) {
  if (![void 0, null].includes(g) && _) {
    let X = !1;
    const _e = Array.isArray(_) ? _ : [_], Ae = [];
    for (let We = 0; We < _e.length && !X; We++) {
      const { valid: Ke, expectedType: Ee } = NK(g, _e[We]);
      Ae.push(Ee || ""), X = Ke;
    }
    if (!X)
      throw new Error(`Invalid prop: type check failed, expecting [${Ae.join(", ")}], receiving: ${g}`);
  }
  if (D && !D(g))
    throw new Error(`Invalid prop: validator check failed, receiving: ${g}`);
}
function DK(g, {
  mergeObject: _,
  mergeFunction: D
}) {
  const X = D ? (_e, Ae) => _e instanceof Function && Ae instanceof Function ? D(Ae, _e) : void 0 : void 0;
  return _ === "deep" ? bK(...g, X) : qW(...g, X);
}
function OK(g, {
  mergeFunction: _
}) {
  return g.reduce(_, () => {
  });
}
function Rk(g, _ = {}) {
  const {
    type: D,
    default: X,
    defaultIsDynamic: _e = !1,
    required: Ae = !1,
    validator: We,
    camelCase: Ke = !0,
    mergeObjectApplyOnlyToDefault: Ee = !1,
    mergeFunctionApplyOnlyToDefault: Ie = !0
  } = _;
  let {
    mergeObject: pt = "deep",
    mergeFunction: _t = !1
  } = _, $e;
  if (_e) {
    if (!(X instanceof Function))
      throw new Error(`Invalid option: default. config.default should be Function when config.defaultIsDynamic enabled, receiving: ${X}`);
    $e = [...g];
  } else
    $e = [...g, X];
  let Ne, tt = !1, xe = !1;
  for (let rt = 0; rt < $e.length; rt++) {
    const ae = $e[rt];
    if (ae !== void 0) {
      RK({
        type: D,
        prop: ae,
        validator: We
      });
      const ke = ZS(ae), ge = ae instanceof Function;
      if (tt = ke, xe = ge, !ke && !ge)
        break;
    }
  }
  tt ? $e = kG($e) : (pt = !1, xe || (_t = !1));
  for (let rt = 0; rt < $e.length; rt++) {
    const ae = $e[rt];
    if (ae !== void 0) {
      rt === $e.length - 1 ? Ne = ae : pt ? Ne = DK(Ee ? [X, ae] : [...$e].reverse(), {
        mergeObject: pt,
        mergeFunction: _t
      }) : _t ? Ne = OK(Ie ? [ae, X] : $e, {
        mergeFunction: _t
      }) : Ne = ae;
      break;
    }
  }
  if (Ae && [void 0, null].includes(Ne))
    throw new Error("Missing required prop");
  return _e ? Rk(
    g,
    {
      ..._,
      default: X(Ne),
      defaultIsDynamic: !1
    }
  ) : Ke && ZS(Ne) ? kK(Ne, (rt, ae) => EK(ae, {
    stripRegexp: /-/g
  })) : Ne;
}
let Ak;
const PK = new Uint8Array(16);
function BK() {
  if (!Ak && (Ak = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ak))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ak(PK);
}
const Kr = [];
for (let g = 0; g < 256; ++g)
  Kr.push((g + 256).toString(16).slice(1));
function $K(g, _ = 0) {
  return (Kr[g[_ + 0]] + Kr[g[_ + 1]] + Kr[g[_ + 2]] + Kr[g[_ + 3]] + "-" + Kr[g[_ + 4]] + Kr[g[_ + 5]] + "-" + Kr[g[_ + 6]] + Kr[g[_ + 7]] + "-" + Kr[g[_ + 8]] + Kr[g[_ + 9]] + "-" + Kr[g[_ + 10]] + Kr[g[_ + 11]] + Kr[g[_ + 12]] + Kr[g[_ + 13]] + Kr[g[_ + 14]] + Kr[g[_ + 15]]).toLowerCase();
}
const FK = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), C6 = {
  randomUUID: FK
};
function IK(g, _, D) {
  if (C6.randomUUID && !_ && !g)
    return C6.randomUUID();
  g = g || {};
  const X = g.random || (g.rng || BK)();
  if (X[6] = X[6] & 15 | 64, X[8] = X[8] & 63 | 128, _) {
    D = D || 0;
    for (let _e = 0; _e < 16; ++_e)
      _[D + _e] = X[_e];
    return _;
  }
  return $K(X);
}
var LK = typeof global == "object" && global && global.Object === Object && global;
const MK = LK;
var jK = typeof self == "object" && self && self.Object === Object && self, UK = MK || jK || Function("return this")();
const aR = UK;
var HK = aR.Symbol;
const Ik = HK;
var cR = Object.prototype, WK = cR.hasOwnProperty, qK = cR.toString, vh = Ik ? Ik.toStringTag : void 0;
function VK(g) {
  var _ = WK.call(g, vh), D = g[vh];
  try {
    g[vh] = void 0;
    var X = !0;
  } catch {
  }
  var _e = qK.call(g);
  return X && (_ ? g[vh] = D : delete g[vh]), _e;
}
var GK = Object.prototype, KK = GK.toString;
function YK(g) {
  return KK.call(g);
}
var XK = "[object Null]", ZK = "[object Undefined]", S6 = Ik ? Ik.toStringTag : void 0;
function QK(g) {
  return g == null ? g === void 0 ? ZK : XK : S6 && S6 in Object(g) ? VK(g) : YK(g);
}
function JK(g) {
  return g != null && typeof g == "object";
}
var eY = "[object Symbol]";
function tY(g) {
  return typeof g == "symbol" || JK(g) && QK(g) == eY;
}
var nY = /\s/;
function oY(g) {
  for (var _ = g.length; _-- && nY.test(g.charAt(_)); )
    ;
  return _;
}
var sY = /^\s+/;
function rY(g) {
  return g && g.slice(0, oY(g) + 1).replace(sY, "");
}
function sx(g) {
  var _ = typeof g;
  return g != null && (_ == "object" || _ == "function");
}
var x6 = 0 / 0, aY = /^[-+]0x[0-9a-f]+$/i, cY = /^0b[01]+$/i, iY = /^0o[0-7]+$/i, lY = parseInt;
function E6(g) {
  if (typeof g == "number")
    return g;
  if (tY(g))
    return x6;
  if (sx(g)) {
    var _ = typeof g.valueOf == "function" ? g.valueOf() : g;
    g = sx(_) ? _ + "" : _;
  }
  if (typeof g != "string")
    return g === 0 ? g : +g;
  g = rY(g);
  var D = cY.test(g);
  return D || iY.test(g) ? lY(g.slice(2), D ? 2 : 8) : aY.test(g) ? x6 : +g;
}
var uY = function() {
  return aR.Date.now();
};
const YS = uY;
var fY = "Expected a function", dY = Math.max, mY = Math.min;
function pY(g, _, D) {
  var X, _e, Ae, We, Ke, Ee, Ie = 0, pt = !1, _t = !1, $e = !0;
  if (typeof g != "function")
    throw new TypeError(fY);
  _ = E6(_) || 0, sx(D) && (pt = !!D.leading, _t = "maxWait" in D, Ae = _t ? dY(E6(D.maxWait) || 0, _) : Ae, $e = "trailing" in D ? !!D.trailing : $e);
  function Ne(le) {
    var it = X, ft = _e;
    return X = _e = void 0, Ie = le, We = g.apply(ft, it), We;
  }
  function tt(le) {
    return Ie = le, Ke = setTimeout(ae, _), pt ? Ne(le) : We;
  }
  function xe(le) {
    var it = le - Ee, ft = le - Ie, Le = _ - it;
    return _t ? mY(Le, Ae - ft) : Le;
  }
  function rt(le) {
    var it = le - Ee, ft = le - Ie;
    return Ee === void 0 || it >= _ || it < 0 || _t && ft >= Ae;
  }
  function ae() {
    var le = YS();
    if (rt(le))
      return ke(le);
    Ke = setTimeout(ae, xe(le));
  }
  function ke(le) {
    return Ke = void 0, $e && X ? Ne(le) : (X = _e = void 0, We);
  }
  function ge() {
    Ke !== void 0 && clearTimeout(Ke), Ie = 0, X = Ee = _e = Ke = void 0;
  }
  function zt() {
    return Ke === void 0 ? We : ke(YS());
  }
  function ot() {
    var le = YS(), it = rt(le);
    if (X = arguments, _e = this, Ee = le, it) {
      if (Ke === void 0)
        return tt(Ee);
      if (_t)
        return clearTimeout(Ke), Ke = setTimeout(ae, _), Ne(Ee);
    }
    return Ke === void 0 && (Ke = setTimeout(ae, _)), We;
  }
  return ot.cancel = ge, ot.flush = zt, ot;
}
var iR = { exports: {} };
(function(g) {
  (function() {
    var _ = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var t = typeof e;
      return t === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : t === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : t;
    }, D = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, X = function(e, t) {
      var n = Array.prototype.slice.call(e);
      return n.sort(t);
    }, _e = function(e, t) {
      return Ae(function(n, o) {
        return e.eq(t(n), t(o));
      });
    }, Ae = function(e) {
      return { eq: e };
    }, We = Ae(function(e, t) {
      return e === t;
    }), Ke = We, Ee = function(e) {
      return Ae(function(t, n) {
        if (t.length !== n.length)
          return !1;
        for (var o = t.length, s = 0; s < o; s++)
          if (!e.eq(t[s], n[s]))
            return !1;
        return !0;
      });
    }, Ie = function(e, t) {
      return _e(Ee(e), function(n) {
        return X(n, t);
      });
    }, pt = function(e) {
      return Ae(function(t, n) {
        var o = Object.keys(t), s = Object.keys(n);
        if (!Ie(Ke).eq(o, s))
          return !1;
        for (var a = o.length, i = 0; i < a; i++) {
          var u = o[i];
          if (!e.eq(t[u], n[u]))
            return !1;
        }
        return !0;
      });
    }, _t = Ae(function(e, t) {
      if (e === t)
        return !0;
      var n = _(e), o = _(t);
      return n !== o ? !1 : D(n) ? e === t : n === "array" ? Ee(_t).eq(e, t) : n === "object" ? pt(_t).eq(e, t) : !1;
    });
    const $e = Object.getPrototypeOf, Ne = (e, t, n) => {
      var o;
      return n(e, t.prototype) ? !0 : ((o = e.constructor) === null || o === void 0 ? void 0 : o.name) === t.name;
    }, tt = (e) => {
      const t = typeof e;
      return e === null ? "null" : t === "object" && Array.isArray(e) ? "array" : t === "object" && Ne(e, String, (n, o) => o.isPrototypeOf(n)) ? "string" : t;
    }, xe = (e) => (t) => tt(t) === e, rt = (e) => (t) => typeof t === e, ae = (e) => (t) => e === t, ke = (e, t) => zt(e) && Ne(e, t, (n, o) => $e(n) === o), ge = xe("string"), zt = xe("object"), ot = (e) => ke(e, Object), le = xe("array"), it = ae(null), ft = rt("boolean"), Le = ae(void 0), Ve = (e) => e == null, L = (e) => !Ve(e), Wt = rt("function"), Je = rt("number"), jt = (e, t) => {
      if (le(e)) {
        for (let n = 0, o = e.length; n < o; ++n)
          if (!t(e[n]))
            return !1;
        return !0;
      }
      return !1;
    }, ye = () => {
    }, Ze = (e, t) => (...n) => e(t.apply(null, n)), qt = (e, t) => (n) => e(t(n)), Z = (e) => () => e, Pe = (e) => e, yt = (e, t) => e === t;
    function et(e, ...t) {
      return (...n) => {
        const o = t.concat(n);
        return e.apply(null, o);
      };
    }
    const kn = (e) => (t) => !e(t), Rn = (e) => () => {
      throw new Error(e);
    }, an = (e) => e(), en = (e) => {
      e();
    }, cn = Z(!1), wn = Z(!0);
    class w {
      constructor(t, n) {
        this.tag = t, this.value = n;
      }
      static some(t) {
        return new w(!0, t);
      }
      static none() {
        return w.singletonNone;
      }
      fold(t, n) {
        return this.tag ? n(this.value) : t();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(t) {
        return this.tag ? w.some(t(this.value)) : w.none();
      }
      bind(t) {
        return this.tag ? t(this.value) : w.none();
      }
      exists(t) {
        return this.tag && t(this.value);
      }
      forall(t) {
        return !this.tag || t(this.value);
      }
      filter(t) {
        return !this.tag || t(this.value) ? this : w.none();
      }
      getOr(t) {
        return this.tag ? this.value : t;
      }
      or(t) {
        return this.tag ? this : t;
      }
      getOrThunk(t) {
        return this.tag ? this.value : t();
      }
      orThunk(t) {
        return this.tag ? this : t();
      }
      getOrDie(t) {
        if (this.tag)
          return this.value;
        throw new Error(t != null ? t : "Called getOrDie on None");
      }
      static from(t) {
        return L(t) ? w.some(t) : w.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(t) {
        this.tag && t(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    w.singletonNone = new w(!1);
    const ie = Array.prototype.slice, re = Array.prototype.indexOf, we = Array.prototype.push, J = (e, t) => re.call(e, t), me = (e, t) => {
      const n = J(e, t);
      return n === -1 ? w.none() : w.some(n);
    }, ce = (e, t) => J(e, t) > -1, Ce = (e, t) => {
      for (let n = 0, o = e.length; n < o; n++) {
        const s = e[n];
        if (t(s, n))
          return !0;
      }
      return !1;
    }, W = (e, t) => {
      const n = e.length, o = new Array(n);
      for (let s = 0; s < n; s++) {
        const a = e[s];
        o[s] = t(a, s);
      }
      return o;
    }, M = (e, t) => {
      for (let n = 0, o = e.length; n < o; n++) {
        const s = e[n];
        t(s, n);
      }
    }, Ue = (e, t) => {
      for (let n = e.length - 1; n >= 0; n--) {
        const o = e[n];
        t(o, n);
      }
    }, kt = (e, t) => {
      const n = [], o = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const i = e[s];
        (t(i, s) ? n : o).push(i);
      }
      return {
        pass: n,
        fail: o
      };
    }, Qe = (e, t) => {
      const n = [];
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        t(a, o) && n.push(a);
      }
      return n;
    }, pn = (e, t, n) => (Ue(e, (o, s) => {
      n = t(n, o, s);
    }), n), En = (e, t, n) => (M(e, (o, s) => {
      n = t(n, o, s);
    }), n), Eo = (e, t, n) => {
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        if (t(a, o))
          return w.some(a);
        if (n(a, o))
          break;
      }
      return w.none();
    }, oo = (e, t) => Eo(e, t, cn), Yn = (e, t) => {
      for (let n = 0, o = e.length; n < o; n++) {
        const s = e[n];
        if (t(s, n))
          return w.some(n);
      }
      return w.none();
    }, eo = (e) => {
      const t = [];
      for (let n = 0, o = e.length; n < o; ++n) {
        if (!le(e[n]))
          throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
        we.apply(t, e[n]);
      }
      return t;
    }, Xt = (e, t) => eo(W(e, t)), ro = (e, t) => {
      for (let n = 0, o = e.length; n < o; ++n) {
        const s = e[n];
        if (t(s, n) !== !0)
          return !1;
      }
      return !0;
    }, io = (e) => {
      const t = ie.call(e, 0);
      return t.reverse(), t;
    }, Fe = (e, t) => Qe(e, (n) => !ce(t, n)), st = (e, t) => {
      const n = {};
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        n[String(a)] = t(a, o);
      }
      return n;
    }, Qt = (e, t) => {
      const n = ie.call(e, 0);
      return n.sort(t), n;
    }, Ut = (e, t) => t >= 0 && t < e.length ? w.some(e[t]) : w.none(), Tn = (e) => Ut(e, 0), Pn = (e) => Ut(e, e.length - 1), ho = Wt(Array.from) ? Array.from : (e) => ie.call(e), Bo = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const o = t(e[n], n);
        if (o.isSome())
          return o;
      }
      return w.none();
    }, ue = (e, t) => {
      const n = [], o = Wt(t) ? (s) => Ce(n, (a) => t(a, s)) : (s) => ce(n, s);
      for (let s = 0, a = e.length; s < a; s++) {
        const i = e[s];
        o(i) || n.push(i);
      }
      return n;
    }, ze = Object.keys, At = Object.hasOwnProperty, Ot = (e, t) => {
      const n = ze(e);
      for (let o = 0, s = n.length; o < s; o++) {
        const a = n[o], i = e[a];
        t(i, a);
      }
    }, hn = (e, t) => Ao(e, (n, o) => ({
      k: o,
      v: t(n, o)
    })), Ao = (e, t) => {
      const n = {};
      return Ot(e, (o, s) => {
        const a = t(o, s);
        n[a.k] = a.v;
      }), n;
    }, xs = (e) => (t, n) => {
      e[n] = t;
    }, zs = (e, t, n, o) => {
      const s = {};
      return Ot(e, (a, i) => {
        (t(a, i) ? n : o)(a, i);
      }), s;
    }, To = (e, t) => {
      const n = {}, o = {};
      return zs(e, t, xs(n), xs(o)), {
        t: n,
        f: o
      };
    }, rs = (e, t) => {
      const n = {};
      return zs(e, t, xs(n), ye), n;
    }, wo = (e, t) => {
      const n = [];
      return Ot(e, (o, s) => {
        n.push(t(o, s));
      }), n;
    }, os = (e) => wo(e, Pe), Vn = (e, t) => gn(e, t) ? w.from(e[t]) : w.none(), gn = (e, t) => At.call(e, t), qo = (e, t) => gn(e, t) && e[t] !== void 0 && e[t] !== null, lo = (e, t, n = _t) => pt(n).eq(e, t), Io = (e) => {
      const t = {};
      return M(e, (n) => {
        t[n] = {};
      }), ze(t);
    }, Ks = Array.isArray, As = (e) => {
      if (Ks(e))
        return e;
      {
        const t = [];
        for (let n = 0, o = e.length; n < o; n++)
          t[n] = e[n];
        return t;
      }
    }, cs = (e, t, n) => {
      let o, s;
      if (!e)
        return !1;
      if (n = n || e, e.length !== void 0) {
        for (o = 0, s = e.length; o < s; o++)
          if (t.call(n, e[o], o, e) === !1)
            return !1;
      } else
        for (o in e)
          if (gn(e, o) && t.call(n, e[o], o, e) === !1)
            return !1;
      return !0;
    }, Lo = (e, t) => {
      const n = [];
      return cs(e, (o, s) => {
        n.push(t(o, s, e));
      }), n;
    }, Ys = (e, t) => {
      const n = [];
      return cs(e, (o, s) => {
        (!t || t(o, s, e)) && n.push(o);
      }), n;
    }, O = (e, t) => {
      if (e) {
        for (let n = 0, o = e.length; n < o; n++)
          if (e[n] === t)
            return n;
      }
      return -1;
    }, G = (e, t, n, o) => {
      let s = Le(n) ? e[0] : n;
      for (let a = 0; a < e.length; a++)
        s = t.call(o, s, e[a], a);
      return s;
    }, de = (e, t, n) => {
      let o, s;
      for (o = 0, s = e.length; o < s; o++)
        if (t.call(n, e[o], o, e))
          return o;
      return -1;
    }, dt = (e) => e[e.length - 1], rn = (e) => {
      let t = !1, n;
      return (...o) => (t || (t = !0, n = e.apply(null, o)), n);
    }, Et = (e, t, n, o) => {
      const s = e.isiOS() && /ipad/i.test(n) === !0, a = e.isiOS() && !s, i = e.isiOS() || e.isAndroid(), u = i || o("(pointer:coarse)"), d = s || !a && i && o("(min-device-width:768px)"), y = a || i && !d, v = t.isSafari() && e.isiOS() && /safari/i.test(n) === !1, T = !y && !d && !v;
      return {
        isiPad: Z(s),
        isiPhone: Z(a),
        isTablet: Z(d),
        isPhone: Z(y),
        isTouch: Z(u),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: Z(v),
        isDesktop: Z(T)
      };
    }, An = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const o = e[n];
        if (o.test(t))
          return o;
      }
    }, Po = (e, t) => {
      const n = An(e, t);
      if (!n)
        return {
          major: 0,
          minor: 0
        };
      const o = (s) => Number(t.replace(n, "$" + s));
      return Mo(o(1), o(2));
    }, ln = (e, t) => {
      const n = String(t).toLowerCase();
      return e.length === 0 ? jn() : Po(e, n);
    }, jn = () => Mo(0, 0), Mo = (e, t) => ({
      major: e,
      minor: t
    }), No = {
      nu: Mo,
      detect: ln,
      unknown: jn
    }, q = (e, t) => Bo(t.brands, (n) => {
      const o = n.brand.toLowerCase();
      return oo(e, (s) => {
        var a;
        return o === ((a = s.brand) === null || a === void 0 ? void 0 : a.toLowerCase());
      }).map((s) => ({
        current: s.name,
        version: No.nu(parseInt(n.version, 10), 0)
      }));
    }), ee = (e, t) => {
      const n = String(t).toLowerCase();
      return oo(e, (o) => o.search(n));
    }, Ge = (e, t) => ee(e, t).map((n) => {
      const o = No.detect(n.versionRegexes, t);
      return {
        current: n.name,
        version: o
      };
    }), St = (e, t) => ee(e, t).map((n) => {
      const o = No.detect(n.versionRegexes, t);
      return {
        current: n.name,
        version: o
      };
    }), vt = (e, t) => e.substring(t), wt = (e, t, n) => t === "" || e.length >= t.length && e.substr(n, n + t.length) === t, It = (e, t) => un(e, t) ? vt(e, t.length) : e, Lt = (e, t) => e.indexOf(t) !== -1, un = (e, t) => wt(e, t, 0), Xn = (e, t) => wt(e, t, e.length - t.length), yo = (e) => (t) => t.replace(e, ""), Dn = yo(/^\s+|\s+$/g), sr = yo(/^\s+/g), bs = yo(/\s+$/g), Bn = (e) => e.length > 0, to = (e) => !Bn(e), Qo = (e, t) => t <= 0 ? "" : new Array(t + 1).join(e), Jo = (e, t = 10) => {
      const n = parseInt(e, t);
      return isNaN(n) ? w.none() : w.some(n);
    }, Ns = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Rs = (e) => (t) => Lt(t, e), Yr = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => Lt(e, "edge/") && Lt(e, "chrome") && Lt(e, "safari") && Lt(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          Ns
        ],
        search: (e) => Lt(e, "chrome") && !Lt(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => Lt(e, "msie") || Lt(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          Ns,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: Rs("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Rs("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          Ns,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (Lt(e, "safari") || Lt(e, "mobile/")) && Lt(e, "applewebkit")
      }
    ], js = [
      {
        name: "Windows",
        search: Rs("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => Lt(e, "iphone") || Lt(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: Rs("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Rs("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Rs("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Rs("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Rs("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Rs("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], vr = {
      browsers: Z(Yr),
      oses: Z(js)
    }, rr = "Edge", Ra = "Chromium", Cr = "IE", $r = "Opera", Xr = "Firefox", Fr = "Safari", Xs = () => Da({
      current: void 0,
      version: No.unknown()
    }), Da = (e) => {
      const t = e.current, n = e.version, o = (s) => () => t === s;
      return {
        current: t,
        version: n,
        isEdge: o(rr),
        isChromium: o(Ra),
        isIE: o(Cr),
        isOpera: o($r),
        isFirefox: o(Xr),
        isSafari: o(Fr)
      };
    }, ar = {
      unknown: Xs,
      nu: Da,
      edge: Z(rr),
      chromium: Z(Ra),
      ie: Z(Cr),
      opera: Z($r),
      firefox: Z(Xr),
      safari: Z(Fr)
    }, Sr = "Windows", Zr = "iOS", is = "Android", R = "Linux", Q = "macOS", fe = "Solaris", qe = "FreeBSD", bt = "ChromeOS", Nn = () => bo({
      current: void 0,
      version: No.unknown()
    }), bo = (e) => {
      const t = e.current, n = e.version, o = (s) => () => t === s;
      return {
        current: t,
        version: n,
        isWindows: o(Sr),
        isiOS: o(Zr),
        isAndroid: o(is),
        isMacOS: o(Q),
        isLinux: o(R),
        isSolaris: o(fe),
        isFreeBSD: o(qe),
        isChromeOS: o(bt)
      };
    }, Vo = {
      unknown: Nn,
      nu: bo,
      windows: Z(Sr),
      ios: Z(Zr),
      android: Z(is),
      linux: Z(R),
      macos: Z(Q),
      solaris: Z(fe),
      freebsd: Z(qe),
      chromeos: Z(bt)
    }, ms = { detect: (e, t, n) => {
      const o = vr.browsers(), s = vr.oses(), a = t.bind((d) => q(o, d)).orThunk(() => Ge(o, e)).fold(ar.unknown, ar.nu), i = St(s, e).fold(Vo.unknown, Vo.nu), u = Et(i, a, e, n);
      return {
        browser: a,
        os: i,
        deviceType: u
      };
    } }, ks = (e) => window.matchMedia(e).matches;
    let xr = rn(() => ms.detect(navigator.userAgent, w.from(navigator.userAgentData), ks));
    const Ro = () => xr(), Oa = navigator.userAgent, ya = Ro(), cr = ya.browser, ps = ya.os, hr = ya.deviceType, Er = Oa.indexOf("Windows Phone") !== -1, Gn = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: cr.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !cr.isIE(),
      windowsPhone: Er,
      browser: {
        current: cr.current,
        version: cr.version,
        isChromium: cr.isChromium,
        isEdge: cr.isEdge,
        isFirefox: cr.isFirefox,
        isIE: cr.isIE,
        isOpera: cr.isOpera,
        isSafari: cr.isSafari
      },
      os: {
        current: ps.current,
        version: ps.version,
        isAndroid: ps.isAndroid,
        isChromeOS: ps.isChromeOS,
        isFreeBSD: ps.isFreeBSD,
        isiOS: ps.isiOS,
        isLinux: ps.isLinux,
        isMacOS: ps.isMacOS,
        isSolaris: ps.isSolaris,
        isWindows: ps.isWindows
      },
      deviceType: {
        isDesktop: hr.isDesktop,
        isiPad: hr.isiPad,
        isiPhone: hr.isiPhone,
        isPhone: hr.isPhone,
        isTablet: hr.isTablet,
        isTouch: hr.isTouch,
        isWebView: hr.isWebView
      }
    }, Ds = /^\s*|\s*$/g, Pa = (e) => e == null ? "" : ("" + e).replace(Ds, ""), Qr = (e, t) => t ? t === "array" && Ks(e) ? !0 : typeof e === t : e !== void 0, x = (e, t, n) => {
      let o;
      for (e = e || [], t = t || ",", typeof e == "string" && (e = e.split(t)), n = n || {}, o = e.length; o--; )
        n[e[o]] = {};
      return n;
    }, B = gn, K = (e, ...t) => {
      for (let n = 0; n < t.length; n++) {
        const o = t[n];
        for (const s in o)
          if (gn(o, s)) {
            const a = o[s];
            a !== void 0 && (e[s] = a);
          }
      }
      return e;
    }, Re = function(e, t, n, o) {
      o = o || this, e && (n && (e = e[n]), cs(e, (s, a) => {
        if (t.call(o, s, a, n) === !1)
          return !1;
        Re(s, t, n, o);
      }));
    }, nt = {
      trim: Pa,
      isArray: Ks,
      is: Qr,
      toArray: As,
      makeMap: x,
      each: cs,
      map: Lo,
      grep: Ys,
      inArray: O,
      hasOwn: B,
      extend: K,
      walk: Re,
      resolve: (e, t) => {
        let n, o;
        for (t = t || window, e = e.split("."), n = 0, o = e.length; n < o && (t = t[e[n]], !!t); n++)
          ;
        return t;
      },
      explode: (e, t) => !e || Qr(e, "array") ? e : Lo(e.split(t || ","), Pa),
      _addCacheSuffix: (e) => {
        const t = Gn.cacheSuffix;
        return t && (e += (e.indexOf("?") === -1 ? "?" : "&") + t), e;
      }
    }, Xo = (e, t, n = yt) => e.exists((o) => n(o, t)), Tr = (e) => {
      const t = [], n = (o) => {
        t.push(o);
      };
      for (let o = 0; o < e.length; o++)
        e[o].each(n);
      return t;
    }, zo = (e, t, n) => e.isSome() && t.isSome() ? w.some(n(e.getOrDie(), t.getOrDie())) : w.none(), zr = (e, t, n, o) => e.isSome() && t.isSome() && n.isSome() ? w.some(o(e.getOrDie(), t.getOrDie(), n.getOrDie())) : w.none(), gs = (e, t) => e ? w.some(t) : w.none();
    typeof window < "u" || Function("return this;")();
    const $ = 8, V = 9, Te = 11, He = 1, Zt = 3, tn = (e) => e.dom.nodeName.toLowerCase(), vo = (e) => e.dom.nodeType, jo = (e) => (t) => vo(t) === e, Zs = (e) => vo(e) === $ || tn(e) === "#comment", qn = jo(He), ko = jo(Zt), Qs = jo(V), Js = jo(Te), Ya = (e) => (t) => qn(t) && tn(t) === e, ir = (e, t, n) => {
      if (ge(n) || ft(n) || Je(n))
        e.setAttribute(t, n + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e), new Error("Attribute value was not simple");
    }, ao = (e, t, n) => {
      ir(e.dom, t, n);
    }, es = (e, t) => {
      const n = e.dom;
      Ot(t, (o, s) => {
        ir(n, s, o);
      });
    }, Os = (e, t) => {
      const n = e.dom.getAttribute(t);
      return n === null ? void 0 : n;
    }, Jr = (e, t) => w.from(Os(e, t)), Ba = (e, t) => {
      const n = e.dom;
      return n && n.hasAttribute ? n.hasAttribute(t) : !1;
    }, as = (e, t) => {
      e.dom.removeAttribute(t);
    }, ba = (e) => {
      const t = e.dom.attributes;
      return t == null || t.length === 0;
    }, ea = (e) => En(e.dom.attributes, (t, n) => (t[n.name] = n.value, t), {}), rc = (e, t) => {
      const n = Os(e, t);
      return n === void 0 || n === "" ? [] : n.split(" ");
    }, Ki = (e, t, n) => {
      const s = rc(e, t).concat([n]);
      return ao(e, t, s.join(" ")), !0;
    }, ta = (e, t, n) => {
      const o = Qe(rc(e, t), (s) => s !== n);
      return o.length > 0 ? ao(e, t, o.join(" ")) : as(e, t), !1;
    }, na = (e) => e.dom.classList !== void 0, Xa = (e) => rc(e, "class"), ac = (e, t) => Ki(e, "class", t), Us = (e, t) => ta(e, "class", t), Yi = (e, t) => ce(Xa(e), t) ? Us(e, t) : ac(e, t), ka = (e, t) => {
      na(e) ? e.dom.classList.add(t) : ac(e, t);
    }, Sc = (e) => {
      (na(e) ? e.dom.classList : Xa(e)).length === 0 && as(e, "class");
    }, xc = (e, t) => {
      na(e) ? e.dom.classList.remove(t) : Us(e, t), Sc(e);
    }, ui = (e, t) => {
      const n = na(e) ? e.dom.classList.toggle(t) : Yi(e, t);
      return Sc(e), n;
    }, Ec = (e, t) => na(e) && e.dom.classList.contains(t), oa = (e) => e.style !== void 0 && Wt(e.style.getPropertyValue), tf = (e, t) => {
      const o = (t || document).createElement("div");
      if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) {
        const s = "HTML does not have a single root node";
        throw console.error(s, e), new Error(s);
      }
      return lr(o.childNodes[0]);
    }, Tc = (e, t) => {
      const o = (t || document).createElement(e);
      return lr(o);
    }, Xi = (e, t) => {
      const o = (t || document).createTextNode(e);
      return lr(o);
    }, lr = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, ne = {
      fromHtml: tf,
      fromTag: Tc,
      fromText: Xi,
      fromDom: lr,
      fromPoint: (e, t, n) => w.from(e.dom.elementFromPoint(t, n)).map(lr)
    }, cc = (e, t) => {
      const n = [], o = (a) => (n.push(a), t(a));
      let s = t(e);
      do
        s = s.bind(o);
      while (s.isSome());
      return n;
    }, sa = (e, t) => {
      const n = e.dom;
      if (n.nodeType !== He)
        return !1;
      {
        const o = n;
        if (o.matches !== void 0)
          return o.matches(t);
        if (o.msMatchesSelector !== void 0)
          return o.msMatchesSelector(t);
        if (o.webkitMatchesSelector !== void 0)
          return o.webkitMatchesSelector(t);
        if (o.mozMatchesSelector !== void 0)
          return o.mozMatchesSelector(t);
        throw new Error("Browser lacks native selectors");
      }
    }, Qi = (e) => e.nodeType !== He && e.nodeType !== V && e.nodeType !== Te || e.childElementCount === 0, nf = (e, t) => {
      const n = t === void 0 ? document : t.dom;
      return Qi(n) ? [] : W(n.querySelectorAll(e), ne.fromDom);
    }, ql = (e, t) => {
      const n = t === void 0 ? document : t.dom;
      return Qi(n) ? w.none() : w.from(n.querySelector(e)).map(ne.fromDom);
    }, _o = (e, t) => e.dom === t.dom, ws = (e, t) => {
      const n = e.dom, o = t.dom;
      return n === o ? !1 : n.contains(o);
    }, fi = (e) => ne.fromDom(e.dom.ownerDocument), wa = (e) => Qs(e) ? e : fi(e), Vl = (e) => ne.fromDom(wa(e).dom.documentElement), $a = (e) => ne.fromDom(wa(e).dom.defaultView), er = (e) => w.from(e.dom.parentNode).map(ne.fromDom), Ji = (e) => w.from(e.dom.parentElement).map(ne.fromDom), Gl = (e, t) => {
      const n = Wt(t) ? t : cn;
      let o = e.dom;
      const s = [];
      for (; o.parentNode !== null && o.parentNode !== void 0; ) {
        const a = o.parentNode, i = ne.fromDom(a);
        if (s.push(i), n(i) === !0)
          break;
        o = a;
      }
      return s;
    }, el = (e) => {
      const t = (n) => Qe(n, (o) => !_o(e, o));
      return er(e).map(fs).map(t).getOr([]);
    }, Fa = (e) => w.from(e.dom.previousSibling).map(ne.fromDom), di = (e) => w.from(e.dom.nextSibling).map(ne.fromDom), mi = (e) => io(cc(e, Fa)), tl = (e) => cc(e, di), fs = (e) => W(e.dom.childNodes, ne.fromDom), ic = (e, t) => {
      const n = e.dom.childNodes;
      return w.from(n[t]).map(ne.fromDom);
    }, nl = (e) => ic(e, 0), pi = (e) => ic(e, e.dom.childNodes.length - 1), ol = (e) => e.dom.childNodes.length, Kl = (e) => {
      const t = e.dom.head;
      if (t == null)
        throw new Error("Head is not available yet");
      return ne.fromDom(t);
    }, sl = (e) => Js(e) && L(e.dom.host), rl = Wt(Element.prototype.attachShadow) && Wt(Node.prototype.getRootNode), b = Z(rl), S = rl ? (e) => ne.fromDom(e.dom.getRootNode()) : wa, A = (e) => sl(e) ? e : Kl(wa(e)), te = (e) => {
      const t = S(e);
      return sl(t) ? w.some(t) : w.none();
    }, be = (e) => ne.fromDom(e.dom.host), $t = (e) => {
      if (b() && L(e.target)) {
        const t = ne.fromDom(e.target);
        if (qn(t) && yn(t) && e.composed && e.composedPath) {
          const n = e.composedPath();
          if (n)
            return Tn(n);
        }
      }
      return w.from(e.target);
    }, yn = (e) => L(e.dom.shadowRoot), On = (e) => {
      const t = ko(e) ? e.dom.parentNode : e.dom;
      if (t == null || t.ownerDocument === null)
        return !1;
      const n = t.ownerDocument;
      return te(ne.fromDom(t)).fold(() => n.body.contains(t), qt(On, be));
    }, Hn = (e, t, n) => {
      if (!ge(n))
        throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e), new Error("CSS value must be a string: " + n);
      oa(e) && e.style.setProperty(t, n);
    }, Mn = (e, t) => {
      oa(e) && e.style.removeProperty(t);
    }, ts = (e, t, n) => {
      const o = e.dom;
      Hn(o, t, n);
    }, Ir = (e, t) => {
      const n = e.dom;
      Ot(t, (o, s) => {
        Hn(n, s, o);
      });
    }, Hs = (e, t) => {
      const n = e.dom, s = window.getComputedStyle(n).getPropertyValue(t);
      return s === "" && !On(e) ? gd(n, t) : s;
    }, gd = (e, t) => oa(e) ? e.style.getPropertyValue(t) : "", gi = (e, t) => {
      const n = e.dom, o = gd(n, t);
      return w.from(o).filter((s) => s.length > 0);
    }, hd = (e) => {
      const t = {}, n = e.dom;
      if (oa(n))
        for (let o = 0; o < n.style.length; o++) {
          const s = n.style.item(o);
          t[s] = n.style[s];
        }
      return t;
    }, Yl = (e, t) => {
      const n = e.dom;
      Mn(n, t), Xo(Jr(e, "style").map(Dn), "") && as(e, "style");
    }, Ia = (e) => e.dom.offsetWidth, yr = (e, t) => {
      er(e).each((o) => {
        o.dom.insertBefore(t.dom, e.dom);
      });
    }, ra = (e, t) => {
      di(e).fold(() => {
        er(e).each((s) => {
          ls(s, t);
        });
      }, (o) => {
        yr(o, t);
      });
    }, yd = (e, t) => {
      nl(e).fold(() => {
        ls(e, t);
      }, (o) => {
        e.dom.insertBefore(t.dom, o.dom);
      });
    }, ls = (e, t) => {
      e.dom.appendChild(t.dom);
    }, bd = (e, t) => {
      yr(e, t), ls(t, e);
    }, al = (e, t) => {
      M(t, (n, o) => {
        const s = o === 0 ? e : t[o - 1];
        ra(s, n);
      });
    }, lc = (e, t) => {
      M(t, (n) => {
        ls(e, n);
      });
    }, cl = (e) => {
      e.dom.textContent = "", M(fs(e), (t) => {
        Do(t);
      });
    }, Do = (e) => {
      const t = e.dom;
      t.parentNode !== null && t.parentNode.removeChild(t);
    }, Es = (e) => {
      const t = fs(e);
      t.length > 0 && al(e, t), Do(e);
    }, Ar = (e, t) => {
      const o = (t || document).createElement("div");
      return o.innerHTML = e, fs(ne.fromDom(o));
    }, _s = (e) => W(e, ne.fromDom), of = (e) => e.dom.innerHTML, hi = (e, t) => {
      const o = fi(e).dom, s = ne.fromDom(o.createDocumentFragment()), a = Ar(t, o);
      lc(s, a), cl(e), ls(e, s);
    }, sf = (e) => {
      const t = ne.fromTag("div"), n = ne.fromDom(e.dom.cloneNode(!0));
      return ls(t, n), of(t);
    }, uc = (e, t, n, o, s, a, i) => ({
      target: e,
      x: t,
      y: n,
      stop: o,
      prevent: s,
      kill: a,
      raw: i
    }), Xl = (e) => {
      const t = ne.fromDom($t(e).getOr(e.target)), n = () => e.stopPropagation(), o = () => e.preventDefault(), s = Ze(o, n);
      return uc(t, e.clientX, e.clientY, n, o, s, e);
    }, bp = (e, t) => (n) => {
      e(n) && t(Xl(n));
    }, kp = (e, t, n, o, s) => {
      const a = bp(n, o);
      return e.dom.addEventListener(t, a, s), { unbind: et(wp, e, t, a, s) };
    }, Zl = (e, t, n, o) => kp(e, t, n, o, !1), wp = (e, t, n, o) => {
      e.dom.removeEventListener(t, n, o);
    }, rf = (e, t) => ({
      left: e,
      top: t,
      translate: (o, s) => rf(e + o, t + s)
    }), il = rf, kd = (e) => {
      const t = e.getBoundingClientRect();
      return il(t.left, t.top);
    }, zc = (e, t) => e !== void 0 ? e : t !== void 0 ? t : 0, yi = (e) => {
      const t = e.dom.ownerDocument, n = t.body, o = t.defaultView, s = t.documentElement;
      if (n === e.dom)
        return il(n.offsetLeft, n.offsetTop);
      const a = zc(o == null ? void 0 : o.pageYOffset, s.scrollTop), i = zc(o == null ? void 0 : o.pageXOffset, s.scrollLeft), u = zc(s.clientTop, n.clientTop), d = zc(s.clientLeft, n.clientLeft);
      return Ac(e).translate(i - d, a - u);
    }, Ac = (e) => {
      const t = e.dom, o = t.ownerDocument.body;
      return o === t ? il(o.offsetLeft, o.offsetTop) : On(e) ? kd(t) : il(0, 0);
    }, In = (e) => {
      const t = e !== void 0 ? e.dom : document, n = t.body.scrollLeft || t.documentElement.scrollLeft, o = t.body.scrollTop || t.documentElement.scrollTop;
      return il(n, o);
    }, fc = (e, t, n) => {
      const s = (n !== void 0 ? n.dom : document).defaultView;
      s && s.scrollTo(e, t);
    }, bi = (e, t) => {
      Ro().browser.isSafari() && Wt(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t);
    }, af = (e) => {
      const t = e === void 0 ? window : e;
      return Ro().browser.isFirefox() ? w.none() : w.from(t.visualViewport);
    }, cf = (e, t, n, o) => ({
      x: e,
      y: t,
      width: n,
      height: o,
      right: e + n,
      bottom: t + o
    }), lf = (e) => {
      const t = e === void 0 ? window : e, n = t.document, o = In(ne.fromDom(n));
      return af(t).fold(() => {
        const s = t.document.documentElement, a = s.clientWidth, i = s.clientHeight;
        return cf(o.left, o.top, a, i);
      }, (s) => cf(Math.max(s.pageLeft, o.left), Math.max(s.pageTop, o.top), s.width, s.height));
    }, Nc = (e) => (t) => !!t && t.nodeType === e, ki = (e) => !!e && !Object.getPrototypeOf(e), dn = Nc(1), aa = (e) => {
      const t = e.map((n) => n.toLowerCase());
      return (n) => {
        if (n && n.nodeName) {
          const o = n.nodeName.toLowerCase();
          return ce(t, o);
        }
        return !1;
      };
    }, wi = (e, t) => {
      const n = t.toLowerCase().split(" ");
      return (o) => {
        if (dn(o))
          for (let s = 0; s < n.length; s++) {
            const a = o.ownerDocument.defaultView.getComputedStyle(o, null);
            if ((a ? a.getPropertyValue(e) : null) === n[s])
              return !0;
          }
        return !1;
      };
    }, uf = (e) => (t) => dn(t) && t.hasAttribute(e), Za = (e, t) => (n) => dn(n) && n.getAttribute(e) === t, Rc = (e) => dn(e) && e.hasAttribute("data-mce-bogus"), Ql = (e) => dn(e) && e.getAttribute("data-mce-bogus") === "all", La = (e) => dn(e) && e.tagName === "TABLE", wd = (e) => (t) => !!(dn(t) && (t.contentEditable === e || t.getAttribute("data-mce-contenteditable") === e)), ll = aa([
      "textarea",
      "input"
    ]), Ft = Nc(3), _d = Nc(4), vd = Nc(7), ul = Nc(8), Jl = Nc(9), _i = Nc(11), ds = aa(["br"]), Cd = aa(["img"]), ca = wd("true"), ns = wd("false"), fl = aa([
      "td",
      "th"
    ]), dc = aa([
      "video",
      "audio",
      "object",
      "embed"
    ]), Nh = Ro().browser, Dc = (e) => oo(e, qn), vi = (e) => Nh.isFirefox() && tn(e) === "table" ? Dc(fs(e)).filter((t) => tn(t) === "caption").bind((t) => Dc(tl(t)).map((n) => {
      const o = n.dom.offsetTop, s = t.dom.offsetTop, a = t.dom.offsetHeight;
      return o <= s ? -a : 0;
    })).getOr(0) : 0, ff = (e, t) => e.children && ce(e.children, t), Sd = (e, t, n) => {
      let o = 0, s = 0;
      const a = e.ownerDocument;
      if (n = n || e, t) {
        if (n === e && t.getBoundingClientRect && Hs(ne.fromDom(e), "position") === "static") {
          const u = t.getBoundingClientRect();
          return o = u.left + (a.documentElement.scrollLeft || e.scrollLeft) - a.documentElement.clientLeft, s = u.top + (a.documentElement.scrollTop || e.scrollTop) - a.documentElement.clientTop, {
            x: o,
            y: s
          };
        }
        let i = t;
        for (; i && i !== n && i.nodeType && !ff(i, n); ) {
          const u = i;
          o += u.offsetLeft || 0, s += u.offsetTop || 0, i = u.offsetParent;
        }
        for (i = t.parentNode; i && i !== n && i.nodeType && !ff(i, n); )
          o -= i.scrollLeft || 0, s -= i.scrollTop || 0, i = i.parentNode;
        s += vi(ne.fromDom(t));
      }
      return {
        x: o,
        y: s
      };
    };
    var eu = (e, t, n, o, s) => e(n, o) ? w.some(n) : Wt(s) && s(n) ? w.none() : t(n, o, s);
    const Ci = (e, t, n) => {
      let o = e.dom;
      const s = Wt(n) ? n : cn;
      for (; o.parentNode; ) {
        o = o.parentNode;
        const a = ne.fromDom(o);
        if (t(a))
          return w.some(a);
        if (s(a))
          break;
      }
      return w.none();
    }, Oc = (e, t, n) => eu((s, a) => a(s), Ci, e, t, n), _p = (e, t) => {
      const n = e.dom;
      return n.parentNode ? vp(ne.fromDom(n.parentNode), (o) => !_o(e, o) && t(o)) : w.none();
    }, vp = (e, t) => {
      const n = (s) => t(ne.fromDom(s));
      return oo(e.dom.childNodes, n).map(ne.fromDom);
    }, xd = (e, t) => {
      const n = (o) => {
        for (let s = 0; s < o.childNodes.length; s++) {
          const a = ne.fromDom(o.childNodes[s]);
          if (t(a))
            return w.some(a);
          const i = n(o.childNodes[s]);
          if (i.isSome())
            return i;
        }
        return w.none();
      };
      return n(e.dom);
    }, Si = (e, t, n) => Ci(e, (o) => sa(o, t), n), Pc = (e, t) => ql(t, e), Ma = (e, t, n) => eu((s, a) => sa(s, a), Si, e, t, n), Ed = (e, t = {}) => {
      let n = 0;
      const o = {}, s = ne.fromDom(e), a = wa(s), i = t.maxLoadTime || 5e3, u = (j) => {
        t.referrerPolicy = j;
      }, d = (j) => {
        ls(A(s), j);
      }, y = (j) => {
        const H = A(s);
        Pc(H, "#" + j).each(Do);
      }, v = (j) => Vn(o, j).getOrThunk(() => ({
        id: "mce-u" + n++,
        passed: [],
        failed: [],
        count: 0
      })), T = (j) => new Promise((H, se) => {
        let ve;
        const Se = nt._addCacheSuffix(j), Be = v(Se);
        o[Se] = Be, Be.count++;
        const at = (nn, Ht) => {
          M(nn, en), Be.status = Ht, Be.passed = [], Be.failed = [], ve && (ve.onload = null, ve.onerror = null, ve = null);
        }, Vt = () => at(Be.passed, 2), lt = () => at(Be.failed, 3), gt = (nn, Ht) => {
          nn() || (Date.now() - bn < i ? setTimeout(Ht) : lt());
        }, Dt = () => {
          gt(() => {
            const nn = e.styleSheets;
            let Ht = nn.length;
            for (; Ht--; ) {
              const Co = nn[Ht].ownerNode;
              if (Co && Co.id === ve.id)
                return Vt(), !0;
            }
            return !1;
          }, Dt);
        };
        if (H && Be.passed.push(H), se && Be.failed.push(se), Be.status === 1)
          return;
        if (Be.status === 2) {
          Vt();
          return;
        }
        if (Be.status === 3) {
          lt();
          return;
        }
        Be.status = 1;
        const Pt = ne.fromTag("link", a.dom);
        es(Pt, {
          rel: "stylesheet",
          type: "text/css",
          id: Be.id
        });
        const bn = Date.now();
        t.contentCssCors && ao(Pt, "crossOrigin", "anonymous"), t.referrerPolicy && ao(Pt, "referrerpolicy", t.referrerPolicy), ve = Pt.dom, ve.onload = Dt, ve.onerror = lt, d(Pt), ao(Pt, "href", Se);
      }), N = (j) => Promise.allSettled(W(j, (se) => T(se).then(Z(se)))).then((se) => {
        const ve = kt(se, (Se) => Se.status === "fulfilled");
        return ve.fail.length > 0 ? Promise.reject(W(ve.fail, (Se) => Se.reason)) : W(ve.pass, (Se) => Se.value);
      }), F = (j) => {
        const H = nt._addCacheSuffix(j);
        Vn(o, H).each((se) => {
          --se.count === 0 && (delete o[H], y(se.id));
        });
      };
      return {
        load: T,
        loadAll: N,
        unload: F,
        unloadAll: (j) => {
          M(j, (H) => {
            F(H);
          });
        },
        _setReferrerPolicy: u
      };
    }, Td = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (n, o) => {
        const a = S(n).dom;
        return w.from(e.get(a)).getOrThunk(() => {
          const i = Ed(a, o);
          return e.set(a, i), i;
        });
      } };
    })();
    class hs {
      constructor(t, n) {
        this.node = t, this.rootNode = n, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(t) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", t), this.node;
      }
      prev(t) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", t), this.node;
      }
      prev2(t) {
        return this.node = this.findPreviousNode(this.node, t), this.node;
      }
      findSibling(t, n, o, s) {
        let a, i;
        if (t) {
          if (!s && t[n])
            return t[n];
          if (t !== this.rootNode) {
            if (a = t[o], a)
              return a;
            for (i = t.parentNode; i && i !== this.rootNode; i = i.parentNode)
              if (a = i[o], a)
                return a;
          }
        }
      }
      findPreviousNode(t, n) {
        let o, s, a;
        if (t) {
          if (o = t.previousSibling, this.rootNode && o === this.rootNode)
            return;
          if (o) {
            if (!n) {
              for (a = o.lastChild; a; a = a.lastChild)
                if (!a.lastChild)
                  return a;
            }
            return o;
          }
          if (s = t.parentNode, s && s !== this.rootNode)
            return s;
        }
      }
    }
    const Cp = [
      "article",
      "aside",
      "details",
      "div",
      "dt",
      "figcaption",
      "footer",
      "form",
      "fieldset",
      "header",
      "hgroup",
      "html",
      "main",
      "nav",
      "section",
      "summary",
      "body",
      "p",
      "dl",
      "multicol",
      "dd",
      "figure",
      "address",
      "center",
      "blockquote",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "listing",
      "xmp",
      "pre",
      "plaintext",
      "menu",
      "dir",
      "ul",
      "ol",
      "li",
      "hr",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "th",
      "tr",
      "td",
      "caption"
    ], zd = [
      "td",
      "th"
    ], xi = [
      "thead",
      "tbody",
      "tfoot"
    ], Sp = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], xp = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ], df = [
      "li",
      "dd",
      "dt"
    ], Ad = [
      "ul",
      "ol",
      "dl"
    ], Ep = [
      "pre",
      "script",
      "textarea",
      "style"
    ], Nd = ["pre"].concat(xp), mc = (e) => {
      let t;
      return (n) => (t = t || st(e, wn), gn(t, tn(n)));
    }, ia = mc(Cp), Tp = (e) => tn(e) === "table", mf = (e) => qn(e) && !ia(e), Ei = (e) => qn(e) && tn(e) === "br", pf = mc(Sp), gf = mc(Ad), dl = mc(df), Rd = mc(xi), tu = mc(zd), nu = mc(Ep), hf = mc(Nd), yf = (e) => hf(e) || mf(e), bf = (e, t, n) => Si(e, t, n).isSome(), ml = "\uFEFF", Ws = "\xA0", ou = (e) => e === ml, Dd = (e) => e.replace(/\uFEFF/g, ""), kf = (e, t) => {
      let n = [];
      return M(fs(e), (o) => {
        t(o) && (n = n.concat([o])), n = n.concat(kf(o, t));
      }), n;
    }, br = (e, t) => nf(t, e), su = ((e, t) => {
      const n = (a) => {
        if (!e(a))
          throw new Error("Can only get " + t + " value of a " + t + " node");
        return o(a).getOr("");
      }, o = (a) => e(a) ? w.from(a.dom.nodeValue) : w.none();
      return {
        get: n,
        getOption: o,
        set: (a, i) => {
          if (!e(a))
            throw new Error("Can only set raw " + t + " value of a " + t + " node");
          a.dom.nodeValue = i;
        }
      };
    })(ko, "text"), Bc = (e) => su.get(e), Ti = (e) => su.getOption(e), zp = (e) => {
      const t = [];
      let n = e.dom;
      for (; n; )
        t.push(ne.fromDom(n)), n = n.lastChild;
      return t;
    }, Dh = (e) => {
      const t = br(e, "br"), n = Qe(zp(e).slice(-1), Ei);
      t.length === n.length && M(n, Do);
    }, pc = () => {
      const e = ne.fromTag("br");
      return ao(e, "data-mce-bogus", "1"), e;
    }, $c = (e) => {
      cl(e), ls(e, pc());
    }, Ap = (e) => {
      pi(e).each((t) => {
        Fa(t).each((n) => {
          ia(e) && Ei(t) && ia(n) && Do(t);
        });
      });
    }, m = ml, h = ou, E = Dd, P = dn, oe = Ft, Me = (e) => (oe(e) && (e = e.parentNode), P(e) && e.hasAttribute("data-mce-caret")), mt = (e) => oe(e) && h(e.data), xt = (e) => Me(e) || mt(e), vn = (e) => e.firstChild !== e.lastChild || !ds(e.firstChild), Ln = (e, t) => {
      const o = e.ownerDocument.createTextNode(m), s = e.parentNode;
      if (t) {
        const a = e.previousSibling;
        if (oe(a)) {
          if (xt(a))
            return a;
          if (Nr(a))
            return a.splitText(a.data.length - 1);
        }
        s.insertBefore(o, e);
      } else {
        const a = e.nextSibling;
        if (oe(a)) {
          if (xt(a))
            return a;
          if (tr(a))
            return a.splitText(1), a;
        }
        e.nextSibling ? s.insertBefore(o, e.nextSibling) : s.appendChild(o);
      }
      return o;
    }, ss = (e) => {
      const t = e.container();
      return Ft(t) ? t.data.charAt(e.offset()) === m || e.isAtStart() && mt(t.previousSibling) : !1;
    }, uo = (e) => {
      const t = e.container();
      return Ft(t) ? t.data.charAt(e.offset() - 1) === m || e.isAtEnd() && mt(t.nextSibling) : !1;
    }, Go = (e, t, n) => {
      const s = t.ownerDocument.createElement(e);
      s.setAttribute("data-mce-caret", n ? "before" : "after"), s.setAttribute("data-mce-bogus", "all"), s.appendChild(pc().dom);
      const a = t.parentNode;
      return n ? a.insertBefore(s, t) : t.nextSibling ? a.insertBefore(s, t.nextSibling) : a.appendChild(s), s;
    }, tr = (e) => oe(e) && e.data[0] === m, Nr = (e) => oe(e) && e.data[e.data.length - 1] === m, Qa = (e) => {
      const t = e.getElementsByTagName("br"), n = t[t.length - 1];
      Rc(n) && n.parentNode.removeChild(n);
    }, ja = (e) => e && e.hasAttribute("data-mce-caret") ? (Qa(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, ru = (e) => Me(e.startContainer), pl = ca, Fc = ns, Ic = ds, au = Ft, gl = aa([
      "script",
      "style",
      "textarea"
    ]), hl = aa([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), Np = aa(["table"]), Rp = xt, $n = (e) => Rp(e) ? !1 : au(e) ? !gl(e.parentNode) : hl(e) || Ic(e) || Np(e) || Ps(e), Ko = (e) => dn(e) && e.getAttribute("unselectable") === "true", Ps = (e) => Ko(e) === !1 && Fc(e), Lr = (e, t) => {
      for (e = e.parentNode; e && e !== t; e = e.parentNode) {
        if (Ps(e))
          return !1;
        if (pl(e))
          return !0;
      }
      return !0;
    }, Dp = (e) => Ps(e) ? En(ho(e.getElementsByTagName("*")), (t, n) => t || pl(n), !1) !== !0 : !1, cu = (e) => hl(e) || Dp(e), Ua = (e, t) => $n(e) && Lr(e, t), Ha = /^[ \t\r\n]*$/, gc = (e) => Ha.test(e), Oh = (e) => " \f	\v".indexOf(e) !== -1, Op = (e) => e === `
` || e === "\r", Wk = (e, t) => t < e.length && t >= 0 ? Op(e[t]) : !1, Ph = (e, t = 4, n = !0, o = !0) => {
      const s = Qo(" ", t), a = e.replace(/\t/g, s);
      return En(a, (u, d) => Oh(d) || d === Ws ? u.pcIsSpace || u.str === "" && n || u.str.length === a.length - 1 && o || Wk(a, u.str.length + 1) ? {
        pcIsSpace: !1,
        str: u.str + Ws
      } : {
        pcIsSpace: !0,
        str: u.str + " "
      } : {
        pcIsSpace: Op(d),
        str: u.str + d
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, qk = (e, t) => {
      const n = ne.fromDom(t), o = ne.fromDom(e);
      return bf(o, "pre,code", et(_o, n));
    }, Vk = (e, t) => Ft(e) && gc(e.data) && qk(e, t) === !1, Gk = (e) => dn(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), Od = (e, t) => $n(e) && Vk(e, t) === !1 || Gk(e) || Kk(e), Kk = uf("data-mce-bookmark"), Bh = uf("data-mce-bogus"), Yk = Za("data-mce-bogus", "all"), Xk = (e, t) => {
      let n = 0;
      if (Od(e, e))
        return !1;
      {
        let o = e.firstChild;
        if (!o)
          return !0;
        const s = new hs(o, e);
        do {
          if (t) {
            if (Yk(o)) {
              o = s.next(!0);
              continue;
            }
            if (Bh(o)) {
              o = s.next();
              continue;
            }
          }
          if (ds(o)) {
            n++, o = s.next();
            continue;
          }
          if (Od(o, e))
            return !1;
          o = s.next();
        } while (o);
        return n <= 1;
      }
    }, Bs = (e, t = !0) => Xk(e.dom, t), $h = (e) => e.nodeName.toLowerCase() === "span", Fh = (e, t) => L(e) && (Od(e, t) || mf(ne.fromDom(e))), Zk = (e, t) => {
      const n = new hs(e, t).prev(!1), o = new hs(e, t).next(!1), s = Le(n) || Fh(n, t), a = Le(o) || Fh(o, t);
      return s && a;
    }, Pd = (e) => $h(e) && e.getAttribute("data-mce-type") === "bookmark", Qk = (e, t) => Ft(e) && e.data.length > 0 && Zk(e, t), Bd = (e) => dn(e) ? e.childNodes.length > 0 : !1, Jk = (e) => _i(e) || Jl(e), iu = (e, t, n) => {
      const o = n || t;
      if (dn(t) && Pd(t))
        return t;
      const s = t.childNodes;
      for (let a = s.length - 1; a >= 0; a--)
        iu(e, s[a], o);
      if (dn(t)) {
        const a = t.childNodes;
        a.length === 1 && Pd(a[0]) && t.parentNode.insertBefore(a[0], t);
      }
      return !Jk(t) && !Od(t, o) && !Bd(t) && !Qk(t, o) && e.remove(t), t;
    }, ew = nt.makeMap, $d = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Fd = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, tw = /[<>&\"\']/g, nw = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, ow = {
      128: "\u20AC",
      130: "\u201A",
      131: "\u0192",
      132: "\u201E",
      133: "\u2026",
      134: "\u2020",
      135: "\u2021",
      136: "\u02C6",
      137: "\u2030",
      138: "\u0160",
      139: "\u2039",
      140: "\u0152",
      142: "\u017D",
      145: "\u2018",
      146: "\u2019",
      147: "\u201C",
      148: "\u201D",
      149: "\u2022",
      150: "\u2013",
      151: "\u2014",
      152: "\u02DC",
      153: "\u2122",
      154: "\u0161",
      155: "\u203A",
      156: "\u0153",
      158: "\u017E",
      159: "\u0178"
    }, yl = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, sw = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, Ih = (e) => {
      const t = ne.fromTag("div").dom;
      return t.innerHTML = e, t.textContent || t.innerText || e;
    }, Id = (e, t) => {
      let n, o, s;
      const a = {};
      if (e) {
        for (e = e.split(","), t = t || 10, n = 0; n < e.length; n += 2)
          o = String.fromCharCode(parseInt(e[n], t)), yl[o] || (s = "&" + e[n + 1] + ";", a[o] = s, a[s] = o);
        return a;
      }
    }, Pp = Id("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), Ld = (e, t) => e.replace(t ? $d : Fd, (n) => yl[n] || n), Md = (e) => ("" + e).replace(tw, (t) => yl[t] || t), jd = (e, t) => e.replace(t ? $d : Fd, (n) => n.length > 1 ? "&#" + ((n.charCodeAt(0) - 55296) * 1024 + (n.charCodeAt(1) - 56320) + 65536) + ";" : yl[n] || "&#" + n.charCodeAt(0) + ";"), Bp = (e, t, n) => (n = n || Pp, e.replace(t ? $d : Fd, (o) => yl[o] || n[o] || o)), zi = {
      encodeRaw: Ld,
      encodeAllRaw: Md,
      encodeNumeric: jd,
      encodeNamed: Bp,
      getEncodeFunc: (e, t) => {
        const n = Id(t) || Pp, o = (i, u) => i.replace(u ? $d : Fd, (d) => yl[d] !== void 0 ? yl[d] : n[d] !== void 0 ? n[d] : d.length > 1 ? "&#" + ((d.charCodeAt(0) - 55296) * 1024 + (d.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + d.charCodeAt(0) + ";"), s = (i, u) => Bp(i, u, n), a = ew(e.replace(/\+/g, ","));
        return a.named && a.numeric ? o : a.named ? t ? s : Bp : a.numeric ? jd : Ld;
      },
      decode: (e) => e.replace(nw, (t, n) => n ? (n.charAt(0).toLowerCase() === "x" ? n = parseInt(n.substr(1), 16) : n = parseInt(n, 10), n > 65535 ? (n -= 65536, String.fromCharCode(55296 + (n >> 10), 56320 + (n & 1023))) : ow[n] || String.fromCharCode(n)) : sw[t] || Pp[t] || Ih(t))
    }, Lc = {}, aw = {}, bl = nt.makeMap, ur = nt.each, $p = nt.extend, _f = nt.explode, cw = nt.inArray, nr = (e, t) => (e = nt.trim(e), e ? e.split(t || " ") : []), Ud = (e, t) => {
      const n = bl(e, " ", bl(e.toUpperCase(), " "));
      return $p(n, t);
    }, Lh = (e) => Ud("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), Fp = (e) => {
      const t = {};
      let n, o, s, a, i, u;
      const d = (v, T = "", N = "") => {
        const F = nr(N), U = nr(v);
        let j = U.length;
        for (; j--; ) {
          const H = nr([
            n,
            T
          ].join(" "));
          t[U[j]] = {
            attributes: st(H, () => ({})),
            attributesOrder: H,
            children: st(F, Z(aw))
          };
        }
      }, y = (v, T) => {
        const N = nr(v), F = nr(T);
        let U = N.length;
        for (; U--; ) {
          const j = t[N[U]];
          for (let H = 0, se = F.length; H < se; H++)
            j.attributes[F[H]] = {}, j.attributesOrder.push(F[H]);
        }
      };
      return Lc[e] ? Lc[e] : (n = "id accesskey class dir lang style tabindex title role", o = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", s = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4" && (n += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", o += " article aside details dialog figure main header footer hgroup section nav", s += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen"), e !== "html5-strict" && (n += " xml:lang", u = "acronym applet basefont big font strike tt", s = [
        s,
        u
      ].join(" "), ur(nr(u), (v) => {
        d(v, "", s);
      }), i = "center dir isindex noframes", o = [
        o,
        i
      ].join(" "), a = [
        o,
        s
      ].join(" "), ur(nr(i), (v) => {
        d(v, "", a);
      })), a = a || [
        o,
        s
      ].join(" "), d("html", "manifest", "head body"), d("head", "", "base command link meta noscript script style title"), d("title hr noscript br"), d("base", "href target"), d("link", "href rel media hreflang type sizes hreflang"), d("meta", "name http-equiv content charset"), d("style", "media type scoped"), d("script", "src async defer type charset"), d("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", a), d("address dt dd div caption", "", a), d("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", s), d("blockquote", "cite", a), d("ol", "reversed start type", "li"), d("ul", "", "li"), d("li", "value", a), d("dl", "", "dt dd"), d("a", "href target rel media hreflang type", s), d("q", "cite", s), d("ins del", "cite datetime", a), d("img", "src sizes srcset alt usemap ismap width height"), d("iframe", "src name width height", a), d("embed", "src type width height"), d("object", "data type typemustmatch name usemap form width height", [
        a,
        "param"
      ].join(" ")), d("param", "name value"), d("map", "name", [
        a,
        "area"
      ].join(" ")), d("area", "alt coords shape href target rel media hreflang type"), d("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), d("colgroup", "span", "col"), d("col", "span"), d("tbody thead tfoot", "", "tr"), d("tr", "", "td th"), d("td", "colspan rowspan headers", a), d("th", "colspan rowspan headers scope abbr", a), d("form", "accept-charset action autocomplete enctype method name novalidate target", a), d("fieldset", "disabled form name", [
        a,
        "legend"
      ].join(" ")), d("label", "form for", s), d("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), d("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? a : s), d("select", "disabled form multiple name required size", "option optgroup"), d("optgroup", "disabled label", "option"), d("option", "disabled label selected value"), d("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), d("menu", "type label", [
        a,
        "li"
      ].join(" ")), d("noscript", "", a), e !== "html4" && (d("wbr"), d("ruby", "", [
        s,
        "rt rp"
      ].join(" ")), d("figcaption", "", a), d("mark rt rp summary bdi", "", s), d("canvas", "width height", a), d("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        a,
        "track source"
      ].join(" ")), d("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        a,
        "track source"
      ].join(" ")), d("picture", "", "img source"), d("source", "src srcset type media sizes"), d("track", "kind src srclang label default"), d("datalist", "", [
        s,
        "option"
      ].join(" ")), d("article section nav aside main header footer", "", a), d("hgroup", "", "h1 h2 h3 h4 h5 h6"), d("figure", "", [
        a,
        "figcaption"
      ].join(" ")), d("time", "datetime", s), d("dialog", "open", a), d("command", "type label icon disabled checked radiogroup command"), d("output", "for form name", s), d("progress", "value max", s), d("meter", "value min max low high optimum", s), d("details", "open", [
        a,
        "summary"
      ].join(" ")), d("keygen", "autofocus challenge disabled form keytype name")), e !== "html5-strict" && (y("script", "language xml:space"), y("style", "xml:space"), y("object", "declare classid code codebase codetype archive standby align border hspace vspace"), y("embed", "align name hspace vspace"), y("param", "valuetype type"), y("a", "charset name rev shape coords"), y("br", "clear"), y("applet", "codebase archive code object alt name width height align hspace vspace"), y("img", "name longdesc align border hspace vspace"), y("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), y("font basefont", "size color face"), y("input", "usemap align"), y("select"), y("textarea"), y("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), y("ul", "type compact"), y("li", "type"), y("ol dl menu dir", "compact"), y("pre", "width xml:space"), y("hr", "align noshade size width"), y("isindex", "prompt"), y("table", "summary width frame rules cellspacing cellpadding align bgcolor"), y("col", "width align char charoff valign"), y("colgroup", "width align char charoff valign"), y("thead", "align char charoff valign"), y("tr", "align char charoff valign bgcolor"), y("th", "axis align char charoff valign nowrap bgcolor width height"), y("form", "accept"), y("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), y("tfoot", "align char charoff valign"), y("tbody", "align char charoff valign"), y("area", "nohref"), y("body", "background bgcolor text link vlink alink")), e !== "html4" && (y("input button select textarea", "autofocus"), y("input textarea", "placeholder"), y("a", "download"), y("link script img", "crossorigin"), y("img", "loading"), y("iframe", "sandbox seamless allowfullscreen loading")), e !== "html4" && M([
        t.video,
        t.audio
      ], (v) => {
        delete v.children.audio, delete v.children.video;
      }), ur(nr("a form meter progress dfn"), (v) => {
        t[v] && delete t[v].children[v];
      }), delete t.caption.children.table, delete t.script, Lc[e] = t, t);
    }, Ip = (e, t) => {
      let n;
      return e && (n = {}, typeof e == "string" && (e = { "*": e }), ur(e, (o, s) => {
        n[s] = n[s.toUpperCase()] = t === "map" ? bl(o, /[, ]/) : _f(o, /[, ]/);
      })), n;
    }, Ai = (e) => {
      var t;
      const n = {}, o = {};
      let s = [];
      const a = {}, i = {}, u = (xn, Sn, So) => {
        let xo = e[xn];
        return xo ? xo = bl(xo, /[, ]/, bl(xo.toUpperCase(), /[, ]/)) : (xo = Lc[xn], xo || (xo = Ud(Sn, So), Lc[xn] = xo)), xo;
      };
      e = e || {};
      const d = (t = e.schema) !== null && t !== void 0 ? t : "html5", y = Fp(d);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const v = Ip(e.valid_styles), T = Ip(e.invalid_styles, "map"), N = Ip(e.valid_classes, "map"), F = u("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), U = u("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), j = u("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), H = u("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), se = "td th iframe video audio object script code", ve = u("non_empty_elements", se + " pre", j), Se = u("move_caret_before_on_enter_elements", se + " table", j), Be = u("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), at = u("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", Be), Vt = u("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");
      ur("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (xn) => {
        i[xn] = new RegExp("</" + xn + "[^>]*>", "gi");
      });
      const lt = (xn) => new RegExp("^" + xn.replace(/([?+*])/g, ".$1") + "$"), gt = (xn) => {
        let Sn, So, xo, Ms, Ho, so, Wo, Pr, Br, gr, si, pa, qr, oc, Qu, Ui, Hi, ri;
        const id = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, Ju = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, sc = /[*?+]/;
        if (xn) {
          const ai = nr(xn, ",");
          for (n["@"] && (Ui = n["@"].attributes, Hi = n["@"].attributesOrder), Sn = 0, So = ai.length; Sn < So; Sn++)
            if (Ho = id.exec(ai[Sn]), Ho) {
              if (oc = Ho[1], Br = Ho[2], Qu = Ho[3], Pr = Ho[5], pa = {}, qr = [], so = {
                attributes: pa,
                attributesOrder: qr
              }, oc === "#" && (so.paddEmpty = !0), oc === "-" && (so.removeEmpty = !0), Ho[4] === "!" && (so.removeEmptyAttrs = !0), Ui && (Ot(Ui, (ld, ci) => {
                pa[ci] = ld;
              }), qr.push.apply(qr, Hi)), Pr) {
                for (Pr = nr(Pr, "|"), xo = 0, Ms = Pr.length; xo < Ms; xo++)
                  if (Ho = Ju.exec(Pr[xo]), Ho) {
                    if (Wo = {}, si = Ho[1], gr = Ho[2].replace(/[\\:]:/g, ":"), oc = Ho[3], ri = Ho[4], si === "!" && (so.attributesRequired = so.attributesRequired || [], so.attributesRequired.push(gr), Wo.required = !0), si === "-") {
                      delete pa[gr], qr.splice(cw(qr, gr), 1);
                      continue;
                    }
                    oc && (oc === "=" && (so.attributesDefault = so.attributesDefault || [], so.attributesDefault.push({
                      name: gr,
                      value: ri
                    }), Wo.defaultValue = ri), oc === "~" && (so.attributesForced = so.attributesForced || [], so.attributesForced.push({
                      name: gr,
                      value: ri
                    }), Wo.forcedValue = ri), oc === "<" && (Wo.validValues = bl(ri, "?"))), sc.test(gr) ? (so.attributePatterns = so.attributePatterns || [], Wo.pattern = lt(gr), so.attributePatterns.push(Wo)) : (pa[gr] || qr.push(gr), pa[gr] = Wo);
                  }
              }
              !Ui && Br === "@" && (Ui = pa, Hi = qr), Qu && (so.outputName = Br, n[Qu] = so), sc.test(Br) ? (so.pattern = lt(Br), s.push(so)) : n[Br] = so;
            }
        }
      }, Dt = (xn) => {
        s = [], M(ze(n), (Sn) => {
          delete n[Sn];
        }), gt(xn), ur(y, (Sn, So) => {
          o[So] = Sn.children;
        });
      }, Pt = (xn) => {
        const Sn = /^(~)?(.+)$/;
        xn && (Lc.text_block_elements = Lc.block_elements = null, ur(nr(xn, ","), (So) => {
          const xo = Sn.exec(So), Ms = xo[1] === "~", Ho = Ms ? "span" : "div", so = xo[2];
          if (o[so] = o[Ho], a[so] = Ho, ve[so.toUpperCase()] = {}, ve[so] = {}, Ms || (at[so.toUpperCase()] = {}, at[so] = {}), !n[so]) {
            let Wo = n[Ho];
            Wo = $p({}, Wo), delete Wo.removeEmptyAttrs, delete Wo.removeEmpty, n[so] = Wo;
          }
          ur(o, (Wo, Pr) => {
            Wo[Ho] && (o[Pr] = Wo = $p({}, o[Pr]), Wo[so] = Wo[Ho]);
          });
        }));
      }, bn = (xn) => {
        const Sn = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        Lc[d] = null, xn && ur(nr(xn, ","), (So) => {
          const xo = Sn.exec(So);
          let Ms, Ho;
          xo && (Ho = xo[1], Ho ? Ms = o[xo[2]] : Ms = o[xo[2]] = { "#comment": {} }, Ms = o[xo[2]], ur(nr(xo[3], "|"), (so) => {
            Ho === "-" ? delete Ms[so] : Ms[so] = {};
          }));
        });
      }, nn = (xn) => {
        let Sn = n[xn], So;
        if (Sn)
          return Sn;
        for (So = s.length; So--; )
          if (Sn = s[So], Sn.pattern.test(xn))
            return Sn;
      };
      e.valid_elements ? Dt(e.valid_elements) : (ur(y, (xn, Sn) => {
        n[Sn] = {
          attributes: xn.attributes,
          attributesOrder: xn.attributesOrder
        }, o[Sn] = xn.children;
      }), ur(nr("strong/b em/i"), (xn) => {
        const Sn = nr(xn, "/");
        n[Sn[1]].outputName = Sn[0];
      }), ur(Vt, (xn, Sn) => {
        n[Sn] && (e.padd_empty_block_inline_children && (n[Sn].paddInEmptyBlock = !0), n[Sn].removeEmpty = !0);
      }), ur(nr("ol ul blockquote a table tbody"), (xn) => {
        n[xn] && (n[xn].removeEmpty = !0);
      }), ur(nr("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), (xn) => {
        n[xn].paddEmpty = !0;
      }), ur(nr("span"), (xn) => {
        n[xn].removeEmptyAttrs = !0;
      })), Pt(e.custom_elements), bn(e.valid_children), gt(e.extended_valid_elements), bn("+ol[ul|ol],+ul[ul|ol]"), ur({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, (xn, Sn) => {
        n[Sn] && (n[Sn].parentsRequired = nr(xn));
      }), e.invalid_elements && ur(_f(e.invalid_elements), (xn) => {
        n[xn] && delete n[xn];
      }), nn("span") || gt("span[!data-mce-type|*]");
      const Ht = Z(v), fo = Z(T), Co = Z(N), Fo = Z(H), Ls = Z(at), Nt = Z(Be), fn = Z(Vt), no = Z(Object.seal(j)), Qn = Z(U), Gs = Z(ve), Mt = Z(Se), _n = Z(F), on = Z(Object.seal(i)), Bt = (xn, Sn) => {
        const So = o[xn.toLowerCase()];
        return !!(So && So[Sn.toLowerCase()]);
      }, Jn = (xn, Sn) => {
        let So, xo;
        const Ms = nn(xn);
        if (Ms)
          if (Sn) {
            if (Ms.attributes[Sn])
              return !0;
            if (So = Ms.attributePatterns, So) {
              for (xo = So.length; xo--; )
                if (So[xo].pattern.test(Sn))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, co = Z(a);
      return {
        type: d,
        children: o,
        elements: n,
        getValidStyles: Ht,
        getValidClasses: Co,
        getBlockElements: Ls,
        getInvalidStyles: fo,
        getVoidElements: no,
        getTextBlockElements: Nt,
        getTextInlineElements: fn,
        getBoolAttrs: Fo,
        getElementRule: nn,
        getSelfClosingElements: Qn,
        getNonEmptyElements: Gs,
        getMoveCaretBeforeOnEnterElements: Mt,
        getWhitespaceElements: _n,
        getSpecialElements: on,
        isValidChild: Bt,
        isValid: Jn,
        getCustomElements: co,
        addValidElements: gt,
        setValidElements: Dt,
        addCustomElements: Pt,
        addValidChildren: bn
      };
    }, Mc = (e, t) => {
      const n = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, o = /\s*([^:]+):\s*([^;]+);?/g, s = /\s+$/;
      let a;
      const i = {};
      let u, d;
      const y = ml;
      e = e || {}, t && (u = t.getValidStyles(), d = t.getInvalidStyles());
      const v = (`\\" \\' \\; \\: ; : ` + y).split(" ");
      for (a = 0; a < v.length; a++)
        i[v[a]] = y + a, i[y + a] = v[a];
      const T = {
        parse: (N) => {
          const F = {};
          let U, j, H, se;
          const ve = e.url_converter, Se = e.url_converter_scope || T, Be = (nn, Ht, fo) => {
            const Co = F[nn + "-top" + Ht];
            if (!Co)
              return;
            const Fo = F[nn + "-right" + Ht];
            if (!Fo)
              return;
            const Ls = F[nn + "-bottom" + Ht];
            if (!Ls)
              return;
            const Nt = F[nn + "-left" + Ht];
            if (!Nt)
              return;
            const fn = [
              Co,
              Fo,
              Ls,
              Nt
            ];
            for (a = fn.length - 1; a-- && fn[a] === fn[a + 1]; )
              ;
            a > -1 && fo || (F[nn + Ht] = a === -1 ? fn[0] : fn.join(" "), delete F[nn + "-top" + Ht], delete F[nn + "-right" + Ht], delete F[nn + "-bottom" + Ht], delete F[nn + "-left" + Ht]);
          }, at = (nn) => {
            let Ht = F[nn], fo;
            if (!!Ht) {
              for (Ht = Ht.split(" "), fo = Ht.length; fo--; )
                if (Ht[fo] !== Ht[0])
                  return !1;
              return F[nn] = Ht[0], !0;
            }
          }, Vt = (nn, Ht, fo, Co) => {
            !at(Ht) || !at(fo) || !at(Co) || (F[nn] = F[Ht] + " " + F[fo] + " " + F[Co], delete F[Ht], delete F[fo], delete F[Co]);
          }, lt = (nn) => (se = !0, i[nn]), gt = (nn, Ht) => (se && (nn = nn.replace(/\uFEFF[0-9]/g, (fo) => i[fo])), Ht || (nn = nn.replace(/\\([\'\";:])/g, "$1")), nn), Dt = (nn) => String.fromCharCode(parseInt(nn.slice(1), 16)), Pt = (nn) => nn.replace(/\\[0-9a-f]+/gi, Dt), bn = (nn, Ht, fo, Co, Fo, Ls) => {
            if (Fo = Fo || Ls, Fo)
              return Fo = gt(Fo), "'" + Fo.replace(/\'/g, "\\'") + "'";
            if (Ht = gt(Ht || fo || Co), !e.allow_script_urls) {
              const Nt = Ht.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(Nt) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(Nt))
                return "";
            }
            return ve && (Ht = ve.call(Se, Ht, "style")), "url('" + Ht.replace(/\'/g, "\\'") + "')";
          };
          if (N) {
            for (N = N.replace(/[\u0000-\u001F]/g, ""), N = N.replace(/\\[\"\';:\uFEFF]/g, lt).replace(/\"[^\"]+\"|\'[^\']+\'/g, (nn) => nn.replace(/[;:]/g, lt)); U = o.exec(N); )
              if (o.lastIndex = U.index + U[0].length, j = U[1].replace(s, "").toLowerCase(), H = U[2].replace(s, ""), j && H) {
                if (j = Pt(j), H = Pt(H), j.indexOf(y) !== -1 || j.indexOf('"') !== -1 || !e.allow_script_urls && (j === "behavior" || /expression\s*\(|\/\*|\*\//.test(H)))
                  continue;
                j === "font-weight" && H === "700" ? H = "bold" : (j === "color" || j === "background-color") && (H = H.toLowerCase()), H = H.replace(n, bn), F[j] = se ? gt(H, !0) : H;
              }
            Be("border", "", !0), Be("border", "-width"), Be("border", "-color"), Be("border", "-style"), Be("padding", ""), Be("margin", ""), Vt("border", "border-width", "border-style", "border-color"), F.border === "medium none" && delete F.border, F["border-image"] === "none" && delete F["border-image"];
          }
          return F;
        },
        serialize: (N, F) => {
          let U = "";
          const j = (se) => {
            let ve;
            const Se = u[se];
            if (Se)
              for (let Be = 0, at = Se.length; Be < at; Be++)
                se = Se[Be], ve = N[se], ve && (U += (U.length > 0 ? " " : "") + se + ": " + ve + ";");
          }, H = (se, ve) => {
            let Se = d["*"];
            return Se && Se[se] ? !1 : (Se = d[ve], !(Se && Se[se]));
          };
          return F && u ? (j("*"), j(F)) : Ot(N, (se, ve) => {
            se && (!d || H(ve, F)) && (U += (U.length > 0 ? " " : "") + ve + ": " + se + ";");
          }), U;
        }
      };
      return T;
    }, Hd = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, iw = (e) => e instanceof Event || Wt(e.initEvent), lw = (e) => e.isDefaultPrevented === wn || e.isDefaultPrevented === cn, uw = (e) => Ve(e.preventDefault) || iw(e), Lp = (e, t) => {
      const n = t != null ? t : {};
      for (const o in e)
        gn(Hd, o) || (n[o] = e[o]);
      return L(n.composedPath) && (n.composedPath = () => e.composedPath()), n;
    }, Mp = (e, t, n, o) => {
      var s;
      const a = Lp(t, o);
      return a.type = e, Ve(a.target) && (a.target = (s = a.srcElement) !== null && s !== void 0 ? s : n), uw(t) && (a.preventDefault = () => {
        a.defaultPrevented = !0, a.isDefaultPrevented = wn, Wt(t.preventDefault) && t.preventDefault();
      }, a.stopPropagation = () => {
        a.cancelBubble = !0, a.isPropagationStopped = wn, Wt(t.stopPropagation) && t.stopPropagation();
      }, a.stopImmediatePropagation = () => {
        a.isImmediatePropagationStopped = wn, a.stopPropagation();
      }, lw(a) || (a.isDefaultPrevented = a.defaultPrevented === !0 ? wn : cn, a.isPropagationStopped = a.cancelBubble === !0 ? wn : cn, a.isImmediatePropagationStopped = cn)), a;
    }, jp = "mce-data-", hc = /^(?:mouse|contextmenu)|click/, Up = (e, t, n, o) => {
      e.addEventListener ? e.addEventListener(t, n, o || !1) : e.attachEvent && e.attachEvent("on" + t, n);
    }, Wd = (e, t, n, o) => {
      e.removeEventListener ? e.removeEventListener(t, n, o || !1) : e.detachEvent && e.detachEvent("on" + t, n);
    }, fw = (e) => L(e) && hc.test(e.type), lu = (e, t) => {
      const n = Mp(e.type, e, document, t);
      if (fw(e) && Le(e.pageX) && !Le(e.clientX)) {
        const o = n.target.ownerDocument || document, s = o.documentElement, a = o.body, i = n;
        i.pageX = e.clientX + (s && s.scrollLeft || a && a.scrollLeft || 0) - (s && s.clientLeft || a && a.clientLeft || 0), i.pageY = e.clientY + (s && s.scrollTop || a && a.scrollTop || 0) - (s && s.clientTop || a && a.clientTop || 0);
      }
      return n;
    }, dw = (e, t, n) => {
      const o = e.document, s = { type: "ready" };
      if (n.domLoaded) {
        t(s);
        return;
      }
      const a = () => o.readyState === "complete" || o.readyState === "interactive" && o.body, i = () => {
        Wd(e, "DOMContentLoaded", i), Wd(e, "load", i), n.domLoaded || (n.domLoaded = !0, t(s)), e = null;
      };
      a() ? i() : Up(e, "DOMContentLoaded", i), n.domLoaded || Up(e, "load", i);
    };
    class Ja {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = jp + (+new Date()).toString(32), this.hasMouseEnterLeave = "onmouseenter" in document.documentElement, this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(t, n, o, s) {
        const a = this;
        let i, u, d, y, v, T, N;
        const F = window, U = (H) => {
          a.executeHandlers(lu(H || F.event), i);
        };
        if (!t || t.nodeType === 3 || t.nodeType === 8)
          return;
        t[a.expando] ? i = t[a.expando] : (i = a.count++, t[a.expando] = i, a.events[i] = {}), s = s || t;
        const j = n.split(" ");
        for (d = j.length; d--; ) {
          if (y = j[d], T = U, v = N = !1, y === "DOMContentLoaded" && (y = "ready"), a.domLoaded && y === "ready" && t.readyState === "complete") {
            o.call(s, lu({ type: y }));
            continue;
          }
          a.hasMouseEnterLeave || (v = a.mouseEnterLeave[y], v && (T = (H) => {
            const se = H.currentTarget;
            let ve = H.relatedTarget;
            if (ve && se.contains)
              ve = se.contains(ve);
            else
              for (; ve && ve !== se; )
                ve = ve.parentNode;
            ve || (H = lu(H || F.event), H.type = H.type === "mouseout" ? "mouseleave" : "mouseenter", H.target = se, a.executeHandlers(H, i));
          })), !a.hasFocusIn && (y === "focusin" || y === "focusout") && (N = !0, v = y === "focusin" ? "focus" : "blur", T = (H) => {
            H = lu(H || F.event), H.type = H.type === "focus" ? "focusin" : "focusout", a.executeHandlers(H, i);
          }), u = a.events[i][y], u ? y === "ready" && a.domLoaded ? o(lu({ type: y })) : u.push({
            func: o,
            scope: s
          }) : (a.events[i][y] = u = [{
            func: o,
            scope: s
          }], u.fakeName = v, u.capture = N, u.nativeHandler = T, y === "ready" ? dw(t, T, a) : Up(t, v || y, T, N));
        }
        return t = u = null, o;
      }
      unbind(t, n, o) {
        let s, a, i, u, d;
        if (!t || t.nodeType === 3 || t.nodeType === 8)
          return this;
        const y = t[this.expando];
        if (y) {
          if (d = this.events[y], n) {
            const v = n.split(" ");
            for (a = v.length; a--; )
              if (u = v[a], s = d[u], s) {
                if (o) {
                  for (i = s.length; i--; )
                    if (s[i].func === o) {
                      const T = s.nativeHandler, N = s.fakeName, F = s.capture;
                      s = s.slice(0, i).concat(s.slice(i + 1)), s.nativeHandler = T, s.fakeName = N, s.capture = F, d[u] = s;
                    }
                }
                (!o || s.length === 0) && (delete d[u], Wd(t, s.fakeName || u, s.nativeHandler, s.capture));
              }
          } else
            Ot(d, (v, T) => {
              Wd(t, v.fakeName || T, v.nativeHandler, v.capture);
            }), d = {};
          for (u in d)
            if (gn(d, u))
              return this;
          delete this.events[y];
          try {
            delete t[this.expando];
          } catch {
            t[this.expando] = null;
          }
        }
        return this;
      }
      fire(t, n, o) {
        return this.dispatch(t, n, o);
      }
      dispatch(t, n, o) {
        let s;
        if (!t || t.nodeType === 3 || t.nodeType === 8)
          return this;
        const a = lu({
          type: n,
          target: t
        }, o);
        do
          s = t[this.expando], s && this.executeHandlers(a, s), t = t.parentNode || t.ownerDocument || t.defaultView || t.parentWindow;
        while (t && !a.isPropagationStopped());
        return this;
      }
      clean(t) {
        let n, o;
        if (!t || t.nodeType === 3 || t.nodeType === 8)
          return this;
        if (t[this.expando] && this.unbind(t), t.getElementsByTagName || (t = t.document), t && t.getElementsByTagName)
          for (this.unbind(t), o = t.getElementsByTagName("*"), n = o.length; n--; )
            t = o[n], t[this.expando] && this.unbind(t);
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(t) {
        return t && (t.preventDefault(), t.stopImmediatePropagation()), !1;
      }
      executeHandlers(t, n) {
        const o = this.events[n], s = o && o[t.type];
        if (s)
          for (let a = 0, i = s.length; a < i; a++) {
            const u = s[a];
            if (u && u.func.call(u.scope, t) === !1 && t.preventDefault(), t.isImmediatePropagationStopped())
              return;
          }
      }
    }
    Ja.Event = new Ja();
    const qd = nt.each, Mh = nt.grep, Vd = "data-mce-style", vf = (e, t, n) => {
      Ve(n) || n === "" ? as(e, t) : ao(e, t, n);
    }, mw = (e, t, n) => {
      const o = t.keep_values, s = {
        set: (i, u, d) => {
          const y = ne.fromDom(i);
          Wt(t.url_converter) && L(u) && (u = t.url_converter.call(t.url_converter_scope || n(), u, d, i[0]));
          const v = "data-mce-" + d;
          vf(y, v, u), vf(y, d, u);
        },
        get: (i, u) => {
          const d = ne.fromDom(i);
          return Os(d, "data-mce-" + u) || Os(d, u);
        }
      }, a = {
        style: {
          set: (i, u) => {
            const d = ne.fromDom(i);
            if (zt(u)) {
              Ir(d, u);
              return;
            }
            o && vf(d, Vd, u), as(d, "style"), ge(u) && Ir(d, e.parse(u));
          },
          get: (i) => {
            const u = ne.fromDom(i), d = Os(u, Vd) || Os(u, "style");
            return e.serialize(e.parse(d), tn(u));
          }
        }
      };
      return o && (a.href = a.src = s), a;
    }, pw = (e, t) => {
      const n = Os(t, "style"), o = e.serialize(e.parse(n), tn(t));
      vf(t, Vd, o);
    }, uu = (e, t) => {
      let n = 0, o, s;
      if (e)
        for (o = e.nodeType, e = e.previousSibling; e; e = e.previousSibling)
          s = e.nodeType, !(t && s === 3 && (s === o || !e.nodeValue.length)) && (n++, o = s);
      return n;
    }, Gd = nt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), Hp = (e) => e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), Uo = (e, t = {}) => {
      const n = {}, o = window, s = {};
      let a = 0;
      const i = !0, u = !0, d = Td.forElement(ne.fromDom(e), {
        contentCssCors: t.contentCssCors,
        referrerPolicy: t.referrerPolicy
      }), y = [], v = t.schema ? t.schema : Ai({}), T = Mc({
        url_converter: t.url_converter,
        url_converter_scope: t.url_converter_scope
      }, t.schema), N = t.ownEvents ? new Ja() : Ja.Event, F = v.getBlockElements(), U = (pe) => ge(pe) ? gn(F, pe) : dn(pe) && gn(F, pe.nodeName), j = (pe) => pe && e && ge(pe) ? e.getElementById(pe) : pe, H = (pe) => {
        const De = j(pe);
        return L(De) ? ne.fromDom(De) : null;
      }, se = (pe, De, ht) => {
        let ut;
        const mn = H(pe);
        if (L(mn) && qn(mn)) {
          const go = xk[De];
          go && go.get ? ut = go.get(mn.dom, De) : ut = Os(mn, De);
        }
        return L(ut) ? ut : ht != null ? ht : "";
      }, ve = (pe) => {
        const De = j(pe);
        return Ve(De) ? [] : De.attributes;
      }, Se = (pe, De, ht) => {
        no(pe, (ut) => {
          if (dn(ut)) {
            const mn = ne.fromDom(ut);
            ht === "" && (ht = null);
            const go = Os(mn, De), mo = xk[De];
            mo && mo.set ? mo.set(mn.dom, ht, De) : vf(mn, De, ht), go !== ht && t.onSetAttrib && t.onSetAttrib({
              attrElm: mn,
              attrName: De,
              attrValue: ht
            });
          }
        });
      }, Be = (pe, De) => pe.cloneNode(De), at = () => t.root_element || e.body, Vt = (pe) => {
        const De = lf(pe);
        return {
          x: De.x,
          y: De.y,
          w: De.width,
          h: De.height
        };
      }, lt = (pe, De) => Sd(e.body, j(pe), De), gt = (pe, De, ht) => {
        const ut = (go, mo) => ge(go) ? go : Je(go) ? gn(Gd, mo) ? go + "" : go + "px" : hn(go, ut), mn = (go, mo, Na) => {
          const ii = Hp(mo);
          Ve(Na) || Na === "" ? Yl(go, ii) : ts(go, ii, ut(Na, ii));
        };
        no(pe, (go) => {
          const mo = ne.fromDom(go);
          ge(De) ? mn(mo, De, ht) : Ot(De, (Na, ii) => {
            mn(mo, ii, Na);
          }), t.update_styles && pw(T, mo);
        });
      }, Dt = (pe, De) => {
        gt(pe, De);
      }, Pt = (pe, De, ht) => {
        const ut = j(pe);
        if (!(Ve(ut) || !dn(ut)))
          return ht ? Hs(ne.fromDom(ut), Hp(De)) : (De = De.replace(/-(\D)/g, (mn, go) => go.toUpperCase()), De === "float" && (De = "cssFloat"), ut.style ? ut.style[De] : void 0);
      }, bn = (pe) => {
        let De, ht;
        const ut = j(pe);
        return De = Pt(ut, "width"), ht = Pt(ut, "height"), De.indexOf("px") === -1 && (De = 0), ht.indexOf("px") === -1 && (ht = 0), {
          w: parseInt(De, 10) || ut.offsetWidth || ut.clientWidth,
          h: parseInt(ht, 10) || ut.offsetHeight || ut.clientHeight
        };
      }, nn = (pe) => {
        const De = j(pe), ht = lt(De), ut = bn(De);
        return {
          x: ht.x,
          y: ht.y,
          w: ut.w,
          h: ut.h
        };
      }, Ht = (pe, De) => {
        if (!pe)
          return !1;
        const ht = le(pe) ? pe : [pe];
        return Ce(ht, (ut) => sa(ne.fromDom(ut), De));
      }, fo = (pe, De, ht, ut) => {
        const mn = [];
        let go, mo = j(pe);
        for (ut = ut === void 0, ht = ht || (at().nodeName !== "BODY" ? at().parentNode : null), ge(De) && (go = De, De === "*" ? De = dn : De = (Na) => Ht(Na, go)); mo && !(mo === ht || Ve(mo.nodeType) || Jl(mo) || _i(mo)); ) {
          if (!De || De(mo))
            if (ut)
              mn.push(mo);
            else
              return [mo];
          mo = mo.parentNode;
        }
        return ut ? mn : null;
      }, Co = (pe, De, ht) => {
        const ut = fo(pe, De, ht, !1);
        return ut && ut.length > 0 ? ut[0] : null;
      }, Fo = (pe, De, ht) => {
        let ut = De;
        if (pe) {
          for (ge(De) && (ut = (mn) => Ht(mn, De)), pe = pe[ht]; pe; pe = pe[ht])
            if (Wt(ut) && ut(pe))
              return pe;
        }
        return null;
      }, Ls = (pe, De) => Fo(pe, De, "nextSibling"), Nt = (pe, De) => Fo(pe, De, "previousSibling"), fn = (pe, De) => {
        var ht, ut;
        const mn = (ut = (ht = j(De)) !== null && ht !== void 0 ? ht : t.root_element) !== null && ut !== void 0 ? ut : e;
        return ho(mn.querySelectorAll(pe));
      }, no = function(pe, De, ht) {
        const ut = ht != null ? ht : this, mn = ge(pe) ? j(pe) : pe;
        if (!mn)
          return !1;
        if (le(mn) && (mn.length || mn.length === 0)) {
          const go = [];
          return qd(mn, (mo, Na) => {
            mo && go.push(De.call(ut, ge(mo) ? j(mo) : mo, Na));
          }), go;
        } else
          return De.call(ut, mn);
      }, Qn = (pe, De) => {
        no(pe, (ht) => {
          Ot(De, (ut, mn) => {
            Se(ht, mn, ut);
          });
        });
      }, Gs = (pe, De) => {
        no(pe, (ht) => {
          const ut = ne.fromDom(ht);
          hi(ut, De);
        });
      }, Mt = (pe, De, ht, ut, mn) => no(pe, (go) => {
        const mo = ge(De) ? e.createElement(De) : De;
        return L(ht) && Qn(mo, ht), ut && (!ge(ut) && ut.nodeType ? mo.appendChild(ut) : ge(ut) && Gs(mo, ut)), mn ? mo : go.appendChild(mo);
      }), _n = (pe, De, ht) => Mt(e.createElement(pe), pe, De, ht, !0), on = zi.decode, Bt = zi.encodeAllRaw, Jn = (pe, De, ht = "") => {
        let ut = "", mn;
        ut += "<" + pe;
        for (mn in De)
          qo(De, mn) && (ut += " " + mn + '="' + Bt(De[mn]) + '"');
        return to(ht) && gn(v.getVoidElements(), pe) ? ut + " />" : ut + ">" + ht + "</" + pe + ">";
      }, co = (pe) => {
        let De;
        const ht = e.createElement("div"), ut = e.createDocumentFragment();
        for (ut.appendChild(ht), pe && (ht.innerHTML = pe); De = ht.firstChild; )
          ut.appendChild(De);
        return ut.removeChild(ht), ut;
      }, xn = (pe, De) => no(pe, (ht) => {
        const ut = ne.fromDom(ht);
        return De && M(fs(ut), (mn) => {
          ko(mn) && mn.dom.length === 0 ? Do(mn) : yr(ut, mn);
        }), Do(ut), ut.dom;
      }), Sn = (pe) => no(pe, (De) => {
        const ht = De.attributes;
        for (let ut = ht.length - 1; ut >= 0; ut--)
          De.removeAttributeNode(ht.item(ut));
      }), So = (pe) => T.parse(pe), xo = (pe, De) => T.serialize(pe, De), Ms = (pe) => {
        let De, ht;
        if (jl !== Uo.DOM && e === document) {
          if (n[pe])
            return;
          n[pe] = !0;
        }
        ht = e.getElementById("mceDefaultStyles"), ht || (ht = e.createElement("style"), ht.id = "mceDefaultStyles", ht.type = "text/css", De = e.getElementsByTagName("head")[0], De.firstChild ? De.insertBefore(ht, De.firstChild) : De.appendChild(ht)), ht.styleSheet ? ht.styleSheet.cssText += pe : ht.appendChild(e.createTextNode(pe));
      }, Ho = (pe) => {
        pe || (pe = ""), M(pe.split(","), (De) => {
          s[De] = !0, d.load(De).catch(ye);
        });
      }, so = (pe, De, ht) => {
        no(pe, (ut) => {
          if (dn(ut)) {
            const mn = ne.fromDom(ut), go = De.split(" ");
            M(go, (mo) => {
              L(ht) ? (ht ? ka : xc)(mn, mo) : ui(mn, mo);
            });
          }
        });
      }, Wo = (pe, De) => {
        so(pe, De, !0);
      }, Pr = (pe, De) => {
        so(pe, De, !1);
      }, Br = (pe, De) => {
        const ht = H(pe), ut = De.split(" ");
        return ro(ut, (mn) => Ec(ht, mn));
      }, gr = (pe) => {
        no(pe, (De) => Yl(ne.fromDom(De), "display"));
      }, si = (pe) => {
        no(pe, (De) => ts(ne.fromDom(De), "display", "none"));
      }, pa = (pe) => {
        const De = H(pe);
        return Xo(gi(De, "display"), "none");
      }, qr = (pe) => (pe || "mce_") + a++, oc = (pe) => {
        const De = H(pe);
        return dn(De.dom) ? De.dom.outerHTML : sf(De);
      }, Qu = (pe, De) => {
        no(pe, (ht) => {
          dn(ht) && (ht.outerHTML = De);
        });
      }, Ui = (pe, De) => {
        const ht = j(De);
        return no(pe, (ut) => {
          const mn = ht.parentNode, go = ht.nextSibling;
          return go ? mn.insertBefore(ut, go) : mn.appendChild(ut), ut;
        });
      }, Hi = (pe, De, ht) => no(De, (ut) => (le(ut) && (pe = pe.cloneNode(!0)), ht && qd(Mh(ut.childNodes), (mn) => {
        pe.appendChild(mn);
      }), ut.parentNode.replaceChild(pe, ut))), ri = (pe, De) => {
        let ht;
        return pe.nodeName !== De.toUpperCase() && (ht = _n(De), qd(ve(pe), (ut) => {
          Se(ht, ut.nodeName, se(pe, ut.nodeName));
        }), Hi(ht, pe, !0)), ht || pe;
      }, id = (pe, De) => {
        let ht = pe, ut;
        for (; ht; ) {
          for (ut = De; ut && ht !== ut; )
            ut = ut.parentNode;
          if (ht === ut)
            break;
          ht = ht.parentNode;
        }
        return !ht && pe.ownerDocument ? pe.ownerDocument.documentElement : ht;
      }, Ju = (pe) => {
        if (dn(pe)) {
          const De = pe.nodeName.toLowerCase() === "a" && !se(pe, "href") && se(pe, "id");
          if (se(pe, "name") || se(pe, "data-mce-bookmark") || De)
            return !0;
        }
        return !1;
      }, sc = (pe, De) => {
        let ht, ut, mn = 0;
        if (Ju(pe))
          return !1;
        if (pe = pe.firstChild, pe) {
          const go = new hs(pe, pe.parentNode), mo = v ? v.getWhitespaceElements() : {};
          De = De || (v ? v.getNonEmptyElements() : null);
          do {
            if (ht = pe.nodeType, dn(pe)) {
              const Na = pe.getAttribute("data-mce-bogus");
              if (Na) {
                pe = go.next(Na === "all");
                continue;
              }
              if (ut = pe.nodeName.toLowerCase(), De && De[ut]) {
                if (ut === "br") {
                  mn++, pe = go.next();
                  continue;
                }
                return !1;
              }
              if (Ju(pe))
                return !1;
            }
            if (ht === 8 || ht === 3 && !gc(pe.nodeValue) || ht === 3 && pe.parentNode && mo[pe.parentNode.nodeName] && gc(pe.nodeValue))
              return !1;
            pe = go.next();
          } while (pe);
        }
        return mn <= 1;
      }, ai = () => e.createRange(), ld = (pe, De, ht) => {
        let ut = ai(), mn, go, mo;
        if (pe && De)
          return ut.setStart(pe.parentNode, uu(pe)), ut.setEnd(De.parentNode, uu(De)), mn = ut.extractContents(), ut = ai(), ut.setStart(De.parentNode, uu(De) + 1), ut.setEnd(pe.parentNode, uu(pe) + 1), go = ut.extractContents(), mo = pe.parentNode, mo.insertBefore(iu(jl, mn), pe), ht ? mo.insertBefore(ht, pe) : mo.insertBefore(De, pe), mo.insertBefore(iu(jl, go), pe), xn(pe), ht || De;
      }, ci = (pe, De, ht, ut) => {
        if (le(pe)) {
          let mn = pe.length;
          const go = [];
          for (; mn--; )
            go[mn] = ci(pe[mn], De, ht, ut);
          return go;
        } else
          return t.collect && (pe === e || pe === o) && y.push([
            pe,
            De,
            ht,
            ut
          ]), N.bind(pe, De, ht, ut || jl);
      }, Ck = (pe, De, ht) => {
        if (le(pe)) {
          let ut = pe.length;
          const mn = [];
          for (; ut--; )
            mn[ut] = Ck(pe[ut], De, ht);
          return mn;
        } else {
          if (y.length > 0 && (pe === e || pe === o)) {
            let ut = y.length;
            for (; ut--; ) {
              const mn = y[ut];
              pe === mn[0] && (!De || De === mn[1]) && (!ht || ht === mn[2]) && N.unbind(mn[0], mn[1], mn[2]);
            }
          }
          return N.unbind(pe, De, ht);
        }
      }, US = (pe, De, ht) => N.dispatch(pe, De, ht), Ll = (pe, De, ht) => N.dispatch(pe, De, ht), Ml = (pe) => {
        if (pe && dn(pe)) {
          const De = pe.getAttribute("data-mce-contenteditable");
          return De && De !== "inherit" ? De : pe.contentEditable !== "inherit" ? pe.contentEditable : null;
        } else
          return null;
      }, jl = {
        doc: e,
        settings: t,
        win: o,
        files: s,
        stdMode: i,
        boxModel: u,
        styleSheetLoader: d,
        boundEvents: y,
        styles: T,
        schema: v,
        events: N,
        isBlock: U,
        root: null,
        clone: Be,
        getRoot: at,
        getViewPort: Vt,
        getRect: nn,
        getSize: bn,
        getParent: Co,
        getParents: fo,
        get: j,
        getNext: Ls,
        getPrev: Nt,
        select: fn,
        is: Ht,
        add: Mt,
        create: _n,
        createHTML: Jn,
        createFragment: co,
        remove: xn,
        setStyle: gt,
        getStyle: Pt,
        setStyles: Dt,
        removeAllAttribs: Sn,
        setAttrib: Se,
        setAttribs: Qn,
        getAttrib: se,
        getPos: lt,
        parseStyle: So,
        serializeStyle: xo,
        addStyle: Ms,
        loadCSS: Ho,
        addClass: Wo,
        removeClass: Pr,
        hasClass: Br,
        toggleClass: so,
        show: gr,
        hide: si,
        isHidden: pa,
        uniqueId: qr,
        setHTML: Gs,
        getOuterHTML: oc,
        setOuterHTML: Qu,
        decode: on,
        encode: Bt,
        insertAfter: Ui,
        replace: Hi,
        rename: ri,
        findCommonAncestor: id,
        run: no,
        getAttribs: ve,
        isEmpty: sc,
        createRng: ai,
        nodeIndex: uu,
        split: ld,
        bind: ci,
        unbind: Ck,
        fire: Ll,
        dispatch: US,
        getContentEditable: Ml,
        getContentEditableParent: (pe) => {
          const De = at();
          let ht = null;
          for (; pe && pe !== De && (ht = Ml(pe), ht === null); pe = pe.parentNode)
            ;
          return ht;
        },
        destroy: () => {
          if (y.length > 0) {
            let pe = y.length;
            for (; pe--; ) {
              const De = y[pe];
              N.unbind(De[0], De[1], De[2]);
            }
          }
          Ot(s, (pe, De) => {
            d.unload(De), delete s[De];
          });
        },
        isChildOf: (pe, De) => pe === De || De.contains(pe),
        dumpRng: (pe) => "startContainer: " + pe.startContainer.nodeName + ", startOffset: " + pe.startOffset + ", endContainer: " + pe.endContainer.nodeName + ", endOffset: " + pe.endOffset
      }, xk = mw(T, t, Z(jl));
      return jl;
    };
    Uo.DOM = Uo(document), Uo.nodeIndex = uu;
    const Kd = Uo.DOM, gw = 0, jh = 1, fu = 2, Yd = 3;
    class Wa {
      constructor(t = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = t;
      }
      _setReferrerPolicy(t) {
        this.settings.referrerPolicy = t;
      }
      loadScript(t) {
        return new Promise((n, o) => {
          const s = Kd;
          let a;
          const i = () => {
            s.remove(y), a && (a.onerror = a.onload = a = null);
          }, u = () => {
            i(), n();
          }, d = () => {
            i(), o("Failed to load script: " + t);
          }, y = s.uniqueId();
          a = document.createElement("script"), a.id = y, a.type = "text/javascript", a.src = nt._addCacheSuffix(t), this.settings.referrerPolicy && s.setAttrib(a, "referrerpolicy", this.settings.referrerPolicy), a.onload = u, a.onerror = d, (document.getElementsByTagName("head")[0] || document.body).appendChild(a);
        });
      }
      isDone(t) {
        return this.states[t] === fu;
      }
      markDone(t) {
        this.states[t] = fu;
      }
      add(t) {
        const n = this;
        return n.queue.push(t), n.states[t] === void 0 && (n.states[t] = gw), new Promise((s, a) => {
          n.scriptLoadedCallbacks[t] || (n.scriptLoadedCallbacks[t] = []), n.scriptLoadedCallbacks[t].push({
            resolve: s,
            reject: a
          });
        });
      }
      load(t) {
        return this.add(t);
      }
      remove(t) {
        delete this.states[t], delete this.scriptLoadedCallbacks[t];
      }
      loadQueue() {
        const t = this.queue;
        return this.queue = [], this.loadScripts(t);
      }
      loadScripts(t) {
        const n = this, o = (d, y) => {
          Vn(n.scriptLoadedCallbacks, y).each((v) => {
            M(v, (T) => T[d](y));
          }), delete n.scriptLoadedCallbacks[y];
        }, s = (d) => {
          const y = Qe(d, (v) => v.status === "rejected");
          return y.length > 0 ? Promise.reject(Xt(y, ({ reason: v }) => le(v) ? v : [v])) : Promise.resolve();
        }, a = (d) => Promise.allSettled(W(d, (y) => n.states[y] === fu ? (o("resolve", y), Promise.resolve()) : n.states[y] === Yd ? (o("reject", y), Promise.reject(y)) : (n.states[y] = jh, n.loadScript(y).then(() => {
          n.states[y] = fu, o("resolve", y);
          const v = n.queue;
          if (v.length > 0)
            return n.queue = [], a(v).then(s);
        }, () => (n.states[y] = Yd, o("reject", y), Promise.reject(y)))))), i = (d) => (n.loading = !0, a(d).then((y) => {
          n.loading = !1;
          const v = n.queueLoadedCallbacks.shift();
          return w.from(v).each(en), s(y);
        })), u = Io(t);
        return n.loading ? new Promise((d, y) => {
          n.queueLoadedCallbacks.push(() => i(u).then(d, y));
        }) : i(u);
      }
    }
    Wa.ScriptLoader = new Wa();
    const vs = (e) => {
      let t = e;
      return {
        get: () => t,
        set: (s) => {
          t = s;
        }
      };
    }, hw = (e) => zt(e) && gn(e, "raw"), Uh = (e) => le(e) && e.length > 1, kl = {}, Wp = vs("en"), Hh = () => Vn(kl, Wp.get()), Mr = {
      getData: () => hn(kl, (e) => ({ ...e })),
      setCode: (e) => {
        e && Wp.set(e);
      },
      getCode: () => Wp.get(),
      add: (e, t) => {
        let n = kl[e];
        n || (kl[e] = n = {}), Ot(t, (o, s) => {
          n[s.toLowerCase()] = o;
        });
      },
      translate: (e) => {
        const t = Hh().getOr({}), n = (i) => Wt(i) ? Object.prototype.toString.call(i) : o(i) ? "" : "" + i, o = (i) => i === "" || i === null || i === void 0, s = (i) => {
          const u = n(i);
          return Vn(t, u.toLowerCase()).map(n).getOr(u);
        }, a = (i) => i.replace(/{context:\w+}$/, "");
        if (o(e))
          return "";
        if (hw(e))
          return n(e.raw);
        if (Uh(e)) {
          const i = e.slice(1), u = s(e[0]).replace(/\{([0-9]+)\}/g, (d, y) => gn(i, y) ? n(i[y]) : d);
          return a(u);
        }
        return a(s(e));
      },
      isRtl: () => Hh().bind((e) => Vn(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => gn(kl, e)
    }, fr = () => {
      const e = [], t = {}, n = {}, o = [], s = (j, H) => {
        const se = Qe(o, (ve) => ve.name === j && ve.state === H);
        M(se, (ve) => ve.resolve());
      }, a = (j) => gn(t, j), i = (j) => gn(n, j), u = (j) => {
        if (n[j])
          return n[j].instance;
      }, d = (j, H) => {
        const se = Mr.getCode(), ve = "," + (H || "") + ",";
        !se || H && ve.indexOf("," + se + ",") === -1 || Wa.ScriptLoader.add(t[j] + "/langs/" + se + ".js");
      }, y = (j, H) => {
        fr.languageLoad !== !1 && (a(j) ? d(j, H) : U(j, "loaded").then(() => d(j, H)));
      }, v = (j, H) => (e.push(H), n[j] = { instance: H }, s(j, "added"), H), T = (j) => {
        delete t[j], delete n[j];
      }, N = (j, H) => ge(H) ? ge(j) ? {
        prefix: "",
        resource: H,
        suffix: ""
      } : {
        prefix: j.prefix,
        resource: H,
        suffix: j.suffix
      } : H, F = (j, H) => {
        if (t[j])
          return Promise.resolve();
        let se = ge(H) ? H : H.prefix + H.resource + H.suffix;
        se.indexOf("/") !== 0 && se.indexOf("://") === -1 && (se = fr.baseURL + "/" + se), t[j] = se.substring(0, se.lastIndexOf("/"));
        const ve = () => (s(j, "loaded"), Promise.resolve());
        return n[j] ? ve() : Wa.ScriptLoader.add(se).then(ve);
      }, U = (j, H = "added") => H === "added" && i(j) || H === "loaded" && a(j) ? Promise.resolve() : new Promise((se) => {
        o.push({
          name: j,
          state: H,
          resolve: se
        });
      });
      return {
        items: e,
        urls: t,
        lookup: n,
        get: u,
        requireLangPack: y,
        add: v,
        remove: T,
        createUrl: N,
        load: F,
        waitFor: U
      };
    };
    fr.languageLoad = !0, fr.baseURL = "", fr.PluginManager = fr(), fr.ThemeManager = fr(), fr.ModelManager = fr();
    const Vh = (e) => {
      const t = vs(w.none()), n = () => t.get().each(e);
      return {
        clear: () => {
          n(), t.set(w.none());
        },
        isSet: () => t.get().isSome(),
        get: () => t.get(),
        set: (u) => {
          n(), t.set(w.some(u));
        }
      };
    }, jc = () => {
      const e = Vh(ye);
      return {
        ...e,
        on: (n) => e.get().each(n)
      };
    }, Ni = (e, t) => {
      let n = null;
      return {
        cancel: () => {
          it(n) || (clearTimeout(n), n = null);
        },
        throttle: (...a) => {
          it(n) && (n = setTimeout(() => {
            n = null, e.apply(null, a);
          }, t));
        }
      };
    }, Xd = (e, t) => {
      let n = null;
      const o = () => {
        it(n) || (clearTimeout(n), n = null);
      };
      return {
        cancel: o,
        throttle: (...a) => {
          o(), n = setTimeout(() => {
            n = null, e.apply(null, a);
          }, t);
        }
      };
    }, Cf = Z("mce-annotation"), wl = Z("data-mce-annotation"), du = Z("data-mce-annotation-uid"), Sf = Z("data-mce-annotation-active"), xf = Z("data-mce-annotation-classes"), mu = Z("data-mce-annotation-attrs"), Gh = (e) => (t) => _o(t, e), Kh = (e, t) => {
      const n = e.selection.getRng(), o = ne.fromDom(n.startContainer), s = ne.fromDom(e.getBody()), a = t.fold(() => "." + Cf(), (y) => `[${wl()}="${y}"]`), i = ic(o, n.startOffset).getOr(o), u = Ma(i, a, Gh(s)), d = (y, v) => Ba(y, v) ? w.some(Os(y, v)) : w.none();
      return u.bind((y) => d(y, `${du()}`).bind((v) => d(y, `${wl()}`).map((T) => {
        const N = Tf(e, v);
        return {
          uid: v,
          name: T,
          elements: N
        };
      })));
    }, Ef = (e) => qn(e) && Ec(e, Cf()), Yh = (e, t) => Ba(e, "data-mce-bogus") || bf(e, '[data-mce-bogus="all"]', Gh(t)), Tf = (e, t) => {
      const n = ne.fromDom(e.getBody()), o = br(n, `[${du()}="${t}"]`);
      return Qe(o, (s) => !Yh(s, n));
    }, Zd = (e, t) => {
      const n = ne.fromDom(e.getBody()), o = br(n, `[${wl()}="${t}"]`), s = {};
      return M(o, (a) => {
        if (!Yh(a, n)) {
          const i = Os(a, du()), u = Vn(s, i).getOr([]);
          s[i] = u.concat([a]);
        }
      }), s;
    }, qp = (e, t) => {
      const n = vs({}), o = () => ({
        listeners: [],
        previous: jc()
      }), s = (T, N) => {
        a(T, (F) => (N(F), F));
      }, a = (T, N) => {
        const F = n.get(), U = Vn(F, T).getOrThunk(o), j = N(U);
        F[T] = j, n.set(F);
      }, i = (T, N, F) => {
        s(T, (U) => {
          M(U.listeners, (j) => j(!0, T, {
            uid: N,
            nodes: W(F, (H) => H.dom)
          }));
        });
      }, u = (T) => {
        s(T, (N) => {
          M(N.listeners, (F) => F(!1, T));
        });
      }, d = (T, N) => {
        M(Tf(e, T), (F) => {
          N ? ao(F, Sf(), "true") : as(F, Sf());
        });
      }, y = Xd(() => {
        const T = Qt(t.getNames());
        M(T, (N) => {
          a(N, (F) => {
            const U = F.previous.get();
            return Kh(e, w.some(N)).fold(() => {
              U.each((j) => {
                u(N), F.previous.clear(), d(j, !1);
              });
            }, ({ uid: j, name: H, elements: se }) => {
              Xo(U, j) || (U.each((ve) => d(ve, !1)), i(H, j, se), F.previous.set(j), d(j, !0));
            }), {
              previous: F.previous,
              listeners: F.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        y.cancel();
      }), e.on("NodeChange", () => {
        y.throttle();
      }), { addListener: (T, N) => {
        a(T, (F) => ({
          previous: F.previous,
          listeners: F.listeners.concat([N])
        }));
      } };
    }, qs = (e, t) => {
      const n = wl(), o = (a) => w.from(a.attr(n)).bind(t.lookup), s = (a) => {
        var i, u;
        a.attr(du(), null), a.attr(wl(), null), a.attr(Sf(), null);
        const d = w.from(a.attr(mu())).map((N) => N.split(",")).getOr([]), y = w.from(a.attr(xf())).map((N) => N.split(",")).getOr([]);
        M(d, (N) => a.attr(N, null));
        const v = (u = (i = a.attr("class")) === null || i === void 0 ? void 0 : i.split(" ")) !== null && u !== void 0 ? u : [], T = Fe(v, [Cf()].concat(y));
        a.attr("class", T.length > 0 ? T.join(" ") : null), a.attr(xf(), null), a.attr(mu(), null);
      };
      e.serializer.addTempAttr(Sf()), e.serializer.addAttributeFilter(n, (a) => {
        for (const i of a)
          o(i).each((u) => {
            u.persistent === !1 && (i.name === "span" ? i.unwrap() : s(i));
          });
      });
    }, ww = () => {
      const e = {};
      return {
        register: (s, a) => {
          e[s] = {
            name: s,
            settings: a
          };
        },
        lookup: (s) => Vn(e, s).map((a) => a.settings),
        getNames: () => ze(e)
      };
    };
    let Qd = 0;
    const Xh = (e) => {
      const n = new Date().getTime(), o = Math.floor(Math.random() * 1e9);
      return Qd++, e + "_" + o + Qd + String(n);
    }, _w = (e, t) => {
      M(t, (n) => {
        ka(e, n);
      });
    }, Uc = (e, t) => {
      M(t, (n) => {
        xc(e, n);
      });
    }, yc = (e, t) => ne.fromDom(e.dom.cloneNode(t)), pu = (e) => yc(e, !1), Vp = (e) => yc(e, !0), vw = (e, t) => {
      const n = ne.fromTag(t), o = ea(e);
      return es(n, o), n;
    }, Cw = (e, t) => {
      const n = vw(e, t);
      ra(e, n);
      const o = fs(e);
      return lc(n, o), Do(e), n;
    }, Zh = (e, t, n = cn) => {
      const o = new hs(e, t), s = (a) => {
        let i;
        do
          i = o[a]();
        while (i && !Ft(i) && !n(i));
        return w.from(i).filter(Ft);
      };
      return {
        current: () => w.from(o.current()).filter(Ft),
        next: () => s("next"),
        prev: () => s("prev"),
        prev2: () => s("prev2")
      };
    }, Ri = (e, t) => {
      const n = t || ((i) => e.isBlock(i) || ds(i) || ns(i)), o = (i, u, d, y) => {
        if (Ft(i)) {
          const v = y(i, u, i.data);
          if (v !== -1)
            return w.some({
              container: i,
              offset: v
            });
        }
        return d().bind((v) => o(v.container, v.offset, d, y));
      };
      return {
        backwards: (i, u, d, y) => {
          const v = Zh(i, y, n);
          return o(i, u, () => v.prev().map((T) => ({
            container: T,
            offset: T.length
          })), d).getOrNull();
        },
        forwards: (i, u, d, y) => {
          const v = Zh(i, y, n);
          return o(i, u, () => v.next().map((T) => ({
            container: T,
            offset: 0
          })), d).getOrNull();
        }
      };
    }, gu = Math.round, _l = (e) => e ? {
      left: gu(e.left),
      top: gu(e.top),
      bottom: gu(e.bottom),
      right: gu(e.right),
      width: gu(e.width),
      height: gu(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, Qh = (e, t) => (e = _l(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), Jh = (e, t) => e.left === t.left && e.top === t.top && e.bottom === t.bottom && e.right === t.right, Gp = (e, t, n) => e >= 0 && e <= Math.min(t.height, n.height) / 2, Jd = (e, t) => {
      const n = Math.min(t.height / 2, e.height / 2);
      return e.bottom - n < t.top ? !0 : e.top > t.bottom ? !1 : Gp(t.top - e.bottom, e, t);
    }, Di = (e, t) => e.top > t.bottom ? !0 : e.bottom < t.top ? !1 : Gp(t.bottom - e.top, e, t), Sw = (e, t, n) => t >= e.left && t <= e.right && n >= e.top && n <= e.bottom, ey = (e) => En(e, (t, n) => t.fold(() => w.some(n), (o) => {
      const s = Math.min(n.left, o.left), a = Math.min(n.top, o.top), i = Math.max(n.right, o.right), u = Math.max(n.bottom, o.bottom);
      return w.some({
        top: a,
        right: i,
        bottom: u,
        left: s,
        width: i - s,
        height: u - a
      });
    }), w.none()), Kp = (e, t, n) => {
      const o = Math.max(Math.min(t, e.left + e.width), e.left), s = Math.max(Math.min(n, e.top + e.height), e.top);
      return Math.sqrt((t - o) * (t - o) + (n - s) * (n - s));
    }, Yp = (e, t) => Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top)), xw = (e, t, n) => Math.min(Math.max(e, t), n), em = (e) => {
      const t = e.startContainer, n = e.startOffset;
      return t === e.endContainer && t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null;
    }, Oi = (e, t) => {
      if (dn(e) && e.hasChildNodes()) {
        const n = e.childNodes, o = xw(t, 0, n.length - 1);
        return n[o];
      } else
        return e;
    }, zf = (e, t) => {
      if (!(t < 0 && dn(e) && e.hasChildNodes()))
        return Oi(e, t);
    }, Ew = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"), ty = (e) => typeof e == "string" && e.charCodeAt(0) >= 768 && Ew.test(e), Tw = (...e) => (t) => {
      for (let n = 0; n < e.length; n++)
        if (e[n](t))
          return !0;
      return !1;
    }, ny = (...e) => (t) => {
      for (let n = 0; n < e.length; n++)
        if (!e[n](t))
          return !1;
      return !0;
    }, oy = dn, sy = $n, Xp = wi("display", "block table"), zw = wi("float", "left right"), hu = ny(oy, sy, kn(zw)), Aw = kn(wi("white-space", "pre pre-line pre-wrap")), yu = Ft, Zp = ds, ry = Uo.nodeIndex, tm = zf, Qp = (e) => "createRange" in e ? e.createRange() : Uo.DOM.createRng(), nm = (e) => e && /[\r\n\t ]/.test(e), ay = (e) => !!e.setStart && !!e.setEnd, Jp = (e) => {
      const t = e.startContainer, n = e.startOffset;
      if (nm(e.toString()) && Aw(t.parentNode) && Ft(t)) {
        const o = t.data;
        if (nm(o[n - 1]) || nm(o[n + 1]))
          return !0;
      }
      return !1;
    }, cy = (e) => {
      const t = e.ownerDocument, n = Qp(t), o = t.createTextNode(Ws), s = e.parentNode;
      s.insertBefore(o, e), n.setStart(o, 0), n.setEnd(o, 1);
      const a = _l(n.getBoundingClientRect());
      return s.removeChild(o), a;
    }, Nw = (e) => {
      const t = e.startContainer, n = e.endContainer, o = e.startOffset, s = e.endOffset;
      if (t === n && Ft(n) && o === 0 && s === 1) {
        const a = e.cloneRange();
        return a.setEndAfter(n), Hc(a);
      } else
        return null;
    }, iy = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Hc = (e) => {
      let t;
      const n = e.getClientRects();
      return n.length > 0 ? t = _l(n[0]) : t = _l(e.getBoundingClientRect()), !ay(e) && Zp(e) && iy(t) ? cy(e) : iy(t) && ay(e) ? Nw(e) : t;
    }, Wc = (e, t) => {
      const n = Qh(e, t);
      return n.width = 1, n.right = n.left + 1, n;
    }, ly = (e) => {
      const t = [], n = (i) => {
        i.height !== 0 && (t.length > 0 && Jh(i, t[t.length - 1]) || t.push(i));
      }, o = (i, u) => {
        const d = Qp(i.ownerDocument);
        if (u < i.data.length) {
          if (ty(i.data[u]))
            return t;
          if (ty(i.data[u - 1]) && (d.setStart(i, u), d.setEnd(i, u + 1), !Jp(d)))
            return n(Wc(Hc(d), !1)), t;
        }
        u > 0 && (d.setStart(i, u - 1), d.setEnd(i, u), Jp(d) || n(Wc(Hc(d), !1))), u < i.data.length && (d.setStart(i, u), d.setEnd(i, u + 1), Jp(d) || n(Wc(Hc(d), !0)));
      }, s = e.container(), a = e.offset();
      if (yu(s))
        return o(s, a), t;
      if (oy(s))
        if (e.isAtEnd()) {
          const i = tm(s, a);
          yu(i) && o(i, i.data.length), hu(i) && !Zp(i) && n(Wc(Hc(i), !1));
        } else {
          const i = tm(s, a);
          if (yu(i) && o(i, 0), hu(i) && e.isAtEnd())
            return n(Wc(Hc(i), !1)), t;
          const u = tm(e.container(), e.offset() - 1);
          hu(u) && !Zp(u) && (Xp(u) || Xp(i) || !hu(i)) && n(Wc(Hc(u), !1)), hu(i) && n(Wc(Hc(i), !0));
        }
      return t;
    }, je = (e, t, n) => {
      const o = () => (yu(e), t === 0), s = () => yu(e) ? t >= e.data.length : t >= e.childNodes.length, a = () => {
        const v = Qp(e.ownerDocument);
        return v.setStart(e, t), v.setEnd(e, t), v;
      }, i = () => (n || (n = ly(je(e, t))), n), u = () => i().length > 0, d = (v) => v && e === v.container() && t === v.offset(), y = (v) => tm(e, v ? t - 1 : t);
      return {
        container: Z(e),
        offset: Z(t),
        toRange: a,
        getClientRects: i,
        isVisible: u,
        isAtStart: o,
        isAtEnd: s,
        isEqual: d,
        getNode: y
      };
    };
    je.fromRangeStart = (e) => je(e.startContainer, e.startOffset), je.fromRangeEnd = (e) => je(e.endContainer, e.endOffset), je.after = (e) => je(e.parentNode, ry(e) + 1), je.before = (e) => je(e.parentNode, ry(e)), je.isAbove = (e, t) => zo(Tn(t.getClientRects()), Pn(e.getClientRects()), Jd).getOr(!1), je.isBelow = (e, t) => zo(Pn(t.getClientRects()), Tn(e.getClientRects()), Di).getOr(!1), je.isAtStart = (e) => e ? e.isAtStart() : !1, je.isAtEnd = (e) => e ? e.isAtEnd() : !1, je.isTextPosition = (e) => e ? Ft(e.container()) : !1, je.isElementPosition = (e) => je.isTextPosition(e) === !1;
    const Af = (e, t) => {
      Ft(t) && t.data.length === 0 && e.remove(t);
    }, Rw = (e, t, n) => {
      t.insertNode(n), Af(e, n.previousSibling), Af(e, n.nextSibling);
    }, uy = (e, t, n) => {
      const o = w.from(n.firstChild), s = w.from(n.lastChild);
      t.insertNode(n), o.each((a) => Af(e, a.previousSibling)), s.each((a) => Af(e, a.nextSibling));
    }, fy = (e, t, n) => {
      _i(n) ? uy(e, t, n) : Rw(e, t, n);
    }, kr = Ft, Dw = Rc, vl = Uo.nodeIndex, dy = (e) => {
      const t = e.parentNode;
      return Dw(t) ? dy(t) : t;
    }, eg = (e) => e ? G(e.childNodes, (t, n) => (Dw(n) && n.nodeName !== "BR" ? t = t.concat(eg(n)) : t.push(n), t), []) : [], my = (e, t) => {
      for (; (e = e.previousSibling) && kr(e); )
        t += e.data.length;
      return t;
    }, py = (e) => (t) => e === t, Ow = (e) => {
      let t, n;
      t = eg(dy(e)), n = de(t, py(e), e), t = t.slice(0, n + 1);
      const o = G(t, (s, a, i) => (kr(a) && kr(t[i - 1]) && s++, s), 0);
      return t = Ys(t, aa([e.nodeName])), n = de(t, py(e), e), n - o;
    }, gy = (e) => {
      let t;
      return kr(e) ? t = "text()" : t = e.nodeName.toLowerCase(), t + "[" + Ow(e) + "]";
    }, Pw = (e, t, n) => {
      const o = [];
      for (t = t.parentNode; t !== e && !(n && n(t)); t = t.parentNode)
        o.push(t);
      return o;
    }, hy = (e, t) => {
      let n, o, s = [], a, i, u;
      return n = t.container(), o = t.offset(), kr(n) ? a = my(n, o) : (i = n.childNodes, o >= i.length ? (a = "after", o = i.length - 1) : a = "before", n = i[o]), s.push(gy(n)), u = Pw(e, n), u = Ys(u, kn(Rc)), s = s.concat(Lo(u, (d) => gy(d))), s.reverse().join("/") + "," + a;
    }, Bw = (e, t, n) => {
      let o = eg(e);
      return o = Ys(o, (s, a) => !kr(s) || !kr(o[a - 1])), o = Ys(o, aa([t])), o[n];
    }, tg = (e, t) => {
      let n = e, o = 0, s;
      for (; kr(n); ) {
        if (s = n.data.length, t >= o && t <= o + s) {
          e = n, t = t - o;
          break;
        }
        if (!kr(n.nextSibling)) {
          e = n, t = s;
          break;
        }
        o += s, n = n.nextSibling;
      }
      return kr(e) && t > e.data.length && (t = e.data.length), je(e, t);
    }, ng = (e, t) => {
      let n;
      if (!t)
        return null;
      const o = t.split(","), s = o[0].split("/");
      n = o.length > 1 ? o[1] : "before";
      const a = G(s, (i, u) => {
        const d = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(u);
        return d ? (d[1] === "text()" && (d[1] = "#text"), Bw(i, d[1], parseInt(d[2], 10))) : null;
      }, e);
      return a ? kr(a) ? tg(a, parseInt(n, 10)) : (n === "after" ? n = vl(a) + 1 : n = vl(a), je(a.parentNode, n)) : null;
    }, om = ns, $w = (e, t, n) => {
      let o, s;
      for (s = e(t.data.slice(0, n)).length, o = t.previousSibling; o && Ft(o); o = o.previousSibling)
        s += e(o.data).length;
      return s;
    }, yy = (e, t, n, o, s) => {
      let a = o[s ? "startContainer" : "endContainer"], i = o[s ? "startOffset" : "endOffset"];
      const u = [];
      let d, y = 0;
      const v = e.getRoot();
      for (Ft(a) ? u.push(n ? $w(t, a, i) : i) : (d = a.childNodes, i >= d.length && d.length && (y = 1, i = Math.max(0, d.length - 1)), u.push(e.nodeIndex(d[i], n) + y)); a && a !== v; a = a.parentNode)
        u.push(e.nodeIndex(a, n));
      return u;
    }, bu = (e, t, n, o) => {
      const s = t.dom, a = yy(s, e, n, o, !0), i = t.isForward(), u = ru(o) ? { isFakeCaret: !0 } : {};
      if (t.isCollapsed())
        return {
          start: a,
          forward: i,
          ...u
        };
      {
        const d = yy(s, e, n, o, !1);
        return {
          start: a,
          end: d,
          forward: i,
          ...u
        };
      }
    }, sm = (e, t, n) => {
      let o = 0;
      return nt.each(e.select(t), (s) => {
        if (s.getAttribute("data-mce-bogus") !== "all") {
          if (s === n)
            return !1;
          o++;
        }
      }), o;
    }, og = (e, t) => {
      let n, o;
      const s = t ? "start" : "end";
      if (n = e[s + "Container"], o = e[s + "Offset"], dn(n) && n.nodeName === "TR") {
        const a = n.childNodes;
        n = a[Math.min(t ? o : o - 1, a.length - 1)], n && (o = t ? 0 : n.childNodes.length, e["set" + (t ? "Start" : "End")](n, o));
      }
    }, sg = (e) => (og(e, !0), og(e, !1), e), by = (e, t) => {
      let n;
      if (dn(e) && (e = Oi(e, t), om(e)))
        return e;
      if (xt(e) && (Ft(e) && Me(e) && (e = e.parentNode), n = e.previousSibling, om(n) || (n = e.nextSibling, om(n))))
        return n;
    }, Fw = (e) => by(e.startContainer, e.startOffset) || by(e.endContainer, e.endOffset), ky = (e, t, n) => {
      const o = n.getNode();
      let s = o ? o.nodeName : null;
      const a = n.getRng();
      if (om(o) || s === "IMG")
        return {
          name: s,
          index: sm(n.dom, s, o)
        };
      const i = Fw(a);
      return i ? (s = i.tagName, {
        name: s,
        index: sm(n.dom, s, i)
      }) : bu(e, n, t, a);
    }, wy = (e) => {
      const t = e.getRng();
      return {
        start: hy(e.dom.getRoot(), je.fromRangeStart(t)),
        end: hy(e.dom.getRoot(), je.fromRangeEnd(t)),
        forward: e.isForward()
      };
    }, wx = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), Rr = (e, t, n) => {
      const o = {
        "data-mce-type": "bookmark",
        id: t,
        style: "overflow:hidden;line-height:0px"
      };
      return n ? e.create("span", o, "&#xFEFF;") : e.create("span", o);
    }, _y = (e, t) => {
      const n = e.dom;
      let o = e.getRng();
      const s = n.uniqueId(), a = e.isCollapsed(), i = e.getNode(), u = i.nodeName, d = e.isForward();
      if (u === "IMG")
        return {
          name: u,
          index: sm(n, u, i)
        };
      const y = sg(o.cloneRange());
      if (!a) {
        y.collapse(!1);
        const T = Rr(n, s + "_end", t);
        fy(n, y, T);
      }
      o = sg(o), o.collapse(!0);
      const v = Rr(n, s + "_start", t);
      return fy(n, o, v), e.moveToBookmark({
        id: s,
        keep: !0,
        forward: d
      }), {
        id: s,
        forward: d
      };
    }, Iw = (e, t, n) => t === 2 ? ky(E, n, e) : t === 3 ? wy(e) : t ? wx(e) : _y(e, !1), vy = et(ky, Pe, !0), Cy = (e) => {
      const t = (a) => a(e), n = Z(e), o = () => s, s = {
        tag: !0,
        inner: e,
        fold: (a, i) => i(e),
        isValue: wn,
        isError: cn,
        map: (a) => Dr.value(a(e)),
        mapError: o,
        bind: t,
        exists: t,
        forall: t,
        getOr: n,
        or: o,
        getOrThunk: n,
        orThunk: o,
        getOrDie: n,
        each: (a) => {
          a(e);
        },
        toOptional: () => w.some(e)
      };
      return s;
    }, rm = (e) => {
      const t = () => n, n = {
        tag: !1,
        inner: e,
        fold: (o, s) => o(e),
        isValue: cn,
        isError: wn,
        map: t,
        mapError: (o) => Dr.error(o(e)),
        bind: t,
        exists: cn,
        forall: wn,
        getOr: Pe,
        or: Pe,
        getOrThunk: an,
        orThunk: an,
        getOrDie: Rn(String(e)),
        each: ye,
        toOptional: w.none
      };
      return n;
    }, Dr = {
      value: Cy,
      error: rm,
      fromOption: (e, t) => e.fold(() => rm(t), Cy)
    }, bc = { generate: (e) => {
      if (!le(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const t = [], n = {};
      return M(e, (o, s) => {
        const a = ze(o);
        if (a.length !== 1)
          throw new Error("one and only one name per case");
        const i = a[0], u = o[i];
        if (n[i] !== void 0)
          throw new Error("duplicate key detected:" + i);
        if (i === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!le(u))
          throw new Error("case arguments must be an array");
        t.push(i), n[i] = (...d) => {
          const y = d.length;
          if (y !== u.length)
            throw new Error("Wrong number of arguments to case " + i + ". Expected " + u.length + " (" + u + "), got " + y);
          return {
            fold: (...T) => {
              if (T.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + T.length);
              return T[s].apply(null, d);
            },
            match: (T) => {
              const N = ze(T);
              if (t.length !== N.length)
                throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + `
Actual: ` + N.join(","));
              if (!ro(t, (U) => ce(N, U)))
                throw new Error("Not all branches were specified when using match. Specified: " + N.join(", ") + `
Required: ` + t.join(", "));
              return T[i].apply(null, d);
            },
            log: (T) => {
              console.log(T, {
                constructors: t,
                constructor: i,
                params: d
              });
            }
          };
        };
      }), n;
    } };
    bc.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const xy = (e) => {
      const t = [], n = [];
      return M(e, (o) => {
        o.fold((s) => {
          t.push(s);
        }, (s) => {
          n.push(s);
        });
      }), {
        errors: t,
        values: n
      };
    }, Ey = (e) => e.type === "inline-command" || e.type === "inline-format", am = (e) => e.type === "block-command" || e.type === "block-format", Lw = (e) => Qt(e, (t, n) => t.start.length === n.start.length ? 0 : t.start.length > n.start.length ? -1 : 1), Mw = (e) => {
      const t = (o) => Dr.error({
        message: o,
        pattern: e
      }), n = (o, s, a) => {
        if (e.format !== void 0) {
          let i;
          if (le(e.format)) {
            if (!ro(e.format, ge))
              return t(o + " pattern has non-string items in the `format` array");
            i = e.format;
          } else if (ge(e.format))
            i = [e.format];
          else
            return t(o + " pattern has non-string `format` parameter");
          return Dr.value(s(i));
        } else
          return e.cmd !== void 0 ? ge(e.cmd) ? Dr.value(a(e.cmd, e.value)) : t(o + " pattern has non-string `cmd` parameter") : t(o + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!zt(e))
        return t("Raw pattern is not an object");
      if (!ge(e.start))
        return t("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!ge(e.end))
          return t("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return t("Inline pattern has empty `start` and `end` parameters");
        let o = e.start, s = e.end;
        return s.length === 0 && (s = o, o = ""), n("Inline", (a) => ({
          type: "inline-format",
          start: o,
          end: s,
          format: a
        }), (a, i) => ({
          type: "inline-command",
          start: o,
          end: s,
          cmd: a,
          value: i
        }));
      } else
        return e.replacement !== void 0 ? ge(e.replacement) ? e.start.length === 0 ? t("Replacement pattern has empty `start` parameter") : Dr.value({
          type: "inline-command",
          start: "",
          end: e.start,
          cmd: "mceInsertContent",
          value: e.replacement
        }) : t("Replacement pattern has non-string `replacement` parameter") : e.start.length === 0 ? t("Block pattern has empty `start` parameter") : n("Block", (o) => ({
          type: "block-format",
          start: e.start,
          format: o[0]
        }), (o, s) => ({
          type: "block-command",
          start: e.start,
          cmd: o,
          value: s
        }));
    }, Or = (e) => Lw(Qe(e, am)), Nf = (e) => Qe(e, Ey), jw = (e) => ({
      inlinePatterns: Nf(e),
      blockPatterns: Or(e)
    }), Uw = (e) => {
      const t = xy(W(e, Mw));
      return M(t.errors, (n) => console.error(n.message, n.pattern)), t.values;
    }, rg = Ro().deviceType, Hw = rg.isTouch(), Ww = Uo.DOM, qw = (e) => {
      const t = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return En(t, (n, o) => {
        const s = o.split("="), a = s[0], i = s.length > 1 ? s[1] : a;
        return n[Dn(a)] = Dn(i), n;
      }, {});
    }, Ty = (e) => ke(e, RegExp), Jt = (e) => (t) => t.options.get(e), Rf = (e) => ge(e) || zt(e), zy = (e, t = "") => (n) => {
      const o = ge(n);
      if (o)
        if (n.indexOf("=") !== -1) {
          const s = qw(n);
          return {
            value: Vn(s, e.id).getOr(t),
            valid: o
          };
        } else
          return {
            value: n,
            valid: o
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, Vw = (e) => {
      const t = e.options.register;
      t("id", {
        processor: "string",
        default: e.id
      }), t("selector", { processor: "string" }), t("target", { processor: "object" }), t("suffix", { processor: "string" }), t("cache_suffix", { processor: "string" }), t("base_url", { processor: "string" }), t("referrer_policy", {
        processor: "string",
        default: ""
      }), t("language_load", { processor: "boolean" }), t("inline", {
        processor: "boolean",
        default: !1
      }), t("iframe_attrs", {
        processor: "object",
        default: {}
      }), t("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), t("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), t("body_id", {
        processor: zy(e, "tinymce"),
        default: "tinymce"
      }), t("body_class", {
        processor: zy(e),
        default: ""
      }), t("content_security_policy", {
        processor: "string",
        default: ""
      }), t("br_in_pre", {
        processor: "boolean",
        default: !0
      }), t("forced_root_block", {
        processor: (n) => {
          const o = ge(n) && Bn(n);
          return o ? {
            value: n,
            valid: o
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), t("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), t("newline_behavior", {
        processor: (n) => {
          const o = ce([
            "block",
            "linebreak",
            "invert",
            "default"
          ], n);
          return o ? {
            value: n,
            valid: o
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), t("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), t("no_newline_selector", {
        processor: "string",
        default: ""
      }), t("keep_styles", {
        processor: "boolean",
        default: !0
      }), t("end_container_on_empty_block", {
        processor: (n) => ft(n) ? {
          valid: !0,
          value: n
        } : ge(n) ? {
          valid: !0,
          value: n
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), t("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), t("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), t("font_size_classes", {
        processor: "string",
        default: ""
      }), t("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), t("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), t("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), t("icons", {
        processor: "string",
        default: ""
      }), t("icons_url", {
        processor: "string",
        default: ""
      }), t("images_upload_url", {
        processor: "string",
        default: ""
      }), t("images_upload_base_path", {
        processor: "string",
        default: ""
      }), t("images_upload_base_path", {
        processor: "string",
        default: ""
      }), t("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), t("images_upload_handler", { processor: "function" }), t("language", {
        processor: "string",
        default: "en"
      }), t("language_url", {
        processor: "string",
        default: ""
      }), t("entity_encoding", {
        processor: "string",
        default: "named"
      }), t("indent", {
        processor: "boolean",
        default: !0
      }), t("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), t("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), t("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), t("indentation", {
        processor: "string",
        default: "40px"
      }), t("content_css", {
        processor: (n) => {
          const o = n === !1 || ge(n) || jt(n, ge);
          return o ? ge(n) ? {
            value: W(n.split(","), Dn),
            valid: o
          } : le(n) ? {
            value: n,
            valid: o
          } : n === !1 ? {
            value: [],
            valid: o
          } : {
            value: n,
            valid: o
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: fm(e) ? [] : ["default"]
      }), t("content_style", { processor: "string" }), t("content_css_cors", {
        processor: "boolean",
        default: !1
      }), t("font_css", {
        processor: (n) => {
          const o = ge(n) || jt(n, ge);
          return o ? {
            value: le(n) ? n : W(n.split(","), Dn),
            valid: o
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), t("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), t("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), t("object_resizing", {
        processor: (n) => {
          const o = ft(n) || ge(n);
          return o ? n === !1 || rg.isiPhone() || rg.isiPad() ? {
            value: "",
            valid: o
          } : {
            value: n === !0 ? "table,img,figure.image,div,video,iframe" : n,
            valid: o
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !Hw
      }), t("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), t("event_root", { processor: "object" }), t("service_message", { processor: "string" }), t("theme", {
        processor: (n) => n === !1 || ge(n) || Wt(n),
        default: "silver"
      }), t("theme_url", { processor: "string" }), t("formats", { processor: "object" }), t("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), t("preview_styles", {
        processor: (n) => {
          const o = n === !1 || ge(n);
          return o ? {
            value: n === !1 ? "" : n,
            valid: o
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), t("custom_ui_selector", {
        processor: "string",
        default: ""
      }), t("hidden_input", {
        processor: "boolean",
        default: !0
      }), t("submit_patch", {
        processor: "boolean",
        default: !0
      }), t("encoding", { processor: "string" }), t("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), t("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), t("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), t("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), t("readonly", {
        processor: "boolean",
        default: !1
      }), t("plugins", {
        processor: "string[]",
        default: []
      }), t("external_plugins", { processor: "object" }), t("forced_plugins", { processor: "string[]" }), t("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), t("model_url", { processor: "string" }), t("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), t("visual", {
        processor: "boolean",
        default: !0
      }), t("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), t("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), t("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), t("setup", { processor: "function" }), t("init_instance_callback", { processor: "function" }), t("url_converter", {
        processor: "function",
        default: e.convertURL
      }), t("url_converter_scope", {
        processor: "object",
        default: e
      }), t("urlconverter_callback", { processor: "function" }), t("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), t("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), t("allow_svg_data_urls", { processor: "boolean" }), t("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), t("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), t("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), t("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), t("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), t("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), t("remove_trailing_brs", { processor: "boolean" }), t("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), t("element_format", {
        processor: "string",
        default: "html"
      }), t("entities", { processor: "string" }), t("schema", {
        processor: "string",
        default: "html5"
      }), t("convert_urls", {
        processor: "boolean",
        default: !0
      }), t("relative_urls", {
        processor: "boolean",
        default: !0
      }), t("remove_script_host", {
        processor: "boolean",
        default: !0
      }), t("custom_elements", { processor: "string" }), t("extended_valid_elements", { processor: "string" }), t("invalid_elements", { processor: "string" }), t("invalid_styles", { processor: Rf }), t("valid_children", { processor: "string" }), t("valid_classes", { processor: Rf }), t("valid_elements", { processor: "string" }), t("valid_styles", { processor: Rf }), t("verify_html", {
        processor: "boolean",
        default: !0
      }), t("auto_focus", { processor: (n) => ge(n) || n === !0 }), t("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), t("protect", { processor: "array" }), t("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), t("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), t("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), t("api_key", { processor: "string" }), t("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), t("paste_data_images", {
        processor: "boolean",
        default: !0
      }), t("paste_preprocess", { processor: "function" }), t("paste_postprocess", { processor: "function" }), t("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), t("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), t("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), t("smart_paste", {
        processor: "boolean",
        default: !0
      }), t("paste_as_text", {
        processor: "boolean",
        default: !1
      }), t("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), t("text_patterns", {
        processor: (n) => jt(n, zt) || n === !1 ? {
          value: Uw(n === !1 ? [] : n),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1"
          },
          {
            start: "##",
            format: "h2"
          },
          {
            start: "###",
            format: "h3"
          },
          {
            start: "####",
            format: "h4"
          },
          {
            start: "#####",
            format: "h5"
          },
          {
            start: "######",
            format: "h6"
          },
          {
            start: "1. ",
            cmd: "InsertOrderedList"
          },
          {
            start: "* ",
            cmd: "InsertUnorderedList"
          },
          {
            start: "- ",
            cmd: "InsertUnorderedList"
          }
        ]
      }), t("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), t("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), t("noneditable_regexp", {
        processor: (n) => jt(n, Ty) ? {
          value: n,
          valid: !0
        } : Ty(n) ? {
          value: [n],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), t("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), e.on("ScriptsLoaded", () => {
        t("directionality", {
          processor: "string",
          default: Mr.isRtl() ? "rtl" : void 0
        }), t("placeholder", {
          processor: "string",
          default: Ww.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, Gw = Jt("iframe_attrs"), Kw = Jt("doctype"), Ay = Jt("document_base_url"), Yw = Jt("body_id"), Xw = Jt("body_class"), Ny = Jt("content_security_policy"), cm = Jt("br_in_pre"), la = Jt("forced_root_block"), Df = Jt("forced_root_block_attrs"), Zw = Jt("newline_behavior"), Qw = Jt("br_newline_selector"), Jw = Jt("no_newline_selector"), e_ = Jt("keep_styles"), t_ = Jt("end_container_on_empty_block"), im = Jt("automatic_uploads"), lm = Jt("images_reuse_filename"), Ry = Jt("images_replace_blob_uris"), ag = Jt("icons"), Dy = Jt("icons_url"), Oy = Jt("images_upload_url"), n_ = Jt("images_upload_base_path"), Py = Jt("images_upload_credentials"), cg = Jt("images_upload_handler"), um = Jt("content_css_cors"), ig = Jt("referrer_policy"), By = Jt("language"), o_ = Jt("language_url"), $y = Jt("indent_use_margin"), s_ = Jt("indentation"), r_ = Jt("content_css"), a_ = Jt("content_style"), Fy = Jt("font_css"), c_ = Jt("directionality"), i_ = Jt("inline_boundaries_selector"), Iy = Jt("object_resizing"), l_ = Jt("resize_img_proportional"), u_ = Jt("placeholder"), Ly = Jt("event_root"), f_ = Jt("service_message"), ku = Jt("theme"), d_ = Jt("theme_url"), lg = Jt("model"), m_ = Jt("model_url"), Of = Jt("inline_boundaries"), p_ = Jt("formats"), g_ = Jt("preview_styles"), h_ = Jt("format_empty_lines"), My = Jt("custom_ui_selector"), fm = Jt("inline"), Cl = Jt("hidden_input"), y_ = Jt("submit_patch"), b_ = Jt("add_form_submit_trigger"), k_ = Jt("add_unload_trigger"), w_ = Jt("custom_undo_redo_levels"), dm = Jt("disable_nodechange"), Ts = Jt("readonly"), __ = Jt("content_css_cors"), qc = Jt("plugins"), jy = Jt("external_plugins"), Uy = Jt("block_unsupported_drop"), v_ = Jt("visual"), C_ = Jt("visual_table_class"), Hy = Jt("visual_anchor_class"), Wy = Jt("iframe_aria_text"), S_ = Jt("setup"), qy = Jt("init_instance_callback"), ug = Jt("urlconverter_callback"), Vy = Jt("auto_focus"), Gy = Jt("browser_spellcheck"), fg = Jt("protect"), mm = Jt("paste_block_drop"), Vc = Jt("paste_data_images"), Pf = Jt("paste_preprocess"), x_ = Jt("paste_postprocess"), Ky = Jt("paste_webkit_styles"), E_ = Jt("paste_remove_styles_if_webkit"), T_ = Jt("paste_merge_formats"), z_ = Jt("smart_paste"), Yy = Jt("paste_as_text"), A_ = Jt("paste_tab_spaces"), Xy = Jt("allow_html_data_urls"), dg = Jt("text_patterns"), Zy = Jt("noneditable_class"), N_ = Jt("editable_class"), R_ = Jt("noneditable_regexp"), D_ = (e) => nt.explode(e.options.get("font_size_style_values")), Bf = (e) => nt.explode(e.options.get("font_size_classes")), Qy = (e) => e.options.get("encoding") === "xml", O_ = (e) => nt.explode(e.options.get("images_file_types")), Sl = Jt("table_tab_navigation"), P_ = dn, Jy = Ft, eb = (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    }, tb = (e) => {
      const t = E(e);
      return {
        count: e.length - t.length,
        text: t
      };
    }, mg = (e) => {
      let t;
      for (; (t = e.data.lastIndexOf(m)) !== -1; )
        e.deleteData(t, 1);
    }, pm = (e, t) => (xl(e), t), B_ = (e, t) => {
      const n = tb(e.data.substr(0, t.offset())), o = tb(e.data.substr(t.offset()));
      return (n.text + o.text).length > 0 ? (mg(e), je(e, t.offset() - n.count)) : t;
    }, $_ = (e, t) => {
      const n = t.container(), o = me(ho(n.childNodes), e).map((s) => s < t.offset() ? je(n, t.offset() - 1) : t).getOr(t);
      return xl(e), o;
    }, F_ = (e, t) => Jy(e) && t.container() === e ? B_(e, t) : pm(e, t), I_ = (e, t) => t.container() === e.parentNode ? $_(e, t) : pm(e, t), L_ = (e, t) => je.isTextPosition(t) ? F_(e, t) : I_(e, t), xl = (e) => {
      P_(e) && xt(e) && (vn(e) ? e.removeAttribute("data-mce-caret") : eb(e)), Jy(e) && (mg(e), e.data.length === 0 && eb(e));
    }, M_ = ns, nb = dc, ob = fl, sb = "*[contentEditable=false],video,audio,embed,object", pg = (e, t, n) => {
      const o = Qh(t.getBoundingClientRect(), n);
      let s, a;
      if (e.tagName === "BODY") {
        const u = e.ownerDocument.documentElement;
        s = e.scrollLeft || u.scrollLeft, a = e.scrollTop || u.scrollTop;
      } else {
        const u = e.getBoundingClientRect();
        s = e.scrollLeft - u.left, a = e.scrollTop - u.top;
      }
      o.left += s, o.right += s, o.top += a, o.bottom += a, o.width = 1;
      let i = t.offsetWidth - t.clientWidth;
      return i > 0 && (n && (i *= -1), o.left += i, o.right += i), o;
    }, rb = (e) => {
      const t = br(ne.fromDom(e), sb);
      for (let n = 0; n < t.length; n++) {
        const o = t[n].dom;
        let s = o.previousSibling;
        if (Nr(s)) {
          const a = s.data;
          a.length === 1 ? s.parentNode.removeChild(s) : s.deleteData(a.length - 1, 1);
        }
        s = o.nextSibling, tr(s) && (s.data.length === 1 ? s.parentNode.removeChild(s) : s.deleteData(0, 1));
      }
    }, gm = (e, t, n, o) => {
      const s = jc();
      let a, i;
      const u = la(e), d = e.dom, y = (j, H) => {
        let se;
        if (v(), ob(H))
          return null;
        if (n(H)) {
          i = Go(u, H, j);
          const ve = pg(t, H, j);
          d.setStyle(i, "top", ve.top);
          const Se = d.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          d.setStyles(Se, { ...ve }), d.add(t, Se), s.set({
            caret: Se,
            element: H,
            before: j
          }), j && d.addClass(Se, "mce-visual-caret-before"), T(), se = H.ownerDocument.createRange(), se.setStart(i, 0), se.setEnd(i, 0);
        } else
          return i = Ln(H, j), se = H.ownerDocument.createRange(), El(i.nextSibling) ? (se.setStart(i, 0), se.setEnd(i, 0)) : (se.setStart(i, 1), se.setEnd(i, 1)), se;
        return se;
      }, v = () => {
        rb(t), i && (xl(i), i = null), s.on((j) => {
          d.remove(j.caret), s.clear();
        }), a && (clearInterval(a), a = void 0);
      }, T = () => {
        a = setInterval(() => {
          s.on((j) => {
            o() ? d.toggleClass(j.caret, "mce-visual-caret-hidden") : d.addClass(j.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: y,
        hide: v,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          s.on((j) => {
            const H = pg(t, j.element, j.before);
            d.setStyles(j.caret, { ...H });
          });
        },
        destroy: () => clearInterval(a)
      };
    }, wu = () => Gn.browser.isFirefox(), El = (e) => M_(e) || nb(e), _u = (e) => El(e) || La(e) && wu(), j_ = ca, gg = ns, U_ = dc, ab = wi("display", "block table table-cell table-caption list-item"), cb = xt, ib = Me, hg = dn, H_ = $n, vu = (e) => e > 0, Tl = (e) => e < 0, hm = (e, t) => {
      let n;
      for (; n = e(t); )
        if (!ib(n))
          return n;
      return null;
    }, $f = (e, t, n, o, s) => {
      const a = new hs(e, o), i = gg(e) || ib(e);
      if (Tl(t)) {
        if (i && (e = hm(a.prev.bind(a), !0), n(e)))
          return e;
        for (; e = hm(a.prev.bind(a), s); )
          if (n(e))
            return e;
      }
      if (vu(t)) {
        if (i && (e = hm(a.next.bind(a), !0), n(e)))
          return e;
        for (; e = hm(a.next.bind(a), s); )
          if (n(e))
            return e;
      }
      return null;
    }, W_ = (e, t) => {
      const n = (s) => j_(s.dom), o = (s) => s.dom === t;
      return Ci(ne.fromDom(e), n, o).map((s) => s.dom).getOr(t);
    }, Pi = (e, t) => {
      for (; e && e !== t; ) {
        if (ab(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, kc = (e, t, n) => Pi(e.container(), n) === Pi(t.container(), n), yg = (e, t) => {
      if (!t)
        return null;
      const n = t.container(), o = t.offset();
      return hg(n) ? n.childNodes[o + e] : null;
    }, Ff = (e, t) => {
      const n = t.ownerDocument.createRange();
      return e ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), n;
    }, lb = (e, t, n) => Pi(t, e) === Pi(n, e), ym = (e, t, n) => {
      const o = e ? "previousSibling" : "nextSibling";
      for (; n && n !== t; ) {
        let s = n[o];
        if (cb(s) && (s = s[o]), gg(s) || U_(s)) {
          if (lb(t, s, n))
            return s;
          break;
        }
        if (H_(s))
          break;
        n = n.parentNode;
      }
      return null;
    }, zl = et(Ff, !0), Cu = et(Ff, !1), If = (e, t, n) => {
      let o;
      const s = et(ym, !0, t), a = et(ym, !1, t);
      let i = n.startContainer;
      const u = n.startOffset;
      if (Me(i)) {
        hg(i) || (i = i.parentNode);
        const d = i.getAttribute("data-mce-caret");
        if (d === "before" && (o = i.nextSibling, _u(o)))
          return zl(o);
        if (d === "after" && (o = i.previousSibling, _u(o)))
          return Cu(o);
      }
      if (!n.collapsed)
        return n;
      if (Ft(i)) {
        if (cb(i)) {
          if (e === 1) {
            if (o = a(i), o)
              return zl(o);
            if (o = s(i), o)
              return Cu(o);
          }
          if (e === -1) {
            if (o = s(i), o)
              return Cu(o);
            if (o = a(i), o)
              return zl(o);
          }
          return n;
        }
        if (Nr(i) && u >= i.data.length - 1)
          return e === 1 && (o = a(i), o) ? zl(o) : n;
        if (tr(i) && u <= 1)
          return e === -1 && (o = s(i), o) ? Cu(o) : n;
        if (u === i.data.length)
          return o = a(i), o ? zl(o) : n;
        if (u === 0)
          return o = s(i), o ? Cu(o) : n;
      }
      return n;
    }, bg = (e, t) => w.from(yg(e ? 0 : -1, t)).filter(gg), Su = (e, t, n) => {
      const o = If(e, t, n);
      return e === -1 ? je.fromRangeStart(o) : je.fromRangeEnd(o);
    }, Lf = (e) => w.from(e.getNode()).map(ne.fromDom), q_ = (e) => w.from(e.getNode(!0)).map(ne.fromDom), bm = (e, t) => {
      for (; t = e(t); )
        if (t.isVisible())
          return t;
      return t;
    }, Mf = (e, t) => {
      const n = kc(e, t);
      return !n && ds(e.getNode()) ? !0 : n;
    };
    var $s;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })($s || ($s = {}));
    const kg = ns, wc = Ft, ub = dn, wg = ds, Bi = $n, fb = cu, km = Ua, V_ = (e, t) => {
      const n = [];
      for (; e && e !== t; )
        n.push(e), e = e.parentNode;
      return n;
    }, db = (e, t) => e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null, mb = (e, t) => {
      if (vu(e)) {
        if (Bi(t.previousSibling) && !wc(t.previousSibling))
          return je.before(t);
        if (wc(t))
          return je(t, 0);
      }
      if (Tl(e)) {
        if (Bi(t.nextSibling) && !wc(t.nextSibling))
          return je.after(t);
        if (wc(t))
          return je(t, t.data.length);
      }
      return Tl(e) ? wg(t) ? je.before(t) : je.after(t) : je.before(t);
    }, wr = (e, t) => {
      const n = t.nextSibling;
      return n && Bi(n) ? wc(n) ? je(n, 0) : je.before(n) : pb($s.Forwards, je.after(t), e);
    }, pb = (e, t, n) => {
      let o, s, a, i;
      if (!ub(n) || !t)
        return null;
      if (t.isEqual(je.after(n)) && n.lastChild) {
        if (i = je.after(n.lastChild), Tl(e) && Bi(n.lastChild) && ub(n.lastChild))
          return wg(n.lastChild) ? je.before(n.lastChild) : i;
      } else
        i = t;
      const u = i.container();
      let d = i.offset();
      if (wc(u)) {
        if (Tl(e) && d > 0)
          return je(u, --d);
        if (vu(e) && d < u.length)
          return je(u, ++d);
        o = u;
      } else {
        if (Tl(e) && d > 0 && (s = db(u, d - 1), Bi(s)))
          return !fb(s) && (a = $f(s, e, km, s), a) ? wc(a) ? je(a, a.data.length) : je.after(a) : wc(s) ? je(s, s.data.length) : je.before(s);
        if (vu(e) && d < u.childNodes.length && (s = db(u, d), Bi(s)))
          return wg(s) ? wr(n, s) : !fb(s) && (a = $f(s, e, km, s), a) ? wc(a) ? je(a, 0) : je.before(a) : wc(s) ? je(s, 0) : je.after(s);
        o = s || i.getNode();
      }
      if ((vu(e) && i.isAtEnd() || Tl(e) && i.isAtStart()) && (o = $f(o, e, wn, n, !0), km(o, n)))
        return mb(e, o);
      s = $f(o, e, km, n);
      const y = dt(Qe(V_(u, n), kg));
      return y && (!s || !y.contains(s)) ? (vu(e) ? i = je.after(y) : i = je.before(y), i) : s ? mb(e, s) : null;
    }, jr = (e) => ({
      next: (t) => pb($s.Forwards, t, e),
      prev: (t) => pb($s.Backwards, t, e)
    }), G_ = (e, t, n) => {
      const o = e ? je.before(n) : je.after(n);
      return _a(e, t, o);
    }, K_ = (e) => ds(e) ? je.before(e) : je.after(e), gb = (e) => je.isTextPosition(e) ? e.offset() === 0 : $n(e.getNode()), hb = (e) => {
      if (je.isTextPosition(e)) {
        const t = e.container();
        return e.offset() === t.data.length;
      } else
        return $n(e.getNode(!0));
    }, yb = (e, t) => !je.isTextPosition(e) && !je.isTextPosition(t) && e.getNode() === t.getNode(!0), bb = (e) => !je.isTextPosition(e) && ds(e.getNode()), _g = (e, t, n) => e ? !yb(t, n) && !bb(t) && hb(t) && gb(n) : !yb(n, t) && gb(t) && hb(n), _a = (e, t, n) => {
      const o = jr(t);
      return w.from(e ? o.next(n) : o.prev(n));
    }, wm = (e, t, n) => _a(e, t, n).bind((o) => kc(n, o, t) && _g(e, n, o) ? _a(e, t, o) : w.some(o)), xu = (e, t, n, o) => wm(e, t, n).bind((s) => o(s) ? xu(e, t, s, o) : w.some(s)), Al = (e, t) => {
      const n = e ? t.firstChild : t.lastChild;
      return Ft(n) ? w.some(je(n, e ? 0 : n.data.length)) : n ? $n(n) ? w.some(e ? je.before(n) : K_(n)) : G_(e, t, n) : w.none();
    }, va = et(_a, !0), ec = et(_a, !1), _r = et(Al, !0), qa = et(Al, !1), Y_ = "_mce_caret", ua = (e) => dn(e) && e.id === Y_, Eu = (e, t) => {
      for (; t && t !== e; ) {
        if (t.id === Y_)
          return t;
        t = t.parentNode;
      }
      return null;
    }, kb = (e) => ge(e.start), wb = (e) => gn(e, "rng"), _m = (e) => gn(e, "id"), _b = (e) => gn(e, "name"), vg = (e) => nt.isArray(e.start), vm = (e) => !_b(e) && ft(e.forward) ? e.forward : !0, Cm = (e, t) => (dn(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t), vb = (e, t) => {
      const n = e.createRng(), o = ng(e.getRoot(), t.start);
      n.setStart(o.container(), o.offset());
      const s = ng(e.getRoot(), t.end);
      return n.setEnd(s.container(), s.offset()), {
        range: n,
        forward: vm(t)
      };
    }, Tu = (e, t) => {
      const n = e.ownerDocument.createTextNode(m);
      e.appendChild(n), t.setStart(n, 0), t.setEnd(n, 0);
    }, jf = (e) => e.hasChildNodes() === !1, X_ = (e, t) => qa(e).fold(cn, (n) => (t.setStart(n.container(), n.offset()), t.setEnd(n.container(), n.offset()), !0)), Cg = (e, t, n) => jf(t) && Eu(e, t) ? (Tu(t, n), !0) : !1, Z_ = (e, t, n, o) => {
      const s = n[t ? "start" : "end"];
      let a, i, u, d;
      const y = e.getRoot();
      if (s) {
        for (u = s[0], i = y, a = s.length - 1; a >= 1; a--) {
          if (d = i.childNodes, Cg(y, i, o))
            return !0;
          if (s[a] > d.length - 1)
            return Cg(y, i, o) ? !0 : X_(i, o);
          i = d[s[a]];
        }
        i.nodeType === 3 && (u = Math.min(s[0], i.nodeValue.length)), i.nodeType === 1 && (u = Math.min(s[0], i.childNodes.length)), t ? o.setStart(i, u) : o.setEnd(i, u);
      }
      return !0;
    }, Cb = (e) => Ft(e) && e.data.length > 0, Sg = (e, t, n) => {
      let o = e.get(n.id + "_" + t), s, a, i, u;
      const d = n.keep;
      let y, v;
      if (o) {
        if (s = o.parentNode, t === "start" ? (d ? o.hasChildNodes() ? (s = o.firstChild, a = 1) : Cb(o.nextSibling) ? (s = o.nextSibling, a = 0) : Cb(o.previousSibling) ? (s = o.previousSibling, a = o.previousSibling.data.length) : (s = o.parentNode, a = e.nodeIndex(o) + 1) : a = e.nodeIndex(o), y = s, v = a) : (d ? o.hasChildNodes() ? (s = o.firstChild, a = 1) : Cb(o.previousSibling) ? (s = o.previousSibling, a = o.previousSibling.data.length) : (s = o.parentNode, a = e.nodeIndex(o)) : a = e.nodeIndex(o), y = s, v = a), !d) {
          for (u = o.previousSibling, i = o.nextSibling, nt.each(nt.grep(o.childNodes), (T) => {
            Ft(T) && (T.nodeValue = T.nodeValue.replace(/\uFEFF/g, ""));
          }); o = e.get(n.id + "_" + t); )
            e.remove(o, !0);
          u && i && u.nodeType === i.nodeType && Ft(u) && !Gn.browser.isOpera() && (a = u.nodeValue.length, u.appendData(i.nodeValue), e.remove(i), y = u, v = a);
        }
        return w.some(je(y, v));
      } else
        return w.none();
    }, xg = (e, t) => {
      const n = e.createRng();
      return Z_(e, !0, t, n) && Z_(e, !1, t, n) ? w.some({
        range: n,
        forward: vm(t)
      }) : w.none();
    }, Q_ = (e, t) => {
      const n = Sg(e, "start", t), o = Sg(e, "end", t);
      return zo(n, o.or(n), (s, a) => {
        const i = e.createRng();
        return i.setStart(Cm(e, s.container()), s.offset()), i.setEnd(Cm(e, a.container()), a.offset()), {
          range: i,
          forward: vm(t)
        };
      });
    }, J_ = (e, t) => w.from(e.select(t.name)[t.index]).map((n) => {
      const o = e.createRng();
      return o.selectNode(n), {
        range: o,
        forward: !0
      };
    }), Sb = (e, t) => {
      const n = e.dom;
      if (t) {
        if (vg(t))
          return xg(n, t);
        if (kb(t))
          return w.some(vb(n, t));
        if (_m(t))
          return Q_(n, t);
        if (_b(t))
          return J_(n, t);
        if (wb(t))
          return w.some({
            range: t.rng,
            forward: vm(t)
          });
      }
      return w.none();
    }, e0 = (e, t, n) => Iw(e, t, n), t0 = (e, t) => {
      Sb(e, t).each(({ range: n, forward: o }) => {
        e.setRng(n, o);
      });
    }, fa = (e) => dn(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", Nl = ((e) => (t) => e === t)(Ws), zu = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, Sm = (e) => !zu(e) && !Nl(e) && !ou(e), o0 = (e) => ({ value: e }), Eg = (e) => {
      const t = e.toString(16);
      return (t.length === 1 ? "0" + t : t).toUpperCase();
    }, s0 = (e) => {
      const t = Eg(e.red) + Eg(e.green) + Eg(e.blue);
      return o0(t);
    }, xm = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, r0 = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, xb = (e, t, n, o) => ({
      red: e,
      green: t,
      blue: n,
      alpha: o
    }), a0 = (e, t, n, o) => {
      const s = parseInt(e, 10), a = parseInt(t, 10), i = parseInt(n, 10), u = parseFloat(o);
      return xb(s, a, i, u);
    }, vx = (e) => {
      if (e === "transparent")
        return w.some(xb(0, 0, 0, 0));
      const t = xm.exec(e);
      if (t !== null)
        return w.some(a0(t[1], t[2], t[3], "1"));
      const n = r0.exec(e);
      return n !== null ? w.some(a0(n[1], n[2], n[3], n[4])) : w.none();
    }, Gc = (e) => vx(e).map(s0).map((t) => "#" + t.value).getOr(e), Em = (e) => !!e.nodeType, c0 = (e) => e && /^(IMG)$/.test(e.nodeName), Eb = (e, t, n) => {
      const o = n.startOffset;
      let s = n.startContainer;
      if (!(s === n.endContainer && c0(s.childNodes[o])) && dn(s)) {
        const a = s.childNodes;
        let i;
        o < a.length ? (s = a[o], i = new hs(s, e.getParent(s, e.isBlock))) : (s = a[a.length - 1], i = new hs(s, e.getParent(s, e.isBlock)), i.next(!0));
        for (let u = i.current(); u; u = i.next())
          if (Ft(u) && !Tg(u)) {
            n.setStart(u, 0), t.setRng(n);
            return;
          }
      }
    }, Tm = (e, t, n) => {
      if (e) {
        const o = t ? "nextSibling" : "previousSibling";
        for (e = n ? e : e[o]; e; e = e[o])
          if (dn(e) || !Tg(e))
            return e;
      }
    }, Uf = (e, t) => (Em(t) && (t = t.nodeName), !!e.schema.getTextBlockElements()[t.toLowerCase()]), Au = (e, t, n) => e.schema.isValidChild(t, n), Tg = (e, t = !1) => {
      if (L(e) && Ft(e)) {
        const n = t ? e.data.replace(/ /g, "\xA0") : e.data;
        return gc(n);
      } else
        return !1;
    }, i0 = (e) => L(e) && Ft(e) && e.length === 0, Kc = (e, t) => (Wt(e) ? e = e(t) : L(t) && (e = e.replace(/%(\w+)/g, (n, o) => t[o] || n)), e), zg = (e, t) => (e = e || "", t = t || "", e = "" + (e.nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase()), Nu = (e, t) => ((t === "color" || t === "backgroundColor") && (e = Gc(e)), t === "fontWeight" && e === 700 && (e = "bold"), t === "fontFamily" && (e = e.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), "" + e), Rl = (e, t, n) => Nu(e.getStyle(t, n), n), Ag = (e, t) => {
      let n;
      return e.getParent(t, (o) => (n = e.getStyle(o, "text-decoration"), n && n !== "none")), n;
    }, zm = (e, t, n) => e.getParents(t, n, e.getRoot()), l0 = (e, t) => {
      const n = (o) => {
        const s = (a) => a.length > 1 && a.charAt(0) === "%";
        return Ce([
          "styles",
          "attributes"
        ], (a) => Vn(o, a).exists((i) => {
          const u = le(i) ? i : os(i);
          return Ce(u, s);
        }));
      };
      return Ce(e.formatter.get(t), n);
    }, u0 = (e, t, n) => {
      const o = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], s = (a) => rs(a, (i, u) => Ce(o, (d) => d === u));
      return Ce(e.formatter.get(t), (a) => {
        const i = s(a);
        return Ce(e.formatter.get(n), (u) => {
          const d = s(u);
          return lo(i, d);
        });
      });
    }, Ca = (e) => qo(e, "block"), Ur = (e) => qo(e, "selector"), Fs = (e) => qo(e, "inline"), Tb = (e) => Ur(e) && Fs(e) && Xo(Vn(e, "mixed"), !0), Yc = (e) => Ur(e) && e.expand !== !1 && !Fs(e), Ru = fa, tc = zm, zb = Tg, Ab = Uf, f0 = (e) => ds(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, d0 = (e, t) => {
      let n = t;
      for (; n; ) {
        if (dn(n) && e.getContentEditable(n))
          return e.getContentEditable(n) === "false" ? n : t;
        n = n.parentNode;
      }
      return t;
    }, Nb = (e, t, n, o) => {
      const s = t.data;
      for (let a = n; e ? a >= 0 : a < s.length; e ? a-- : a++)
        if (o(s.charAt(a)))
          return e ? a + 1 : a;
      return -1;
    }, m0 = (e, t, n) => Nb(e, t, n, (o) => Nl(o) || zu(o)), p0 = (e, t, n) => Nb(e, t, n, Sm), Rb = (e, t, n, o, s, a) => {
      let i;
      const u = e.getParent(n, e.isBlock) || t, d = (v, T, N) => {
        const F = Ri(e), U = s ? F.backwards : F.forwards;
        return w.from(U(v, T, (j, H) => Ru(j.parentNode) ? -1 : (i = j, N(s, j, H)), u));
      };
      return d(n, o, m0).bind((v) => a ? d(v.container, v.offset + (s ? -1 : 0), p0) : w.some(v)).orThunk(() => i ? w.some({
        container: i,
        offset: s ? 0 : i.length
      }) : w.none());
    }, Am = (e, t, n, o, s) => {
      Ft(o) && to(o.data) && o[s] && (o = o[s]);
      const a = tc(e, o);
      for (let i = 0; i < a.length; i++)
        for (let u = 0; u < t.length; u++) {
          const d = t[u];
          if (!(L(d.collapsed) && d.collapsed !== n.collapsed) && Ur(d) && e.is(a[i], d.selector))
            return a[i];
        }
      return o;
    }, Db = (e, t, n, o) => {
      let s = n;
      const a = e.dom, i = a.getRoot(), u = t[0];
      if (Ca(u) && (s = u.wrapper ? null : a.getParent(n, u.block, i)), !s) {
        const d = a.getParent(n, "LI,TD,TH");
        s = a.getParent(Ft(n) ? n.parentNode : n, (y) => y !== i && Ab(e, y), d);
      }
      if (s && Ca(u) && u.wrapper && (s = tc(a, s, "ul,ol").reverse()[0] || s), !s)
        for (s = n; s[o] && !a.isBlock(s[o]) && (s = s[o], !zg(s, "br")); )
          ;
      return s || n;
    }, Ng = (e, t, n, o) => {
      const s = n.parentNode;
      return L(n[o]) ? !1 : s === t || Ve(s) || e.isBlock(s) ? !0 : Ng(e, t, s, o);
    }, Du = (e, t, n, o, s) => {
      let a = n;
      const i = s ? "previousSibling" : "nextSibling", u = e.getRoot();
      if (Ft(n) && !zb(n) && (s ? o > 0 : o < n.data.length))
        return n;
      for (; ; ) {
        if (!t[0].block_expand && e.isBlock(a))
          return a;
        for (let d = a[i]; d; d = d[i]) {
          const y = Ft(d) && !Ng(e, u, d, i);
          if (!Ru(d) && !f0(d) && !zb(d, y))
            return a;
        }
        if (a === u || a.parentNode === u) {
          n = a;
          break;
        }
        a = a.parentNode;
      }
      return n;
    }, Ob = (e) => Ru(e.parentNode) || Ru(e), Ou = (e, t, n, o = !1) => {
      let { startContainer: s, startOffset: a, endContainer: i, endOffset: u } = t;
      const d = e.dom, y = n[0];
      return dn(s) && s.hasChildNodes() && (s = Oi(s, a), Ft(s) && (a = 0)), dn(i) && i.hasChildNodes() && (i = Oi(i, t.collapsed ? u : u - 1), Ft(i) && (u = i.nodeValue.length)), s = d0(d, s), i = d0(d, i), Ob(s) && (s = Ru(s) ? s : s.parentNode, t.collapsed ? s = s.previousSibling || s : s = s.nextSibling || s, Ft(s) && (a = t.collapsed ? s.length : 0)), Ob(i) && (i = Ru(i) ? i : i.parentNode, t.collapsed ? i = i.nextSibling || i : i = i.previousSibling || i, Ft(i) && (u = t.collapsed ? 0 : i.length)), t.collapsed && (Rb(d, e.getBody(), s, a, !0, o).each(({ container: N, offset: F }) => {
        s = N, a = F;
      }), Rb(d, e.getBody(), i, u, !1, o).each(({ container: N, offset: F }) => {
        i = N, u = F;
      })), (Fs(y) || y.block_expand) && ((!Fs(y) || !Ft(s) || a === 0) && (s = Du(d, n, s, a, !0)), (!Fs(y) || !Ft(i) || u === i.nodeValue.length) && (i = Du(d, n, i, u, !1))), Yc(y) && (s = Am(d, n, t, s, "previousSibling"), i = Am(d, n, t, i, "nextSibling")), (Ca(y) || Ur(y)) && (s = Db(e, n, s, "previousSibling"), i = Db(e, n, i, "nextSibling"), Ca(y) && (d.isBlock(s) || (s = Du(d, n, s, a, !0)), d.isBlock(i) || (i = Du(d, n, i, u, !1)))), dn(s) && (a = d.nodeIndex(s), s = s.parentNode), dn(i) && (u = d.nodeIndex(i) + 1, i = i.parentNode), {
        startContainer: s,
        startOffset: a,
        endContainer: i,
        endOffset: u
      };
    }, Dl = (e, t, n) => {
      const o = t.startOffset, s = Oi(t.startContainer, o), a = t.endOffset, i = Oi(t.endContainer, a - 1), u = (j) => {
        const H = j[0];
        Ft(H) && H === s && o >= H.data.length && j.splice(0, 1);
        const se = j[j.length - 1];
        return a === 0 && j.length > 0 && se === i && Ft(se) && j.splice(j.length - 1, 1), j;
      }, d = (j, H, se) => {
        const ve = [];
        for (; j && j !== se; j = j[H])
          ve.push(j);
        return ve;
      }, y = (j, H) => e.getParent(j, (se) => se.parentNode === H, H), v = (j, H, se) => {
        const ve = se ? "nextSibling" : "previousSibling";
        for (let Se = j, Be = Se.parentNode; Se && Se !== H; Se = Be) {
          Be = Se.parentNode;
          const at = d(Se === j ? Se : Se[ve], ve);
          at.length && (se || at.reverse(), n(u(at)));
        }
      };
      if (s === i)
        return n(u([s]));
      const T = e.findCommonAncestor(s, i);
      if (e.isChildOf(s, i))
        return v(s, T, !0);
      if (e.isChildOf(i, s))
        return v(i, T);
      const N = y(s, T) || s, F = y(i, T) || i;
      v(s, N, !0);
      const U = d(N === s ? N : N.nextSibling, "nextSibling", F === i ? F.nextSibling : F);
      U.length && n(u(U)), v(i, F);
    }, Nm = (e) => {
      const t = [];
      if (e)
        for (let n = 0; n < e.rangeCount; n++)
          t.push(e.getRangeAt(n));
      return t;
    }, Pb = (e) => Xt(e, (t) => {
      const n = em(t);
      return n ? [ne.fromDom(n)] : [];
    }), g0 = (e) => Nm(e).length > 1, h0 = (e) => Qe(Pb(e), tu), y0 = (e) => br(e, "td[data-mce-selected],th[data-mce-selected]"), Rg = (e, t) => {
      const n = y0(t);
      return n.length > 0 ? n : h0(e);
    }, Ol = (e) => Rg(Nm(e.selection.getSel()), ne.fromDom(e.getBody())), Hf = (e, t) => Si(e, "table", t), b0 = (e) => {
      const t = e.startContainer, n = e.startOffset;
      return Ft(t) ? n === 0 ? w.some(ne.fromDom(t)) : w.none() : w.from(t.childNodes[n]).map(ne.fromDom);
    }, Bb = (e) => {
      const t = e.endContainer, n = e.endOffset;
      return Ft(t) ? n === t.data.length ? w.some(ne.fromDom(t)) : w.none() : w.from(t.childNodes[n - 1]).map(ne.fromDom);
    }, Rm = (e) => nl(e).fold(Z([e]), (t) => [e].concat(Rm(t))), Dg = (e) => pi(e).fold(Z([e]), (t) => tn(t) === "br" ? Fa(t).map((n) => [e].concat(Dg(n))).getOr([]) : [e].concat(Dg(t))), Pu = (e, t) => zo(b0(t), Bb(t), (n, o) => {
      const s = oo(Rm(e), et(_o, n)), a = oo(Dg(e), et(_o, o));
      return s.isSome() && a.isSome();
    }).getOr(!1), Dm = (e, t, n, o) => {
      const s = n, a = new hs(n, s), i = rs(e.schema.getMoveCaretBeforeOnEnterElements(), (u, d) => !ce([
        "td",
        "th",
        "table"
      ], d.toLowerCase()));
      do {
        if (Ft(n) && nt.trim(n.nodeValue).length !== 0) {
          o ? t.setStart(n, 0) : t.setEnd(n, n.nodeValue.length);
          return;
        }
        if (i[n.nodeName]) {
          o ? t.setStartBefore(n) : n.nodeName === "BR" ? t.setEndBefore(n) : t.setEndAfter(n);
          return;
        }
      } while (n = o ? a.next() : a.prev());
      s.nodeName === "BODY" && (o ? t.setStart(s, 0) : t.setEnd(s, s.childNodes.length));
    }, Om = (e) => {
      const t = e.selection.getSel();
      return t && t.rangeCount > 0;
    }, Pm = (e, t) => {
      const n = Ol(e);
      n.length > 0 ? M(n, (o) => {
        const s = o.dom, a = e.dom.createRng();
        a.setStartBefore(s), a.setEndAfter(s), t(a, !0);
      }) : t(e.selection.getRng(), !1);
    }, Bm = (e, t, n) => {
      const o = _y(e, t);
      n(o), e.moveToBookmark(o);
    }, Bu = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], Og = (e) => ko(e) && Bc(e) === m, $m = (e, t, n, o) => er(t).fold(() => "skipping", (s) => o === "br" || Og(t) ? "valid" : Ef(t) ? "existing" : ua(t.dom) ? "caret" : Ce(Bu, (a) => sa(t, a)) ? "valid-block" : !Au(e, n, o) || !Au(e, tn(s), n) ? "invalid-child" : "valid"), Fm = (e, t) => {
      const n = Ou(e, t, [{ inline: "span" }]);
      t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t);
    }, $b = (e, t, n, o, s, a) => {
      const { uid: i = t, ...u } = n;
      ka(e, Cf()), ao(e, `${du()}`, i), ao(e, `${wl()}`, o);
      const { attributes: d = {}, classes: y = [] } = s(i, u);
      if (es(e, d), _w(e, y), a) {
        y.length > 0 && ao(e, `${xf()}`, y.join(","));
        const v = ze(d);
        v.length > 0 && ao(e, `${mu()}`, v.join(","));
      }
    }, k0 = (e) => {
      xc(e, Cf()), as(e, `${du()}`), as(e, `${wl()}`), as(e, `${Sf()}`);
      const t = Jr(e, `${mu()}`).map((o) => o.split(",")).getOr([]), n = Jr(e, `${xf()}`).map((o) => o.split(",")).getOr([]);
      M(t, (o) => as(e, o)), Uc(e, n), as(e, `${xf()}`), as(e, `${mu()}`);
    }, Fb = (e, t, n, o, s) => {
      const a = ne.fromTag("span", e);
      return $b(a, t, n, o, s, !1), a;
    }, w0 = (e, t, n, o, s, a) => {
      const i = [], u = Fb(e.getDoc(), n, a, o, s), d = jc(), y = () => {
        d.clear();
      }, v = () => d.get().getOrThunk(() => {
        const U = pu(u);
        return i.push(U), d.set(U), U;
      }), T = (U) => {
        M(U, N);
      }, N = (U) => {
        switch ($m(e, U, "span", tn(U))) {
          case "invalid-child": {
            y();
            const H = fs(U);
            T(H), y();
            break;
          }
          case "valid-block": {
            y(), $b(U, n, a, o, s, !0);
            break;
          }
          case "valid": {
            const H = v();
            bd(U, H);
            break;
          }
        }
      }, F = (U) => {
        const j = W(U, ne.fromDom);
        T(j);
      };
      return Dl(e.dom, t, (U) => {
        y(), F(U);
      }), i;
    }, Im = (e, t, n, o) => {
      e.undoManager.transact(() => {
        const s = e.selection, a = s.getRng(), i = Ol(e).length > 0, u = Xh("mce-annotation");
        if (a.collapsed && !i && Fm(e, a), s.getRng().collapsed && !i) {
          const d = Fb(e.getDoc(), u, o, t, n.decorate);
          hi(d, Ws), s.getRng().insertNode(d.dom), s.select(d.dom);
        } else
          Bm(s, !1, () => {
            Pm(e, (d) => {
              w0(e, d, u, t, n.decorate, o);
            });
          });
      });
    }, Ib = (e) => {
      const t = ww();
      qs(e, t);
      const n = qp(e, t), o = Ya("span"), s = (a) => {
        M(a, (i) => {
          o(i) ? Es(i) : k0(i);
        });
      };
      return {
        register: (a, i) => {
          t.register(a, i);
        },
        annotate: (a, i) => {
          t.lookup(a).each((u) => {
            Im(e, a, u, i);
          });
        },
        annotationChanged: (a, i) => {
          n.addListener(a, i);
        },
        remove: (a) => {
          const i = e.selection.getBookmark();
          Kh(e, w.some(a)).each(({ elements: u }) => {
            s(u);
          }), e.selection.moveToBookmark(i);
        },
        removeAll: (a) => {
          const i = e.selection.getBookmark();
          Ot(Zd(e, a), (u, d) => {
            s(u);
          }), e.selection.moveToBookmark(i);
        },
        getAll: (a) => {
          const i = Zd(e, a);
          return hn(i, (u) => W(u, (d) => d.dom));
        }
      };
    }, Wf = (e) => ({
      getBookmark: et(e0, e),
      moveToBookmark: et(t0, e)
    });
    Wf.isBookmarkNode = fa;
    const Lb = (e, t, n) => n.collapsed ? !1 : Ce(n.getClientRects(), (o) => Sw(o, e, t)), _0 = (e, t) => e.dispatch("PreProcess", t), v0 = (e, t) => e.dispatch("PostProcess", t), C0 = (e) => e.dispatch("remove"), S0 = (e) => e.dispatch("detach"), $u = (e, t) => e.dispatch("SwitchMode", { mode: t }), x0 = (e, t, n, o, s) => {
      e.dispatch("ObjectResizeStart", {
        target: t,
        width: n,
        height: o,
        origin: s
      });
    }, E0 = (e, t, n, o, s) => {
      e.dispatch("ObjectResized", {
        target: t,
        width: n,
        height: o,
        origin: s
      });
    }, T0 = (e) => e.dispatch("PreInit"), z0 = (e) => e.dispatch("PostRender"), Lm = (e) => e.dispatch("Init"), A0 = (e, t) => e.dispatch("PlaceholderToggle", { state: t }), Mb = (e, t, n) => e.dispatch(t, n), jb = (e, t, n, o) => e.dispatch("FormatApply", {
      format: t,
      node: n,
      vars: o
    }), Pg = (e, t, n, o) => e.dispatch("FormatRemove", {
      format: t,
      node: n,
      vars: o
    }), Mm = (e, t) => e.dispatch("BeforeSetContent", t), Bg = (e, t) => e.dispatch("SetContent", t), $g = (e, t) => e.dispatch("BeforeGetContent", t), Ub = (e, t) => e.dispatch("GetContent", t), Hb = (e, t) => e.dispatch("AutocompleterStart", t), Wb = (e, t) => e.dispatch("AutocompleterUpdate", t), qb = (e) => e.dispatch("AutocompleterEnd"), Vb = (e, t, n) => e.dispatch("PastePreProcess", {
      content: t,
      internal: n
    }), N0 = (e, t, n) => e.dispatch("PastePostProcess", {
      node: t,
      internal: n
    }), Fg = (e, t) => e.dispatch("PastePlainTextToggle", { state: t }), sn = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || sn.metaKeyPressed(e),
      metaKeyPressed: (e) => Gn.os.isMacOS() || Gn.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, $i = "data-mce-selected", R0 = "table,img,figure.image,hr,video,span.mce-preview-object", Gb = Math.abs, jm = Math.round, qf = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, Fu = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, Kb = (e, t) => {
      const n = t.dom, o = t.getDoc(), s = document, a = t.getBody();
      let i, u, d, y, v, T, N, F, U, j, H, se, ve, Se, Be, at, Vt;
      const lt = (Bt) => L(Bt) && (Cd(Bt) || n.is(Bt, "figure.image")), gt = (Bt) => dc(Bt) || n.hasClass(Bt, "mce-preview-object"), Dt = (Bt, Jn) => {
        if (Fu(Bt)) {
          const co = Bt.touches[0];
          return lt(Bt.target) && !Lb(co.clientX, co.clientY, Jn);
        } else
          return lt(Bt.target) && !Lb(Bt.clientX, Bt.clientY, Jn);
      }, Pt = (Bt) => {
        const Jn = Bt.target;
        Dt(Bt, t.selection.getRng()) && !Bt.isDefaultPrevented() && t.selection.select(Jn);
      }, bn = (Bt) => n.is(Bt, "figure.image") ? [Bt.querySelector("img")] : n.hasClass(Bt, "mce-preview-object") && L(Bt.firstElementChild) ? [
        Bt,
        Bt.firstElementChild
      ] : [Bt], nn = (Bt) => {
        const Jn = Iy(t);
        return !Jn || Bt.getAttribute("data-mce-resize") === "false" || Bt === t.getBody() ? !1 : n.hasClass(Bt, "mce-preview-object") ? sa(ne.fromDom(Bt.firstElementChild), Jn) : sa(ne.fromDom(Bt), Jn);
      }, Ht = (Bt) => gt(Bt) ? n.create("img", { src: Gn.transparentSrc }) : Bt.cloneNode(!0), fo = (Bt, Jn, co) => {
        if (L(co)) {
          const xn = bn(Bt);
          M(xn, (Sn) => {
            Sn.style[Jn] || !t.schema.isValid(Sn.nodeName.toLowerCase(), Jn) ? n.setStyle(Sn, Jn, co) : n.setAttrib(Sn, Jn, "" + co);
          });
        }
      }, Co = (Bt, Jn, co) => {
        fo(Bt, "width", Jn), fo(Bt, "height", co);
      }, Fo = (Bt) => {
        let Jn, co, xn, Sn, So;
        Jn = Bt.screenX - T, co = Bt.screenY - N, Se = Jn * y[2] + j, Be = co * y[3] + H, Se = Se < 5 ? 5 : Se, Be = Be < 5 ? 5 : Be, (lt(i) || gt(i)) && l_(t) !== !1 ? xn = !sn.modifierPressed(Bt) : xn = sn.modifierPressed(Bt), xn && (Gb(Jn) > Gb(co) ? (Be = jm(Se * se), Se = jm(Be / se)) : (Se = jm(Be / se), Be = jm(Se * se))), Co(u, Se, Be), Sn = y.startPos.x + Jn, So = y.startPos.y + co, Sn = Sn > 0 ? Sn : 0, So = So > 0 ? So : 0, n.setStyles(d, {
          left: Sn,
          top: So,
          display: "block"
        }), d.innerHTML = Se + " &times; " + Be, y[2] < 0 && u.clientWidth <= Se && n.setStyle(u, "left", F + (j - Se)), y[3] < 0 && u.clientHeight <= Be && n.setStyle(u, "top", U + (H - Be)), Jn = a.scrollWidth - at, co = a.scrollHeight - Vt, Jn + co !== 0 && n.setStyles(d, {
          left: Sn - Jn,
          top: So - co
        }), ve || (x0(t, i, j, H, "corner-" + y.name), ve = !0);
      }, Ls = () => {
        const Bt = ve;
        ve = !1, Bt && (fo(i, "width", Se), fo(i, "height", Be)), n.unbind(o, "mousemove", Fo), n.unbind(o, "mouseup", Ls), s !== o && (n.unbind(s, "mousemove", Fo), n.unbind(s, "mouseup", Ls)), n.remove(u), n.remove(d), n.remove(v), Nt(i), Bt && (E0(t, i, Se, Be, "corner-" + y.name), n.setAttrib(i, "style", n.getAttrib(i, "style"))), t.nodeChanged();
      }, Nt = (Bt) => {
        Mt();
        const Jn = n.getPos(Bt, a), co = Jn.x, xn = Jn.y, Sn = Bt.getBoundingClientRect(), So = Sn.width || Sn.right - Sn.left, xo = Sn.height || Sn.bottom - Sn.top;
        i !== Bt && (no(), i = Bt, Se = Be = 0);
        const Ms = t.dispatch("ObjectSelected", { target: Bt });
        nn(Bt) && !Ms.isDefaultPrevented() ? Ot(qf, (Ho, so) => {
          let Wo;
          const Pr = (Br) => {
            const gr = bn(i)[0];
            T = Br.screenX, N = Br.screenY, j = gr.clientWidth, H = gr.clientHeight, se = H / j, y = Ho, y.name = so, y.startPos = {
              x: So * Ho[0] + co,
              y: xo * Ho[1] + xn
            }, at = a.scrollWidth, Vt = a.scrollHeight, v = n.add(a, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), n.setStyles(v, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), u = Ht(i), n.addClass(u, "mce-clonedresizable"), n.setAttrib(u, "data-mce-bogus", "all"), u.contentEditable = "false", n.setStyles(u, {
              left: co,
              top: xn,
              margin: 0
            }), Co(u, So, xo), u.removeAttribute($i), a.appendChild(u), n.bind(o, "mousemove", Fo), n.bind(o, "mouseup", Ls), s !== o && (n.bind(s, "mousemove", Fo), n.bind(s, "mouseup", Ls)), d = n.add(a, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, j + " &times; " + H);
          };
          Wo = n.get("mceResizeHandle" + so), Wo && n.remove(Wo), Wo = n.add(a, "div", {
            id: "mceResizeHandle" + so,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + so + "-resize; margin:0; padding:0"
          }), n.bind(Wo, "mousedown", (Br) => {
            Br.stopImmediatePropagation(), Br.preventDefault(), Pr(Br);
          }), Ho.elm = Wo, n.setStyles(Wo, {
            left: So * Ho[0] + co - Wo.offsetWidth / 2,
            top: xo * Ho[1] + xn - Wo.offsetHeight / 2
          });
        }) : no(!1);
      }, fn = Ni(Nt, 0), no = (Bt = !0) => {
        fn.cancel(), Mt(), i && Bt && i.removeAttribute($i), Ot(qf, (Jn, co) => {
          const xn = n.get("mceResizeHandle" + co);
          xn && (n.unbind(xn), n.remove(xn));
        });
      }, Qn = (Bt, Jn) => L(Bt) && n.isChildOf(Bt, Jn), Gs = (Bt) => {
        if (ve || t.removed || t.composing)
          return;
        const Jn = Bt.type === "mousedown" ? Bt.target : e.getNode(), co = Ma(ne.fromDom(Jn), R0).map((Sn) => Sn.dom).getOrUndefined(), xn = L(co) ? n.getAttrib(co, $i, "1") : "1";
        if (M(n.select(`img[${$i}],hr[${$i}]`), (Sn) => {
          Sn.removeAttribute($i);
        }), Qn(co, a)) {
          _n();
          const Sn = e.getStart(!0);
          if (Qn(Sn, co) && Qn(e.getEnd(!0), co)) {
            n.setAttrib(co, $i, xn), fn.throttle(co);
            return;
          }
        }
        no();
      }, Mt = () => {
        Ot(qf, (Bt) => {
          Bt.elm && (n.unbind(Bt.elm), delete Bt.elm);
        });
      }, _n = () => {
        try {
          t.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return t.on("init", () => {
        _n(), t.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", Gs), t.on("keyup compositionend", (Bt) => {
          i && i.nodeName === "TABLE" && Gs(Bt);
        }), t.on("hide blur", no), t.on("contextmenu longpress", Pt, !0);
      }), t.on("remove", Mt), {
        isResizable: nn,
        showResizeRect: Nt,
        hideResizeRect: no,
        updateResizeRect: Gs,
        destroy: () => {
          fn.cancel(), i = u = v = null;
        }
      };
    }, D0 = (e, t) => {
      t.fold((n) => {
        e.setStartBefore(n.dom);
      }, (n, o) => {
        e.setStart(n.dom, o);
      }, (n) => {
        e.setStartAfter(n.dom);
      });
    }, O0 = (e, t) => {
      t.fold((n) => {
        e.setEndBefore(n.dom);
      }, (n, o) => {
        e.setEnd(n.dom, o);
      }, (n) => {
        e.setEndAfter(n.dom);
      });
    }, Um = (e, t, n) => {
      const o = e.document.createRange();
      return D0(o, t), O0(o, n), o;
    }, Ig = (e, t, n, o, s) => {
      const a = e.document.createRange();
      return a.setStart(t.dom, n), a.setEnd(o.dom, s), a;
    }, Vf = bc.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), Gf = (e, t, n) => t(ne.fromDom(n.startContainer), n.startOffset, ne.fromDom(n.endContainer), n.endOffset), P0 = (e, t) => t.match({
      domRange: (n) => ({
        ltr: Z(n),
        rtl: w.none
      }),
      relative: (n, o) => ({
        ltr: rn(() => Um(e, n, o)),
        rtl: rn(() => w.some(Um(e, o, n)))
      }),
      exact: (n, o, s, a) => ({
        ltr: rn(() => Ig(e, n, o, s, a)),
        rtl: rn(() => w.some(Ig(e, s, a, n, o)))
      })
    }), B0 = (e, t) => {
      const n = t.ltr();
      return n.collapsed ? t.rtl().filter((s) => s.collapsed === !1).map((s) => Vf.rtl(ne.fromDom(s.endContainer), s.endOffset, ne.fromDom(s.startContainer), s.startOffset)).getOrThunk(() => Gf(e, Vf.ltr, n)) : Gf(e, Vf.ltr, n);
    }, $0 = (e, t) => {
      const n = P0(e, t);
      return B0(e, n);
    };
    Vf.ltr, Vf.rtl;
    const Yb = { create: (e, t, n, o) => ({
      start: e,
      soffset: t,
      finish: n,
      foffset: o
    }) }, F0 = (e, t, n) => {
      var o, s;
      return w.from((s = (o = e.dom).caretPositionFromPoint) === null || s === void 0 ? void 0 : s.call(o, t, n)).bind((a) => {
        if (a.offsetNode === null)
          return w.none();
        const i = e.dom.createRange();
        return i.setStart(a.offsetNode, a.offset), i.collapse(), w.some(i);
      });
    }, Lg = (e, t, n) => {
      var o, s;
      return w.from((s = (o = e.dom).caretRangeFromPoint) === null || s === void 0 ? void 0 : s.call(o, t, n));
    }, I0 = (() => document.caretPositionFromPoint ? F0 : document.caretRangeFromPoint ? Lg : w.none)(), L0 = (e, t, n) => {
      const o = ne.fromDom(e.document);
      return I0(o, t, n).map((s) => Yb.create(ne.fromDom(s.startContainer), s.startOffset, ne.fromDom(s.endContainer), s.endOffset));
    }, Mg = bc.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), Cx = (e, t, n, o) => e.fold(t, n, o), Sx = (e) => e.fold(Pe, Pe, Pe), M0 = Mg.before, j0 = Mg.on, U0 = Mg.after, Xc = {
      before: M0,
      on: j0,
      after: U0,
      cata: Cx,
      getStart: Sx
    }, Hm = bc.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), H0 = (e) => Hm.exact(e.start, e.soffset, e.finish, e.foffset), W0 = (e) => e.match({
      domRange: (t) => ne.fromDom(t.startContainer),
      relative: (t, n) => Xc.getStart(t),
      exact: (t, n, o, s) => t
    }), q0 = Hm.domRange, V0 = Hm.relative, G0 = Hm.exact, Xb = (e) => {
      const t = W0(e);
      return $a(t);
    }, K0 = Yb.create, Iu = {
      domRange: q0,
      relative: V0,
      exact: G0,
      exactFromRange: H0,
      getWin: Xb,
      range: K0
    }, Wm = (e, t) => {
      const n = tn(e);
      return n === "input" ? Xc.after(e) : ce([
        "br",
        "img"
      ], n) ? t === 0 ? Xc.before(e) : Xc.after(e) : Xc.on(e, t);
    }, Y0 = (e, t) => {
      const n = e.fold(Xc.before, Wm, Xc.after), o = t.fold(Xc.before, Wm, Xc.after);
      return Iu.relative(n, o);
    }, Zb = (e, t, n, o) => {
      const s = Wm(e, t), a = Wm(n, o);
      return Iu.relative(s, a);
    }, Lu = (e) => e.match({
      domRange: (t) => {
        const n = ne.fromDom(t.startContainer), o = ne.fromDom(t.endContainer);
        return Zb(n, t.startOffset, o, t.endOffset);
      },
      relative: Y0,
      exact: Zb
    }), Pl = (e, t) => {
      const o = (t || document).createDocumentFragment();
      return M(e, (s) => {
        o.appendChild(s.dom);
      }), ne.fromDom(o);
    }, jg = (e) => {
      const t = Iu.getWin(e).dom, n = (s, a, i, u) => Ig(t, s, a, i, u), o = Lu(e);
      return $0(t, o).match({
        ltr: n,
        rtl: n
      });
    }, X0 = (e, t, n) => L0(e, t, n), Sa = (e, t, n) => X0(n.defaultView, e, t).map((o) => {
      const s = n.createRange();
      return s.setStart(o.start.dom, o.soffset), s.setEnd(o.finish.dom, o.foffset), s;
    }).getOrUndefined(), Zc = (e, t) => e && t && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset, Z0 = (e, t, n) => {
      for (; e && e !== t; ) {
        if (n(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, Mu = (e, t, n) => Z0(e, t, n) !== null, Q0 = (e, t, n) => Mu(e, t, (o) => o.nodeName === n), Ug = (e) => e && e.nodeName === "TABLE", J0 = (e) => e && /^(TD|TH|CAPTION)$/.test(e.nodeName), ev = (e, t) => xt(e) && Mu(e, t, ua) === !1, Qb = (e, t, n) => {
      const o = new hs(t, e.getParent(t.parentNode, e.isBlock) || e.getRoot());
      for (; t = o[n ? "prev" : "next"](); )
        if (ds(t))
          return !0;
    }, tv = (e, t) => e.previousSibling && e.previousSibling.nodeName === t, nv = (e, t) => {
      for (; t && t !== e; ) {
        if (ns(t))
          return !0;
        t = t.parentNode;
      }
      return !1;
    }, Hg = (e, t, n, o, s) => {
      let a;
      const i = e.getRoot();
      let u;
      const d = e.schema.getNonEmptyElements(), y = e.getParent(s.parentNode, e.isBlock) || i;
      if (o && ds(s) && t && e.isEmpty(y))
        return w.some(je(s.parentNode, e.nodeIndex(s)));
      const v = new hs(s, y);
      for (; u = v[o ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(u) === "false" || ev(u, i))
          return w.none();
        if (Ft(u) && u.nodeValue.length > 0)
          return Q0(u, i, "A") === !1 ? w.some(je(u, o ? u.nodeValue.length : 0)) : w.none();
        if (e.isBlock(u) || d[u.nodeName.toLowerCase()])
          return w.none();
        a = u;
      }
      return ul(a) ? w.none() : n && a ? w.some(je(a, 0)) : w.none();
    }, qm = (e, t, n, o) => {
      let s, a;
      const i = e.getRoot();
      let u, d, y = !1;
      s = o[(n ? "start" : "end") + "Container"], a = o[(n ? "start" : "end") + "Offset"];
      const v = dn(s) && a === s.childNodes.length, T = e.schema.getNonEmptyElements();
      if (d = n, xt(s))
        return w.none();
      if (dn(s) && a > s.childNodes.length - 1 && (d = !1), Jl(s) && (s = i, a = 0), s === i) {
        if (d && (u = s.childNodes[a > 0 ? a - 1 : 0], u && (xt(u) || T[u.nodeName] || Ug(u))))
          return w.none();
        if (s.hasChildNodes()) {
          if (a = Math.min(!d && a > 0 ? a - 1 : a, s.childNodes.length - 1), s = s.childNodes[a], a = Ft(s) && v ? s.data.length : 0, !t && s === i.lastChild && Ug(s) || nv(i, s) || xt(s))
            return w.none();
          if (s.hasChildNodes() && Ug(s) === !1) {
            u = s;
            const N = new hs(s, i);
            do {
              if (ns(u) || xt(u)) {
                y = !1;
                break;
              }
              if (Ft(u) && u.nodeValue.length > 0) {
                a = d ? 0 : u.nodeValue.length, s = u, y = !0;
                break;
              }
              if (T[u.nodeName.toLowerCase()] && !J0(u)) {
                a = e.nodeIndex(u), s = u.parentNode, d || a++, y = !0;
                break;
              }
            } while (u = d ? N.next() : N.prev());
          }
        }
      }
      return t && (Ft(s) && a === 0 && Hg(e, v, t, !0, s).each((N) => {
        s = N.container(), a = N.offset(), y = !0;
      }), dn(s) && (u = s.childNodes[a], u || (u = s.childNodes[a - 1]), u && ds(u) && !tv(u, "A") && !Qb(e, u, !1) && !Qb(e, u, !0) && Hg(e, v, t, !0, u).each((N) => {
        s = N.container(), a = N.offset(), y = !0;
      }))), d && !t && Ft(s) && a === s.nodeValue.length && Hg(e, v, t, !1, s).each((N) => {
        s = N.container(), a = N.offset(), y = !0;
      }), y ? w.some(je(s, a)) : w.none();
    }, Vm = (e, t) => {
      const n = t.collapsed, o = t.cloneRange(), s = je.fromRangeStart(t);
      return qm(e, n, !0, o).each((a) => {
        (!n || !je.isAbove(s, a)) && o.setStart(a.container(), a.offset());
      }), n || qm(e, n, !1, o).each((a) => {
        o.setEnd(a.container(), a.offset());
      }), n && o.collapse(!0), Zc(t, o) ? w.none() : w.some(o);
    }, Gm = (e, t) => e.splitText(t), Km = (e) => {
      let t = e.startContainer, n = e.startOffset, o = e.endContainer, s = e.endOffset;
      return t === o && Ft(t) ? n > 0 && n < t.nodeValue.length && (o = Gm(t, n), t = o.previousSibling, s > n ? (s = s - n, t = o = Gm(o, s).previousSibling, s = o.nodeValue.length, n = 0) : s = 0) : (Ft(t) && n > 0 && n < t.nodeValue.length && (t = Gm(t, n), n = 0), Ft(o) && s > 0 && s < o.nodeValue.length && (o = Gm(o, s).previousSibling, s = o.nodeValue.length)), {
        startContainer: t,
        startOffset: n,
        endContainer: o,
        endOffset: s
      };
    }, ju = (e) => ({
      walk: (s, a) => Dl(e, s, a),
      split: Km,
      normalize: (s) => Vm(e, s).fold(cn, (a) => (s.setStart(a.startContainer, a.startOffset), s.setEnd(a.endContainer, a.endOffset), !0))
    });
    ju.compareRanges = Zc, ju.getCaretRangeFromPoint = Sa, ju.getSelectedNode = em, ju.getNode = Oi;
    const ov = ((e, t) => {
      const n = (u, d) => {
        if (!Je(d) && !d.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + d);
        const y = u.dom;
        oa(y) && (y.style[e] = d + "px");
      }, o = (u) => {
        const d = t(u);
        if (d <= 0 || d === null) {
          const y = Hs(u, e);
          return parseFloat(y) || 0;
        }
        return d;
      }, s = o, a = (u, d) => En(d, (y, v) => {
        const T = Hs(u, v), N = T === void 0 ? 0 : parseInt(T, 10);
        return isNaN(N) ? y : y + N;
      }, 0);
      return {
        set: n,
        get: o,
        getOuter: s,
        aggregate: a,
        max: (u, d, y) => {
          const v = a(u, y);
          return d > v ? d - v : 0;
        }
      };
    })("height", (e) => {
      const t = e.dom;
      return On(e) ? t.getBoundingClientRect().height : t.offsetHeight;
    }), sv = (e) => ov.get(e), Wg = () => ne.fromDom(document), rv = (e, t) => e.view(t).fold(Z([]), (o) => {
      const s = e.owner(o), a = rv(e, s);
      return [o].concat(a);
    }), Jb = (e, t) => {
      const n = t.owner(e);
      return rv(t, n);
    };
    var Tx = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var t;
        return (e.dom === document ? w.none() : w.from((t = e.dom.defaultView) === null || t === void 0 ? void 0 : t.frameElement)).map(ne.fromDom);
      },
      owner: (e) => wa(e)
    });
    const zx = (e) => {
      const t = Wg(), n = In(t), o = Jb(e, Tx), s = Ac(e), a = pn(o, (i, u) => {
        const d = Ac(u);
        return {
          left: i.left + d.left,
          top: i.top + d.top
        };
      }, {
        left: 0,
        top: 0
      });
      return il(a.left + s.left + n.left, a.top + s.top + n.top);
    }, e1 = (e) => tn(e) === "textarea", av = (e, t) => e.dispatch("ScrollIntoView", t).isDefaultPrevented(), cv = (e, t) => {
      e.dispatch("AfterScrollIntoView", t);
    }, Ax = (e, t) => {
      const n = fs(e);
      if (n.length === 0 || e1(e))
        return {
          element: e,
          offset: t
        };
      if (t < n.length && !e1(n[t]))
        return {
          element: n[t],
          offset: 0
        };
      {
        const o = n[n.length - 1];
        return e1(o) ? {
          element: e,
          offset: t
        } : tn(o) === "img" ? {
          element: o,
          offset: 1
        } : ko(o) ? {
          element: o,
          offset: Bc(o).length
        } : {
          element: o,
          offset: fs(o).length
        };
      }
    }, Kf = (e, t) => {
      const n = yi(e), o = sv(e);
      return {
        element: e,
        bottom: n.top + o,
        height: o,
        pos: n,
        cleanup: t
      };
    }, iv = (e, t) => {
      const n = Ax(e, t), o = ne.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + m + "</span>");
      return yr(n.element, o), Kf(o, () => Do(o));
    }, lv = (e) => Kf(ne.fromDom(e), ye), t1 = (e, t, n, o) => {
      o1(e, (s, a) => qg(e, t, n, o), n);
    }, n1 = (e, t, n, o, s) => {
      const a = {
        elm: o.element.dom,
        alignToTop: s
      };
      if (av(e, a))
        return;
      const i = In(t).top;
      n(t, i, o, s), cv(e, a);
    }, qg = (e, t, n, o) => {
      const s = ne.fromDom(e.getBody()), a = ne.fromDom(e.getDoc());
      Ia(s);
      const i = iv(ne.fromDom(n.startContainer), n.startOffset);
      n1(e, a, t, i, o), i.cleanup();
    }, Vg = (e, t, n, o) => {
      const s = ne.fromDom(e.getDoc());
      n1(e, s, n, lv(t), o);
    }, o1 = (e, t, n) => {
      const o = n.startContainer, s = n.startOffset, a = n.endContainer, i = n.endOffset;
      t(ne.fromDom(o), ne.fromDom(a));
      const u = e.dom.createRng();
      u.setStart(o, s), u.setEnd(a, i), e.selection.setRng(n);
    }, Ym = (e, t, n, o) => {
      const s = e.pos;
      if (n)
        fc(s.left, s.top, o);
      else {
        const a = s.top - t + e.height;
        fc(s.left, a, o);
      }
    }, s1 = (e, t, n, o, s) => {
      const a = n + t, i = o.pos.top, u = o.bottom, d = u - i >= n;
      i < t ? Ym(o, n, s !== !1, e) : i > a ? Ym(o, n, d ? s !== !1 : s === !0, e) : u > a && !d && Ym(o, n, s === !0, e);
    }, r1 = (e, t, n, o) => {
      const s = e.dom.defaultView.innerHeight;
      s1(e, t, s, n, o);
    }, Xm = (e, t, n, o) => {
      const s = e.dom.defaultView.innerHeight;
      s1(e, t, s, n, o);
      const a = zx(n.element), i = lf(window);
      a.top < i.y ? bi(n.element, o !== !1) : a.top > i.bottom && bi(n.element, o === !0);
    }, a1 = (e, t, n) => t1(e, r1, t, n), uv = (e, t, n) => Vg(e, t, r1, n), fv = (e, t, n) => t1(e, Xm, t, n), dv = (e, t, n) => Vg(e, t, Xm, n), Gg = (e, t, n) => {
      (e.inline ? uv : dv)(e, t, n);
    }, Uu = (e, t, n) => {
      (e.inline ? a1 : fv)(e, t, n);
    }, c1 = (e) => e.dom.focus(), i1 = (e) => {
      const t = S(e).dom;
      return e.dom === t.activeElement;
    }, Kg = (e = Wg()) => w.from(e.dom.activeElement).map(ne.fromDom), mv = (e) => Kg(S(e)).filter((t) => e.dom.contains(t.dom)), l1 = (e, t) => {
      const n = ko(t) ? Bc(t).length : fs(t).length + 1;
      return e > n ? n : e < 0 ? 0 : e;
    }, pv = (e) => Iu.range(e.start, l1(e.soffset, e.start), e.finish, l1(e.foffset, e.finish)), gv = (e, t) => !ki(t.dom) && (ws(e, t) || _o(e, t)), u1 = (e) => (t) => gv(e, t.start) && gv(e, t.finish), Nx = (e) => e.inline, Rx = (e) => Iu.range(ne.fromDom(e.startContainer), e.startOffset, ne.fromDom(e.endContainer), e.endOffset), Dx = (e) => {
      const t = e.getSelection();
      return (!t || t.rangeCount === 0 ? w.none() : w.from(t.getRangeAt(0))).map(Rx);
    }, f1 = (e) => {
      const t = $a(e);
      return Dx(t.dom).filter(u1(e));
    }, hv = (e, t) => w.from(t).filter(u1(e)).map(pv), yv = (e) => {
      const t = document.createRange();
      try {
        return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), w.some(t);
      } catch {
        return w.none();
      }
    }, Yg = (e) => {
      const t = Nx(e) ? f1(ne.fromDom(e.getBody())) : w.none();
      e.bookmark = t.isSome() ? t : e.bookmark;
    }, Zm = (e) => (e.bookmark ? e.bookmark : w.none()).bind((n) => hv(ne.fromDom(e.getBody()), n)).bind(yv), Xg = (e) => {
      Zm(e).each((t) => e.selection.setRng(t));
    }, d1 = { isEditorUIElement: (e) => {
      const t = e.className.toString();
      return t.indexOf("tox-") !== -1 || t.indexOf("mce-") !== -1;
    } }, bv = (e, t) => (Je(t) || (t = 0), setTimeout(e, t)), kv = (e, t) => (Je(t) || (t = 0), setInterval(e, t)), xa = {
      setEditorTimeout: (e, t, n) => bv(() => {
        e.removed || t();
      }, n),
      setEditorInterval: (e, t, n) => {
        const o = kv(() => {
          e.removed ? clearInterval(o) : t();
        }, n);
        return o;
      }
    }, wv = (e) => e.type === "nodechange" && e.selectionChange, r = (e, t) => {
      const n = () => {
        t.throttle();
      };
      Uo.DOM.bind(document, "mouseup", n), e.on("remove", () => {
        Uo.DOM.unbind(document, "mouseup", n);
      });
    }, c = (e, t) => {
      e.on("mouseup touchend", (n) => {
        t.throttle();
      });
    }, l = (e, t) => {
      c(e, t), e.on("keyup NodeChange AfterSetSelectionRange", (n) => {
        wv(n) || Yg(e);
      });
    }, f = (e) => {
      const t = Ni(() => {
        Yg(e);
      }, 0);
      e.on("init", () => {
        e.inline && r(e, t), l(e, t);
      }), e.on("remove", () => {
        t.cancel();
      });
    };
    let p;
    const k = Uo.DOM, C = (e) => d1.isEditorUIElement(e), z = (e) => {
      const t = e.classList;
      return t !== void 0 ? t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body") : !1;
    }, I = (e, t) => {
      const n = My(e);
      return k.getParent(t, (s) => C(s) || (n ? e.dom.is(s, n) : !1)) !== null;
    }, Y = (e) => {
      try {
        const t = S(ne.fromDom(e.getElement()));
        return Kg(t).fold(() => document.body, (n) => n.dom);
      } catch {
        return document.body;
      }
    }, he = (e, t) => {
      const n = t.editor;
      f(n), n.on("focusin", () => {
        const o = e.focusedEditor;
        o !== n && (o && o.dispatch("blur", { focusedEditor: n }), e.setActive(n), e.focusedEditor = n, n.dispatch("focus", { blurredEditor: o }), n.focus(!0));
      }), n.on("focusout", () => {
        xa.setEditorTimeout(n, () => {
          const o = e.focusedEditor;
          !I(n, Y(n)) && o === n && (n.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), p || (p = (o) => {
        const s = e.activeEditor;
        s && $t(o).each((a) => {
          a.ownerDocument === document && a !== document.body && !I(s, a) && e.focusedEditor === s && (s.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, k.bind(document, "focusin", p));
    }, ct = (e, t) => {
      e.focusedEditor === t.editor && (e.focusedEditor = null), e.activeEditor || (k.unbind(document, "focusin", p), p = null);
    }, Tt = (e) => {
      e.on("AddEditor", et(he, e)), e.on("RemoveEditor", et(ct, e));
    }, Ct = (e, t) => e.dom.getParent(t, (n) => e.dom.getContentEditable(n) === "true"), Ye = (e) => e.collapsed ? w.from(Oi(e.startContainer, e.startOffset)).map(ne.fromDom) : w.none(), Rt = (e, t) => Ye(t).bind((n) => Rd(n) ? w.some(n) : ws(e, n) === !1 ? w.some(e) : w.none()), Xe = (e, t) => {
      Rt(ne.fromDom(e.getBody()), t).bind((n) => _r(n.dom)).fold(() => {
        e.selection.normalize();
      }, (n) => e.selection.setRng(n.toRange()));
    }, Kt = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, Cn = (e) => i1(e) || mv(e).isSome(), Fn = (e) => e.iframeElement && i1(ne.fromDom(e.iframeElement)), Zo = (e) => {
      const t = e.getBody();
      return t && Cn(ne.fromDom(t));
    }, Is = (e) => {
      const t = S(ne.fromDom(e.getElement()));
      return Kg(t).filter((n) => !z(n.dom) && I(e, n.dom)).isSome();
    }, Yo = (e) => e.inline ? Zo(e) : Fn(e), Hr = (e) => Yo(e) || Is(e), Hu = (e) => {
      const t = e.selection, n = e.getBody();
      let o = t.getRng();
      e.quirks.refreshContentEditable(), e.bookmark !== void 0 && Yo(e) === !1 && Zm(e).each((a) => {
        e.selection.setRng(a), o = a;
      });
      const s = Ct(e, t.getNode());
      if (e.dom.isChildOf(s, n)) {
        Kt(s), Xe(e, o), Yf(e);
        return;
      }
      e.inline || (Gn.browser.isOpera() || Kt(n), e.getWin().focus()), (Gn.browser.isFirefox() || e.inline) && (Kt(n), Xe(e, o)), Yf(e);
    }, Yf = (e) => e.editorManager.setActive(e), m1 = (e, t) => {
      e.removed || (t ? Yf(e) : Hu(e));
    }, Qm = (e, t, n, o, s) => {
      const a = n ? t.startContainer : t.endContainer, i = n ? t.startOffset : t.endOffset;
      return w.from(a).map(ne.fromDom).map((u) => !o || !t.collapsed ? ic(u, s(u, i)).getOr(u) : u).bind((u) => qn(u) ? w.some(u) : er(u).filter(qn)).map((u) => u.dom).getOr(e);
    }, Oo = (e, t, n) => Qm(e, t, !0, n, (o, s) => Math.min(ol(o), s)), dr = (e, t, n) => Qm(e, t, !1, n, (o, s) => s > 0 ? s - 1 : s), mr = (e, t) => {
      const n = e;
      for (; e && Ft(e) && e.length === 0; )
        e = t ? e.nextSibling : e.previousSibling;
      return e || n;
    }, Va = (e, t) => {
      let n, o, s;
      if (!t)
        return e;
      o = t.startContainer, s = t.endContainer;
      const a = t.startOffset, i = t.endOffset;
      return n = t.commonAncestorContainer, !t.collapsed && (o === s && i - a < 2 && o.hasChildNodes() && (n = o.childNodes[a]), o.nodeType === 3 && s.nodeType === 3 && (o.length === a ? o = mr(o.nextSibling, !0) : o = o.parentNode, i === 0 ? s = mr(s.previousSibling, !1) : s = s.parentNode, o && o === s)) ? o : n && n.nodeType === 3 ? n.parentNode : n;
    }, Ea = (e, t, n, o) => {
      let s;
      const a = [], i = e.getRoot();
      if (n = e.getParent(n || Oo(i, t, t.collapsed), e.isBlock), o = e.getParent(o || dr(i, t, t.collapsed), e.isBlock), n && n !== i && a.push(n), n && o && n !== o) {
        s = n;
        const u = new hs(n, i);
        for (; (s = u.next()) && s !== o; )
          e.isBlock(s) && a.push(s);
      }
      return o && n !== o && o !== i && a.push(o), a;
    }, Wu = (e, t, n) => w.from(t).map((o) => {
      const s = e.nodeIndex(o), a = e.createRng();
      return a.setStart(o.parentNode, s), a.setEnd(o.parentNode, s + 1), n && (Dm(e, a, o, !0), Dm(e, a, o, !1)), a;
    }), or = (e, t) => W(t, (n) => {
      const o = e.dispatch("GetSelectionRange", { range: n });
      return o.range !== n ? o.range : n;
    }), Zg = (e) => tn(e) === "img" ? 1 : Ti(e).fold(() => fs(e).length, (t) => t.length), Xf = (e) => Ti(e).filter((t) => t.trim().length !== 0 || t.indexOf(Ws) > -1).isSome(), _c = [
      "img",
      "br"
    ], Vs = (e) => Xf(e) || ce(_c, tn(e)), _v = (e) => xd(e, Vs), vv = (e) => Cv(e, Vs), Cv = (e, t) => {
      const n = (o) => {
        const s = fs(o);
        for (let a = s.length - 1; a >= 0; a--) {
          const i = s[a];
          if (t(i))
            return w.some(i);
          const u = n(i);
          if (u.isSome())
            return u;
        }
        return w.none();
      };
      return n(e);
    }, p1 = "[data-mce-autocompleter]", Sv = (e, t) => {
      if (g1(ne.fromDom(e.getBody())).isNone()) {
        const n = ne.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
        ls(n, ne.fromDom(t.extractContents())), t.insertNode(n.dom), er(n).each((o) => o.dom.normalize()), vv(n).map((o) => {
          e.selection.setCursorLocation(o.dom, Zg(o));
        });
      }
    }, Qg = (e) => Ma(e, p1), g1 = (e) => Pc(e, p1), Zf = (e, t) => g1(t).each((n) => {
      const o = e.selection.getBookmark();
      Es(n), e.selection.moveToBookmark(o);
    }), mR = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, h1 = (e, t, n) => {
      const o = n ? "lastChild" : "firstChild", s = n ? "prev" : "next";
      if (e[o])
        return e[o];
      if (e !== t) {
        let a = e[s];
        if (a)
          return a;
        for (let i = e.parent; i && i !== t; i = i.parent)
          if (a = i[s], a)
            return a;
      }
    }, pR = (e) => {
      if (!gc(e.value))
        return !1;
      const t = e.parent;
      return !(t && (t.name !== "span" || t.attr("style")) && /^[ ]+$/.test(e.value));
    }, Px = (e) => {
      const t = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t;
    };
    class da {
      constructor(t, n) {
        this.name = t, this.type = n, n === 1 && (this.attributes = [], this.attributes.map = {});
      }
      static create(t, n) {
        const o = new da(t, mR[t] || 1);
        return n && Ot(n, (s, a) => {
          o.attr(a, s);
        }), o;
      }
      replace(t) {
        const n = this;
        return t.parent && t.remove(), n.insert(t, n), n.remove(), n;
      }
      attr(t, n) {
        const o = this;
        let s;
        if (typeof t != "string")
          return t != null && Ot(t, (a, i) => {
            o.attr(i, a);
          }), o;
        if (s = o.attributes) {
          if (n !== void 0) {
            if (n === null) {
              if (t in s.map) {
                delete s.map[t];
                let a = s.length;
                for (; a--; )
                  if (s[a].name === t)
                    return s.splice(a, 1), o;
              }
              return o;
            }
            if (t in s.map) {
              let a = s.length;
              for (; a--; )
                if (s[a].name === t) {
                  s[a].value = n;
                  break;
                }
            } else
              s.push({
                name: t,
                value: n
              });
            return s.map[t] = n, o;
          }
          return s.map[t];
        }
      }
      clone() {
        const t = this, n = new da(t.name, t.type);
        let o;
        if (o = t.attributes) {
          const s = [];
          s.map = {};
          for (let a = 0, i = o.length; a < i; a++) {
            const u = o[a];
            u.name !== "id" && (s[s.length] = {
              name: u.name,
              value: u.value
            }, s.map[u.name] = u.value);
          }
          n.attributes = s;
        }
        return n.value = t.value, n;
      }
      wrap(t) {
        const n = this;
        return n.parent.insert(t, n), t.append(n), n;
      }
      unwrap() {
        const t = this;
        for (let n = t.firstChild; n; ) {
          const o = n.next;
          t.insert(n, t, !0), n = o;
        }
        t.remove();
      }
      remove() {
        const t = this, n = t.parent, o = t.next, s = t.prev;
        return n && (n.firstChild === t ? (n.firstChild = o, o && (o.prev = null)) : s.next = o, n.lastChild === t ? (n.lastChild = s, s && (s.next = null)) : o.prev = s, t.parent = t.next = t.prev = null), t;
      }
      append(t) {
        const n = this;
        t.parent && t.remove();
        const o = n.lastChild;
        return o ? (o.next = t, t.prev = o, n.lastChild = t) : n.lastChild = n.firstChild = t, t.parent = n, t;
      }
      insert(t, n, o) {
        t.parent && t.remove();
        const s = n.parent || this;
        return o ? (n === s.firstChild ? s.firstChild = t : n.prev.next = t, t.prev = n.prev, t.next = n, n.prev = t) : (n === s.lastChild ? s.lastChild = t : n.next.prev = t, t.next = n.next, t.prev = n, n.next = t), t.parent = s, t;
      }
      getAll(t) {
        const n = this, o = [];
        for (let s = n.firstChild; s; s = h1(s, n))
          s.name === t && o.push(s);
        return o;
      }
      children() {
        const t = this, n = [];
        for (let o = t.firstChild; o; o = o.next)
          n.push(o);
        return n;
      }
      empty() {
        const t = this;
        if (t.firstChild) {
          const n = [];
          for (let s = t.firstChild; s; s = h1(s, t))
            n.push(s);
          let o = n.length;
          for (; o--; ) {
            const s = n[o];
            s.parent = s.firstChild = s.lastChild = s.next = s.prev = null;
          }
        }
        return t.firstChild = t.lastChild = null, t;
      }
      isEmpty(t, n = {}, o) {
        const s = this;
        let a = s.firstChild;
        if (Px(s))
          return !1;
        if (a)
          do {
            if (a.type === 1) {
              if (a.attr("data-mce-bogus"))
                continue;
              if (t[a.name] || Px(a))
                return !1;
            }
            if (a.type === 8 || a.type === 3 && !pR(a) || a.type === 3 && a.parent && n[a.parent.name] && gc(a.value) || o && o(a))
              return !1;
          } while (a = h1(a, s));
        return !0;
      }
      walk(t) {
        return h1(this, null, t);
      }
    }
    const gR = (e, t) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(e.substr(t)), Bx = (e, t, n = 0) => {
      const o = e.toLowerCase();
      if (o.indexOf("[if ", n) !== -1 && gR(o, n)) {
        const s = o.indexOf("[endif]", n);
        return o.indexOf(">", s);
      } else if (t) {
        const s = o.indexOf(">", n);
        return s !== -1 ? s : o.length;
      } else {
        const s = /--!?>/g;
        s.lastIndex = n;
        const a = s.exec(e);
        return a ? a.index + a[0].length : o.length;
      }
    }, hR = (e, t, n) => {
      const o = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g, s = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g, a = e.getVoidElements();
      let i = 1, u = n;
      for (; i !== 0; )
        for (o.lastIndex = u; ; ) {
          const d = o.exec(t);
          if (d === null)
            return u;
          if (d[1] === "!") {
            un(d[2], "--") ? u = Bx(t, !1, d.index + 3) : u = Bx(t, !0, d.index + 1);
            break;
          } else {
            s.lastIndex = o.lastIndex;
            const y = s.exec(t);
            if (it(y) || y.index !== o.lastIndex)
              continue;
            d[1] === "/" ? i -= 1 : gn(a, d[2]) || (i += 1), u = o.lastIndex + y[0].length;
            break;
          }
        }
      return u;
    }, yR = (e, t) => {
      const n = new RegExp(["\\s?(" + e.join("|") + ')="[^"]+"'].join("|"), "gi");
      return t.replace(n, "");
    }, $x = (e, t) => {
      const n = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g, o = e.schema;
      let s = yR(e.getTempAttrs(), t);
      const a = o.getVoidElements();
      let i;
      for (; i = n.exec(s); ) {
        const u = n.lastIndex, d = i[0].length;
        let y;
        a[i[1]] ? y = u : y = hR(o, s, u), s = s.substring(0, u - d) + s.substring(y), n.lastIndex = u - d;
      }
      return E(s);
    }, bR = $x, kR = (e, t) => {
      const n = la(e), o = new RegExp(`^(<${n}[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/${n}>[\r
]*|<br \\/>[\r
]*)$`);
      return t.replace(o, "");
    }, wR = (e, t, n) => {
      let o;
      return t.format === "raw" ? o = nt.trim(bR(e.serializer, n.innerHTML)) : t.format === "text" ? (o = E(n.innerText), o = o === `
` ? "" : o) : t.format === "tree" ? o = e.serializer.serialize(n, t) : o = kR(e, e.serializer.serialize(n, t)), t.format !== "text" && !nu(ne.fromDom(n)) && ge(o) ? nt.trim(o) : o;
    }, _R = (e, t) => w.from(e.getBody()).fold(Z(t.format === "tree" ? new da("body", 11) : ""), (n) => wR(e, t, n)), vR = nt.each, Fx = (e) => ({ compare: (n, o) => {
      if (n.nodeName !== o.nodeName)
        return !1;
      const s = (i) => {
        const u = {};
        return vR(e.getAttribs(i), (d) => {
          const y = d.nodeName.toLowerCase();
          y.indexOf("_") !== 0 && y !== "style" && y.indexOf("data-") !== 0 && (u[y] = e.getAttrib(i, y));
        }), u;
      }, a = (i, u) => {
        let d, y;
        for (y in i)
          if (gn(i, y)) {
            if (d = u[y], typeof d > "u" || i[y] !== d)
              return !1;
            delete u[y];
          }
        for (y in u)
          if (gn(u, y))
            return !1;
        return !0;
      };
      return !a(s(n), s(o)) || !a(e.parseStyle(e.getAttrib(n, "style")), e.parseStyle(e.getAttrib(o, "style"))) ? !1 : !fa(n) && !fa(o);
    } }), Ix = nt.makeMap, Lx = (e) => {
      const t = [];
      e = e || {};
      const n = e.indent, o = Ix(e.indent_before || ""), s = Ix(e.indent_after || ""), a = zi.getEncodeFunc(e.entity_encoding || "raw", e.entities), i = e.element_format !== "xhtml";
      return {
        start: (u, d, y) => {
          let v, T, N, F;
          if (n && o[u] && t.length > 0 && (F = t[t.length - 1], F.length > 0 && F !== `
` && t.push(`
`)), t.push("<", u), d)
            for (v = 0, T = d.length; v < T; v++)
              N = d[v], t.push(" ", N.name, '="', a(N.value, !0), '"');
          !y || i ? t[t.length] = ">" : t[t.length] = " />", y && n && s[u] && t.length > 0 && (F = t[t.length - 1], F.length > 0 && F !== `
` && t.push(`
`));
        },
        end: (u) => {
          let d;
          t.push("</", u, ">"), n && s[u] && t.length > 0 && (d = t[t.length - 1], d.length > 0 && d !== `
` && t.push(`
`));
        },
        text: (u, d) => {
          u.length > 0 && (t[t.length] = d ? u : a(u));
        },
        cdata: (u) => {
          t.push("<![CDATA[", u, "]]>");
        },
        comment: (u) => {
          t.push("<!--", u, "-->");
        },
        pi: (u, d) => {
          d ? t.push("<?", u, " ", a(d), "?>") : t.push("<?", u, "?>"), n && t.push(`
`);
        },
        doctype: (u) => {
          t.push("<!DOCTYPE", u, ">", n ? `
` : "");
        },
        reset: () => {
          t.length = 0;
        },
        getContent: () => t.join("").replace(/\n$/, "")
      };
    }, qu = (e, t = Ai()) => {
      const n = Lx(e);
      return e = e || {}, e.validate = "validate" in e ? e.validate : !0, { serialize: (s) => {
        const a = e.validate, i = {
          3: (d) => {
            n.text(d.value, d.raw);
          },
          8: (d) => {
            n.comment(d.value);
          },
          7: (d) => {
            n.pi(d.name, d.value);
          },
          10: (d) => {
            n.doctype(d.value);
          },
          4: (d) => {
            n.cdata(d.value);
          },
          11: (d) => {
            if (d = d.firstChild)
              do
                u(d);
              while (d = d.next);
          }
        };
        n.reset();
        const u = (d) => {
          const y = i[d.type];
          if (y)
            y(d);
          else {
            const v = d.name, T = v in t.getVoidElements();
            let N = d.attributes;
            if (a && N && N.length > 1) {
              const F = [];
              F.map = {};
              const U = t.getElementRule(d.name);
              if (U) {
                for (let j = 0, H = U.attributesOrder.length; j < H; j++) {
                  const se = U.attributesOrder[j];
                  if (se in N.map) {
                    const ve = N.map[se];
                    F.map[se] = ve, F.push({
                      name: se,
                      value: ve
                    });
                  }
                }
                for (let j = 0, H = N.length; j < H; j++) {
                  const se = N[j].name;
                  if (!(se in F.map)) {
                    const ve = N.map[se];
                    F.map[se] = ve, F.push({
                      name: se,
                      value: ve
                    });
                  }
                }
                N = F;
              }
            }
            if (n.start(v, N, T), !T) {
              let F = d.firstChild;
              if (F) {
                (v === "pre" || v === "textarea") && F.type === 3 && F.value[0] === `
` && n.text(`
`, !0);
                do
                  u(F);
                while (F = F.next);
              }
              n.end(v);
            }
          }
        };
        return s.type === 1 && !e.inner ? u(s) : s.type === 3 ? i[3](s) : i[11](s), n.getContent();
      } };
    }, Mx = /* @__PURE__ */ new Set();
    M([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (t) => {
      Mx.add(t);
    });
    const jx = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], xv = (e, t) => ze(e.parseStyle(e.getAttrib(t, "style"))), CR = (e) => Mx.has(e), SR = (e, t) => ro(xv(e, t), (n) => !CR(n)), xR = (e) => Qe(e, (t) => Ce(jx, (n) => un(t, n))), ER = (e, t, n) => {
      const o = xv(e, t), s = xv(e, n), a = (i) => {
        var u, d;
        const y = (u = e.getStyle(t, i)) !== null && u !== void 0 ? u : "", v = (d = e.getStyle(n, i)) !== null && d !== void 0 ? d : "";
        return Bn(y) && Bn(v) && y !== v;
      };
      return Ce(o, (i) => {
        const u = (d) => Ce(d, (y) => y === i);
        if (!u(s) && u(jx)) {
          const d = xR(s);
          return Ce(d, a);
        } else
          return a(i);
      });
    }, Ux = (e, t, n) => w.from(n.container()).filter(Ft).exists((o) => {
      const s = e ? 0 : -1;
      return t(o.data.charAt(n.offset() + s));
    }), Ev = et(Ux, !0, zu), Tv = et(Ux, !1, zu), TR = (e) => {
      const t = e.container();
      return Ft(t) && (t.data.length === 0 || h(t.data) && Wf.isBookmarkNode(t.parentNode));
    }, Vu = (e, t) => (n) => w.from(yg(e ? 0 : -1, n)).filter(t).isSome(), Hx = (e) => Cd(e) && Hs(ne.fromDom(e), "display") === "block", Wx = (e) => ns(e) && !Ql(e), zR = Vu(!0, Hx), AR = Vu(!1, Hx), Jg = Vu(!0, dc), eh = Vu(!1, dc), qx = Vu(!0, La), Vx = Vu(!1, La), Gu = Vu(!0, Wx), Ku = Vu(!1, Wx), NR = (e) => e.slice(0, -1), RR = (e, t, n) => ws(t, e) ? NR(Gl(e, (o) => n(o) || _o(o, t))) : [], Gx = (e, t) => RR(e, t, cn), Bl = (e, t) => [e].concat(Gx(e, t)), zv = (e, t, n) => xu(e, t, n, TR), Kx = (e, t) => oo(Bl(ne.fromDom(t.container()), e), ia), Yx = (e, t, n) => zv(e, t.dom, n).forall((o) => Kx(t, n).fold(() => kc(o, n, t.dom) === !1, (s) => kc(o, n, t.dom) === !1 && ws(s, ne.fromDom(o.container())))), Xx = (e, t, n) => Kx(t, n).fold(() => zv(e, t.dom, n).forall((o) => kc(o, n, t.dom) === !1), (o) => zv(e, o.dom, n).isNone()), Av = et(Xx, !1), Zx = et(Xx, !0), DR = et(Yx, !1), OR = et(Yx, !0), PR = (e) => Lf(e).exists(Ei), y1 = (e, t, n) => {
      const o = Qe(Bl(ne.fromDom(n.container()), t), ia), s = Tn(o).getOr(t);
      return _a(e, s.dom, n).filter(PR);
    }, Nv = (e, t) => Lf(t).exists(Ei) || y1(!0, e, t).isSome(), Rv = (e, t) => q_(t).exists(Ei) || y1(!1, e, t).isSome(), BR = et(y1, !1), $R = et(y1, !0), Qx = (e) => je.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), Jx = (e, t) => {
      const n = Qe(Bl(ne.fromDom(t.container()), e), ia);
      return Tn(n).getOr(e);
    }, eE = (e, t) => Qx(t) ? Tv(t) : Tv(t) || ec(Jx(e, t).dom, t).exists(Tv), tE = (e, t) => Qx(t) ? Ev(t) : Ev(t) || va(Jx(e, t).dom, t).exists(Ev), FR = (e) => ce([
      "pre",
      "pre-wrap"
    ], e), Dv = (e) => Lf(e).bind((t) => Oc(t, qn)).exists((t) => FR(Hs(t, "white-space"))), IR = (e, t) => ec(e.dom, t).isNone(), LR = (e, t) => va(e.dom, t).isNone(), MR = (e, t) => IR(e, t) || LR(e, t) || Av(e, t) || Zx(e, t) || Rv(e, t) || Nv(e, t), jR = (e) => L(e) && ns(e) && ab(e), UR = (e) => (t) => jR(new hs(t, e).next()), HR = (e, t) => {
      const n = va(e.dom, t).getOr(t), o = UR(e.dom);
      return t.isAtEnd() && (o(t.container()) || o(n.container()));
    }, WR = (e, t) => Dv(t) ? !1 : MR(e, t) || eE(e, t) || tE(e, t), b1 = (e, t) => Dv(t) ? !1 : Av(e, t) || DR(e, t) || Rv(e, t) || eE(e, t), qR = (e) => {
      const t = e.container(), n = e.offset();
      return Ft(t) && n < t.data.length ? je(t, n + 1) : e;
    }, k1 = (e, t) => Dv(t) ? !1 : Zx(e, t) || OR(e, t) || Nv(e, t) || tE(e, t) || HR(e, t), nE = (e, t) => b1(e, t) || k1(e, qR(t)), oE = (e, t) => Nl(e.charAt(t)), VR = (e) => {
      const t = e.container();
      return Ft(t) && Lt(t.data, Ws);
    }, GR = (e) => {
      const t = e.split("");
      return W(t, (n, o) => Nl(n) && o > 0 && o < t.length - 1 && Sm(t[o - 1]) && Sm(t[o + 1]) ? " " : n).join("");
    }, KR = (e, t) => {
      const n = t.data, o = je(t, 0);
      return oE(n, 0) && !nE(e, o) ? (t.data = " " + n.slice(1), !0) : !1;
    }, YR = (e) => {
      const t = e.data, n = GR(t);
      return n !== t ? (e.data = n, !0) : !1;
    }, XR = (e, t) => {
      const n = t.data, o = je(t, n.length - 1);
      return oE(n, n.length - 1) && !nE(e, o) ? (t.data = n.slice(0, -1) + " ", !0) : !1;
    }, ZR = (e, t) => w.some(t).filter(VR).bind((n) => {
      const o = n.container();
      return KR(e, o) || YR(o) || XR(e, o) ? w.some(n) : w.none();
    }), QR = (e) => {
      const t = ne.fromDom(e.getBody());
      e.selection.isCollapsed() && ZR(t, je.fromRangeStart(e.selection.getRng())).each((n) => {
        e.selection.setRng(n.toRange());
      });
    }, sE = (e, t, n) => {
      if (n === 0)
        return;
      const o = ne.fromDom(e), s = Ci(o, ia).getOr(o), a = e.data.slice(t, t + n), i = t + n >= e.data.length && k1(s, je(e, e.data.length)), u = t === 0 && b1(s, je(e, 0));
      e.replaceData(t, n, Ph(a, 4, u, i));
    }, w1 = (e, t) => {
      const n = e.data.slice(t), o = n.length - sr(n).length;
      sE(e, t, o);
    }, Ov = (e, t) => {
      const n = e.data.slice(0, t), o = n.length - bs(n).length;
      sE(e, t - o, o);
    }, Pv = (e, t, n, o = !0) => {
      const s = bs(e.data).length, a = o ? e : t, i = o ? t : e;
      return o ? a.appendData(i.data) : a.insertData(0, i.data), Do(ne.fromDom(i)), n && w1(a, s), a;
    }, JR = (e, t) => {
      const n = e.container(), o = e.offset();
      return je.isTextPosition(e) === !1 && n === t.parentNode && o > je.before(t).offset();
    }, eD = (e, t) => JR(t, e) ? je(t.container(), t.offset() - 1) : t, tD = (e) => Ft(e) ? je(e, 0) : je.before(e), nD = (e) => Ft(e) ? je(e, e.data.length) : je.after(e), rE = (e) => $n(e.previousSibling) ? w.some(nD(e.previousSibling)) : e.previousSibling ? qa(e.previousSibling) : w.none(), aE = (e) => $n(e.nextSibling) ? w.some(tD(e.nextSibling)) : e.nextSibling ? _r(e.nextSibling) : w.none(), oD = (e, t) => {
      const n = je.before(t.previousSibling ? t.previousSibling : t.parentNode);
      return ec(e, n).fold(() => va(e, je.after(t)), w.some);
    }, sD = (e, t) => va(e, je.after(t)).fold(() => ec(e, je.before(t)), w.some), rD = (e, t) => rE(t).orThunk(() => aE(t)).orThunk(() => oD(e, t)), aD = (e, t) => aE(t).orThunk(() => rE(t)).orThunk(() => sD(e, t)), cD = (e, t, n) => e ? aD(t, n) : rD(t, n), iD = (e, t, n) => cD(e, t, n).map(et(eD, n)), cE = (e, t, n) => {
      n.fold(() => {
        e.focus();
      }, (o) => {
        e.selection.setRng(o.toRange(), t);
      });
    }, lD = (e) => (t) => t.dom === e, uD = (e, t) => t && gn(e.schema.getBlockElements(), tn(t)), fD = (e) => {
      if (Bs(e)) {
        const t = ne.fromHtml('<br data-mce-bogus="1">');
        return cl(e), ls(e, t), w.some(je.before(t.dom));
      } else
        return w.none();
    }, dD = (e, t, n) => {
      const o = Fa(e).filter(ko), s = di(e).filter(ko);
      return Do(e), zr(o, s, t, (a, i, u) => {
        const d = a.dom, y = i.dom, v = d.data.length;
        return Pv(d, y, n), u.container() === y ? je(d, v) : u;
      }).orThunk(() => (n && (o.each((a) => Ov(a.dom, a.dom.length)), s.each((a) => w1(a.dom, 0))), t));
    }, mD = (e, t) => gn(e.schema.getTextInlineElements(), tn(t)), Qf = (e, t, n, o = !0) => {
      const s = iD(t, e.getBody(), n.dom), a = Ci(n, et(uD, e), lD(e.getBody())), i = dD(n, s, mD(e, n));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : a.bind(fD).fold(() => {
        o && cE(e, t, i);
      }, (u) => {
        o && cE(e, t, w.some(u));
      });
    }, pD = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, gD = (e) => pD.test(e), Jf = (e, t) => sa(ne.fromDom(t), i_(e)), hD = (e) => Uo.DOM.getStyle(e, "direction", !0) === "rtl" || gD(e.textContent), yD = (e, t, n) => Qe(Uo.DOM.getParents(n.container(), "*", t), e), Yu = (e, t, n) => {
      const o = yD(e, t, n);
      return w.from(o[o.length - 1]);
    }, bD = (e, t, n) => {
      const o = Pi(t, e), s = Pi(n, e);
      return o && o === s;
    }, kD = (e) => ss(e) || uo(e), nc = (e, t) => {
      if (!t)
        return t;
      const n = t.container(), o = t.offset();
      return e ? mt(n) ? Ft(n.nextSibling) ? je(n.nextSibling, 0) : je.after(n) : ss(t) ? je(n, o + 1) : t : mt(n) ? Ft(n.previousSibling) ? je(n.previousSibling, n.previousSibling.data.length) : je.before(n) : uo(t) ? je(n, o - 1) : t;
    }, iE = et(nc, !0), lE = et(nc, !1), uE = (e, t) => {
      const n = (o) => o.stopImmediatePropagation();
      e.on("beforeinput input", n, !0), e.getDoc().execCommand(t), e.off("beforeinput input", n);
    }, Bv = (e) => uE(e, "Delete"), wD = (e) => uE(e, "ForwardDelete"), _D = (e) => (t) => _o(e, ne.fromDom(t.dom.parentNode)), vD = (e) => pf(e) || dl(e), _1 = (e, t) => ws(e, t) ? Oc(t, vD, _D(e)) : w.none(), $v = (e, t = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !t });
    }, CD = (e, t, n) => zo(_r(n), qa(n), (o, s) => {
      const a = nc(!0, o), i = nc(!1, s), u = nc(!1, t);
      return e ? va(n, u).exists((d) => d.isEqual(i) && t.isEqual(a)) : ec(n, u).exists((d) => d.isEqual(a) && t.isEqual(i));
    }).getOr(!0), fE = (e) => (Zs(e) ? Fa(e) : pi(e)).bind(fE).orThunk(() => w.some(e)), dE = (e, t, n, o = !0) => {
      var s;
      t.deleteContents();
      const a = fE(n).getOr(n), i = ne.fromDom((s = e.dom.getParent(a.dom, e.dom.isBlock)) !== null && s !== void 0 ? s : n.dom);
      if (i.dom === e.getBody() ? $v(e, o) : Bs(i) && ($c(i), o && e.selection.setCursorLocation(i.dom, 0)), !_o(n, i)) {
        const u = Xo(er(i), n) ? [] : el(i);
        M(u.concat(fs(n)), (d) => {
          !_o(d, i) && !ws(d, i) && Bs(d) && Do(d);
        });
      }
    }, SD = (e) => (t) => _o(e, t), Fv = (e) => br(e, "td,th"), xD = (e, t) => {
      const n = (y) => Hf(ne.fromDom(y), t), o = n(e.startContainer), s = n(e.endContainer), a = o.isSome(), i = s.isSome(), u = zo(o, s, _o).getOr(!1);
      return {
        startTable: o,
        endTable: s,
        isStartInTable: a,
        isEndInTable: i,
        isSameTable: u,
        isMultiTable: !u && a && i
      };
    }, Iv = (e, t) => ({
      start: e,
      end: t
    }), ED = (e, t, n) => ({
      rng: e,
      table: t,
      cells: n
    }), th = bc.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), v1 = (e, t) => Ma(ne.fromDom(e), "td,th", t), mE = (e) => !_o(e.start, e.end), pE = (e, t) => Hf(e.start, t).bind((n) => Hf(e.end, t).bind((o) => gs(_o(n, o), n))), TD = (e, t) => !mE(e) && pE(e, t).exists((n) => {
      const o = n.dom.rows;
      return o.length === 1 && o[0].cells.length === 1;
    }), zD = (e, t) => {
      const n = v1(e.startContainer, t), o = v1(e.endContainer, t);
      return zo(n, o, Iv);
    }, AD = (e) => (t) => Hf(t, e).bind((n) => Pn(Fv(n)).map((o) => Iv(t, o))), ND = (e) => (t) => Hf(t, e).bind((n) => Tn(Fv(n)).map((o) => Iv(o, t))), Lv = (e) => (t) => pE(t, e).map((n) => ED(t, n, Fv(n))), gE = (e, t, n, o) => {
      if (n.collapsed || !e.forall(mE))
        return w.none();
      if (t.isSameTable) {
        const s = e.bind(Lv(o));
        return w.some({
          start: s,
          end: s
        });
      } else {
        const s = v1(n.startContainer, o), a = v1(n.endContainer, o), i = s.bind(AD(o)).bind(Lv(o)), u = a.bind(ND(o)).bind(Lv(o));
        return w.some({
          start: i,
          end: u
        });
      }
    }, hE = (e, t) => Yn(e, (n) => _o(n, t)), Mv = (e) => zo(hE(e.cells, e.rng.start), hE(e.cells, e.rng.end), (t, n) => e.cells.slice(t, n + 1)), RD = (e, t, n) => e.exists((o) => TD(o, n) && Pu(o.start, t)), yE = (e, t) => {
      const { startTable: n, endTable: o } = t, s = e.cloneRange();
      return n.each((a) => s.setStartAfter(a.dom)), o.each((a) => s.setEndBefore(a.dom)), s;
    }, DD = (e, t, n, o) => gE(e, t, n, o).bind(({ start: s, end: a }) => s.or(a)).bind((s) => {
      const { isSameTable: a } = t, i = Mv(s).getOr([]);
      if (a && s.cells.length === i.length)
        return w.some(th.fullTable(s.table));
      if (i.length > 0) {
        if (a)
          return w.some(th.partialTable(i, w.none()));
        {
          const u = yE(n, t);
          return w.some(th.partialTable(i, w.some({
            ...t,
            rng: u
          })));
        }
      } else
        return w.none();
    }), OD = (e, t, n, o) => gE(e, t, n, o).bind(({ start: s, end: a }) => {
      const i = s.bind(Mv).getOr([]), u = a.bind(Mv).getOr([]);
      if (i.length > 0 && u.length > 0) {
        const d = yE(n, t);
        return w.some(th.multiTable(i, u, d));
      } else
        return w.none();
    }), PD = (e, t) => {
      const n = SD(e), o = zD(t, n), s = xD(t, n);
      return RD(o, t, n) ? o.map((a) => th.singleCellTable(t, a.start)) : s.isMultiTable ? OD(o, s, t, n) : DD(o, s, t, n);
    }, bE = (e) => M(e, (t) => {
      as(t, "contenteditable"), $c(t);
    }), BD = (e, t) => w.from(e.dom.getParent(t, e.dom.isBlock)).map(ne.fromDom), $D = (e, t, n) => {
      n.each((o) => {
        t ? Do(o) : ($c(o), e.selection.setCursorLocation(o.dom, 0));
      });
    }, jv = (e, t, n, o) => {
      const s = n.cloneRange();
      o ? (s.setStart(n.startContainer, n.startOffset), s.setEndAfter(t.dom.lastChild)) : (s.setStartBefore(t.dom.firstChild), s.setEnd(n.endContainer, n.endOffset)), Uv(e, s, t, !1).each((a) => a());
    }, kE = (e) => {
      const t = Ol(e), n = ne.fromDom(e.selection.getNode());
      fl(n.dom) && Bs(n) ? e.selection.setCursorLocation(n.dom, 0) : e.selection.collapse(!0), t.length > 1 && Ce(t, (o) => _o(o, n)) && ao(n, "data-mce-selected", "1");
    }, wE = (e, t, n) => w.some(() => {
      const o = e.selection.getRng(), s = n.bind(({ rng: a, isStartInTable: i }) => {
        const u = BD(e, i ? a.endContainer : a.startContainer);
        a.deleteContents(), $D(e, i, u.filter(Bs));
        const d = i ? t[0] : t[t.length - 1];
        return jv(e, d, o, i), Bs(d) ? w.none() : w.some(i ? t.slice(1) : t.slice(0, -1));
      }).getOr(t);
      bE(s), kE(e);
    }), FD = (e, t, n, o) => w.some(() => {
      const s = e.selection.getRng(), a = t[0], i = n[n.length - 1];
      jv(e, a, s, !0), jv(e, i, s, !1);
      const u = Bs(a) ? t : t.slice(1), d = Bs(i) ? n : n.slice(0, -1);
      bE(u.concat(d)), o.deleteContents(), kE(e);
    }), Uv = (e, t, n, o = !0) => w.some(() => {
      dE(e, t, n, o);
    }), ID = (e, t) => w.some(() => Qf(e, !1, t)), LD = (e, t, n) => PD(t, n).bind((o) => o.fold(et(Uv, e), et(ID, e), et(wE, e), et(FD, e))), MD = (e, t) => C1(e, t), jD = (e, t, n, o) => Hv(t, o).fold(() => LD(e, t, n), (s) => MD(e, s)), UD = (e, t, n) => {
      const o = ne.fromDom(e.getBody()), s = e.selection.getRng();
      return n.length !== 0 ? wE(e, n, w.none()) : jD(e, o, s, t);
    }, _E = (e, t) => oo(Bl(t, e), tu), Hv = (e, t) => oo(Bl(t, e), Ya("caption")), HD = (e, t, n, o, s) => wm(n, e.getBody(), s).bind((a) => _E(t, ne.fromDom(a.getNode())).bind((i) => _o(i, o) ? w.none() : w.some(ye))), C1 = (e, t) => w.some(() => {
      $c(t), e.selection.setCursorLocation(t.dom, 0);
    }), WD = (e, t, n, o) => _r(e.dom).bind((s) => qa(e.dom).map((a) => t ? n.isEqual(s) && o.isEqual(a) : n.isEqual(a) && o.isEqual(s))).getOr(!0), qD = (e, t) => C1(e, t), VD = (e, t, n) => Hv(e, ne.fromDom(n.getNode())).fold(() => w.some(ye), (o) => gs(!_o(o, t), ye)), GD = (e, t, n, o, s) => wm(n, e.getBody(), s).fold(() => w.some(ye), (a) => WD(o, n, s, a) ? qD(e, o) : VD(t, o, a)), KD = (e, t, n, o) => {
      const s = je.fromRangeStart(e.selection.getRng());
      return _E(n, o).bind((a) => Bs(a) ? C1(e, a) : HD(e, n, t, a, s));
    }, YD = (e, t, n, o) => {
      const s = je.fromRangeStart(e.selection.getRng());
      return Bs(o) ? C1(e, o) : GD(e, n, t, o, s);
    }, vE = (e, t) => e ? qx(t) : Vx(t), XD = (e, t) => {
      const n = je.fromRangeStart(e.selection.getRng());
      return vE(t, n) || _a(t, e.getBody(), n).exists((o) => vE(t, o));
    }, ZD = (e, t, n) => {
      const o = ne.fromDom(e.getBody());
      return Hv(o, n).fold(() => KD(e, t, o, n).orThunk(() => gs(XD(e, t), ye)), (s) => YD(e, t, o, s));
    }, Wv = (e, t) => {
      const n = ne.fromDom(e.selection.getStart(!0)), o = Ol(e);
      return e.selection.isCollapsed() && o.length === 0 ? ZD(e, t, n) : UD(e, n, o);
    }, Jm = (e, t) => {
      for (; t && t !== e; ) {
        if (ca(t) || ns(t))
          return t;
        t = t.parentNode;
      }
      return null;
    }, qv = (e, t) => {
      t(e), e.firstChild && qv(e.firstChild, t), e.next && qv(e.next, t);
    }, CE = (e, t, n, o) => {
      const s = n.name;
      for (let a = 0, i = e.length; a < i; a++) {
        const u = e[a];
        if (u.name === s) {
          const d = o.nodes[s];
          d ? d.nodes.push(n) : o.nodes[s] = {
            filter: u,
            nodes: [n]
          };
        }
      }
      if (n.attributes)
        for (let a = 0, i = t.length; a < i; a++) {
          const u = t[a], d = u.name;
          if (d in n.attributes.map) {
            const y = o.attributes[d];
            y ? y.nodes.push(n) : o.attributes[d] = {
              filter: u,
              nodes: [n]
            };
          }
        }
    }, QD = (e, t, n) => {
      const o = {
        nodes: {},
        attributes: {}
      };
      return n.firstChild && qv(n.firstChild, (s) => {
        CE(e, t, s, o);
      }), o;
    }, SE = (e, t) => {
      const n = (o) => {
        Ot(o, (s) => {
          const a = Qe(s.nodes, (i) => L(i.parent));
          M(s.filter.callbacks, (i) => {
            i(a, s.filter.name, t);
          });
        });
      };
      n(e.nodes), n(e.attributes);
    }, xE = (e, t, n, o = {}) => {
      const s = QD(e, t, n);
      SE(s, o);
    }, Vv = (e, t, n, o) => {
      t.insert && n[o.name] ? o.empty().append(new da("br", 1)) : o.empty().append(new da("#text", 3)).value = Ws;
    }, JD = (e) => EE(e, "#text") && e.firstChild.value === Ws, EE = (e, t) => e && e.firstChild && e.firstChild === e.lastChild && e.firstChild.name === t, e5 = (e, t) => {
      const n = e.getElementRule(t.name);
      return n && n.paddEmpty;
    }, nh = (e, t, n, o) => o.isEmpty(t, n, (s) => e5(e, s)), t5 = (e, t) => e && (e.name in t || e.name === "br"), Gv = (e, t, n = e.parent) => {
      if (t.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const o = e.children();
        for (const s of o)
          t.isValidChild(n.name, s.name) || Gv(s, t, n);
        e.unwrap();
      }
    }, Kv = (e, t, n = ye) => {
      const o = t.getTextBlockElements(), s = t.getNonEmptyElements(), a = t.getWhitespaceElements(), i = nt.makeMap("tr,td,th,tbody,thead,tfoot,table"), u = /* @__PURE__ */ new Set();
      for (let d = 0; d < e.length; d++) {
        const y = e[d];
        let v, T, N;
        if (!y.parent || u.has(y))
          continue;
        if (o[y.name] && y.parent.name === "li") {
          let U = y.next;
          for (; U && o[U.name]; ) {
            U.name = "li", u.add(U), y.parent.insert(U, y.parent);
            U = U.next;
          }
          y.unwrap();
          continue;
        }
        const F = [y];
        for (v = y.parent; v && !t.isValidChild(v.name, y.name) && !i[v.name]; v = v.parent)
          F.push(v);
        if (v && F.length > 1)
          if (t.isValidChild(v.name, y.name)) {
            F.reverse(), T = F[0].clone(), n(T);
            let U = T;
            for (let j = 0; j < F.length - 1; j++) {
              t.isValidChild(U.name, F[j].name) ? (N = F[j].clone(), n(N), U.append(N)) : N = U;
              for (let H = F[j].firstChild; H && H !== F[j + 1]; ) {
                const se = H.next;
                N.append(H), H = se;
              }
              U = N;
            }
            nh(t, s, a, T) ? v.insert(y, F[0], !0) : (v.insert(T, F[0], !0), v.insert(y, T)), v = F[0], (nh(t, s, a, v) || EE(v, "br")) && v.empty().remove();
          } else
            Gv(y, t);
        else if (y.parent) {
          if (y.name === "li") {
            let U = y.prev;
            if (U && (U.name === "ul" || U.name === "ol")) {
              U.append(y);
              continue;
            }
            if (U = y.next, U && (U.name === "ul" || U.name === "ol")) {
              U.insert(y, U.firstChild, !0);
              continue;
            }
            const j = new da("ul", 1);
            n(j), y.wrap(j);
            continue;
          }
          if (t.isValidChild(y.parent.name, "div") && t.isValidChild("div", y.name)) {
            const U = new da("div", 1);
            n(U), y.wrap(U);
          } else
            Gv(y, t);
        }
      }
    }, n5 = (e, t, n, o) => {
      const s = document.createRange();
      return s.setStart(e, t), s.setEnd(n, o), s;
    }, o5 = (e) => {
      const t = je.fromRangeStart(e), n = je.fromRangeEnd(e), o = e.commonAncestorContainer;
      return _a(!1, o, n).map((s) => !kc(t, n, o) && kc(t, s, o) ? n5(t.container(), t.offset(), s.container(), s.offset()) : e).getOr(e);
    }, Yv = (e) => e.collapsed ? e : o5(e), s5 = (e) => e.firstChild && e.firstChild === e.lastChild, r5 = (e) => e.name === "br" || e.value === Ws, a5 = (e, t) => e.getBlockElements()[t.name] && s5(t) && r5(t.firstChild), c5 = (e, t) => {
      const n = e.getNonEmptyElements();
      return t && (t.isEmpty(n) || a5(e, t));
    }, i5 = (e, t) => {
      let n = t.firstChild, o = t.lastChild;
      return n && n.name === "meta" && (n = n.next), o && o.attr("id") === "mce_marker" && (o = o.prev), c5(e, o) && (o = o.prev), !n || n !== o ? !1 : n.name === "ul" || n.name === "ol";
    }, l5 = (e) => {
      const t = e.firstChild, n = e.lastChild;
      return t && t.nodeName === "META" && t.parentNode.removeChild(t), n && n.id === "mce_marker" && n.parentNode.removeChild(n), e;
    }, u5 = (e, t, n) => {
      const o = t.serialize(n), s = e.createFragment(o);
      return l5(s);
    }, f5 = (e) => Qe(e.childNodes, (t) => t.nodeName === "LI"), d5 = (e) => e.data === Ws || ds(e), m5 = (e) => e && e.firstChild && e.firstChild === e.lastChild && d5(e.firstChild), p5 = (e) => !e.firstChild || m5(e), g5 = (e) => e.length > 0 && p5(e[e.length - 1]) ? e.slice(0, -1) : e, Xv = (e, t) => {
      const n = e.getParent(t, e.isBlock);
      return n && n.nodeName === "LI" ? n : null;
    }, h5 = (e, t) => !!Xv(e, t), y5 = (e, t) => {
      const n = t.cloneRange(), o = t.cloneRange();
      return n.setStartBefore(e), o.setEndAfter(e), [
        n.cloneContents(),
        o.cloneContents()
      ];
    }, b5 = (e, t) => {
      const n = je.before(e), s = jr(t).next(n);
      return s ? s.toRange() : null;
    }, TE = (e, t) => {
      const n = je.after(e), s = jr(t).prev(n);
      return s ? s.toRange() : null;
    }, k5 = (e, t, n, o) => {
      const s = y5(e, o), a = e.parentNode;
      return a.insertBefore(s[0], e), nt.each(t, (i) => {
        a.insertBefore(i, e);
      }), a.insertBefore(s[1], e), a.removeChild(e), TE(t[t.length - 1], n);
    }, w5 = (e, t, n) => {
      const o = e.parentNode;
      return nt.each(t, (s) => {
        o.insertBefore(s, e);
      }), b5(e, n);
    }, _5 = (e, t, n, o) => (o.insertAfter(t.reverse(), e), TE(t[0], n)), v5 = (e, t, n, o) => {
      const s = u5(t, e, o), a = Xv(t, n.startContainer), i = g5(f5(s.firstChild)), u = 1, d = 2, y = t.getRoot(), v = (T) => {
        const N = je.fromRangeStart(n), F = jr(t.getRoot()), U = T === u ? F.prev(N) : F.next(N);
        return U ? Xv(t, U.getNode()) !== a : !0;
      };
      return v(u) ? w5(a, i, y) : v(d) ? _5(a, i, y, t) : k5(a, i, y, n);
    }, C5 = ["pre"], S5 = (e, t, n, o) => {
      var s;
      const a = t.firstChild, i = t.lastChild, u = i.attr("data-mce-type") === "bookmark" ? i.prev : i, d = a === u, y = ce(C5, a.name);
      if (d && y) {
        const v = a.attr("contenteditable") !== "false", T = ((s = e.getParent(n, e.isBlock)) === null || s === void 0 ? void 0 : s.nodeName.toLowerCase()) === a.name, N = w.from(Jm(o, n)).forall(ca);
        return v && T && N;
      } else
        return !1;
    }, Zv = fl, x5 = (e, t, n) => {
      if (n !== null) {
        const o = e.getParent(t.endContainer, Zv);
        return n === o && Pu(ne.fromDom(n), t);
      } else
        return !1;
    }, E5 = (e, t, n) => {
      if (n.getAttribute("data-mce-bogus") === "all")
        n.parentNode.insertBefore(e.dom.createFragment(t), n);
      else {
        const o = n.firstChild, s = n.lastChild;
        !o || o === s && o.nodeName === "BR" ? e.dom.setHTML(n, t) : e.selection.setContent(t, { no_events: !0 });
      }
    }, T5 = (e, t) => {
      w.from(e.getParent(t, "td,th")).map(ne.fromDom).each(Ap);
    }, z5 = (e, t) => {
      const n = e.schema.getTextInlineElements(), o = e.dom;
      if (t) {
        const s = e.getBody(), a = Fx(o);
        nt.each(o.select("*[data-mce-fragment]"), (i) => {
          if (L(n[i.nodeName.toLowerCase()]) && SR(o, i)) {
            for (let d = i.parentNode; L(d) && d !== s && !ER(o, i, d); d = d.parentNode)
              if (a.compare(d, i)) {
                o.remove(i, !0);
                break;
              }
          }
        });
      }
    }, A5 = (e) => {
      let t = e;
      for (; t = t.walk(); )
        t.type === 1 && t.attr("data-mce-fragment", "1");
    }, N5 = (e) => {
      nt.each(e.getElementsByTagName("*"), (t) => {
        t.removeAttribute("data-mce-fragment");
      });
    }, R5 = (e) => !!e.getAttribute("data-mce-fragment"), D5 = (e, t) => t && !e.schema.getVoidElements()[t.nodeName], O5 = (e, t) => {
      let n;
      const o = e.dom, s = e.selection;
      if (!t)
        return;
      s.scrollIntoView(t);
      const a = Jm(e.getBody(), t);
      if (o.getContentEditable(a) === "false") {
        o.remove(t), s.select(a);
        return;
      }
      let i = o.createRng();
      const u = t.previousSibling;
      if (Ft(u)) {
        i.setStart(u, u.nodeValue.length);
        const v = t.nextSibling;
        Ft(v) && (u.appendData(v.data), v.parentNode.removeChild(v));
      } else
        i.setStartBefore(t), i.setEndBefore(t);
      const d = (v) => {
        let T = je.fromRangeStart(v);
        if (T = jr(e.getBody()).next(T), T)
          return T.toRange();
      }, y = o.getParent(t, o.isBlock);
      o.remove(t), y && o.isEmpty(y) && (cl(ne.fromDom(y)), i.setStart(y, 0), i.setEnd(y, 0), !Zv(y) && !R5(y) && (n = d(i)) ? (i = n, o.remove(y)) : o.add(y, o.create("br", { "data-mce-bogus": "1" }))), s.setRng(i);
    }, P5 = (e) => {
      const t = e.dom, n = Yv(e.selection.getRng());
      e.selection.setRng(n);
      const o = t.getParent(n.startContainer, Zv);
      x5(t, n, o) ? Uv(e, n, ne.fromDom(o)) : e.getDoc().execCommand("Delete", !1, null);
    }, B5 = (e, t, n) => {
      var o;
      let s, a, i;
      const u = e.selection, d = e.dom, y = e.parser, v = n.merge, T = qu({ validate: !0 }, e.schema), N = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      t.indexOf("{$caret}") === -1 && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, N), a = u.getRng();
      const F = a.startContainer || (a.parentElement ? a.parentElement() : null), U = e.getBody();
      F === U && u.isCollapsed() && d.isBlock(U.firstChild) && D5(e, U.firstChild) && d.isEmpty(U.firstChild) && (a = d.createRng(), a.setStart(U.firstChild, 0), a.setEnd(U.firstChild, 0), u.setRng(a)), u.isCollapsed() || P5(e), s = u.getNode();
      const j = {
        context: s.nodeName.toLowerCase(),
        data: n.data,
        insert: !0
      }, H = y.parse(t, j);
      if (n.paste === !0 && i5(e.schema, H) && h5(d, s))
        return a = v5(T, d, u.getRng(), H), u.setRng(a), t;
      if (n.paste === !0 && S5(d, H, s, e.getBody()) && ((o = H.firstChild) === null || o === void 0 || o.unwrap()), A5(H), i = H.lastChild, i.attr("id") === "mce_marker") {
        const se = i;
        for (i = i.prev; i; i = i.walk(!0))
          if (i.type === 3 || !d.isBlock(i.name)) {
            e.schema.isValidChild(i.parent.name, "span") && i.parent.insert(se, i, i.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(s), !j.invalid)
        t = T.serialize(H), E5(e, t, s);
      else {
        e.selection.setContent(N), s = u.getNode();
        const se = e.getBody();
        for (s.nodeType === 9 ? s = i = se : i = s; i !== se; )
          s = i, i = i.parentNode;
        t = s === se ? se.innerHTML : d.getOuterHTML(s);
        const ve = y.parse(t);
        for (let Vt = ve; Vt; Vt = Vt.walk())
          if (Vt.attr("id") === "mce_marker") {
            Vt.replace(H);
            break;
          }
        const Se = H.children(), Be = H.parent.name;
        H.unwrap();
        const at = Qe(Se, (Vt) => !e.schema.isValidChild(Be, Vt.name));
        Kv(at, e.schema), xE(y.getNodeFilters(), y.getAttributeFilters(), ve), t = T.serialize(ve), s === se ? d.setHTML(se, t) : d.setOuterHTML(s, t);
      }
      return z5(e, v), O5(e, d.get("mce_marker")), N5(e.getBody()), T5(d, u.getStart()), t;
    }, S1 = (e) => e instanceof da, $5 = (e) => {
      Yo(e) && _r(e.getBody()).each((t) => {
        const n = t.getNode(), o = La(n) ? _r(n).getOr(t) : t;
        e.selection.setRng(o.toRange());
      });
    }, Qv = (e, t, n) => {
      e.dom.setHTML(e.getBody(), t), n !== !0 && $5(e);
    }, F5 = (e, t, n, o) => {
      if (n.length === 0 || /^\s+$/.test(n)) {
        const s = '<br data-mce-bogus="1">';
        t.nodeName === "TABLE" ? n = "<tr><td>" + s + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (n = "<li>" + s + "</li>");
        const a = la(e);
        return e.schema.isValidChild(t.nodeName.toLowerCase(), a.toLowerCase()) ? (n = s, n = e.dom.createHTML(a, Df(e), n)) : n || (n = s), Qv(e, n, o.no_selection), {
          content: n,
          html: n
        };
      } else {
        o.format !== "raw" && (n = qu({ validate: !1 }, e.schema).serialize(e.parser.parse(n, {
          isRootContent: !0,
          insert: !0
        })));
        const s = nu(ne.fromDom(t)) ? n : nt.trim(n);
        return Qv(e, s, o.no_selection), {
          content: s,
          html: s
        };
      }
    }, I5 = (e, t, n, o) => {
      xE(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), n);
      const s = qu({ validate: !1 }, e.schema).serialize(n), a = nu(ne.fromDom(t)) ? s : nt.trim(s);
      return Qv(e, a, o.no_selection), {
        content: n,
        html: a
      };
    }, L5 = (e, t, n) => w.from(e.getBody()).map((o) => S1(t) ? I5(e, o, t, n) : F5(e, o, t, n)).getOr({
      content: t,
      html: S1(n.content) ? "" : n.content
    }), M5 = (e, t) => _p(e, t).isSome(), zE = (e) => Wt(e) ? e : cn, j5 = (e, t, n) => {
      let o = e.dom;
      const s = zE(n);
      for (; o.parentNode; ) {
        o = o.parentNode;
        const a = ne.fromDom(o), i = t(a);
        if (i.isSome())
          return i;
        if (s(a))
          break;
      }
      return w.none();
    }, Jv = (e, t, n) => {
      const o = t(e), s = zE(n);
      return o.orThunk(() => s(e) ? w.none() : j5(e, t, s));
    }, eC = zg, AE = (e, t, n) => {
      const o = e.formatter.get(n);
      if (o)
        for (let s = 0; s < o.length; s++) {
          const a = o[s];
          if (Ur(a) && a.inherit === !1 && e.dom.is(t, a.selector))
            return !0;
        }
      return !1;
    }, tC = (e, t, n, o, s) => {
      const a = e.dom.getRoot();
      return t === a ? !1 : (t = e.dom.getParent(t, (i) => AE(e, i, n) ? !0 : i.parentNode === a || !!Ii(e, i, n, o, !0)), !!Ii(e, t, n, o, s));
    }, x1 = (e, t, n) => Fs(n) && eC(t, n.inline) || Ca(n) && eC(t, n.block) ? !0 : Ur(n) ? dn(t) && e.is(t, n.selector) : !1, NE = (e, t, n, o, s, a) => {
      const i = n[o];
      if (Wt(n.onmatch))
        return n.onmatch(t, n, o);
      if (i) {
        if (Le(i.length)) {
          for (const u in i)
            if (gn(i, u)) {
              const d = o === "attributes" ? e.getAttrib(t, u) : Rl(e, t, u), y = Kc(i[u], a), v = Ve(d) || to(d);
              if (v && Ve(y))
                continue;
              if (s && v && !n.exact || (!s || n.exact) && !eC(d, Nu(y, u)))
                return !1;
            }
        } else
          for (let u = 0; u < i.length; u++)
            if (o === "attributes" ? e.getAttrib(t, i[u]) : Rl(e, t, i[u]))
              return !0;
      }
      return !0;
    }, Ii = (e, t, n, o, s) => {
      const a = e.formatter.get(n), i = e.dom;
      if (a && t)
        for (let u = 0; u < a.length; u++) {
          const d = a[u];
          if (x1(e.dom, t, d) && NE(i, t, d, "attributes", s, o) && NE(i, t, d, "styles", s, o)) {
            const y = d.classes;
            if (y) {
              for (let v = 0; v < y.length; v++)
                if (!e.dom.hasClass(t, Kc(y[v], o)))
                  return;
            }
            return d;
          }
        }
    }, nC = (e, t, n, o, s) => {
      if (o)
        return tC(e, o, t, n, s);
      if (o = e.selection.getNode(), tC(e, o, t, n, s))
        return !0;
      const a = e.selection.getStart();
      return !!(a !== o && tC(e, a, t, n, s));
    }, U5 = (e, t, n) => {
      const o = [], s = {}, a = e.selection.getStart();
      return e.dom.getParent(a, (i) => {
        for (let u = 0; u < t.length; u++) {
          const d = t[u];
          !s[d] && Ii(e, i, d, n) && (s[d] = !0, o.push(d));
        }
      }, e.dom.getRoot()), o;
    }, H5 = (e, t) => {
      const n = (s) => _o(s, ne.fromDom(e.getBody())), o = (s, a) => Ii(e, s.dom, a) ? w.some(a) : w.none();
      return w.from(e.selection.getStart(!0)).bind((s) => Jv(ne.fromDom(s), (a) => Bo(t, (i) => o(a, i)), n)).getOrNull();
    }, W5 = (e, t) => {
      const n = e.formatter.get(t), o = e.dom;
      if (n) {
        const s = e.selection.getStart(), a = zm(o, s);
        for (let i = n.length - 1; i >= 0; i--) {
          const u = n[i];
          if (!Ur(u))
            return !0;
          for (let d = a.length - 1; d >= 0; d--)
            if (o.is(a[d], u.selector))
              return !0;
        }
      }
      return !1;
    }, q5 = (e, t, n) => En(n, (o, s) => {
      const a = l0(e, s);
      return e.formatter.matchNode(t, s, {}, a) ? o.concat([s]) : o;
    }, []), ep = m, RE = "_mce_caret", V5 = (e, t) => e.importNode(t, !0), G5 = (e) => {
      const t = [];
      for (; e; ) {
        if (e.nodeType === 3 && e.nodeValue !== ep || e.childNodes.length > 1)
          return [];
        e.nodeType === 1 && t.push(e), e = e.firstChild;
      }
      return t;
    }, DE = (e) => G5(e).length > 0, OE = (e) => {
      if (e) {
        const t = new hs(e, e);
        for (e = t.current(); e; e = t.next())
          if (Ft(e))
            return e;
      }
      return null;
    }, oC = (e) => {
      const t = ne.fromTag("span");
      return es(t, {
        id: RE,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && ls(t, ne.fromText(ep)), t;
    }, K5 = (e) => {
      const t = OE(e);
      return t && t.nodeValue.charAt(0) === ep && t.deleteData(0, 1), t;
    }, sC = (e, t, n = !0) => {
      const o = e.dom, s = e.selection;
      if (DE(t))
        Qf(e, !1, ne.fromDom(t), n);
      else {
        const a = s.getRng(), i = o.getParent(t, o.isBlock), u = a.startContainer, d = a.startOffset, y = a.endContainer, v = a.endOffset, T = K5(t);
        o.remove(t, !0), u === T && d > 0 && a.setStart(T, d - 1), y === T && v > 0 && a.setEnd(T, v - 1), i && o.isEmpty(i) && $c(ne.fromDom(i)), s.setRng(a);
      }
    }, rC = (e, t, n = !0) => {
      const o = e.dom, s = e.selection;
      if (t)
        sC(e, t, n);
      else if (t = Eu(e.getBody(), s.getStart()), !t)
        for (; t = o.get(RE); )
          sC(e, t, !1);
    }, Y5 = (e, t, n) => {
      const o = e.dom, s = o.getParent(n, et(Uf, e));
      s && o.isEmpty(s) ? n.parentNode.replaceChild(t, n) : (Dh(ne.fromDom(n)), o.isEmpty(n) ? n.parentNode.replaceChild(t, n) : o.insertAfter(t, n));
    }, PE = (e, t) => (e.appendChild(t), t), BE = (e, t) => {
      const n = pn(e, (o, s) => PE(o, s.cloneNode(!1)), t);
      return PE(n, n.ownerDocument.createTextNode(ep));
    }, X5 = (e, t, n, o, s, a) => {
      const i = e.formatter, u = e.dom, d = Qe(ze(i.get()), (T) => T !== o && !Lt(T, "removeformat")), y = q5(e, n, d);
      if (Qe(y, (T) => !u0(e, T, o)).length > 0) {
        const T = n.cloneNode(!1);
        return u.add(t, T), i.remove(o, s, T, a), u.remove(T), w.some(T);
      } else
        return w.none();
    }, Z5 = (e, t, n) => {
      let o, s;
      const a = e.selection, i = a.getRng();
      let u = i.startOffset;
      const y = i.startContainer.nodeValue;
      o = Eu(e.getBody(), a.getStart()), o && (s = OE(o));
      const v = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (y && u > 0 && u < y.length && v.test(y.charAt(u)) && v.test(y.charAt(u - 1))) {
        const T = a.getBookmark();
        i.collapse(!0);
        let N = Ou(e, i, e.formatter.get(t));
        N = Km(N), e.formatter.apply(t, n, N), a.moveToBookmark(T);
      } else
        (!o || s.nodeValue !== ep) && (o = V5(e.getDoc(), oC(!0).dom), s = o.firstChild, i.insertNode(o), u = 1), e.formatter.apply(t, n, o), a.setCursorLocation(s, u);
    }, Q5 = (e, t, n, o) => {
      const s = e.dom, a = e.selection;
      let i, u, d;
      const y = [], v = a.getRng(), T = v.startContainer, N = v.startOffset;
      for (u = T, T.nodeType === 3 && (N !== T.nodeValue.length && (i = !0), u = u.parentNode); u; ) {
        if (Ii(e, u, t, n, o)) {
          d = u;
          break;
        }
        u.nextSibling && (i = !0), y.push(u), u = u.parentNode;
      }
      if (!!d)
        if (i) {
          const F = a.getBookmark();
          v.collapse(!0);
          let U = Ou(e, v, e.formatter.get(t), !0);
          U = Km(U), e.formatter.remove(t, n, U, o), a.moveToBookmark(F);
        } else {
          const F = Eu(e.getBody(), d), U = oC(!1).dom;
          Y5(e, U, F !== null ? F : d);
          const j = X5(e, U, d, t, n, o), H = BE(y.concat(j.toArray()), U);
          sC(e, F, !1), a.setCursorLocation(H, 1), s.isEmpty(d) && s.remove(d);
        }
    }, J5 = (e, t) => {
      const n = e.selection, o = e.getBody();
      rC(e, null, !1), (t === 8 || t === 46) && n.isCollapsed() && n.getStart().innerHTML === ep && rC(e, Eu(o, n.getStart())), (t === 37 || t === 39) && rC(e, Eu(o, n.getStart()));
    }, e3 = (e) => {
      e.on("mouseup keydown", (t) => {
        J5(e, t.keyCode);
      });
    }, t3 = (e, t) => {
      const n = oC(!1), o = BE(t, n.dom);
      return yr(ne.fromDom(e), n), Do(ne.fromDom(e)), je(o, 0);
    }, n3 = (e, t) => {
      const n = e.schema.getTextInlineElements();
      return gn(n, tn(t)) && !ua(t.dom) && !Rc(t.dom);
    }, o3 = (e) => ua(e.dom) && DE(e.dom), E1 = {}, $E = Ys, FE = cs, s3 = (e, t) => {
      E1[e] || (E1[e] = []), E1[e].push(t);
    }, r3 = (e, t) => {
      FE(E1[e], (n) => {
        n(t);
      });
    };
    s3("pre", (e) => {
      const t = e.selection.getRng();
      let n;
      const o = (i) => a(i.previousSibling) && O(n, i.previousSibling) !== -1, s = (i, u) => {
        const d = ne.fromDom(u), y = wa(d).dom;
        Do(d), lc(ne.fromDom(i), [
          ne.fromTag("br", y),
          ne.fromTag("br", y),
          ...fs(d)
        ]);
      }, a = aa(["pre"]);
      t.collapsed || (n = e.selection.getSelectedBlocks(), FE($E($E(n, a), o), (i) => {
        s(i.previousSibling, i);
      }));
    });
    const aC = nt.each, cC = (e) => dn(e) && !fa(e) && !ua(e) && !Rc(e), IE = (e, t) => {
      for (let n = e; n; n = n[t]) {
        if (Ft(n) && Bn(n.data))
          return e;
        if (dn(n) && !fa(n))
          return n;
      }
      return e;
    }, LE = (e, t, n) => {
      const o = Fx(e);
      if (t && n && (t = IE(t, "previousSibling"), n = IE(n, "nextSibling"), o.compare(t, n))) {
        for (let s = t.nextSibling; s && s !== n; ) {
          const a = s;
          s = s.nextSibling, t.appendChild(a);
        }
        return e.remove(n), nt.each(nt.grep(n.childNodes), (s) => {
          t.appendChild(s);
        }), t;
      }
      return n;
    }, ME = (e, t, n, o) => {
      if (o && t.merge_siblings !== !1) {
        const s = LE(e, Tm(o), o);
        LE(e, s, Tm(s, !0));
      }
    }, a3 = (e, t, n) => {
      if (t.clear_child_styles) {
        const o = t.links ? "*:not(a)" : "*";
        aC(e.select(o, n), (s) => {
          cC(s) && aC(t.styles, (a, i) => {
            e.setStyle(s, i, "");
          });
        });
      }
    }, iC = (e, t, n) => {
      aC(e.childNodes, (o) => {
        cC(o) && (t(o) && n(o), o.hasChildNodes() && iC(o, t, n));
      });
    }, c3 = (e, t) => {
      t.nodeName === "SPAN" && e.getAttribs(t).length === 0 && e.remove(t, !0);
    }, jE = (e, t) => (n) => !!(n && Rl(e, n, t)), UE = (e, t, n) => (o) => {
      e.setStyle(o, t, n), o.getAttribute("style") === "" && o.removeAttribute("style"), c3(e, o);
    }, oh = bc.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), i3 = /^(src|href|style)$/, lC = nt.each, T1 = zg, l3 = (e) => /^(TR|TH|TD)$/.test(e.nodeName), HE = (e, t, n) => e.isChildOf(t, n) && t !== n && !e.isBlock(n), WE = (e, t, n) => {
      let o = t[n ? "startContainer" : "endContainer"], s = t[n ? "startOffset" : "endOffset"];
      if (dn(o)) {
        const a = o.childNodes.length - 1;
        !n && s && s--, o = o.childNodes[s > a ? a : s];
      }
      return Ft(o) && n && s >= o.nodeValue.length && (o = new hs(o, e.getBody()).next() || o), Ft(o) && !n && s === 0 && (o = new hs(o, e.getBody()).prev() || o), o;
    }, qE = (e, t) => {
      const n = t ? "firstChild" : "lastChild";
      if (l3(e) && e[n]) {
        const o = e[n];
        return e.nodeName === "TR" && o[n] || o;
      }
      return e;
    }, uC = (e, t, n, o) => {
      const s = e.create(n, o);
      return t.parentNode.insertBefore(s, t), s.appendChild(t), s;
    }, VE = (e, t, n, o, s) => {
      const a = ne.fromDom(t), i = ne.fromDom(e.create(o, s)), u = n ? tl(a) : mi(a);
      return lc(i, u), n ? (yr(a, i), yd(i, a)) : (ra(a, i), ls(i, a)), i.dom;
    }, u3 = (e, t) => t.links && e.nodeName === "A", f3 = (e, t, n) => {
      const o = t.parentNode;
      let s;
      const a = e.dom, i = la(e);
      Ca(n) && o === a.getRoot() && (!n.list_block || !T1(t, n.list_block)) && M(ho(t.childNodes), (u) => {
        Au(e, i, u.nodeName.toLowerCase()) ? s ? s.appendChild(u) : (s = uC(a, u, i), a.setAttribs(s, Df(e))) : s = null;
      }), !(Tb(n) && !T1(n.inline, t)) && a.remove(t, !0);
    }, GE = (e, t, n, o, s) => {
      let a;
      const i = e.dom;
      if (!x1(i, o, t) && !u3(o, t))
        return oh.keep();
      const u = o;
      if (Fs(t) && t.remove === "all" && le(t.preserve_attributes)) {
        const d = Qe(i.getAttribs(u), (y) => ce(t.preserve_attributes, y.name.toLowerCase()));
        if (i.removeAllAttribs(u), M(d, (y) => i.setAttrib(u, y.name, y.value)), d.length > 0)
          return oh.rename("span");
      }
      if (t.remove !== "all") {
        lC(t.styles, (y, v) => {
          y = Nu(Kc(y, n), v + ""), Je(v) && (v = y, s = null), (t.remove_similar || !s || T1(Rl(i, s, v), y)) && i.setStyle(u, v, ""), a = !0;
        }), a && i.getAttrib(u, "style") === "" && (u.removeAttribute("style"), u.removeAttribute("data-mce-style")), lC(t.attributes, (y, v) => {
          let T;
          if (y = Kc(y, n), Je(v) && (v = y, s = null), t.remove_similar || !s || T1(i.getAttrib(s, v), y)) {
            if (v === "class" && (y = i.getAttrib(u, v), y && (T = "", M(y.split(/\s+/), (N) => {
              /mce\-\w+/.test(N) && (T += (T ? " " : "") + N);
            }), T))) {
              i.setAttrib(u, v, T);
              return;
            }
            if (i3.test(v) && u.removeAttribute("data-mce-" + v), v === "style" && aa(["li"])(u) && i.getStyle(u, "list-style-type") === "none") {
              u.removeAttribute(v), i.setStyle(u, "list-style-type", "none");
              return;
            }
            v === "class" && u.removeAttribute("className"), u.removeAttribute(v);
          }
        }), lC(t.classes, (y) => {
          y = Kc(y, n), (!s || i.hasClass(s, y)) && i.removeClass(u, y);
        });
        const d = i.getAttribs(u);
        for (let y = 0; y < d.length; y++) {
          const v = d[y].nodeName;
          if (v.indexOf("_") !== 0 && v.indexOf("data-") !== 0)
            return oh.keep();
        }
      }
      return t.remove !== "none" ? (f3(e, u, t), oh.removed()) : oh.keep();
    }, tp = (e, t, n, o, s) => GE(e, t, n, o, s).fold(cn, (a) => (e.dom.rename(o, a), !0), wn), d3 = (e, t, n, o, s) => {
      let a;
      return M(zm(e.dom, t.parentNode).reverse(), (i) => {
        if (!a && i.id !== "_start" && i.id !== "_end") {
          const u = Ii(e, i, n, o, s);
          u && u.split !== !1 && (a = i);
        }
      }), a;
    }, m3 = (e, t, n, o) => GE(e, t, n, o, o).fold(Z(o), (s) => (e.dom.createFragment().appendChild(o), e.dom.rename(o, s)), Z(null)), p3 = (e, t, n, o, s, a, i, u) => {
      let d, y, v;
      const T = e.dom;
      if (n) {
        const N = n.parentNode;
        for (let F = o.parentNode; F && F !== N; F = F.parentNode) {
          d = T.clone(F, !1);
          for (let U = 0; U < t.length && (d = m3(e, t[U], u, d), d !== null); U++)
            ;
          d && (y && d.appendChild(y), v || (v = d), y = d);
        }
        a && (!i.mixed || !T.isBlock(n)) && (o = T.split(n, o)), y && (s.parentNode.insertBefore(y, s), v.appendChild(s), Fs(i) && ME(T, i, u, y));
      }
      return o;
    }, KE = (e, t, n, o, s) => {
      const a = e.formatter.get(t), i = a[0];
      let u = !0;
      const d = e.dom, y = e.selection, v = (H) => {
        const se = d3(e, H, t, n, s);
        return p3(e, a, se, H, H, !0, i, n);
      }, T = (H) => fa(H) && dn(H) && (H.id === "_start" || H.id === "_end"), N = (H) => Ce(a, (se) => tp(e, se, n, H, H)), F = (H) => {
        let se = !0, ve = !1;
        dn(H) && d.getContentEditable(H) && (se = u, u = d.getContentEditable(H) === "true", ve = !0);
        const Se = ho(H.childNodes);
        if (u && !ve) {
          const Vt = N(H) || Ce(a, (gt) => x1(d, H, gt)), lt = H.parentNode;
          !Vt && L(lt) && Yc(i) && N(lt);
        }
        if (i.deep && Se.length) {
          for (let at = 0; at < Se.length; at++)
            F(Se[at]);
          ve && (u = se);
        }
        M([
          "underline",
          "line-through",
          "overline"
        ], (at) => {
          dn(H) && e.dom.getStyle(H, "text-decoration") === at && H.parentNode && Ag(d, H.parentNode) === at && tp(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: at }
          }, null, H);
        });
      }, U = (H) => {
        const se = d.get(H ? "_start" : "_end");
        let ve = se[H ? "firstChild" : "lastChild"];
        return T(ve) && (ve = ve[H ? "firstChild" : "lastChild"]), Ft(ve) && ve.data.length === 0 && (ve = H ? se.previousSibling || se.nextSibling : se.nextSibling || se.previousSibling), d.remove(se, !0), ve;
      }, j = (H) => {
        let se, ve, Se = Ou(e, H, a, H.collapsed);
        if (i.split) {
          if (Se = Km(Se), se = WE(e, Se, !0), ve = WE(e, Se), se !== ve) {
            if (se = qE(se, !0), ve = qE(ve, !1), HE(d, se, ve)) {
              const at = w.from(se.firstChild).getOr(se);
              v(VE(d, at, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), U(!0);
              return;
            }
            if (HE(d, ve, se)) {
              const at = w.from(ve.lastChild).getOr(ve);
              v(VE(d, at, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), U(!1);
              return;
            }
            se = uC(d, se, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), ve = uC(d, ve, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const Be = d.createRng();
            Be.setStartAfter(se), Be.setEndBefore(ve), Dl(d, Be, (at) => {
              M(at, (Vt) => {
                !fa(Vt) && !fa(Vt.parentNode) && v(Vt);
              });
            }), v(se), v(ve), se = U(!0), ve = U();
          } else
            se = ve = v(se);
          Se.startContainer = se.parentNode ? se.parentNode : se, Se.startOffset = d.nodeIndex(se), Se.endContainer = ve.parentNode ? ve.parentNode : ve, Se.endOffset = d.nodeIndex(ve) + 1;
        }
        Dl(d, Se, (Be) => {
          M(Be, F);
        });
      };
      if (o) {
        if (Em(o)) {
          const H = d.createRng();
          H.setStartBefore(o), H.setEndAfter(o), j(H);
        } else
          j(o);
        Pg(e, t, o, n);
        return;
      }
      if (d.getContentEditable(y.getNode()) === "false") {
        o = y.getNode();
        for (let H = 0; H < a.length && !(a[H].ceFalseOverride && tp(e, a[H], n, o, o)); H++)
          ;
        Pg(e, t, o, n);
        return;
      }
      !y.isCollapsed() || !Fs(i) || Ol(e).length ? (Bm(y, !0, () => {
        Pm(e, j);
      }), Fs(i) && nC(e, t, n, y.getStart()) && Eb(d, y, y.getRng()), e.nodeChanged()) : Q5(e, t, n, s), Pg(e, t, o, n);
    }, YE = nt.each, g3 = (e, t, n, o) => {
      const s = (a) => {
        if (a.nodeType === 1 && a.parentNode && a.parentNode.nodeType === 1) {
          const i = Ag(e, a.parentNode);
          e.getStyle(a, "color") && i ? e.setStyle(a, "text-decoration", i) : e.getStyle(a, "text-decoration") === i && e.setStyle(a, "text-decoration", null);
        }
      };
      t.styles && (t.styles.color || t.styles.textDecoration) && (nt.walk(o, s, "childNodes"), s(o));
    }, h3 = (e, t, n, o) => {
      t.styles && t.styles.backgroundColor && iC(o, jE(e, "fontSize"), UE(e, "backgroundColor", Kc(t.styles.backgroundColor, n)));
    }, y3 = (e, t, n, o) => {
      Fs(t) && (t.inline === "sub" || t.inline === "sup") && (iC(o, jE(e, "fontSize"), UE(e, "fontSize", "")), e.remove(e.select(t.inline === "sup" ? "sub" : "sup", o), !0));
    }, b3 = (e, t, n, o) => {
      YE(t, (s) => {
        Fs(s) && YE(e.dom.select(s.inline, o), (a) => {
          !cC(a) || tp(e, s, n, a, s.exact ? a : null);
        }), a3(e.dom, s, o);
      });
    }, k3 = (e, t, n, o, s) => {
      Ii(e, s.parentNode, n, o) && tp(e, t, o, s) || t.merge_with_parents && e.dom.getParent(s.parentNode, (a) => {
        if (Ii(e, a, n, o))
          return tp(e, t, o, s), !0;
      });
    }, z1 = nt.each, w3 = (e) => dn(e) && !fa(e) && !ua(e) && !Rc(e), _3 = (e, t, n, o) => {
      if (h_(e) && Fs(t)) {
        const s = Lh(e.schema), a = M5(ne.fromDom(n), (i) => ua(i.dom));
        return qo(s, o) && Bs(ne.fromDom(n.parentNode), !1) && !a;
      } else
        return !1;
    }, XE = (e, t, n, o) => {
      const s = e.formatter.get(t), a = s[0], i = !o && e.selection.isCollapsed(), u = e.dom, d = e.selection, y = (F, U = a) => {
        if (Wt(U.onformat) && U.onformat(F, U, n, o), z1(U.styles, (j, H) => {
          u.setStyle(F, H, Kc(j, n));
        }), U.styles) {
          const j = u.getAttrib(F, "style");
          j && u.setAttrib(F, "data-mce-style", j);
        }
        z1(U.attributes, (j, H) => {
          u.setAttrib(F, H, Kc(j, n));
        }), z1(U.classes, (j) => {
          j = Kc(j, n), u.hasClass(F, j) || u.addClass(F, j);
        });
      }, v = (F, U) => {
        let j = !1;
        return z1(F, (H) => {
          if (!Ur(H))
            return !1;
          if (!(L(H.collapsed) && H.collapsed !== i) && u.is(U, H.selector) && !ua(U))
            return y(U, H), j = !0, !1;
        }), j;
      }, T = (F) => {
        if (ge(F)) {
          const U = u.create(F);
          return y(U), U;
        } else
          return null;
      }, N = (F, U, j) => {
        const H = [];
        let se = !0;
        const ve = a.inline || a.block, Se = T(ve);
        Dl(F, U, (Be) => {
          let at;
          const Vt = (lt) => {
            let gt = !1, Dt = se;
            const Pt = lt.nodeName.toLowerCase(), bn = lt.parentNode, nn = bn.nodeName.toLowerCase();
            if (dn(lt) && F.getContentEditable(lt) && (Dt = se, se = F.getContentEditable(lt) === "true", gt = !0), ds(lt) && !_3(e, a, lt, nn)) {
              at = null, Ca(a) && F.remove(lt);
              return;
            }
            if (Ca(a) && a.wrapper && Ii(e, lt, t, n)) {
              at = null;
              return;
            }
            if (se && !gt && Ca(a) && !a.wrapper && Uf(e, Pt) && Au(e, nn, ve)) {
              const Ht = F.rename(lt, ve);
              y(Ht), H.push(Ht), at = null;
              return;
            }
            if (Ur(a)) {
              let Ht = v(s, lt);
              if (!Ht && L(bn) && Yc(a) && (Ht = v(s, bn)), !Fs(a) || Ht) {
                at = null;
                return;
              }
            }
            se && !gt && Au(e, ve, Pt) && Au(e, nn, ve) && !(!j && Ft(lt) && h(lt.data)) && !ua(lt) && (!Fs(a) || !F.isBlock(lt)) ? (at || (at = F.clone(Se, !1), lt.parentNode.insertBefore(at, lt), H.push(at)), at.appendChild(lt)) : (at = null, M(ho(lt.childNodes), Vt), gt && (se = Dt), at = null);
          };
          M(Be, Vt);
        }), a.links === !0 && M(H, (Be) => {
          const at = (Vt) => {
            Vt.nodeName === "A" && y(Vt, a), M(ho(Vt.childNodes), at);
          };
          at(Be);
        }), M(H, (Be) => {
          const at = (gt) => {
            let Dt = 0;
            return M(gt.childNodes, (Pt) => {
              !i0(Pt) && !fa(Pt) && Dt++;
            }), Dt;
          }, Vt = (gt) => oo(gt.childNodes, w3).filter((Pt) => x1(F, Pt, a)).map((Pt) => {
            const bn = F.clone(Pt, !1);
            return y(bn), F.replace(bn, gt, !0), F.remove(Pt, !0), bn;
          }).getOr(gt), lt = at(Be);
          if ((H.length > 1 || !F.isBlock(Be)) && lt === 0) {
            F.remove(Be, !0);
            return;
          }
          (Fs(a) || Ca(a) && a.wrapper) && (!a.exact && lt === 1 && (Be = Vt(Be)), b3(e, s, n, Be), k3(e, a, t, n, Be), h3(F, a, n, Be), g3(F, a, n, Be), y3(F, a, n, Be), ME(F, a, n, Be));
        });
      };
      if (u.getContentEditable(d.getNode()) === "false") {
        o = d.getNode();
        for (let F = 0, U = s.length; F < U; F++) {
          const j = s[F];
          if (j.ceFalseOverride && Ur(j) && u.is(o, j.selector)) {
            y(o, j);
            break;
          }
        }
        jb(e, t, o, n);
        return;
      }
      if (a) {
        if (o)
          if (Em(o)) {
            if (!v(s, o)) {
              const F = u.createRng();
              F.setStartBefore(o), F.setEndAfter(o), N(u, Ou(e, F, s), !0);
            }
          } else
            N(u, o, !0);
        else
          !i || !Fs(a) || Ol(e).length ? (d.setRng(Yv(d.getRng())), Bm(d, !0, () => {
            Pm(e, (F, U) => {
              const j = U ? F : Ou(e, F, s);
              N(u, j, !1);
            });
          }), Eb(u, d, d.getRng()), e.nodeChanged()) : Z5(e, t, n);
        r3(t, e);
      }
      jb(e, t, o, n);
    }, ZE = (e) => gn(e, "vars"), v3 = (e, t) => {
      e.set({}), t.on("NodeChange", (n) => {
        tT(t, n.element, e.get());
      }), t.on("FormatApply FormatRemove", (n) => {
        const o = w.from(n.node).map((s) => Em(s) ? s : s.startContainer).bind((s) => dn(s) ? w.some(s) : w.from(s.parentElement)).getOrThunk(() => QE(t));
        tT(t, o, e.get());
      });
    }, QE = (e) => e.selection.getStart(), JE = (e, t, n, o, s) => Eo(t, (u) => {
      const d = e.formatter.matchNode(u, n, s != null ? s : {}, o);
      return !Le(d);
    }, (u) => AE(e, u, n) ? !0 : o ? !1 : L(e.formatter.matchNode(u, n, s, !0))), eT = (e, t) => {
      const n = t != null ? t : QE(e);
      return Qe(zm(e.dom, n), (o) => dn(o) && !Rc(o));
    }, tT = (e, t, n) => {
      const o = eT(e, t);
      Ot(n, (s, a) => {
        const i = (u) => {
          const d = JE(e, o, a, u.similar, ZE(u) ? u.vars : void 0), y = d.isSome();
          if (u.state.get() !== y) {
            u.state.set(y);
            const v = d.getOr(t);
            ZE(u) ? u.callback(y, {
              node: v,
              format: a,
              parents: o
            }) : M(u.callbacks, (T) => T(y, {
              node: v,
              format: a,
              parents: o
            }));
          }
        };
        M([
          s.withSimilar,
          s.withoutSimilar
        ], i), M(s.withVars, i);
      });
    }, C3 = (e, t, n, o, s, a) => {
      const i = t.get();
      M(n.split(","), (u) => {
        const d = Vn(i, u).getOrThunk(() => {
          const v = {
            withSimilar: {
              state: vs(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: vs(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return i[u] = v, v;
        }), y = () => {
          const v = eT(e);
          return JE(e, v, u, s, a).isSome();
        };
        if (Le(a)) {
          const v = s ? d.withSimilar : d.withoutSimilar;
          v.callbacks.push(o), v.callbacks.length === 1 && v.state.set(y());
        } else
          d.withVars.push({
            state: vs(y()),
            similar: s,
            vars: a,
            callback: o
          });
      }), t.set(i);
    }, S3 = (e, t, n) => {
      const o = e.get();
      M(t.split(","), (s) => Vn(o, s).each((a) => {
        o[s] = {
          withSimilar: {
            ...a.withSimilar,
            callbacks: Qe(a.withSimilar.callbacks, (i) => i !== n)
          },
          withoutSimilar: {
            ...a.withoutSimilar,
            callbacks: Qe(a.withoutSimilar.callbacks, (i) => i !== n)
          },
          withVars: Qe(a.withVars, (i) => i.callback !== n)
        };
      })), e.set(o);
    }, x3 = (e, t, n, o, s, a) => (t.get() === null && v3(t, e), C3(e, t, n, o, s, a), { unbind: () => S3(t, n, o) }), E3 = (e, t, n, o) => {
      const s = e.formatter.get(t);
      nC(e, t, n, o) && (!("toggle" in s[0]) || s[0].toggle) ? KE(e, t, n, o) : XE(e, t, n, o);
    };
    function ed(e) {
      return ed = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t;
      } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, ed(e);
    }
    function fC(e, t) {
      return fC = Object.setPrototypeOf || function(o, s) {
        return o.__proto__ = s, o;
      }, fC(e, t);
    }
    function T3() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function A1(e, t, n) {
      return T3() ? A1 = Reflect.construct : A1 = function(s, a, i) {
        var u = [null];
        u.push.apply(u, a);
        var d = Function.bind.apply(s, u), y = new d();
        return i && fC(y, i.prototype), y;
      }, A1.apply(null, arguments);
    }
    function Qc(e) {
      return z3(e) || A3(e) || N3(e) || R3();
    }
    function z3(e) {
      if (Array.isArray(e))
        return dC(e);
    }
    function A3(e) {
      if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
        return Array.from(e);
    }
    function N3(e, t) {
      if (!!e) {
        if (typeof e == "string")
          return dC(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
          return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return dC(e, t);
      }
    }
    function dC(e, t) {
      (t == null || t > e.length) && (t = e.length);
      for (var n = 0, o = new Array(t); n < t; n++)
        o[n] = e[n];
      return o;
    }
    function R3() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var D3 = Object.hasOwnProperty, nT = Object.setPrototypeOf, O3 = Object.isFrozen, P3 = Object.getPrototypeOf, B3 = Object.getOwnPropertyDescriptor, Ta = Object.freeze, Li = Object.seal, $3 = Object.create, oT = typeof Reflect < "u" && Reflect, N1 = oT.apply, mC = oT.construct;
    N1 || (N1 = function(t, n, o) {
      return t.apply(n, o);
    }), Ta || (Ta = function(t) {
      return t;
    }), Li || (Li = function(t) {
      return t;
    }), mC || (mC = function(t, n) {
      return A1(t, Qc(n));
    });
    var F3 = Jc(Array.prototype.forEach), I3 = Jc(Array.prototype.pop), sh = Jc(Array.prototype.push), R1 = Jc(String.prototype.toLowerCase), L3 = Jc(String.prototype.match), Xu = Jc(String.prototype.replace), M3 = Jc(String.prototype.indexOf), j3 = Jc(String.prototype.trim), za = Jc(RegExp.prototype.test), pC = U3(TypeError);
    function Jc(e) {
      return function(t) {
        for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
          o[s - 1] = arguments[s];
        return N1(e, t, o);
      };
    }
    function U3(e) {
      return function() {
        for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++)
          n[o] = arguments[o];
        return mC(e, n);
      };
    }
    function $o(e, t) {
      nT && nT(e, null);
      for (var n = t.length; n--; ) {
        var o = t[n];
        if (typeof o == "string") {
          var s = R1(o);
          s !== o && (O3(t) || (t[n] = s), o = s);
        }
        e[o] = !0;
      }
      return e;
    }
    function td(e) {
      var t = $3(null), n;
      for (n in e)
        N1(D3, e, [n]) && (t[n] = e[n]);
      return t;
    }
    function D1(e, t) {
      for (; e !== null; ) {
        var n = B3(e, t);
        if (n) {
          if (n.get)
            return Jc(n.get);
          if (typeof n.value == "function")
            return Jc(n.value);
        }
        e = P3(e);
      }
      function o(s) {
        return console.warn("fallback value for", s), null;
      }
      return o;
    }
    var sT = Ta([
      "a",
      "abbr",
      "acronym",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "decorator",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "element",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meter",
      "nav",
      "nobr",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "select",
      "shadow",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]), gC = Ta([
      "svg",
      "a",
      "altglyph",
      "altglyphdef",
      "altglyphitem",
      "animatecolor",
      "animatemotion",
      "animatetransform",
      "circle",
      "clippath",
      "defs",
      "desc",
      "ellipse",
      "filter",
      "font",
      "g",
      "glyph",
      "glyphref",
      "hkern",
      "image",
      "line",
      "lineargradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialgradient",
      "rect",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textpath",
      "title",
      "tref",
      "tspan",
      "view",
      "vkern"
    ]), hC = Ta([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence"
    ]), H3 = Ta([
      "animate",
      "color-profile",
      "cursor",
      "discard",
      "fedropshadow",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignobject",
      "hatch",
      "hatchpath",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "missing-glyph",
      "script",
      "set",
      "solidcolor",
      "unknown",
      "use"
    ]), yC = Ta([
      "math",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mglyph",
      "mi",
      "mlabeledtr",
      "mmultiscripts",
      "mn",
      "mo",
      "mover",
      "mpadded",
      "mphantom",
      "mroot",
      "mrow",
      "ms",
      "mspace",
      "msqrt",
      "mstyle",
      "msub",
      "msup",
      "msubsup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover"
    ]), W3 = Ta([
      "maction",
      "maligngroup",
      "malignmark",
      "mlongdiv",
      "mscarries",
      "mscarry",
      "msgroup",
      "mstack",
      "msline",
      "msrow",
      "semantics",
      "annotation",
      "annotation-xml",
      "mprescripts",
      "none"
    ]), rT = Ta(["#text"]), aT = Ta([
      "accept",
      "action",
      "align",
      "alt",
      "autocapitalize",
      "autocomplete",
      "autopictureinpicture",
      "autoplay",
      "background",
      "bgcolor",
      "border",
      "capture",
      "cellpadding",
      "cellspacing",
      "checked",
      "cite",
      "class",
      "clear",
      "color",
      "cols",
      "colspan",
      "controls",
      "controlslist",
      "coords",
      "crossorigin",
      "datetime",
      "decoding",
      "default",
      "dir",
      "disabled",
      "disablepictureinpicture",
      "disableremoteplayback",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "face",
      "for",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "id",
      "inputmode",
      "integrity",
      "ismap",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "loop",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "multiple",
      "muted",
      "name",
      "nonce",
      "noshade",
      "novalidate",
      "nowrap",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "playsinline",
      "poster",
      "preload",
      "pubdate",
      "radiogroup",
      "readonly",
      "rel",
      "required",
      "rev",
      "reversed",
      "role",
      "rows",
      "rowspan",
      "spellcheck",
      "scope",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "srclang",
      "start",
      "src",
      "srcset",
      "step",
      "style",
      "summary",
      "tabindex",
      "title",
      "translate",
      "type",
      "usemap",
      "valign",
      "value",
      "width",
      "xmlns",
      "slot"
    ]), bC = Ta([
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "ascent",
      "attributename",
      "attributetype",
      "azimuth",
      "basefrequency",
      "baseline-shift",
      "begin",
      "bias",
      "by",
      "class",
      "clip",
      "clippathunits",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "diffuseconstant",
      "direction",
      "display",
      "divisor",
      "dur",
      "edgemode",
      "elevation",
      "end",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterunits",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyphref",
      "gradientunits",
      "gradienttransform",
      "height",
      "href",
      "id",
      "image-rendering",
      "in",
      "in2",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "keypoints",
      "keysplines",
      "keytimes",
      "lang",
      "lengthadjust",
      "letter-spacing",
      "kernelmatrix",
      "kernelunitlength",
      "lighting-color",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerheight",
      "markerunits",
      "markerwidth",
      "maskcontentunits",
      "maskunits",
      "max",
      "mask",
      "media",
      "method",
      "mode",
      "min",
      "name",
      "numoctaves",
      "offset",
      "operator",
      "opacity",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "paint-order",
      "path",
      "pathlength",
      "patterncontentunits",
      "patterntransform",
      "patternunits",
      "points",
      "preservealpha",
      "preserveaspectratio",
      "primitiveunits",
      "r",
      "rx",
      "ry",
      "radius",
      "refx",
      "refy",
      "repeatcount",
      "repeatdur",
      "restart",
      "result",
      "rotate",
      "scale",
      "seed",
      "shape-rendering",
      "specularconstant",
      "specularexponent",
      "spreadmethod",
      "startoffset",
      "stddeviation",
      "stitchtiles",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke",
      "stroke-width",
      "style",
      "surfacescale",
      "systemlanguage",
      "tabindex",
      "targetx",
      "targety",
      "transform",
      "transform-origin",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textlength",
      "type",
      "u1",
      "u2",
      "unicode",
      "values",
      "viewbox",
      "visibility",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "width",
      "word-spacing",
      "wrap",
      "writing-mode",
      "xchannelselector",
      "ychannelselector",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      "zoomandpan"
    ]), cT = Ta([
      "accent",
      "accentunder",
      "align",
      "bevelled",
      "close",
      "columnsalign",
      "columnlines",
      "columnspan",
      "denomalign",
      "depth",
      "dir",
      "display",
      "displaystyle",
      "encoding",
      "fence",
      "frame",
      "height",
      "href",
      "id",
      "largeop",
      "length",
      "linethickness",
      "lspace",
      "lquote",
      "mathbackground",
      "mathcolor",
      "mathsize",
      "mathvariant",
      "maxsize",
      "minsize",
      "movablelimits",
      "notation",
      "numalign",
      "open",
      "rowalign",
      "rowlines",
      "rowspacing",
      "rowspan",
      "rspace",
      "rquote",
      "scriptlevel",
      "scriptminsize",
      "scriptsizemultiplier",
      "selection",
      "separator",
      "separators",
      "stretchy",
      "subscriptshift",
      "supscriptshift",
      "symmetric",
      "voffset",
      "width",
      "xmlns"
    ]), O1 = Ta([
      "xlink:href",
      "xml:id",
      "xlink:title",
      "xml:space",
      "xmlns:xlink"
    ]), q3 = Li(/\{\{[\w\W]*|[\w\W]*\}\}/gm), V3 = Li(/<%[\w\W]*|[\w\W]*%>/gm), G3 = Li(/^data-[\-\w.\u00B7-\uFFFF]/), K3 = Li(/^aria-[\-\w]+$/), Y3 = Li(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), X3 = Li(/^(?:\w+script|data):/i), Z3 = Li(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), Q3 = Li(/^html$/i), J3 = function() {
      return typeof window > "u" ? null : window;
    }, eO = function(t, n) {
      if (ed(t) !== "object" || typeof t.createPolicy != "function")
        return null;
      var o = null, s = "data-tt-policy-suffix";
      n.currentScript && n.currentScript.hasAttribute(s) && (o = n.currentScript.getAttribute(s));
      var a = "dompurify" + (o ? "#" + o : "");
      try {
        return t.createPolicy(a, {
          createHTML: function(u) {
            return u;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + a + " could not be created."), null;
      }
    };
    function iT() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : J3(), t = function(Oe) {
        return iT(Oe);
      };
      if (t.version = "2.3.8", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
        return t.isSupported = !1, t;
      var n = e.document, o = e.document, s = e.DocumentFragment, a = e.HTMLTemplateElement, i = e.Node, u = e.Element, d = e.NodeFilter, y = e.NamedNodeMap, v = y === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : y, T = e.HTMLFormElement, N = e.DOMParser, F = e.trustedTypes, U = u.prototype, j = D1(U, "cloneNode"), H = D1(U, "nextSibling"), se = D1(U, "childNodes"), ve = D1(U, "parentNode");
      if (typeof a == "function") {
        var Se = o.createElement("template");
        Se.content && Se.content.ownerDocument && (o = Se.content.ownerDocument);
      }
      var Be = eO(F, n), at = Be ? Be.createHTML("") : "", Vt = o, lt = Vt.implementation, gt = Vt.createNodeIterator, Dt = Vt.createDocumentFragment, Pt = Vt.getElementsByTagName, bn = n.importNode, nn = {};
      try {
        nn = td(o).documentMode ? o.documentMode : {};
      } catch {
      }
      var Ht = {};
      t.isSupported = typeof ve == "function" && lt && typeof lt.createHTMLDocument < "u" && nn !== 9;
      var fo = q3, Co = V3, Fo = G3, Ls = K3, Nt = X3, fn = Z3, no = Y3, Qn = null, Gs = $o({}, [].concat(Qc(sT), Qc(gC), Qc(hC), Qc(yC), Qc(rT))), Mt = null, _n = $o({}, [].concat(Qc(aT), Qc(bC), Qc(cT), Qc(O1))), on = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), Bt = null, Jn = null, co = !0, xn = !0, Sn = !1, So = !1, xo = !1, Ms = !1, Ho = !1, so = !1, Wo = !1, Pr = !1, Br = !0, gr = !0, si = !1, pa = {}, qr = null, oc = $o({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
      ]), Qu = null, Ui = $o({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
      ]), Hi = null, ri = $o({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
      ]), id = "http://www.w3.org/1998/Math/MathML", Ju = "http://www.w3.org/2000/svg", sc = "http://www.w3.org/1999/xhtml", ai = sc, ld = !1, ci, Ck = [
        "application/xhtml+xml",
        "text/html"
      ], US = "text/html", Ll, Ml = null, MN = o.createElement("form"), HS = function(Oe) {
        return Oe instanceof RegExp || Oe instanceof Function;
      }, Sk = function(Oe) {
        Ml && Ml === Oe || ((!Oe || ed(Oe) !== "object") && (Oe = {}), Oe = td(Oe), Qn = "ALLOWED_TAGS" in Oe ? $o({}, Oe.ALLOWED_TAGS) : Gs, Mt = "ALLOWED_ATTR" in Oe ? $o({}, Oe.ALLOWED_ATTR) : _n, Hi = "ADD_URI_SAFE_ATTR" in Oe ? $o(td(ri), Oe.ADD_URI_SAFE_ATTR) : ri, Qu = "ADD_DATA_URI_TAGS" in Oe ? $o(td(Ui), Oe.ADD_DATA_URI_TAGS) : Ui, qr = "FORBID_CONTENTS" in Oe ? $o({}, Oe.FORBID_CONTENTS) : oc, Bt = "FORBID_TAGS" in Oe ? $o({}, Oe.FORBID_TAGS) : {}, Jn = "FORBID_ATTR" in Oe ? $o({}, Oe.FORBID_ATTR) : {}, pa = "USE_PROFILES" in Oe ? Oe.USE_PROFILES : !1, co = Oe.ALLOW_ARIA_ATTR !== !1, xn = Oe.ALLOW_DATA_ATTR !== !1, Sn = Oe.ALLOW_UNKNOWN_PROTOCOLS || !1, So = Oe.SAFE_FOR_TEMPLATES || !1, xo = Oe.WHOLE_DOCUMENT || !1, so = Oe.RETURN_DOM || !1, Wo = Oe.RETURN_DOM_FRAGMENT || !1, Pr = Oe.RETURN_TRUSTED_TYPE || !1, Ho = Oe.FORCE_BODY || !1, Br = Oe.SANITIZE_DOM !== !1, gr = Oe.KEEP_CONTENT !== !1, si = Oe.IN_PLACE || !1, no = Oe.ALLOWED_URI_REGEXP || no, ai = Oe.NAMESPACE || sc, Oe.CUSTOM_ELEMENT_HANDLING && HS(Oe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (on.tagNameCheck = Oe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Oe.CUSTOM_ELEMENT_HANDLING && HS(Oe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (on.attributeNameCheck = Oe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Oe.CUSTOM_ELEMENT_HANDLING && typeof Oe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (on.allowCustomizedBuiltInElements = Oe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ci = Ck.indexOf(Oe.PARSER_MEDIA_TYPE) === -1 ? ci = US : ci = Oe.PARSER_MEDIA_TYPE, Ll = ci === "application/xhtml+xml" ? function(Yt) {
          return Yt;
        } : R1, So && (xn = !1), Wo && (so = !0), pa && (Qn = $o({}, Qc(rT)), Mt = [], pa.html === !0 && ($o(Qn, sT), $o(Mt, aT)), pa.svg === !0 && ($o(Qn, gC), $o(Mt, bC), $o(Mt, O1)), pa.svgFilters === !0 && ($o(Qn, hC), $o(Mt, bC), $o(Mt, O1)), pa.mathMl === !0 && ($o(Qn, yC), $o(Mt, cT), $o(Mt, O1))), Oe.ADD_TAGS && (Qn === Gs && (Qn = td(Qn)), $o(Qn, Oe.ADD_TAGS)), Oe.ADD_ATTR && (Mt === _n && (Mt = td(Mt)), $o(Mt, Oe.ADD_ATTR)), Oe.ADD_URI_SAFE_ATTR && $o(Hi, Oe.ADD_URI_SAFE_ATTR), Oe.FORBID_CONTENTS && (qr === oc && (qr = td(qr)), $o(qr, Oe.FORBID_CONTENTS)), gr && (Qn["#text"] = !0), xo && $o(Qn, [
          "html",
          "head",
          "body"
        ]), Qn.table && ($o(Qn, ["tbody"]), delete Bt.tbody), Ta && Ta(Oe), Ml = Oe);
      }, WS = $o({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
      ]), jl = $o({}, [
        "foreignobject",
        "desc",
        "title",
        "annotation-xml"
      ]), xk = $o({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
      ]), pe = $o({}, gC);
      $o(pe, hC), $o(pe, H3);
      var De = $o({}, yC);
      $o(De, W3);
      var ht = function(Oe) {
        var Yt = ve(Oe);
        (!Yt || !Yt.tagName) && (Yt = {
          namespaceURI: sc,
          tagName: "template"
        });
        var zn = R1(Oe.tagName), us = R1(Yt.tagName);
        return Oe.namespaceURI === Ju ? Yt.namespaceURI === sc ? zn === "svg" : Yt.namespaceURI === id ? zn === "svg" && (us === "annotation-xml" || WS[us]) : Boolean(pe[zn]) : Oe.namespaceURI === id ? Yt.namespaceURI === sc ? zn === "math" : Yt.namespaceURI === Ju ? zn === "math" && jl[us] : Boolean(De[zn]) : Oe.namespaceURI === sc ? Yt.namespaceURI === Ju && !jl[us] || Yt.namespaceURI === id && !WS[us] ? !1 : !De[zn] && (xk[zn] || !pe[zn]) : !1;
      }, ut = function(Oe) {
        sh(t.removed, { element: Oe });
        try {
          Oe.parentNode.removeChild(Oe);
        } catch {
          try {
            Oe.outerHTML = at;
          } catch {
            Oe.remove();
          }
        }
      }, mn = function(Oe, Yt) {
        try {
          sh(t.removed, {
            attribute: Yt.getAttributeNode(Oe),
            from: Yt
          });
        } catch {
          sh(t.removed, {
            attribute: null,
            from: Yt
          });
        }
        if (Yt.removeAttribute(Oe), Oe === "is" && !Mt[Oe])
          if (so || Wo)
            try {
              ut(Yt);
            } catch {
            }
          else
            try {
              Yt.setAttribute(Oe, "");
            } catch {
            }
      }, go = function(Oe) {
        var Yt, zn;
        if (Ho)
          Oe = "<remove></remove>" + Oe;
        else {
          var us = L3(Oe, /^[\r\n\t ]+/);
          zn = us && us[0];
        }
        ci === "application/xhtml+xml" && (Oe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Oe + "</body></html>");
        var Ka = Be ? Be.createHTML(Oe) : Oe;
        if (ai === sc)
          try {
            Yt = new N().parseFromString(Ka, ci);
          } catch {
          }
        if (!Yt || !Yt.documentElement) {
          Yt = lt.createDocument(ai, "template", null);
          try {
            Yt.documentElement.innerHTML = ld ? "" : Ka;
          } catch {
          }
        }
        var ga = Yt.body || Yt.documentElement;
        return Oe && zn && ga.insertBefore(o.createTextNode(zn), ga.childNodes[0] || null), ai === sc ? Pt.call(Yt, xo ? "html" : "body")[0] : xo ? Yt.documentElement : ga;
      }, mo = function(Oe) {
        return gt.call(Oe.ownerDocument || Oe, Oe, d.SHOW_ELEMENT | d.SHOW_COMMENT | d.SHOW_TEXT, null, !1);
      }, Na = function(Oe) {
        return Oe instanceof T && (typeof Oe.nodeName != "string" || typeof Oe.textContent != "string" || typeof Oe.removeChild != "function" || !(Oe.attributes instanceof v) || typeof Oe.removeAttribute != "function" || typeof Oe.setAttribute != "function" || typeof Oe.namespaceURI != "string" || typeof Oe.insertBefore != "function");
      }, ii = function(Oe) {
        return ed(i) === "object" ? Oe instanceof i : Oe && ed(Oe) === "object" && typeof Oe.nodeType == "number" && typeof Oe.nodeName == "string";
      }, Ul = function(Oe, Yt, zn) {
        !Ht[Oe] || F3(Ht[Oe], function(us) {
          us.call(t, Yt, zn, Ml);
        });
      }, jN = function(Oe) {
        var Yt;
        if (Ul("beforeSanitizeElements", Oe, null), Na(Oe) || za(/[\u0080-\uFFFF]/, Oe.nodeName))
          return ut(Oe), !0;
        var zn = Ll(Oe.nodeName);
        if (Ul("uponSanitizeElement", Oe, {
          tagName: zn,
          allowedTags: Qn
        }), Oe.hasChildNodes() && !ii(Oe.firstElementChild) && (!ii(Oe.content) || !ii(Oe.content.firstElementChild)) && za(/<[/\w]/g, Oe.innerHTML) && za(/<[/\w]/g, Oe.textContent) || zn === "select" && za(/<template/i, Oe.innerHTML))
          return ut(Oe), !0;
        if (!Qn[zn] || Bt[zn]) {
          if (!Bt[zn] && HN(zn) && (on.tagNameCheck instanceof RegExp && za(on.tagNameCheck, zn) || on.tagNameCheck instanceof Function && on.tagNameCheck(zn)))
            return !1;
          if (gr && !qr[zn]) {
            var us = ve(Oe) || Oe.parentNode, Ka = se(Oe) || Oe.childNodes;
            if (Ka && us)
              for (var ga = Ka.length, Vr = ga - 1; Vr >= 0; --Vr)
                us.insertBefore(j(Ka[Vr], !0), H(Oe));
          }
          return ut(Oe), !0;
        }
        return Oe instanceof u && !ht(Oe) || (zn === "noscript" || zn === "noembed") && za(/<\/no(script|embed)/i, Oe.innerHTML) ? (ut(Oe), !0) : (So && Oe.nodeType === 3 && (Yt = Oe.textContent, Yt = Xu(Yt, fo, " "), Yt = Xu(Yt, Co, " "), Oe.textContent !== Yt && (sh(t.removed, { element: Oe.cloneNode() }), Oe.textContent = Yt)), Ul("afterSanitizeElements", Oe, null), !1);
      }, UN = function(Oe, Yt, zn) {
        if (Br && (Yt === "id" || Yt === "name") && (zn in o || zn in MN))
          return !1;
        if (!(xn && !Jn[Yt] && za(Fo, Yt))) {
          if (!(co && za(Ls, Yt))) {
            if (!Mt[Yt] || Jn[Yt]) {
              if (!(HN(Oe) && (on.tagNameCheck instanceof RegExp && za(on.tagNameCheck, Oe) || on.tagNameCheck instanceof Function && on.tagNameCheck(Oe)) && (on.attributeNameCheck instanceof RegExp && za(on.attributeNameCheck, Yt) || on.attributeNameCheck instanceof Function && on.attributeNameCheck(Yt)) || Yt === "is" && on.allowCustomizedBuiltInElements && (on.tagNameCheck instanceof RegExp && za(on.tagNameCheck, zn) || on.tagNameCheck instanceof Function && on.tagNameCheck(zn))))
                return !1;
            } else if (!Hi[Yt]) {
              if (!za(no, Xu(zn, fn, ""))) {
                if (!((Yt === "src" || Yt === "xlink:href" || Yt === "href") && Oe !== "script" && M3(zn, "data:") === 0 && Qu[Oe])) {
                  if (!(Sn && !za(Nt, Xu(zn, fn, "")))) {
                    if (zn)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, HN = function(Oe) {
        return Oe.indexOf("-") > 0;
      }, WN = function(Oe) {
        var Yt, zn, us, Ka;
        Ul("beforeSanitizeAttributes", Oe, null);
        var ga = Oe.attributes;
        if (!!ga) {
          var Vr = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: Mt
          };
          for (Ka = ga.length; Ka--; ) {
            Yt = ga[Ka];
            var Ek = Yt, Gr = Ek.name, qN = Ek.namespaceURI;
            zn = Gr === "value" ? Yt.value : j3(Yt.value), us = Ll(Gr);
            var HU = zn;
            if (Vr.attrName = us, Vr.attrValue = zn, Vr.keepAttr = !0, Vr.forceKeepAttr = void 0, Ul("uponSanitizeAttribute", Oe, Vr), zn = Vr.attrValue, !Vr.forceKeepAttr) {
              if (!Vr.keepAttr) {
                mn(Gr, Oe);
                continue;
              }
              if (za(/\/>/i, zn)) {
                mn(Gr, Oe);
                continue;
              }
              So && (zn = Xu(zn, fo, " "), zn = Xu(zn, Co, " "));
              var WU = Ll(Oe.nodeName);
              if (!UN(WU, us, zn)) {
                mn(Gr, Oe);
                continue;
              }
              if (zn !== HU)
                try {
                  qN ? Oe.setAttributeNS(qN, Gr, zn) : Oe.setAttribute(Gr, zn);
                } catch {
                  mn(Gr, Oe);
                }
            }
          }
          Ul("afterSanitizeAttributes", Oe, null);
        }
      }, UU = function Wn(Oe) {
        var Yt, zn = mo(Oe);
        for (Ul("beforeSanitizeShadowDOM", Oe, null); Yt = zn.nextNode(); )
          Ul("uponSanitizeShadowNode", Yt, null), !jN(Yt) && (Yt.content instanceof s && Wn(Yt.content), WN(Yt));
        Ul("afterSanitizeShadowDOM", Oe, null);
      };
      return t.sanitize = function(Wn, Oe) {
        var Yt, zn, us, Ka, ga;
        if (ld = !Wn, ld && (Wn = "<!-->"), typeof Wn != "string" && !ii(Wn)) {
          if (typeof Wn.toString != "function")
            throw pC("toString is not a function");
          if (Wn = Wn.toString(), typeof Wn != "string")
            throw pC("dirty is not a string, aborting");
        }
        if (!t.isSupported) {
          if (ed(e.toStaticHTML) === "object" || typeof e.toStaticHTML == "function") {
            if (typeof Wn == "string")
              return e.toStaticHTML(Wn);
            if (ii(Wn))
              return e.toStaticHTML(Wn.outerHTML);
          }
          return Wn;
        }
        if (Ms || Sk(Oe), t.removed = [], typeof Wn == "string" && (si = !1), si) {
          if (Wn.nodeName) {
            var Vr = Ll(Wn.nodeName);
            if (!Qn[Vr] || Bt[Vr])
              throw pC("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (Wn instanceof i)
          Yt = go("<!---->"), zn = Yt.ownerDocument.importNode(Wn, !0), zn.nodeType === 1 && zn.nodeName === "BODY" || zn.nodeName === "HTML" ? Yt = zn : Yt.appendChild(zn);
        else {
          if (!so && !So && !xo && Wn.indexOf("<") === -1)
            return Be && Pr ? Be.createHTML(Wn) : Wn;
          if (Yt = go(Wn), !Yt)
            return so ? null : Pr ? at : "";
        }
        Yt && Ho && ut(Yt.firstChild);
        for (var Ek = mo(si ? Wn : Yt); us = Ek.nextNode(); )
          us.nodeType === 3 && us === Ka || jN(us) || (us.content instanceof s && UU(us.content), WN(us), Ka = us);
        if (Ka = null, si)
          return Wn;
        if (so) {
          if (Wo)
            for (ga = Dt.call(Yt.ownerDocument); Yt.firstChild; )
              ga.appendChild(Yt.firstChild);
          else
            ga = Yt;
          return Mt.shadowroot && (ga = bn.call(n, ga, !0)), ga;
        }
        var Gr = xo ? Yt.outerHTML : Yt.innerHTML;
        return xo && Qn["!doctype"] && Yt.ownerDocument && Yt.ownerDocument.doctype && Yt.ownerDocument.doctype.name && za(Q3, Yt.ownerDocument.doctype.name) && (Gr = "<!DOCTYPE " + Yt.ownerDocument.doctype.name + `>
` + Gr), So && (Gr = Xu(Gr, fo, " "), Gr = Xu(Gr, Co, " ")), Be && Pr ? Be.createHTML(Gr) : Gr;
      }, t.setConfig = function(Wn) {
        Sk(Wn), Ms = !0;
      }, t.clearConfig = function() {
        Ml = null, Ms = !1;
      }, t.isValidAttribute = function(Wn, Oe, Yt) {
        Ml || Sk({});
        var zn = Ll(Wn), us = Ll(Oe);
        return UN(zn, us, Yt);
      }, t.addHook = function(Wn, Oe) {
        typeof Oe == "function" && (Ht[Wn] = Ht[Wn] || [], sh(Ht[Wn], Oe));
      }, t.removeHook = function(Wn) {
        if (Ht[Wn])
          return I3(Ht[Wn]);
      }, t.removeHooks = function(Wn) {
        Ht[Wn] && (Ht[Wn] = []);
      }, t.removeAllHooks = function() {
        Ht = {};
      }, t;
    }
    var tO = iT();
    const lT = nt.explode, uT = () => {
      const e = {};
      return {
        addFilter: (s, a) => {
          M(lT(s), (i) => {
            gn(e, i) || (e[i] = {
              name: i,
              callbacks: []
            }), e[i].callbacks.push(a);
          });
        },
        getFilters: () => os(e),
        removeFilter: (s, a) => {
          M(lT(s), (i) => {
            if (gn(e, i))
              if (L(a)) {
                const u = e[i], d = Qe(u.callbacks, (y) => y !== a);
                d.length > 0 ? u.callbacks = d : delete e[i];
              } else
                delete e[i];
          });
        }
      };
    }, nO = (e, t) => {
      M(t, (n) => {
        e.attr(n, null);
      });
    }, oO = (e, t, n) => {
      e.addNodeFilter("font", (o) => {
        M(o, (s) => {
          const a = t.parse(s.attr("style")), i = s.attr("color"), u = s.attr("face"), d = s.attr("size");
          i && (a.color = i), u && (a["font-family"] = u), d && (a["font-size"] = n[parseInt(s.attr("size"), 10) - 1]), s.name = "span", s.attr("style", t.serialize(a)), nO(s, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, sO = (e, t, n) => {
      e.addNodeFilter("strike", (o) => {
        const s = t.type !== "html4";
        M(o, (a) => {
          if (s)
            a.name = "s";
          else {
            const i = n.parse(a.attr("style"));
            i["text-decoration"] = "line-through", a.name = "span", a.attr("style", n.serialize(i));
          }
        });
      });
    }, rO = (e, t, n) => {
      const o = Mc();
      t.convert_fonts_to_spans && oO(e, o, nt.explode(t.font_size_legacy_values)), sO(e, n, o);
    }, aO = (e, t, n) => {
      t.inline_styles && rO(e, t, n);
    }, cO = (e) => fetch(e).then((t) => t.ok ? t.blob() : Promise.reject()).catch(() => Promise.reject(`Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`)), iO = (e) => {
      const t = /([a-z0-9+\/=\s]+)/i.exec(e);
      return t ? t[1] : "";
    }, kC = (e) => {
      const [t, ...n] = e.split(","), o = n.join(","), s = /data:([^/]+\/[^;]+)(;.+)?/.exec(t);
      if (s) {
        const a = s[2] === ";base64", i = a ? iO(o) : decodeURIComponent(o);
        return w.some({
          type: s[1],
          data: i,
          base64Encoded: a
        });
      } else
        return w.none();
    }, fT = (e, t, n = !0) => {
      let o = t;
      if (n)
        try {
          o = atob(t);
        } catch {
          return w.none();
        }
      const s = new Uint8Array(o.length);
      for (let a = 0; a < s.length; a++)
        s[a] = o.charCodeAt(a);
      return w.some(new Blob([s], { type: e }));
    }, lO = (e) => new Promise((t, n) => {
      kC(e).bind(({ type: o, data: s, base64Encoded: a }) => fT(o, s, a)).fold(() => n("Invalid data URI"), t);
    }), uO = (e) => un(e, "blob:") ? cO(e) : un(e, "data:") ? lO(e) : Promise.reject("Unknown URI format"), dT = (e) => new Promise((t, n) => {
      const o = new FileReader();
      o.onloadend = () => {
        t(o.result);
      }, o.onerror = () => {
        n(o.error.message);
      }, o.readAsDataURL(e);
    });
    let fO = 0;
    const dO = (e) => (e || "blobid") + fO++, mT = (e, t, n) => kC(e).bind(({ data: o, type: s, base64Encoded: a }) => {
      if (t && !a)
        return w.none();
      {
        const i = a ? o : btoa(o);
        return n(i, s);
      }
    }), pT = (e, t, n) => {
      const o = e.create(dO(), t, n);
      return e.add(o), o;
    }, gT = (e, t, n = !1) => mT(t, n, (o, s) => w.from(e.getByData(o, s)).orThunk(() => fT(s, o).map((a) => pT(e, a, o)))), mO = (e, t) => {
      const n = () => Promise.reject("Invalid data URI");
      if (un(t, "blob:")) {
        const o = e.getByUri(t);
        return L(o) ? Promise.resolve(o) : uO(t).then((s) => dT(s).then((a) => mT(a, !1, (i) => w.some(pT(e, s, i))).getOrThunk(n)));
      } else
        return un(t, "data:") ? gT(e, t).fold(n, (o) => Promise.resolve(o)) : Promise.reject("Unknown image data format");
    }, pO = (e) => L(e.attr("data-mce-bogus")), gO = (e) => e.attr("src") === Gn.transparentSrc || L(e.attr("data-mce-placeholder")), hO = (e, t) => {
      const { blob_cache: n } = t, o = (s) => {
        const a = s.attr("src");
        gO(s) || pO(s) || gT(n, a, !0).each((i) => {
          s.attr("src", i.blobUri());
        });
      };
      n && e.addAttributeFilter("src", (s) => M(s, o));
    }, yO = (e, t) => {
      const n = e.schema;
      t.remove_trailing_brs && e.addNodeFilter("br", (o, s, a) => {
        const i = nt.extend({}, n.getBlockElements()), u = n.getNonEmptyElements(), d = n.getWhitespaceElements();
        i.body = 1;
        for (let y = 0, v = o.length; y < v; y++) {
          let T = o[y], N = T.parent;
          if (i[T.parent.name] && T === N.lastChild) {
            let F = T.prev;
            for (; F; ) {
              const U = F.name;
              if (U !== "span" || F.attr("data-mce-type") !== "bookmark") {
                U === "br" && (T = null);
                break;
              }
              F = F.prev;
            }
            if (T && (T.remove(), nh(n, u, d, N))) {
              const U = n.getElementRule(N.name);
              U && (U.removeEmpty ? N.remove() : U.paddEmpty && Vv(t, a, i, N));
            }
          } else {
            let F = T;
            for (; N && N.firstChild === F && N.lastChild === F && (F = N, !i[N.name]); )
              N = N.parent;
            if (F === N) {
              const U = new da("#text", 3);
              U.value = Ws, T.replace(U);
            }
          }
        }
      }), e.addAttributeFilter("href", (o) => {
        let s = o.length;
        const a = (u) => u.split(" ").filter((y) => y.length > 0).concat(["noopener"]).sort().join(" "), i = (u) => {
          const d = u ? nt.trim(u) : "";
          return /\b(noopener)\b/g.test(d) ? d : a(d);
        };
        if (!t.allow_unsafe_link_target)
          for (; s--; ) {
            const u = o[s];
            u.name === "a" && u.attr("target") === "_blank" && u.attr("rel", i(u.attr("rel")));
          }
      }), t.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (o) => {
        let s = o.length, a, i, u, d;
        for (; s--; )
          if (d = o[s], d.name === "a" && d.firstChild && !d.attr("href")) {
            u = d.parent, a = d.lastChild;
            do
              i = a.prev, u.insert(a, d), a = i;
            while (a);
          }
      }), t.fix_list_elements && e.addNodeFilter("ul,ol", (o) => {
        let s = o.length, a, i;
        for (; s--; )
          if (a = o[s], i = a.parent, i.name === "ul" || i.name === "ol")
            if (a.prev && a.prev.name === "li")
              a.prev.append(a);
            else {
              const u = new da("li", 1);
              u.attr("style", "list-style-type: none"), a.wrap(u);
            }
      }), t.validate && n.getValidClasses() && e.addAttributeFilter("class", (o) => {
        const s = n.getValidClasses();
        let a = o.length;
        for (; a--; ) {
          const i = o[a], u = i.attr("class").split(" ");
          let d = "";
          for (let y = 0; y < u.length; y++) {
            const v = u[y];
            let T = !1, N = s["*"];
            N && N[v] && (T = !0), N = s[i.name], !T && N && N[v] && (T = !0), T && (d && (d += " "), d += v);
          }
          d.length || (d = null), i.attr("class", d);
        }
      }), hO(e, t);
    }, hT = nt.each, bO = nt.trim, kO = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" "), wO = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, _O = [
      "img",
      "video"
    ], vO = (e, t) => L(e) ? !e : L(t) ? !ce(_O, t) : !0, CO = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, yT = (e, t, n) => {
      const o = CO(t);
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(o) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(o) ? vO(e.allow_svg_data_urls, n) && /^data:image\/svg\+xml/i.test(o) : /^data:/i.test(o);
    };
    class ei {
      constructor(t, n) {
        t = bO(t), this.settings = n || {};
        const o = this.settings.base_uri, s = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(t) || /^\s*#/.test(t)) {
          s.source = t;
          return;
        }
        const a = t.indexOf("//") === 0;
        if (t.indexOf("/") === 0 && !a && (t = (o && o.protocol || "http") + "://mce_host" + t), !/^[\w\-]*:?\/\//.test(t)) {
          const u = this.settings.base_uri ? this.settings.base_uri.path : new ei(document.location.href).directory;
          if (this.settings.base_uri && this.settings.base_uri.protocol == "")
            t = "//mce_host" + s.toAbsPath(u, t);
          else {
            const d = /([^#?]*)([#?]?.*)/.exec(t);
            t = (o && o.protocol || "http") + "://mce_host" + s.toAbsPath(u, d[1]) + d[2];
          }
        }
        t = t.replace(/@@/g, "(mce_at)");
        const i = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(t);
        hT(kO, (u, d) => {
          let y = i[d];
          y && (y = y.replace(/\(mce_at\)/g, "@@")), s[u] = y;
        }), o && (s.protocol || (s.protocol = o.protocol), s.userInfo || (s.userInfo = o.userInfo), !s.port && s.host === "mce_host" && (s.port = o.port), (!s.host || s.host === "mce_host") && (s.host = o.host), s.source = ""), a && (s.protocol = "");
      }
      static parseDataUri(t) {
        let n;
        const o = decodeURIComponent(t).split(","), s = /data:([^;]+)/.exec(o[0]);
        return s && (n = s[1]), {
          type: n,
          data: o[1]
        };
      }
      static isDomSafe(t, n, o = {}) {
        if (o.allow_script_urls)
          return !0;
        {
          const s = zi.decode(t).replace(/[\s\u0000-\u001F]+/g, "");
          return !yT(o, s, n);
        }
      }
      static getDocumentBaseUrl(t) {
        let n;
        return t.protocol.indexOf("http") !== 0 && t.protocol !== "file:" ? n = t.href : n = t.protocol + "//" + t.host + t.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/")), n;
      }
      setPath(t) {
        const n = /^(.*?)\/?(\w+)?$/.exec(t);
        this.path = n[0], this.directory = n[1], this.file = n[2], this.source = "", this.getURI();
      }
      toRelative(t) {
        let n;
        if (t === "./")
          return t;
        const o = new ei(t, { base_uri: this });
        if (o.host !== "mce_host" && this.host !== o.host && o.host || this.port !== o.port || this.protocol !== o.protocol && o.protocol !== "")
          return o.getURI();
        const s = this.getURI(), a = o.getURI();
        return s === a || s.charAt(s.length - 1) === "/" && s.substr(0, s.length - 1) === a ? s : (n = this.toRelPath(this.path, o.path), o.query && (n += "?" + o.query), o.anchor && (n += "#" + o.anchor), n);
      }
      toAbsolute(t, n) {
        const o = new ei(t, { base_uri: this });
        return o.getURI(n && this.isSameOrigin(o));
      }
      isSameOrigin(t) {
        if (this.host == t.host && this.protocol == t.protocol) {
          if (this.port == t.port)
            return !0;
          const n = wO[this.protocol];
          if (n && (this.port || n) == (t.port || n))
            return !0;
        }
        return !1;
      }
      toRelPath(t, n) {
        let o = 0, s = "", a, i;
        const u = t.substring(0, t.lastIndexOf("/")).split("/"), d = n.split("/");
        if (u.length >= d.length) {
          for (a = 0, i = u.length; a < i; a++)
            if (a >= d.length || u[a] !== d[a]) {
              o = a + 1;
              break;
            }
        }
        if (u.length < d.length) {
          for (a = 0, i = d.length; a < i; a++)
            if (a >= u.length || u[a] !== d[a]) {
              o = a + 1;
              break;
            }
        }
        if (o === 1)
          return n;
        for (a = 0, i = u.length - (o - 1); a < i; a++)
          s += "../";
        for (a = o - 1, i = d.length; a < i; a++)
          a !== o - 1 ? s += "/" + d[a] : s += d[a];
        return s;
      }
      toAbsPath(t, n) {
        let o, s = 0, a = [], i;
        const u = /\/$/.test(n) ? "/" : "";
        let d = t.split("/");
        const y = n.split("/");
        for (hT(d, (v) => {
          v && a.push(v);
        }), d = a, o = y.length - 1, a = []; o >= 0; o--)
          if (!(y[o].length === 0 || y[o] === ".")) {
            if (y[o] === "..") {
              s++;
              continue;
            }
            if (s > 0) {
              s--;
              continue;
            }
            a.push(y[o]);
          }
        return o = d.length - s, o <= 0 ? i = io(a).join("/") : i = d.slice(0, o).join("/") + "/" + io(a).join("/"), i.indexOf("/") !== 0 && (i = "/" + i), u && i.lastIndexOf("/") !== i.length - 1 && (i += u), i;
      }
      getURI(t = !1) {
        let n;
        return (!this.source || t) && (n = "", t || (this.protocol ? n += this.protocol + "://" : n += "//", this.userInfo && (n += this.userInfo + "@"), this.host && (n += this.host), this.port && (n += ":" + this.port)), this.path && (n += this.path), this.query && (n += "?" + this.query), this.anchor && (n += "#" + this.anchor), this.source = n), this.source;
      }
    }
    const bT = nt.makeMap, kT = nt.extend, SO = {
      IN_PLACE: !0,
      ALLOW_UNKNOWN_PROTOCOLS: !0,
      ALLOWED_TAGS: [
        "#comment",
        "#cdata-section",
        "body"
      ],
      ALLOWED_ATTR: []
    }, xO = nt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), wC = "data-mce-type", EO = (e, t) => {
      const n = { ...SO };
      return n.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? n.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (n.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), n;
    }, TO = (e, t) => {
      const n = tO(), o = t.getSpecialElements(), s = e.validate;
      let a = 0;
      return n.addHook("uponSanitizeElement", (i, u) => {
        var d, y;
        i.nodeType === $ && !e.allow_conditional_comments && /^\[if/i.test(i.nodeValue) && (i.nodeValue = " " + i.nodeValue);
        const v = u.tagName;
        if (i.nodeType !== He || v === "body")
          return;
        const T = ne.fromDom(i), N = v.toLowerCase(), F = Ba(T, wC), U = Os(T, "data-mce-bogus");
        if (!F && ge(U)) {
          U === "all" ? Do(T) : Es(T);
          return;
        }
        const j = t.getElementRule(N);
        if (s && !j) {
          gn(o, N) ? Do(T) : Es(T);
          return;
        } else
          u.allowedTags[v] = !0;
        if (s && !F) {
          if (M((d = j.attributesForced) !== null && d !== void 0 ? d : [], (H) => {
            ao(T, H.name, H.value === "{$uid}" ? `mce_${a++}` : H.value);
          }), M((y = j.attributesDefault) !== null && y !== void 0 ? y : [], (H) => {
            Ba(T, H.name) || ao(T, H.name, H.value === "{$uid}" ? `mce_${a++}` : H.value);
          }), j.attributesRequired && !Ce(j.attributesRequired, (H) => Ba(T, H))) {
            Es(T);
            return;
          }
          if (j.removeEmptyAttrs && ba(T)) {
            Es(T);
            return;
          }
          j.outputName && j.outputName !== N && Cw(T, j.outputName);
        }
      }), n.addHook("uponSanitizeAttribute", (i, u) => {
        const d = i.tagName.toLowerCase(), { attrName: y, attrValue: v } = u;
        u.keepAttr = !s || t.isValid(d, y) || un(y, "data-") || un(y, "aria-"), y in xO && yT(e, v, d) && (u.keepAttr = !1), u.keepAttr ? (u.allowedAttributes[y] = !0, y in t.getBoolAttrs() && (u.attrValue = y), e.allow_svg_data_urls && un(v, "data:image/svg+xml") && (u.forceKeepAttr = !0)) : i.hasAttribute(wC) && (y === "id" || y === "class" || y === "style") && (u.forceKeepAttr = !0);
      }), n;
    }, wT = (e, t, n) => {
      const o = e.name, s = o in n && o !== "title" && o !== "textarea", a = t.childNodes;
      for (let i = 0, u = a.length; i < u; i++) {
        const d = a[i], y = new da(d.nodeName.toLowerCase(), d.nodeType);
        if (dn(d)) {
          const v = d.attributes;
          for (let T = 0, N = v.length; T < N; T++) {
            const F = v[T];
            y.attr(F.name, F.value);
          }
        } else
          Ft(d) ? (y.value = d.data, s && (y.raw = !0)) : (ul(d) || _d(d) || vd(d)) && (y.value = d.data);
        wT(y, d, n), e.append(y);
      }
    }, zO = (e, t, n) => {
      const o = [];
      for (let s = e, a = s; L(s); a = s, s = s.walk())
        M(t, (i) => i(s)), Ve(s.parent) && s !== e ? s = a : o.push(s);
      for (let s = o.length - 1; s >= 0; s--) {
        const a = o[s];
        M(n, (i) => i(a));
      }
    }, AO = (e, t, n, o) => {
      const s = n.validate, a = t.getNonEmptyElements(), i = t.getWhitespaceElements(), u = kT(bT("script,style,head,html,body,title,meta,param"), t.getBlockElements()), d = Lh(t), y = /[ \t\r\n]+/g, v = /^[ \t\r\n]+/, T = /[ \t\r\n]+$/, N = (se) => {
        for (se = se.parent; L(se); ) {
          if (se.name in i)
            return !0;
          se = se.parent;
        }
        return !1;
      }, F = (se) => {
        let ve = se;
        for (; L(ve); ) {
          if (ve.name in d)
            return nh(t, a, i, ve);
          ve = ve.parent;
        }
        return !1;
      }, U = (se, ve) => {
        const Se = ve ? se.prev : se.next;
        return L(Se) ? !1 : se.parent.name in u && (se.parent !== e || o.isRootContent);
      };
      return [
        (se) => {
          if (se.type === 3 && !N(se)) {
            let ve = se.value;
            ve = ve.replace(y, " "), (t5(se.prev, u) || U(se, !0)) && (ve = ve.replace(v, "")), ve.length === 0 ? se.remove() : se.value = ve;
          }
        },
        (se) => {
          var ve;
          if (se.type === 1) {
            const Se = t.getElementRule(se.name);
            if (s && Se) {
              const Be = nh(t, a, i, se);
              Se.paddInEmptyBlock && Be && F(se) ? Vv(n, o, u, se) : Se.removeEmpty && Be ? u[se.name] ? se.remove() : se.unwrap() : Se.paddEmpty && (Be || JD(se)) && Vv(n, o, u, se);
            }
          } else if (se.type === 3 && !N(se)) {
            let Se = se.value;
            (u[(ve = se.next) === null || ve === void 0 ? void 0 : ve.name] || U(se, !1)) && (Se = Se.replace(T, "")), Se.length === 0 ? se.remove() : se.value = Se;
          }
        }
      ];
    }, NO = (e, t) => {
      var n;
      const o = (n = t.forced_root_block) !== null && n !== void 0 ? n : e.forced_root_block;
      return o === !1 ? "" : o === !0 ? "p" : o;
    }, np = (e = {}, t = Ai()) => {
      const n = uT(), o = uT(), s = {
        validate: !0,
        root_name: "body",
        ...e
      }, a = new DOMParser(), i = TO(s, t), u = (ve, Se, Be = "html") => {
        const at = Be === "xhtml" ? "application/xhtml+xml" : "text/html", Vt = gn(t.getSpecialElements(), Se.toLowerCase()), lt = Vt ? `<${Se}>${ve}</${Se}>` : ve, gt = Be === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${lt}</body></html>` : `<body>${lt}</body>`, Dt = a.parseFromString(gt, at).body;
        return i.sanitize(Dt, EO(s, at)), i.removed = [], Vt ? Dt.firstChild : Dt;
      }, d = n.addFilter, y = n.getFilters, v = n.removeFilter, T = o.addFilter, N = o.getFilters, F = o.removeFilter, U = (ve, Se) => {
        const Be = ve.parent;
        Be && t.children[ve.name] && !t.isValidChild(Be.name, ve.name) && Se.push(ve);
      }, j = (ve, Se) => {
        const Be = kT(bT("script,style,head,html,body,title,meta,param"), t.getBlockElements()), at = /^[ \t\r\n]+/, Vt = /[ \t\r\n]+$/;
        let lt = ve.firstChild, gt = null;
        const Dt = (Pt) => {
          Pt && (lt = Pt.firstChild, lt && lt.type === 3 && (lt.value = lt.value.replace(at, "")), lt = Pt.lastChild, lt && lt.type === 3 && (lt.value = lt.value.replace(Vt, "")));
        };
        if (!!t.isValidChild(ve.name, Se.toLowerCase())) {
          for (; lt; ) {
            const Pt = lt.next;
            lt.type === 3 || lt.type === 1 && lt.name !== "p" && !Be[lt.name] && !lt.attr(wC) ? (gt || (gt = new da(Se, 1), gt.attr(s.forced_root_block_attrs), ve.insert(gt, lt)), gt.append(lt)) : (Dt(gt), gt = null), lt = Pt;
          }
          Dt(gt);
        }
      }, se = {
        schema: t,
        addAttributeFilter: T,
        getAttributeFilters: N,
        removeAttributeFilter: F,
        addNodeFilter: d,
        getNodeFilters: y,
        removeNodeFilter: v,
        parse: (ve, Se = {}) => {
          var Be;
          const at = s.validate, Vt = (Be = Se.context) !== null && Be !== void 0 ? Be : s.root_name, lt = u(ve, Vt, Se.format), gt = new da(Vt, 11);
          wT(gt, lt, t.getSpecialElements());
          const [Dt, Pt] = AO(gt, t, s, Se), bn = [], nn = at ? (Fo) => U(Fo, bn) : ye, Ht = {
            nodes: {},
            attributes: {}
          }, fo = (Fo) => CE(y(), N(), Fo, Ht);
          if (zO(gt, [
            Dt,
            fo
          ], [
            Pt,
            nn
          ]), bn.reverse(), at && bn.length > 0)
            if (Se.context) {
              const {
                pass: Fo,
                fail: Ls
              } = kt(bn, (Nt) => Nt.parent === gt);
              Kv(Ls, t, fo), Se.invalid = Fo.length > 0;
            } else
              Kv(bn, t, fo);
          const Co = NO(s, Se);
          return Co && (gt.name === "body" || Se.isRootContent) && j(gt, Co), Se.invalid || SE(Ht, Se), gt;
        }
      };
      return yO(se, s), aO(se, s, t), se;
    }, RO = (e) => S1(e) ? qu({ validate: !1 }).serialize(e) : e, _T = (e, t) => {
      const n = RO(e), o = t(n);
      if (o.isDefaultPrevented())
        return o;
      if (S1(e))
        if (o.content !== n) {
          const s = np({
            validate: !1,
            forced_root_block: !1
          }).parse(o.content, { context: e.name });
          return {
            ...o,
            content: s
          };
        } else
          return {
            ...o,
            content: e
          };
      else
        return o;
    }, vT = (e, t) => {
      if (t.no_events)
        return Dr.value(t);
      {
        const n = $g(e, t);
        return n.isDefaultPrevented() ? Dr.error(Ub(e, {
          content: "",
          ...n
        }).content) : Dr.value(n);
      }
    }, CT = (e, t, n) => n.no_events ? t : _T(t, (s) => Ub(e, {
      ...n,
      content: s
    })).content, _C = (e, t) => {
      if (t.no_events)
        return Dr.value(t);
      {
        const n = _T(t.content, (o) => Mm(e, {
          ...t,
          content: o
        }));
        return n.isDefaultPrevented() ? (Bg(e, n), Dr.error(void 0)) : Dr.value(n);
      }
    }, vC = (e, t, n) => {
      n.no_events || Bg(e, {
        ...n,
        content: t
      });
    }, CC = (e, t, n) => ({
      element: e,
      width: t,
      rows: n
    }), ST = (e, t) => ({
      element: e,
      cells: t
    }), DO = (e, t) => ({
      x: e,
      y: t
    }), xT = (e, t) => {
      const n = parseInt(Os(e, t), 10);
      return isNaN(n) ? 1 : n;
    }, OO = (e, t, n, o, s) => {
      const a = xT(s, "rowspan"), i = xT(s, "colspan"), u = e.rows;
      for (let d = n; d < n + a; d++) {
        u[d] || (u[d] = ST(Vp(o), []));
        for (let y = t; y < t + i; y++) {
          const v = u[d].cells;
          v[y] = d === n && y === t ? s : pu(s);
        }
      }
    }, PO = (e, t, n) => {
      const o = e.rows;
      return !!(o[n] ? o[n].cells : [])[t];
    }, BO = (e, t, n) => {
      for (; PO(e, t, n); )
        t++;
      return t;
    }, ET = (e) => En(e, (t, n) => n.cells.length > t ? n.cells.length : t, 0), TT = (e, t) => {
      const n = e.rows;
      for (let o = 0; o < n.length; o++) {
        const s = n[o].cells;
        for (let a = 0; a < s.length; a++)
          if (_o(s[a], t))
            return w.some(DO(a, o));
      }
      return w.none();
    }, zT = (e, t, n, o, s) => {
      const a = [], i = e.rows;
      for (let u = n; u <= s; u++) {
        const d = i[u].cells, y = t < o ? d.slice(t, o + 1) : d.slice(o, t + 1);
        a.push(ST(i[u].element, y));
      }
      return a;
    }, $O = (e, t, n) => {
      const o = t.x, s = t.y, a = n.x, i = n.y, u = s < i ? zT(e, o, s, a, i) : zT(e, o, i, a, s);
      return CC(e.element, ET(u), u);
    }, FO = (e, t) => {
      const n = pu(e.element), o = ne.fromTag("tbody");
      return lc(o, t), ls(n, o), n;
    }, IO = (e) => W(e.rows, (t) => {
      const n = W(t.cells, (s) => {
        const a = Vp(s);
        return as(a, "colspan"), as(a, "rowspan"), a;
      }), o = pu(t.element);
      return lc(o, n), o;
    }), LO = (e) => {
      const t = CC(pu(e), 0, []);
      return M(br(e, "tr"), (n, o) => {
        M(br(n, "td,th"), (s, a) => {
          OO(t, BO(t, a, o), o, n, s);
        });
      }), CC(t.element, ET(t.rows), t.rows);
    }, MO = (e) => FO(e, IO(e)), jO = (e, t, n) => TT(e, t).bind((o) => TT(e, n).map((s) => $O(e, o, s))), UO = (e) => oo(e, (t) => tn(t) === "ul" || tn(t) === "ol"), HO = (e, t) => oo(e, (n) => tn(n) === "li" && Pu(n, t)).fold(Z([]), (n) => UO(e).map((o) => {
      const s = ne.fromTag(tn(o)), a = rs(hd(o), (i, u) => un(u, "list-style"));
      return Ir(s, a), [
        ne.fromTag("li"),
        s
      ];
    }).getOr([])), WO = (e, t) => {
      const n = En(t, (o, s) => (ls(s, o), s), e);
      return t.length > 0 ? Pl([n]) : n;
    }, qO = (e) => dl(e) ? er(e).filter(gf).fold(Z([]), (t) => [
      e,
      t
    ]) : gf(e) ? [e] : [], VO = (e, t) => {
      const n = ne.fromDom(t.commonAncestorContainer), o = Bl(n, e), s = Qe(o, yf), a = HO(o, t), i = s.concat(a.length ? a : qO(n));
      return W(i, pu);
    }, AT = () => Pl([]), GO = (e, t) => WO(ne.fromDom(t.cloneContents()), VO(e, t)), KO = (e, t) => Si(t, "table", et(_o, e)), YO = (e, t) => KO(e, t[0]).bind((n) => {
      const o = t[0], s = t[t.length - 1], a = LO(n);
      return jO(a, o, s).map((i) => Pl([MO(i)]));
    }).getOrThunk(AT), XO = (e, t) => t.length > 0 && t[0].collapsed ? AT() : GO(e, t[0]), ZO = (e, t) => {
      const n = Rg(t, e);
      return n.length > 0 ? YO(e, n) : XO(e, t);
    }, P1 = (e, t) => t >= 0 && t < e.length && zu(e.charAt(t)), NT = (e) => E(e.innerText), QO = (e) => e.map((t) => t.nodeName).getOr("div").toLowerCase(), JO = (e) => w.from(e.selection.getRng()).map((t) => {
      const n = w.from(e.dom.getParent(t.commonAncestorContainer, e.dom.isBlock)), o = e.getBody(), s = QO(n), a = e.dom.add(o, s, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, t.cloneContents()), i = NT(a), u = E(a.textContent);
      if (e.dom.remove(a), P1(u, 0) || P1(u, u.length - 1)) {
        const d = n.getOr(o), y = NT(d), v = y.indexOf(i);
        if (v === -1)
          return i;
        {
          const T = P1(y, v - 1), N = P1(y, v + i.length);
          return (T ? " " : "") + i + (N ? " " : "");
        }
      } else
        return i;
    }).getOr(""), eP = (e, t) => {
      const n = e.selection.getRng(), o = e.dom.create("body"), s = e.selection.getSel(), a = or(e, Nm(s)), i = t.contextual ? ZO(ne.fromDom(e.getBody()), a).dom : n.cloneContents();
      return i && o.appendChild(i), e.selection.serializer.serialize(o, t);
    }, tP = (e, t) => {
      if (t.format === "text")
        return JO(e);
      {
        const n = eP(e, t);
        return t.format === "tree" ? n : e.selection.isCollapsed() ? "" : n;
      }
    }, nP = (e, t) => ({
      ...e,
      format: t,
      get: !0,
      selection: !0,
      getInner: !0
    }), oP = (e, t, n = {}) => {
      const o = nP(n, t);
      return vT(e, o).fold(Pe, (s) => {
        const a = tP(e, s);
        return CT(e, a, s);
      });
    }, SC = 0, RT = 1, DT = 2, sP = (e, t) => {
      const n = e.length + t.length + 2, o = new Array(n), s = new Array(n), a = (v, T, N) => ({
        start: v,
        end: T,
        diag: N
      }), i = (v, T, N, F, U) => {
        const j = d(v, T, N, F);
        if (j === null || j.start === T && j.diag === T - F || j.end === v && j.diag === v - N) {
          let H = v, se = N;
          for (; H < T || se < F; )
            H < T && se < F && e[H] === t[se] ? (U.push([
              SC,
              e[H]
            ]), ++H, ++se) : T - v > F - N ? (U.push([
              DT,
              e[H]
            ]), ++H) : (U.push([
              RT,
              t[se]
            ]), ++se);
        } else {
          i(v, j.start, N, j.start - j.diag, U);
          for (let H = j.start; H < j.end; ++H)
            U.push([
              SC,
              e[H]
            ]);
          i(j.end, T, j.end - j.diag, F, U);
        }
      }, u = (v, T, N, F) => {
        let U = v;
        for (; U - T < F && U < N && e[U] === t[U - T]; )
          ++U;
        return a(v, U, T);
      }, d = (v, T, N, F) => {
        const U = T - v, j = F - N;
        if (U === 0 || j === 0)
          return null;
        const H = U - j, se = j + U, ve = (se % 2 === 0 ? se : se + 1) / 2;
        o[1 + ve] = v, s[1 + ve] = T + 1;
        let Se, Be, at, Vt, lt;
        for (Se = 0; Se <= ve; ++Se) {
          for (Be = -Se; Be <= Se; Be += 2) {
            for (at = Be + ve, Be === -Se || Be !== Se && o[at - 1] < o[at + 1] ? o[at] = o[at + 1] : o[at] = o[at - 1] + 1, Vt = o[at], lt = Vt - v + N - Be; Vt < T && lt < F && e[Vt] === t[lt]; )
              o[at] = ++Vt, ++lt;
            if (H % 2 !== 0 && H - Se <= Be && Be <= H + Se && s[at - H] <= o[at])
              return u(s[at - H], Be + v - N, T, F);
          }
          for (Be = H - Se; Be <= H + Se; Be += 2) {
            for (at = Be + ve - H, Be === H - Se || Be !== H + Se && s[at + 1] <= s[at - 1] ? s[at] = s[at + 1] - 1 : s[at] = s[at - 1], Vt = s[at] - 1, lt = Vt - v + N - Be; Vt >= v && lt >= N && e[Vt] === t[lt]; )
              s[at] = Vt--, lt--;
            if (H % 2 === 0 && -Se <= Be && Be <= Se && s[at] <= o[at + H])
              return u(s[at], Be + v - N, T, F);
          }
        }
      }, y = [];
      return i(0, e.length, 0, t.length, y), y;
    }, OT = (e) => dn(e) ? e.outerHTML : Ft(e) ? zi.encodeRaw(e.data, !1) : ul(e) ? "<!--" + e.data + "-->" : "", rP = (e) => {
      let t;
      const n = document.createElement("div"), o = document.createDocumentFragment();
      for (e && (n.innerHTML = e); t = n.firstChild; )
        o.appendChild(t);
      return o;
    }, aP = (e, t, n) => {
      const o = rP(t);
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const s = e.childNodes[n];
        s.parentNode.insertBefore(o, s);
      } else
        e.appendChild(o);
    }, cP = (e, t) => {
      if (e.hasChildNodes() && t < e.childNodes.length) {
        const n = e.childNodes[t];
        n.parentNode.removeChild(n);
      }
    }, iP = (e, t) => {
      let n = 0;
      M(e, (o) => {
        o[0] === SC ? n++ : o[0] === RT ? (aP(t, o[1], n), n++) : o[0] === DT && cP(t, n);
      });
    }, lP = (e) => Qe(W(ho(e.childNodes), OT), (t) => t.length > 0), uP = (e, t) => {
      const n = W(ho(t.childNodes), OT);
      return iP(sP(n, e), t), t;
    }, fP = rn(() => document.implementation.createHTMLDocument("undo")), dP = (e) => e.indexOf("</iframe>") !== -1, mP = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), pP = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), B1 = (e) => {
      const t = lP(e.getBody()), n = Xt(t, (s) => {
        const a = $x(e.serializer, s);
        return a.length > 0 ? [a] : [];
      }), o = n.join("");
      return dP(o) ? mP(n) : pP(o);
    }, xC = (e, t, n) => {
      const o = n ? t.beforeBookmark : t.bookmark;
      t.type === "fragmented" ? uP(t.fragments, e.getBody()) : e.setContent(t.content, {
        format: "raw",
        no_selection: L(o) && vg(o) ? !o.isFakeCaret : !0
      }), e.selection.moveToBookmark(o);
    }, EC = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, PT = (e) => {
      const t = ne.fromTag("body", fP());
      return hi(t, EC(e)), M(br(t, "*[data-mce-bogus]"), Es), of(t);
    }, gP = (e, t) => EC(e) === EC(t), hP = (e, t) => PT(e) === PT(t), TC = (e, t) => !e || !t ? !1 : gP(e, t) ? !0 : hP(e, t), zC = (e) => e.get() === 0, $1 = (e, t, n) => {
      zC(n) && (e.typing = t);
    }, BT = (e, t) => {
      e.typing && ($1(e, !1, t), e.add());
    }, yP = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, bP = (e, t, n) => {
      zC(t) && n.set(vy(e.selection));
    }, kP = (e, t, n, o, s, a, i) => {
      const u = B1(e);
      if (a = a || {}, a = nt.extend(a, u), zC(o) === !1 || e.removed)
        return null;
      const d = t.data[n.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: a,
        lastLevel: d,
        originalEvent: i
      }).isDefaultPrevented() || d && TC(d, a))
        return null;
      t.data[n.get()] && s.get().each((T) => {
        t.data[n.get()].beforeBookmark = T;
      });
      const y = w_(e);
      if (y && t.data.length > y) {
        for (let T = 0; T < t.data.length - 1; T++)
          t.data[T] = t.data[T + 1];
        t.data.length--, n.set(t.data.length);
      }
      a.bookmark = vy(e.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(a), n.set(t.data.length - 1);
      const v = {
        level: a,
        lastLevel: d,
        originalEvent: i
      };
      return n.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", v), e.dispatch("change", v)) : e.dispatch("AddUndo", v), a;
    }, wP = (e, t, n) => {
      t.data = [], n.set(0), t.typing = !1, e.dispatch("ClearUndos");
    }, _P = (e, t, n, o, s) => {
      if (t.transact(o)) {
        const a = t.data[n.get()].bookmark, i = t.data[n.get() - 1];
        xC(e, i, !0), t.transact(s) && (t.data[n.get() - 1].beforeBookmark = a);
      }
    }, vP = (e, t, n) => {
      let o;
      return t.get() < n.length - 1 && (t.set(t.get() + 1), o = n[t.get()], xC(e, o, !1), e.setDirty(!0), e.dispatch("Redo", { level: o })), o;
    }, CP = (e, t, n, o) => {
      let s;
      return t.typing && (t.add(), t.typing = !1, $1(t, !1, n)), o.get() > 0 && (o.set(o.get() - 1), s = t.data[o.get()], xC(e, s, !0), e.setDirty(!0), e.dispatch("Undo", { level: s })), s;
    }, SP = (e) => {
      e.clear(), e.add();
    }, xP = (e, t, n) => n.get() > 0 || t.typing && t.data[0] && !TC(B1(e), t.data[0]), EP = (e, t) => t.get() < e.data.length - 1 && !e.typing, TP = (e, t, n) => (BT(e, t), e.beforeChange(), e.ignore(n), e.add()), zP = (e, t) => {
      try {
        e.set(e.get() + 1), t();
      } finally {
        e.set(e.get() - 1);
      }
    }, AP = (e, t) => {
      const n = e.dom, o = L(t) ? t : e.getBody();
      Le(e.hasVisual) && (e.hasVisual = v_(e)), M(n.select("table,a", o), (s) => {
        switch (s.nodeName) {
          case "TABLE":
            const a = C_(e), i = n.getAttrib(s, "border");
            (!i || i === "0") && e.hasVisual ? n.addClass(s, a) : n.removeClass(s, a);
            break;
          case "A":
            if (!n.getAttrib(s, "href")) {
              const u = n.getAttrib(s, "name") || s.id, d = Hy(e);
              u && e.hasVisual ? n.addClass(s, d) : n.removeClass(s, d);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: t,
        hasVisual: e.hasVisual
      });
    }, $T = (e) => ({
      init: { bindEvents: ye },
      undoManager: {
        beforeChange: (t, n) => bP(e, t, n),
        add: (t, n, o, s, a, i) => kP(e, t, n, o, s, a, i),
        undo: (t, n, o) => CP(e, t, n, o),
        redo: (t, n) => vP(e, t, n),
        clear: (t, n) => wP(e, t, n),
        reset: (t) => SP(t),
        hasUndo: (t, n) => xP(e, t, n),
        hasRedo: (t, n) => EP(t, n),
        transact: (t, n, o) => TP(t, n, o),
        ignore: (t, n) => zP(t, n),
        extra: (t, n, o, s) => _P(e, t, n, o, s)
      },
      formatter: {
        match: (t, n, o, s) => nC(e, t, n, o, s),
        matchAll: (t, n) => U5(e, t, n),
        matchNode: (t, n, o, s) => Ii(e, t, n, o, s),
        canApply: (t) => W5(e, t),
        closest: (t) => H5(e, t),
        apply: (t, n, o) => XE(e, t, n, o),
        remove: (t, n, o, s) => KE(e, t, n, o, s),
        toggle: (t, n, o) => E3(e, t, n, o),
        formatChanged: (t, n, o, s, a) => x3(e, t, n, o, s, a)
      },
      editor: {
        getContent: (t) => _R(e, t),
        setContent: (t, n) => L5(e, t, n),
        insertContent: (t, n) => B5(e, t, n),
        addVisual: (t) => AP(e, t)
      },
      selection: { getContent: (t, n) => oP(e, t, n) },
      autocompleter: {
        addDecoration: (t) => Sv(e, t),
        removeDecoration: () => Zf(e, ne.fromDom(e.getBody()))
      },
      raw: { getModel: () => w.none() }
    }), NP = (e) => {
      const t = (y) => zt(y) ? y : {}, { init: n, undoManager: o, formatter: s, editor: a, selection: i, autocompleter: u, raw: d } = e;
      return {
        init: { bindEvents: n.bindEvents },
        undoManager: {
          beforeChange: o.beforeChange,
          add: o.add,
          undo: o.undo,
          redo: o.redo,
          clear: o.clear,
          reset: o.reset,
          hasUndo: o.hasUndo,
          hasRedo: o.hasRedo,
          transact: (y, v, T) => o.transact(T),
          ignore: (y, v) => o.ignore(v),
          extra: (y, v, T, N) => o.extra(T, N)
        },
        formatter: {
          match: (y, v, T, N) => s.match(y, t(v), N),
          matchAll: s.matchAll,
          matchNode: s.matchNode,
          canApply: (y) => s.canApply(y),
          closest: (y) => s.closest(y),
          apply: (y, v, T) => s.apply(y, t(v)),
          remove: (y, v, T, N) => s.remove(y, t(v)),
          toggle: (y, v, T) => s.toggle(y, t(v)),
          formatChanged: (y, v, T, N, F) => s.formatChanged(v, T, N, F)
        },
        editor: {
          getContent: (y) => a.getContent(y),
          setContent: (y, v) => ({
            content: a.setContent(y, v),
            html: ""
          }),
          insertContent: (y, v) => (a.insertContent(y), ""),
          addVisual: a.addVisual
        },
        selection: { getContent: (y, v) => i.getContent(v) },
        autocompleter: {
          addDecoration: u.addDecoration,
          removeDecoration: u.removeDecoration
        },
        raw: { getModel: () => w.some(d.getRawModel()) }
      };
    }, RP = () => {
      const e = Z(null), t = Z("");
      return {
        init: { bindEvents: ye },
        undoManager: {
          beforeChange: ye,
          add: e,
          undo: e,
          redo: e,
          clear: ye,
          reset: ye,
          hasUndo: cn,
          hasRedo: cn,
          transact: e,
          ignore: ye,
          extra: ye
        },
        formatter: {
          match: cn,
          matchAll: Z([]),
          matchNode: Z(void 0),
          canApply: cn,
          closest: t,
          apply: ye,
          remove: ye,
          toggle: ye,
          formatChanged: Z({ unbind: ye })
        },
        editor: {
          getContent: t,
          setContent: Z({
            content: "",
            html: ""
          }),
          insertContent: Z(""),
          addVisual: ye
        },
        selection: { getContent: t },
        autocompleter: {
          addDecoration: ye,
          removeDecoration: ye
        },
        raw: { getModel: Z(w.none()) }
      };
    }, $l = (e) => gn(e.plugins, "rtc"), DP = (e) => Vn(e.plugins, "rtc").bind((t) => w.from(t.setup)), OP = (e) => {
      const t = e;
      return DP(e).fold(() => (t.rtcInstance = $T(e), w.none()), (n) => (t.rtcInstance = RP(), w.some(() => n().then((o) => (t.rtcInstance = NP(o), o.rtc.isRemote)))));
    }, AC = (e) => e.rtcInstance ? e.rtcInstance : $T(e), Cs = (e) => {
      const t = e.rtcInstance;
      if (t)
        return t;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, PP = (e, t, n) => {
      Cs(e).undoManager.beforeChange(t, n);
    }, BP = (e, t, n, o, s, a, i) => Cs(e).undoManager.add(t, n, o, s, a, i), $P = (e, t, n, o) => Cs(e).undoManager.undo(t, n, o), FP = (e, t, n) => Cs(e).undoManager.redo(t, n), IP = (e, t, n) => {
      Cs(e).undoManager.clear(t, n);
    }, LP = (e, t) => {
      Cs(e).undoManager.reset(t);
    }, MP = (e, t, n) => Cs(e).undoManager.hasUndo(t, n), jP = (e, t, n) => Cs(e).undoManager.hasRedo(t, n), UP = (e, t, n, o) => Cs(e).undoManager.transact(t, n, o), HP = (e, t, n) => {
      Cs(e).undoManager.ignore(t, n);
    }, WP = (e, t, n, o, s) => {
      Cs(e).undoManager.extra(t, n, o, s);
    }, qP = (e, t, n, o, s) => Cs(e).formatter.match(t, n, o, s), VP = (e, t, n) => Cs(e).formatter.matchAll(t, n), GP = (e, t, n, o, s) => Cs(e).formatter.matchNode(t, n, o, s), KP = (e, t) => Cs(e).formatter.canApply(t), YP = (e, t) => Cs(e).formatter.closest(t), XP = (e, t, n, o) => {
      Cs(e).formatter.apply(t, n, o);
    }, ZP = (e, t, n, o, s) => {
      Cs(e).formatter.remove(t, n, o, s);
    }, QP = (e, t, n, o) => {
      Cs(e).formatter.toggle(t, n, o);
    }, JP = (e, t, n, o, s, a) => Cs(e).formatter.formatChanged(t, n, o, s, a), e9 = (e, t) => AC(e).editor.getContent(t), t9 = (e, t, n) => AC(e).editor.setContent(t, n), n9 = (e, t, n) => AC(e).editor.insertContent(t, n), o9 = (e, t, n) => Cs(e).selection.getContent(t, n), s9 = (e, t) => Cs(e).editor.addVisual(t), FT = (e) => Cs(e).init.bindEvents(), r9 = (e, t) => Cs(e).autocompleter.addDecoration(t), a9 = (e) => Cs(e).autocompleter.removeDecoration(), c9 = (e, t = {}) => {
      const n = t.format ? t.format : "html";
      return o9(e, n, t);
    }, IT = (e) => e.dom.length === 0 ? (Do(e), w.none()) : w.some(e), i9 = (e, t) => e.filter((n) => Wf.isBookmarkNode(n.dom)).bind(t ? di : Fa), l9 = (e, t, n, o) => {
      const s = e.dom, a = t.dom, i = o ? s.length : a.length;
      o ? (Pv(s, a, !1, !o), n.setStart(a, i)) : (Pv(a, s, !1, !o), n.setEnd(a, i));
    }, u9 = (e, t) => {
      er(e).each((n) => {
        const o = e.dom;
        t && b1(n, je(o, 0)) ? w1(o, 0) : !t && k1(n, je(o, o.length)) && Ov(o, o.length);
      });
    }, LT = (e, t, n, o) => {
      e.bind((s) => ((o ? Ov : w1)(s.dom, o ? s.dom.length : 0), t.filter(ko).map((i) => l9(s, i, n, o)))).orThunk(() => i9(t, o).or(t).filter(ko).map((a) => u9(a, o)));
    }, f9 = (e, t) => {
      const n = w.from(t.firstChild).map(ne.fromDom), o = w.from(t.lastChild).map(ne.fromDom);
      e.deleteContents(), e.insertNode(t);
      const s = n.bind(Fa).filter(ko).bind(IT), a = o.bind(di).filter(ko).bind(IT);
      LT(s, n, e, !0), LT(a, o, e, !1), e.collapse(!1);
    }, d9 = (e, t) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: t
    }), m9 = (e, t) => {
      if (t.format !== "raw") {
        const n = e.selection.getRng(), o = e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock), s = o ? { context: o.nodeName.toLowerCase() } : {}, a = e.parser.parse(t.content, {
          forced_root_block: !1,
          ...s,
          ...t
        });
        return qu({ validate: !1 }, e.schema).serialize(a);
      } else
        return t.content;
    }, p9 = (e, t, n = {}) => {
      const o = d9(n, t);
      _C(e, o).each((s) => {
        const a = m9(e, s), i = e.selection.getRng();
        f9(i, i.createContextualFragment(a)), e.selection.setRng(i), Uu(e, i), vC(e, a, s);
      });
    }, MT = (e, t, n) => {
      if (e && gn(e, t)) {
        const o = Qe(e[t], (s) => s !== n);
        o.length === 0 ? delete e[t] : e[t] = o;
      }
    };
    var g9 = (e, t) => {
      let n, o;
      const s = (i, u) => oo(u, (d) => e.is(d, i)), a = (i) => e.getParents(i, null, e.getRoot());
      return {
        selectorChangedWithUnbind: (i, u) => (n || (n = {}, o = {}, t.on("NodeChange", (d) => {
          const y = d.element, v = a(y), T = {};
          nt.each(n, (N, F) => {
            s(F, v).each((U) => {
              o[F] || (M(N, (j) => {
                j(!0, {
                  node: U,
                  selector: F,
                  parents: v
                });
              }), o[F] = N), T[F] = N;
            });
          }), nt.each(o, (N, F) => {
            T[F] || (delete o[F], nt.each(N, (U) => {
              U(!1, {
                node: y,
                selector: F,
                parents: v
              });
            }));
          });
        })), n[i] || (n[i] = []), n[i].push(u), s(i, a(t.selection.getStart())).each(() => {
          o[i] = n[i];
        }), {
          unbind: () => {
            MT(n, i, u), MT(o, i, u);
          }
        })
      };
    };
    const jT = (e) => !!(e && e.ownerDocument) && ws(ne.fromDom(e.ownerDocument), ne.fromDom(e)), h9 = (e) => e ? jT(e.startContainer) && jT(e.endContainer) : !1, UT = (e, t, n, o) => {
      let s, a;
      const { selectorChangedWithUnbind: i } = g9(e, o), u = (Nt, fn) => {
        const no = e.createRng();
        L(Nt) && L(fn) ? (no.setStart(Nt, fn), no.setEnd(Nt, fn), Se(no), H(!1)) : (Dm(e, no, o.getBody(), !0), Se(no));
      }, d = (Nt) => c9(o, Nt), y = (Nt, fn) => p9(o, Nt, fn), v = (Nt) => Oo(o.getBody(), ve(), Nt), T = (Nt) => dr(o.getBody(), ve(), Nt), N = (Nt, fn) => Fo.getBookmark(Nt, fn), F = (Nt) => Fo.moveToBookmark(Nt), U = (Nt, fn) => (Wu(e, Nt, fn).each(Se), Nt), j = () => {
        const Nt = ve(), fn = se();
        return !Nt || Nt.item ? !1 : Nt.compareEndPoints ? Nt.compareEndPoints("StartToEnd", Nt) === 0 : !fn || Nt.collapsed;
      }, H = (Nt) => {
        const fn = ve();
        fn.collapse(!!Nt), Se(fn);
      }, se = () => t.getSelection ? t.getSelection() : t.document.selection, ve = () => {
        let Nt, fn, no;
        const Qn = (Mt, _n, on) => {
          try {
            return _n.compareBoundaryPoints(Mt, on);
          } catch {
            return -1;
          }
        }, Gs = t.document;
        if (o.bookmark !== void 0 && Yo(o) === !1) {
          const Mt = Zm(o);
          if (Mt.isSome())
            return Mt.map((_n) => or(o, [_n])[0]).getOr(Gs.createRange());
        }
        try {
          (Nt = se()) && !ki(Nt.anchorNode) && (Nt.rangeCount > 0 ? fn = Nt.getRangeAt(0) : fn = Nt.createRange ? Nt.createRange() : Gs.createRange(), fn = or(o, [fn])[0]);
        } catch {
        }
        return fn || (fn = Gs.createRange()), fn.setStart && fn.startContainer.nodeType === 9 && fn.collapsed && (no = e.getRoot(), fn.setStart(no, 0), fn.setEnd(no, 0)), s && a && (Qn(fn.START_TO_START, fn, s) === 0 && Qn(fn.END_TO_END, fn, s) === 0 ? fn = a : (s = null, a = null)), fn;
      }, Se = (Nt, fn) => {
        let no;
        if (!h9(Nt))
          return;
        const Qn = se();
        if (Nt = o.dispatch("SetSelectionRange", {
          range: Nt,
          forward: fn
        }).range, Qn) {
          a = Nt;
          try {
            Qn.removeAllRanges(), Qn.addRange(Nt);
          } catch {
          }
          fn === !1 && Qn.extend && (Qn.collapse(Nt.endContainer, Nt.endOffset), Qn.extend(Nt.startContainer, Nt.startOffset)), s = Qn.rangeCount > 0 ? Qn.getRangeAt(0) : null;
        }
        !Nt.collapsed && Nt.startContainer === Nt.endContainer && Qn.setBaseAndExtent && Nt.endOffset - Nt.startOffset < 2 && Nt.startContainer.hasChildNodes() && (no = Nt.startContainer.childNodes[Nt.startOffset], no && no.tagName === "IMG" && (Qn.setBaseAndExtent(Nt.startContainer, Nt.startOffset, Nt.endContainer, Nt.endOffset), (Qn.anchorNode !== Nt.startContainer || Qn.focusNode !== Nt.endContainer) && Qn.setBaseAndExtent(no, 0, no, 1))), o.dispatch("AfterSetSelectionRange", {
          range: Nt,
          forward: fn
        });
      }, Be = (Nt) => (y(e.getOuterHTML(Nt)), Nt), at = () => Va(o.getBody(), ve()), Vt = (Nt, fn) => Ea(e, ve(), Nt, fn), lt = () => {
        const Nt = se(), fn = Nt == null ? void 0 : Nt.anchorNode, no = Nt == null ? void 0 : Nt.focusNode;
        if (!Nt || !fn || !no || ki(fn) || ki(no))
          return !0;
        const Qn = e.createRng(), Gs = e.createRng();
        try {
          Qn.setStart(fn, Nt.anchorOffset), Qn.collapse(!0), Gs.setStart(no, Nt.focusOffset), Gs.collapse(!0);
        } catch {
          return !0;
        }
        return Qn.compareBoundaryPoints(Qn.START_TO_START, Gs) <= 0;
      }, Co = {
        bookmarkManager: null,
        controlSelection: null,
        dom: e,
        win: t,
        serializer: n,
        editor: o,
        collapse: H,
        setCursorLocation: u,
        getContent: d,
        setContent: y,
        getBookmark: N,
        moveToBookmark: F,
        select: U,
        isCollapsed: j,
        isForward: lt,
        setNode: Be,
        getNode: at,
        getSel: se,
        setRng: Se,
        getRng: ve,
        getStart: v,
        getEnd: T,
        getSelectedBlocks: Vt,
        normalize: () => {
          const Nt = ve(), fn = se();
          if (!g0(fn) && Om(o)) {
            const no = Vm(e, Nt);
            return no.each((Qn) => {
              Se(Qn, lt());
            }), no.getOr(Nt);
          }
          return Nt;
        },
        selectorChanged: (Nt, fn) => (i(Nt, fn), Co),
        selectorChangedWithUnbind: i,
        getScrollContainer: () => {
          let Nt, fn = e.getRoot();
          for (; fn && fn.nodeName !== "BODY"; ) {
            if (fn.scrollHeight > fn.clientHeight) {
              Nt = fn;
              break;
            }
            fn = fn.parentNode;
          }
          return Nt;
        },
        scrollIntoView: (Nt, fn) => {
          L(Nt) ? Gg(o, Nt, fn) : Uu(o, ve(), fn);
        },
        placeCaretAt: (Nt, fn) => Se(Sa(Nt, fn, o.getDoc())),
        getBoundingClientRect: () => {
          const Nt = ve();
          return Nt.collapsed ? je.fromRangeStart(Nt).getClientRects()[0] : Nt.getBoundingClientRect();
        },
        destroy: () => {
          t = s = a = null, Ls.destroy();
        }
      }, Fo = Wf(Co), Ls = Kb(Co, o);
      return Co.bookmarkManager = Fo, Co.controlSelection = Ls, Co;
    }, y9 = (e, t, n) => {
      e.addAttributeFilter("data-mce-tabindex", (o, s) => {
        let a = o.length;
        for (; a--; ) {
          const i = o[a];
          i.attr("tabindex", i.attr("data-mce-tabindex")), i.attr(s, null);
        }
      }), e.addAttributeFilter("src,href,style", (o, s) => {
        const a = "data-mce-" + s, i = t.url_converter, u = t.url_converter_scope;
        let d = o.length;
        for (; d--; ) {
          const y = o[d];
          let v = y.attr(a);
          v !== void 0 ? (y.attr(s, v.length > 0 ? v : null), y.attr(a, null)) : (v = y.attr(s), s === "style" ? v = n.serializeStyle(n.parseStyle(v), y.name) : i && (v = i.call(u, v, s, y.name)), y.attr(s, v.length > 0 ? v : null));
        }
      }), e.addAttributeFilter("class", (o) => {
        let s = o.length;
        for (; s--; ) {
          const a = o[s];
          let i = a.attr("class");
          i && (i = a.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), a.attr("class", i.length > 0 ? i : null));
        }
      }), e.addAttributeFilter("data-mce-type", (o, s, a) => {
        let i = o.length;
        for (; i--; ) {
          const u = o[i];
          u.attr("data-mce-type") === "bookmark" && !a.cleanup && (w.from(u.firstChild).exists((y) => !h(y.value)) ? u.unwrap() : u.remove());
        }
      }), e.addNodeFilter("noscript", (o) => {
        let s = o.length;
        for (; s--; ) {
          const a = o[s].firstChild;
          a && (a.value = zi.decode(a.value));
        }
      }), e.addNodeFilter("script,style", (o, s) => {
        const a = (u) => u.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let i = o.length;
        for (; i--; ) {
          const u = o[i], d = u.firstChild ? u.firstChild.value : "";
          if (s === "script") {
            const y = u.attr("type");
            y && u.attr("type", y === "mce-no/type" ? null : y.replace(/^mce\-/, "")), t.element_format === "xhtml" && d.length > 0 && (u.firstChild.value = `// <![CDATA[
` + a(d) + `
// ]]>`);
          } else
            t.element_format === "xhtml" && d.length > 0 && (u.firstChild.value = `<!--
` + a(d) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (o) => {
        let s = o.length;
        for (; s--; ) {
          const a = o[s];
          t.preserve_cdata && a.value.indexOf("[CDATA[") === 0 ? (a.name = "#cdata", a.type = 4, a.value = n.decode(a.value.replace(/^\[CDATA\[|\]\]$/g, ""))) : a.value.indexOf("mce:protected ") === 0 && (a.name = "#text", a.type = 3, a.raw = !0, a.value = unescape(a.value).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (o, s) => {
        let a = o.length;
        for (; a--; ) {
          const i = o[a];
          i.type === 7 ? i.remove() : i.type === 1 && s === "input" && !i.attr("type") && i.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (o) => {
        M(o, (s) => {
          s.attr("data-mce-type") === "format-caret" && (s.isEmpty(e.schema.getNonEmptyElements()) ? s.remove() : s.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", (o, s) => {
        let a = o.length;
        for (; a--; )
          o[a].attr(s, null);
      });
    }, b9 = (e) => {
      const t = (o) => o && o.name === "br", n = e.lastChild;
      if (t(n)) {
        const o = n.prev;
        t(o) && (n.remove(), o.remove());
      }
    }, k9 = (e, t, n) => {
      let o;
      const s = e.dom;
      let a = t.cloneNode(!0);
      const i = document.implementation;
      if (i.createHTMLDocument) {
        const u = i.createHTMLDocument("");
        nt.each(a.nodeName === "BODY" ? a.childNodes : [a], (d) => {
          u.body.appendChild(u.importNode(d, !0));
        }), a.nodeName !== "BODY" ? a = u.body.firstChild : a = u.body, o = s.doc, s.doc = u;
      }
      return _0(e, {
        ...n,
        node: a
      }), o && (s.doc = o), a;
    }, w9 = (e, t) => e && e.hasEventListeners("PreProcess") && !t.no_events, _9 = (e, t, n) => w9(e, n) ? k9(e, t, n) : t, v9 = (e, t, n) => {
      nt.inArray(t, n) === -1 && (e.addAttributeFilter(n, (o, s) => {
        let a = o.length;
        for (; a--; )
          o[a].attr(s, null);
      }), t.push(n));
    }, C9 = (e, t, n) => !t.no_events && e ? v0(e, {
      ...t,
      content: n
    }).content : n, S9 = (e, t, n) => {
      const o = E(n.getInner ? t.innerHTML : e.getOuterHTML(t));
      return n.selection || nu(ne.fromDom(t)) ? o : nt.trim(o);
    }, x9 = (e, t, n) => {
      const o = n.selection ? {
        forced_root_block: !1,
        ...n
      } : n, s = e.parse(t, o);
      return b9(s), s;
    }, E9 = (e, t, n) => qu(e, t).serialize(n), T9 = (e, t, n, o, s) => {
      const a = E9(t, n, o);
      return C9(e, s, a);
    }, z9 = (e, t) => {
      const n = ["data-mce-selected"], o = t && t.dom ? t.dom : Uo.DOM, s = t && t.schema ? t.schema : Ai(e);
      e.entity_encoding = e.entity_encoding || "named", e.remove_trailing_brs = "remove_trailing_brs" in e ? e.remove_trailing_brs : !0;
      const a = np(e, s);
      y9(a, e, o);
      const i = (u, d = {}) => {
        const y = {
          format: "html",
          ...d
        }, v = _9(t, u, y), T = S9(o, v, y), N = x9(a, T, y);
        return y.format === "tree" ? N : T9(t, e, s, N, y);
      };
      return {
        schema: s,
        addNodeFilter: a.addNodeFilter,
        addAttributeFilter: a.addAttributeFilter,
        serialize: i,
        addRules: s.addValidElements,
        setRules: s.setValidElements,
        addTempAttr: et(v9, a, n),
        getTempAttrs: Z(n),
        getNodeFilters: a.getNodeFilters,
        getAttributeFilters: a.getAttributeFilters,
        removeNodeFilter: a.removeNodeFilter,
        removeAttributeFilter: a.removeAttributeFilter
      };
    }, HT = (e, t) => {
      const n = z9(e, t);
      return {
        schema: n.schema,
        addNodeFilter: n.addNodeFilter,
        addAttributeFilter: n.addAttributeFilter,
        serialize: n.serialize,
        addRules: n.addRules,
        setRules: n.setRules,
        addTempAttr: n.addTempAttr,
        getTempAttrs: n.getTempAttrs,
        getNodeFilters: n.getNodeFilters,
        getAttributeFilters: n.getAttributeFilters,
        removeNodeFilter: n.removeNodeFilter,
        removeAttributeFilter: n.removeAttributeFilter
      };
    }, A9 = "html", N9 = (e, t) => ({
      ...e,
      format: t,
      get: !0,
      getInner: !0
    }), R9 = (e, t = {}) => {
      const n = t.format ? t.format : A9, o = N9(t, n);
      return vT(e, o).fold(Pe, (s) => {
        const a = e9(e, s);
        return CT(e, a, s);
      });
    }, D9 = "html", O9 = (e, t) => ({
      format: D9,
      ...e,
      set: !0,
      content: t
    }), NC = (e, t, n = {}) => {
      const o = O9(n, t);
      return _C(e, o).map((s) => {
        const a = t9(e, s.content, s);
        return vC(e, a.html, s), a.content;
      }).getOr(t);
    }, P9 = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), B9 = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), $9 = (e) => {
      const t = Qe(P9, (o) => gn(e, o)), n = e.forced_root_block;
      return (n === !1 || n === "") && t.push("forced_root_block (false only)"), Qt(t);
    }, F9 = (e) => {
      const t = nt.makeMap(e.plugins, " "), o = Qe(B9, (s) => gn(t, s));
      return Qt(o);
    }, I9 = (e, t) => {
      const n = $9(e), o = F9(t), s = o.length > 0, a = n.length > 0, i = t.theme === "mobile";
      if (s || a || i) {
        const u = `
- `, d = i ? `

Themes:${u}mobile` : "", y = s ? `

Plugins:${u}${o.join(u)}` : "", v = a ? `

Options:${u}${n.join(u)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + d + y + v);
      }
    }, L9 = (e, t) => {
      I9(e, t);
    }, F1 = Uo.DOM, M9 = (e) => {
      F1.setStyle(e.id, "display", e.orgDisplay);
    }, I1 = (e) => w.from(e).each((t) => t.destroy()), j9 = (e) => {
      e.contentAreaContainer = e.formElement = e.container = e.editorContainer = null, e.bodyElement = e.contentDocument = e.contentWindow = null, e.iframeElement = e.targetElm = null, e.selection && (e.selection = e.selection.win = e.selection.dom = e.selection.dom.doc = null);
    }, U9 = (e) => {
      const t = e.formElement;
      t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, t._mceOldSubmit = null), F1.unbind(t, "submit reset", e.formEventDelegate));
    }, H9 = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: t, editorUpload: n } = e, o = e.getBody(), s = e.getElement();
        o && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && s && F1.remove(s.nextSibling), C0(e), e.editorManager.remove(e), !e.inline && o && M9(e), S0(e), F1.remove(e.getContainer()), I1(t), I1(n), e.destroy();
      }
    }, W9 = (e, t) => {
      const { selection: n, dom: o } = e;
      if (!e.destroyed) {
        if (!t && !e.removed) {
          e.remove();
          return;
        }
        t || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), I1(n), I1(o)), U9(e), j9(e), e.destroyed = !0;
      }
    }, L1 = (() => {
      const e = {};
      return {
        add: (s, a) => {
          e[s] = a;
        },
        get: (s) => e[s] ? e[s] : { icons: {} },
        has: (s) => gn(e, s)
      };
    })(), op = fr.ModelManager, WT = (e, t) => t.dom[e], qT = (e, t) => parseInt(Hs(t, e), 10), q9 = et(WT, "clientWidth"), V9 = et(WT, "clientHeight"), G9 = et(qT, "margin-top"), K9 = et(qT, "margin-left"), Y9 = (e) => e.dom.getBoundingClientRect(), X9 = (e, t, n) => {
      const o = q9(e), s = V9(e);
      return t >= 0 && n >= 0 && t <= o && n <= s;
    }, Z9 = (e, t, n, o) => {
      const s = Y9(t), a = e ? s.left + t.dom.clientLeft + K9(t) : 0, i = e ? s.top + t.dom.clientTop + G9(t) : 0, u = n - a, d = o - i;
      return {
        x: u,
        y: d
      };
    }, Q9 = (e, t, n) => {
      const o = ne.fromDom(e.getBody()), s = e.inline ? o : Vl(o), a = Z9(e.inline, s, t, n);
      return X9(s, a.x, a.y);
    }, J9 = (e) => w.from(e).map(ne.fromDom), eB = (e) => {
      const t = e.inline ? e.getBody() : e.getContentAreaContainer();
      return J9(t).map(On).getOr(!1);
    }, tB = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    }, VT = (e) => {
      const t = [], n = () => {
        const N = e.theme;
        return N && N.getNotificationManagerImpl ? N.getNotificationManagerImpl() : tB();
      }, o = () => w.from(t[0]), s = (N, F) => N.type === F.type && N.text === F.text && !N.progressBar && !N.timeout && !F.progressBar && !F.timeout, a = () => {
        M(t, (N) => {
          N.reposition();
        });
      }, i = (N) => {
        t.push(N);
      }, u = (N) => {
        Yn(t, (F) => F === N).each((F) => {
          t.splice(F, 1);
        });
      }, d = (N, F = !0) => {
        if (!(e.removed || !eB(e)))
          return F && e.dispatch("BeforeOpenNotification", { notification: N }), oo(t, (U) => s(n().getArgs(U), N)).getOrThunk(() => {
            e.editorManager.setActive(e);
            const U = n().open(N, () => {
              u(U), a(), o().fold(() => e.focus(), (j) => c1(ne.fromDom(j.getEl())));
            });
            return i(U), a(), e.dispatch("OpenNotification", { notification: { ...U } }), U;
          });
      }, y = () => {
        o().each((N) => {
          n().close(N), u(N), a();
        });
      }, v = Z(t);
      return ((N) => {
        N.on("SkinLoaded", () => {
          const F = f_(N);
          F && d({
            text: F,
            type: "warning",
            timeout: 0
          }, !1), a();
        }), N.on("show ResizeEditor ResizeWindow NodeChange", () => {
          requestAnimationFrame(a);
        }), N.on("remove", () => {
          M(t.slice(), (F) => {
            n().close(F);
          });
        });
      })(e), {
        open: d,
        close: y,
        getNotifications: v
      };
    }, sp = fr.PluginManager, nd = fr.ThemeManager;
    var nB = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e,
        getParams: e,
        setParams: e
      };
    };
    const GT = (e) => {
      let t = [];
      const n = () => {
        const j = e.theme;
        return j && j.getWindowManagerImpl ? j.getWindowManagerImpl() : nB();
      }, o = (j, H) => (...se) => H ? H.apply(j, se) : void 0, s = (j) => {
        e.dispatch("OpenWindow", { dialog: j });
      }, a = (j) => {
        e.dispatch("CloseWindow", { dialog: j });
      }, i = (j) => {
        t.push(j), s(j);
      }, u = (j) => {
        a(j), t = Qe(t, (H) => H !== j), t.length === 0 && e.focus();
      }, d = () => w.from(t[t.length - 1]), y = (j) => {
        e.editorManager.setActive(e), Yg(e), e.ui.show();
        const H = j();
        return i(H), H;
      }, v = (j, H) => y(() => n().open(j, H, u)), T = (j) => y(() => n().openUrl(j, u)), N = (j, H, se) => {
        const ve = n();
        ve.alert(j, o(se || ve, H));
      }, F = (j, H, se) => {
        const ve = n();
        ve.confirm(j, o(se || ve, H));
      }, U = () => {
        d().each((j) => {
          n().close(j), u(j);
        });
      };
      return e.on("remove", () => {
        M(t, (j) => {
          n().close(j);
        });
      }), {
        open: v,
        openUrl: T,
        alert: N,
        confirm: F,
        close: U
      };
    }, KT = (e, t) => {
      e.notificationManager.open({
        type: "error",
        text: t
      });
    }, M1 = (e, t) => {
      e._skinLoaded ? KT(e, t) : e.on("SkinLoaded", () => {
        KT(e, t);
      });
    }, oB = (e, t) => {
      M1(e, Mr.translate([
        "Failed to upload image: {0}",
        t
      ]));
    }, rh = (e, t, n) => {
      Mb(e, t, { message: n }), console.error(n);
    }, ah = (e, t, n) => n ? `Failed to load ${e}: ${n} from url ${t}` : `Failed to load ${e} url: ${t}`, sB = (e, t, n) => {
      rh(e, "PluginLoadError", ah("plugin", t, n));
    }, rB = (e, t, n) => {
      rh(e, "IconsLoadError", ah("icons", t, n));
    }, aB = (e, t, n) => {
      rh(e, "LanguageLoadError", ah("language", t, n));
    }, cB = (e, t, n) => {
      rh(e, "ThemeLoadError", ah("theme", t, n));
    }, iB = (e, t, n) => {
      rh(e, "ModelLoadError", ah("model", t, n));
    }, lB = (e, t, n) => {
      const o = Mr.translate([
        "Failed to initialize plugin: {0}",
        t
      ]);
      Mb(e, "PluginLoadError", { message: o }), j1(o, n), M1(e, o);
    }, j1 = (e, ...t) => {
      const n = window.console;
      n && (n.error ? n.error(e, ...t) : n.log(e, ...t));
    }, uB = (e) => /^[a-z0-9\-]+$/i.test(e), fB = (e) => YT(e, r_(e)), dB = (e) => YT(e, Fy(e)), YT = (e, t) => {
      const n = e.editorManager.baseURL + "/skins/content", s = `content${e.editorManager.suffix}.css`, a = e.inline === !0;
      return W(t, (i) => uB(i) && !a ? `${n}/${i}/${s}` : e.documentBaseURI.toAbsolute(i));
    }, mB = (e) => {
      e.contentCSS = e.contentCSS.concat(fB(e), dB(e));
    }, pB = wn, gB = (e, t, n) => Zl(e, t, pB, n), hB = (e) => e ? ho(e.getElementsByTagName("img")) : [], yB = (e, t) => {
      const n = {};
      return { findAll: (s, a = wn) => {
        const i = Qe(hB(s), (d) => {
          const y = d.src;
          return d.hasAttribute("data-mce-bogus") || d.hasAttribute("data-mce-placeholder") || !y || y === Gn.transparentSrc ? !1 : un(y, "blob:") ? !e.isUploaded(y) && a(d) : un(y, "data:") ? a(d) : !1;
        }), u = W(i, (d) => {
          const y = d.src;
          if (gn(n, y))
            return n[y].then((v) => ge(v) ? v : {
              image: d,
              blobInfo: v.blobInfo
            });
          {
            const v = mO(t, y).then((T) => (delete n[y], {
              image: d,
              blobInfo: T
            })).catch((T) => (delete n[y], T));
            return n[y] = v, v;
          }
        });
        return Promise.all(u);
      } };
    }, XT = () => {
      let n = {};
      const o = (N, F) => ({
        status: N,
        resultUri: F
      }), s = (N) => N in n;
      return {
        hasBlobUri: s,
        getResultUri: (N) => {
          const F = n[N];
          return F ? F.resultUri : null;
        },
        isPending: (N) => s(N) ? n[N].status === 1 : !1,
        isUploaded: (N) => s(N) ? n[N].status === 2 : !1,
        markPending: (N) => {
          n[N] = o(1, null);
        },
        markUploaded: (N, F) => {
          n[N] = o(2, F);
        },
        removeFailed: (N) => {
          delete n[N];
        },
        destroy: () => {
          n = {};
        }
      };
    };
    let bB = 0;
    const kB = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36), t = new Date().getTime();
      return "s" + t.toString(36) + e() + e() + e();
    }, wB = (e) => e + bB++ + kB(), _B = () => {
      let e = [];
      const t = (T) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[T.toLowerCase()] || "dat", n = (T, N, F, U, j) => {
        if (ge(T))
          return o({
            id: T,
            name: U,
            filename: j,
            blob: N,
            base64: F
          });
        if (zt(T))
          return o(T);
        throw new Error("Unknown input type");
      }, o = (T) => {
        if (!T.blob || !T.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const N = T.id || wB("blobid"), F = T.name || N, U = T.blob;
        return {
          id: Z(N),
          name: Z(F),
          filename: Z(T.filename || F + "." + t(U.type)),
          blob: Z(U),
          base64: Z(T.base64),
          blobUri: Z(T.blobUri || URL.createObjectURL(U)),
          uri: Z(T.uri)
        };
      }, s = (T) => {
        i(T.id()) || e.push(T);
      }, a = (T) => oo(e, T).getOrUndefined(), i = (T) => a((N) => N.id() === T);
      return {
        create: n,
        add: s,
        get: i,
        getByUri: (T) => a((N) => N.blobUri() === T),
        getByData: (T, N) => a((F) => F.base64() === T && F.blob().type === N),
        findFirst: a,
        removeByUri: (T) => {
          e = Qe(e, (N) => N.blobUri() === T ? (URL.revokeObjectURL(N.blobUri()), !1) : !0);
        },
        destroy: () => {
          M(e, (T) => {
            URL.revokeObjectURL(T.blobUri());
          }), e = [];
        }
      };
    }, vB = (e, t) => {
      const n = {}, o = (U, j) => U ? U.replace(/\/$/, "") + "/" + j.replace(/^\//, "") : j, s = (U, j) => new Promise((H, se) => {
        const ve = new XMLHttpRequest();
        ve.open("POST", t.url), ve.withCredentials = t.credentials, ve.upload.onprogress = (Be) => {
          j(Be.loaded / Be.total * 100);
        }, ve.onerror = () => {
          se("Image upload failed due to a XHR Transport error. Code: " + ve.status);
        }, ve.onload = () => {
          if (ve.status < 200 || ve.status >= 300) {
            se("HTTP Error: " + ve.status);
            return;
          }
          const Be = JSON.parse(ve.responseText);
          if (!Be || !ge(Be.location)) {
            se("Invalid JSON: " + ve.responseText);
            return;
          }
          H(o(t.basePath, Be.location));
        };
        const Se = new FormData();
        Se.append("file", U.blob(), U.filename()), ve.send(Se);
      }), a = () => new Promise((U) => {
        U([]);
      }), i = (U, j) => ({
        url: j,
        blobInfo: U,
        status: !0
      }), u = (U, j) => ({
        url: "",
        blobInfo: U,
        status: !1,
        error: j
      }), d = (U, j) => {
        nt.each(n[U], (H) => {
          H(j);
        }), delete n[U];
      }, y = (U, j, H) => (e.markPending(U.blobUri()), new Promise((se) => {
        let ve, Se;
        try {
          const Be = () => {
            ve && (ve.close(), Se = ye);
          }, at = (lt) => {
            Be(), e.markUploaded(U.blobUri(), lt), d(U.blobUri(), i(U, lt)), se(i(U, lt));
          }, Vt = (lt) => {
            Be(), e.removeFailed(U.blobUri()), d(U.blobUri(), u(U, lt)), se(u(U, lt));
          };
          Se = (lt) => {
            lt < 0 || lt > 100 || w.from(ve).orThunk(() => w.from(H).map(an)).each((gt) => {
              ve = gt, gt.progressBar.value(lt);
            });
          }, j(U, Se).then(at, (lt) => {
            Vt(ge(lt) ? { message: lt } : lt);
          });
        } catch (Be) {
          se(u(U, Be));
        }
      })), v = (U) => U === s, T = (U) => {
        const j = U.blobUri();
        return new Promise((H) => {
          n[j] = n[j] || [], n[j].push(H);
        });
      }, N = (U, j) => (U = nt.grep(U, (H) => !e.isUploaded(H.blobUri())), Promise.all(nt.map(U, (H) => e.isPending(H.blobUri()) ? T(H) : y(H, t.handler, j)))), F = (U, j) => !t.url && v(t.handler) ? a() : N(U, j);
      return Wt(t.handler) === !1 && (t.handler = s), { upload: F };
    }, ZT = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), QT = (e, t) => vB(t, {
      url: Oy(e),
      basePath: n_(e),
      credentials: Py(e),
      handler: cg(e)
    }), CB = (e) => {
      const t = XT(), n = QT(e, t);
      return { upload: (o, s = !0) => n.upload(o, s ? ZT(e) : void 0) };
    }, SB = (e) => {
      const t = _B();
      let n, o;
      const s = XT(), a = [], i = (Se) => (Be) => e.selection ? Se(Be) : [], u = (Se) => Se + (Se.indexOf("?") === -1 ? "?" : "&") + new Date().getTime(), d = (Se, Be, at) => {
        let Vt = 0;
        do
          Vt = Se.indexOf(Be, Vt), Vt !== -1 && (Se = Se.substring(0, Vt) + at + Se.substr(Vt + Be.length), Vt += at.length - Be.length + 1);
        while (Vt !== -1);
        return Se;
      }, y = (Se, Be, at) => {
        const Vt = `src="${at}"${at === Gn.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return Se = d(Se, `src="${Be}"`, Vt), Se = d(Se, 'data-mce-src="' + Be + '"', 'data-mce-src="' + at + '"'), Se;
      }, v = (Se, Be) => {
        M(e.undoManager.data, (at) => {
          at.type === "fragmented" ? at.fragments = W(at.fragments, (Vt) => y(Vt, Se, Be)) : at.content = y(at.content, Se, Be);
        });
      }, T = (Se, Be) => {
        const at = e.convertURL(Be, "src");
        v(Se.src, Be), es(ne.fromDom(Se), {
          src: lm(e) ? u(Be) : Be,
          "data-mce-src": at
        });
      }, N = () => (n || (n = QT(e, s)), H().then(i((Se) => {
        const Be = W(Se, (at) => at.blobInfo);
        return n.upload(Be, ZT(e)).then(i((at) => {
          const Vt = [];
          let lt = !1;
          const gt = W(at, (Dt, Pt) => {
            const bn = Se[Pt].blobInfo, nn = Se[Pt].image;
            let Ht = !1;
            return Dt.status && Ry(e) ? (Dt.url && !Lt(nn.src, Dt.url) && (lt = !0), t.removeByUri(nn.src), $l(e) || T(nn, Dt.url)) : Dt.error && (Dt.error.remove && (v(nn.getAttribute("src"), Gn.transparentSrc), Vt.push(nn), Ht = !0), oB(e, Dt.error.message)), {
              element: nn,
              status: Dt.status,
              uploadUri: Dt.url,
              blobInfo: bn,
              removed: Ht
            };
          });
          return Vt.length > 0 && !$l(e) ? e.undoManager.transact(() => {
            M(Vt, (Dt) => {
              e.dom.remove(Dt), t.removeByUri(Dt.src);
            });
          }) : lt && e.undoManager.dispatchChange(), gt;
        }));
      }))), F = () => im(e) ? N() : Promise.resolve([]), U = (Se) => ro(a, (Be) => Be(Se)), j = (Se) => {
        a.push(Se);
      }, H = () => (o || (o = yB(s, t)), o.findAll(e.getBody(), U).then(i((Se) => {
        const Be = Qe(Se, (at) => ge(at) ? (M1(e, at), !1) : !0);
        return $l(e) || M(Be, (at) => {
          v(at.image.src, at.blobInfo.blobUri()), at.image.src = at.blobInfo.blobUri(), at.image.removeAttribute("data-mce-src");
        }), Be;
      }))), se = () => {
        t.destroy(), s.destroy(), o = n = null;
      }, ve = (Se) => Se.replace(/src="(blob:[^"]+)"/g, (Be, at) => {
        const Vt = s.getResultUri(at);
        if (Vt)
          return 'src="' + Vt + '"';
        let lt = t.getByUri(at);
        if (lt || (lt = En(e.editorManager.get(), (gt, Dt) => gt || Dt.editorUpload && Dt.editorUpload.blobCache.getByUri(at), null)), lt) {
          const gt = lt.blob();
          return 'src="data:' + gt.type + ";base64," + lt.base64() + '"';
        }
        return Be;
      });
      return e.on("SetContent", () => {
        im(e) ? F() : H();
      }), e.on("RawSaveContent", (Se) => {
        Se.content = ve(Se.content);
      }), e.on("GetContent", (Se) => {
        Se.source_view || Se.format === "raw" || Se.format === "tree" || (Se.content = ve(Se.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (Se) => {
          M(Se, (Be) => {
            const at = Be.attr("src");
            if (t.getByUri(at))
              return;
            const Vt = s.getResultUri(at);
            Vt && Be.attr("src", Vt);
          });
        });
      }), {
        blobCache: t,
        addFilter: j,
        uploadImages: N,
        uploadImagesAuto: F,
        scanForImages: H,
        destroy: se
      };
    }, xB = (e) => {
      const t = e.dom, n = e.schema.type, o = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (s) => {
              t.setStyle(s, "float", null);
            },
            preview: "font-family font-size"
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (s) => {
              t.setStyle(s, "float", null);
            },
            preview: "font-family font-size"
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: (() => {
          const s = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, a = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, i = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return n !== "html4" ? [
            i,
            s,
            a
          ] : [
            s,
            i,
            a
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (s, a, i) => dn(s) && s.hasAttribute("href"),
          onformat: (s, a, i) => {
            nt.each(i, (u, d) => {
              t.setAttrib(s, d, u);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (s) => {
              var a;
              return (a = s == null ? void 0 : s.customValue) !== null && a !== void 0 ? a : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return nt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (s) => {
        o[s] = {
          block: s,
          remove: "all"
        };
      }), o;
    }, JT = {
      remove_similar: !0,
      inherit: !1
    }, rp = {
      selector: "td,th",
      ...JT
    }, EB = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...rp
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...rp
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...rp
      },
      tablecellclass: {
        classes: ["%value"],
        ...rp
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...JT
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...rp
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...rp
      }
    }, TB = Z(EB), zB = (e) => {
      const t = {}, n = (i) => L(i) ? t[i] : t, o = (i) => gn(t, i), s = (i, u) => {
        i && (ge(i) ? (le(u) || (u = [u]), M(u, (d) => {
          Le(d.deep) && (d.deep = !Ur(d)), Le(d.split) && (d.split = !Ur(d) || Fs(d)), Le(d.remove) && Ur(d) && !Fs(d) && (d.remove = "none"), Ur(d) && Fs(d) && (d.mixed = !0, d.block_expand = !0), ge(d.classes) && (d.classes = d.classes.split(/\s+/));
        }), t[i] = u) : Ot(i, (d, y) => {
          s(y, d);
        }));
      }, a = (i) => (i && t[i] && delete t[i], t);
      return s(xB(e)), s(TB()), s(p_(e)), {
        get: n,
        has: o,
        register: s,
        unregister: a
      };
    }, U1 = nt.each, Aa = Uo.DOM, ez = (e, t) => {
      let n, o, s;
      const a = t && t.schema || Ai({}), i = (v, T) => {
        T.classes.length && Aa.addClass(v, T.classes.join(" ")), Aa.setAttribs(v, T.attrs);
      }, u = (v) => {
        o = typeof v == "string" ? {
          name: v,
          classes: [],
          attrs: {}
        } : v;
        const T = Aa.create(o.name);
        return i(T, o), T;
      }, d = (v, T) => {
        const N = typeof v != "string" ? v.nodeName.toLowerCase() : v, F = a.getElementRule(N), U = F && F.parentsRequired;
        return U && U.length ? T && nt.inArray(U, T) !== -1 ? T : U[0] : !1;
      }, y = (v, T, N) => {
        let F, U;
        const j = T.length > 0 && T[0], H = j && j.name, se = d(v, H);
        if (se)
          H === se ? (U = T[0], T = T.slice(1)) : U = se;
        else if (j)
          U = T[0], T = T.slice(1);
        else if (!N)
          return v;
        return U && (F = u(U), F.appendChild(v)), N && (F || (F = Aa.create("div"), F.appendChild(v)), nt.each(N, (ve) => {
          const Se = u(ve);
          F.insertBefore(Se, v);
        })), y(F, T, U && U.siblings);
      };
      return e && e.length ? (o = e[0], n = u(o), s = Aa.create("div"), s.appendChild(y(n, e.slice(1), o.siblings)), s) : "";
    }, AB = (e) => {
      let t;
      const n = {
        classes: [],
        attrs: {}
      };
      return e = n.selector = nt.trim(e), e !== "*" && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (o, s, a, i, u) => {
        switch (s) {
          case "#":
            n.attrs.id = a;
            break;
          case ".":
            n.classes.push(a);
            break;
          case ":":
            nt.inArray("checked disabled enabled read-only required".split(" "), a) !== -1 && (n.attrs[a] = a);
            break;
        }
        if (i === "[") {
          const d = u.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          d && (n.attrs[d[1]] = d[2]);
        }
        return "";
      })), n.name = t || "div", n;
    }, NB = (e) => !e || typeof e != "string" ? [] : (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), nt.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (t) => {
      const n = nt.map(t.split(/(?:~\+|~|\+)/), AB), o = n.pop();
      return n.length && (o.siblings = n), o;
    }).reverse()), RB = (e, t) => {
      let n, o, s = "", a, i = g_(e);
      if (i === "")
        return "";
      const u = (v) => v.replace(/%(\w+)/g, "");
      if (typeof t == "string") {
        if (t = e.formatter.get(t), !t)
          return;
        t = t[0];
      }
      if ("preview" in t) {
        const v = Vn(t, "preview");
        if (Xo(v, !1))
          return "";
        i = v.getOr(i);
      }
      n = t.block || t.inline || "span";
      const d = NB(t.selector);
      d.length ? (d[0].name || (d[0].name = n), n = t.selector, o = ez(d, e)) : o = ez([n], e);
      const y = Aa.select(n, o)[0] || o.firstChild;
      return U1(t.styles, (v, T) => {
        const N = u(v);
        N && Aa.setStyle(y, T, N);
      }), U1(t.attributes, (v, T) => {
        const N = u(v);
        N && Aa.setAttrib(y, T, N);
      }), U1(t.classes, (v) => {
        const T = u(v);
        Aa.hasClass(y, T) || Aa.addClass(y, T);
      }), e.dispatch("PreviewFormats"), Aa.setStyles(o, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(o), a = Aa.getStyle(e.getBody(), "fontSize", !0), a = /px$/.test(a) ? parseInt(a, 10) : 0, U1(i.split(" "), (v) => {
        let T = Aa.getStyle(y, v, !0);
        if (!(v === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(T) && (T = Aa.getStyle(e.getBody(), v, !0), Gc(T).toLowerCase() === "#ffffff")) && !(v === "color" && Gc(T).toLowerCase() === "#000000")) {
          if (v === "font-size" && /em|%$/.test(T)) {
            if (a === 0)
              return;
            T = parseFloat(T) / (/%$/.test(T) ? 100 : 1) * a + "px";
          }
          v === "border" && T && (s += "padding:0 2px;"), s += v + ":" + T + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), Aa.remove(o), s;
    }, DB = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let t = 1; t <= 6; t++)
        e.addShortcut("access+" + t, "", [
          "FormatBlock",
          !1,
          "h" + t
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, tz = (e) => {
      const t = zB(e), n = vs(null);
      return DB(e), e3(e), {
        get: t.get,
        has: t.has,
        register: t.register,
        unregister: t.unregister,
        apply: (o, s, a) => {
          XP(e, o, s, a);
        },
        remove: (o, s, a, i) => {
          ZP(e, o, s, a, i);
        },
        toggle: (o, s, a) => {
          QP(e, o, s, a);
        },
        match: (o, s, a, i) => qP(e, o, s, a, i),
        closest: (o) => YP(e, o),
        matchAll: (o, s) => VP(e, o, s),
        matchNode: (o, s, a, i) => GP(e, o, s, a, i),
        canApply: (o) => KP(e, o),
        formatChanged: (o, s, a, i) => JP(e, n, o, s, a, i),
        getCssText: et(RB, e)
      };
    }, nz = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, OB = (e, t, n) => {
      const o = vs(!1), s = (d) => {
        $1(t, !1, n), t.add({}, d);
      };
      e.on("init", () => {
        t.add();
      }), e.on("BeforeExecCommand", (d) => {
        const y = d.command;
        nz(y) || (BT(t, n), t.beforeChange());
      }), e.on("ExecCommand", (d) => {
        const y = d.command;
        nz(y) || s(d);
      }), e.on("ObjectResizeStart cut", () => {
        t.beforeChange();
      }), e.on("SaveContent ObjectResized blur", s), e.on("dragend", s), e.on("keyup", (d) => {
        const y = d.keyCode;
        d.isDefaultPrevented() || ((y >= 33 && y <= 36 || y >= 37 && y <= 40 || y === 45 || d.ctrlKey) && (s(), e.nodeChanged()), (y === 46 || y === 8) && e.nodeChanged(), o.get() && t.typing && TC(B1(e), t.data[0]) === !1 && (e.isDirty() === !1 && e.setDirty(!0), e.dispatch("TypingUndo"), o.set(!1), e.nodeChanged()));
      }), e.on("keydown", (d) => {
        const y = d.keyCode;
        if (d.isDefaultPrevented())
          return;
        if (y >= 33 && y <= 36 || y >= 37 && y <= 40 || y === 45) {
          t.typing && s(d);
          return;
        }
        const v = d.ctrlKey && !d.altKey || d.metaKey;
        (y < 16 || y > 20) && y !== 224 && y !== 91 && !t.typing && !v && (t.beforeChange(), $1(t, !0, n), t.add({}, d), o.set(!0));
      }), e.on("mousedown", (d) => {
        t.typing && s(d);
      });
      const a = (d) => d.inputType === "insertReplacementText", i = (d) => d.inputType === "insertText" && d.data === null, u = (d) => d.inputType === "insertFromPaste" || d.inputType === "insertFromDrop";
      e.on("input", (d) => {
        d.inputType && (a(d) || i(d) || u(d)) && s(d);
      }), e.on("AddUndo Undo Redo ClearUndos", (d) => {
        d.isDefaultPrevented() || e.nodeChanged();
      });
    }, PB = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, oz = (e) => {
      const t = jc(), n = vs(0), o = vs(0), s = {
        data: [],
        typing: !1,
        beforeChange: () => {
          PP(e, n, t);
        },
        add: (a, i) => BP(e, s, o, n, t, a, i),
        dispatchChange: () => {
          e.setDirty(!0), e.dispatch("change", {
            level: B1(e),
            lastLevel: Ut(s.data, o.get()).getOrUndefined()
          });
        },
        undo: () => $P(e, s, n, o),
        redo: () => FP(e, o, s.data),
        clear: () => {
          IP(e, s, o);
        },
        reset: () => {
          LP(e, s);
        },
        hasUndo: () => MP(e, s, o),
        hasRedo: () => jP(e, s, o),
        transact: (a) => UP(e, s, n, a),
        ignore: (a) => {
          HP(e, n, a);
        },
        extra: (a, i) => {
          WP(e, s, o, a, i);
        }
      };
      return $l(e) || OB(e, s, n), PB(e), s;
    }, BB = [
      9,
      27,
      sn.HOME,
      sn.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      sn.DOWN,
      sn.UP,
      sn.LEFT,
      sn.RIGHT
    ].concat(Gn.browser.isFirefox() ? [224] : []), sz = "data-mce-placeholder", rz = (e) => e.type === "keydown" || e.type === "keyup", az = (e) => {
      const t = e.keyCode;
      return t === sn.BACKSPACE || t === sn.DELETE;
    }, $B = (e) => {
      if (rz(e)) {
        const t = e.keyCode;
        return !az(e) && (sn.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || ce(BB, t));
      } else
        return !1;
    }, FB = (e) => rz(e) && !(az(e) || e.type === "keyup" && e.keyCode === 229), IB = (e, t, n) => {
      if (Bs(ne.fromDom(t), !1)) {
        const o = t.firstElementChild;
        return o ? e.getStyle(t.firstElementChild, "padding-left") || e.getStyle(t.firstElementChild, "padding-right") ? !1 : n === o.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, LB = (e) => {
      const t = e.dom, n = la(e), o = u_(e), s = (a, i) => {
        if ($B(a))
          return;
        const u = e.getBody(), d = FB(a) ? !1 : IB(t, u, n);
        (t.getAttrib(u, sz) !== "" !== d || i) && (t.setAttrib(u, sz, d ? o : null), t.setAttrib(u, "aria-placeholder", d ? o : null), A0(e, d), e.on(d ? "keydown" : "keyup", s), e.off(d ? "keyup" : "keydown", s));
      };
      o && e.on("init", (a) => {
        s(a, !0), e.on("change SetContent ExecCommand", s), e.on("paste", (i) => xa.setEditorTimeout(e, () => s(i)));
      });
    }, MB = (e, t) => ({
      block: e,
      position: t
    }), jB = (e, t) => ({
      from: e,
      to: t
    }), RC = (e, t) => {
      const n = ne.fromDom(e), o = ne.fromDom(t.container());
      return _1(n, o).map((s) => MB(s, t));
    }, UB = (e) => _o(e.from.block, e.to.block) === !1, HB = (e) => er(e.from.block).bind((t) => er(e.to.block).filter((n) => _o(t, n))).isSome(), WB = (e) => ns(e.from.block.dom) === !1 && ns(e.to.block.dom) === !1, qB = (e, t, n) => ds(n.position.getNode()) && Bs(n.block) === !1 ? Al(!1, n.block.dom).bind((o) => o.isEqual(n.position) ? _a(t, e, o).bind((s) => RC(e, s)) : w.some(n)).getOr(n) : n, VB = (e, t, n) => {
      const o = RC(e, je.fromRangeStart(n)), s = o.bind((a) => _a(t, e, a.position).bind((i) => RC(e, i).map((u) => qB(e, t, u))));
      return zo(o, s, jB).filter((a) => UB(a) && HB(a) && WB(a));
    }, GB = (e, t, n) => n.collapsed ? VB(e, t, n) : w.none(), KB = (e) => {
      const t = fs(e);
      return Yn(t, ia).fold(Z(t), (n) => t.slice(0, n));
    }, cz = (e) => {
      const t = KB(e);
      return M(t, Do), t;
    }, iz = (e, t) => {
      const n = Bl(t, e);
      return oo(n.reverse(), (o) => Bs(o)).each(Do);
    }, YB = (e) => Qe(mi(e), (t) => !Bs(t)).length === 0, XB = (e, t, n, o) => {
      if (Bs(n))
        return $c(n), _r(n.dom);
      YB(o) && Bs(t) && yr(o, ne.fromTag("br"));
      const s = ec(n.dom, je.before(o.dom));
      return M(cz(t), (a) => {
        yr(o, a);
      }), iz(e, t), s;
    }, ZB = (e, t, n) => {
      if (Bs(n))
        return Do(n), Bs(t) && $c(t), _r(t.dom);
      const o = qa(n.dom);
      return M(cz(t), (s) => {
        ls(n, s);
      }), iz(e, t), o;
    }, QB = (e, t) => {
      const n = Bl(t, e);
      return w.from(n[n.length - 1]);
    }, JB = (e, t) => ws(t, e) ? QB(t, e) : w.none(), lz = (e, t) => {
      Al(e, t.dom).map((n) => n.getNode()).map(ne.fromDom).filter(Ei).each(Do);
    }, uz = (e, t, n) => (lz(!0, t), lz(!1, n), JB(t, n).fold(et(ZB, e, t, n), et(XB, e, t, n))), fz = (e, t, n, o) => t ? uz(e, o, n) : uz(e, n, o), DC = (e, t) => {
      const n = ne.fromDom(e.getBody());
      return GB(n.dom, t, e.selection.getRng()).map((s) => () => {
        fz(n, t, s.from.block, s.to.block).each((a) => {
          e.selection.setRng(a.toRange());
        });
      });
    }, e4 = (e, t) => {
      const n = t.getRng();
      return zo(_1(e, ne.fromDom(n.startContainer)), _1(e, ne.fromDom(n.endContainer)), (o, s) => _o(o, s) === !1 ? w.some(() => {
        n.deleteContents(), fz(e, !0, o, s).each((a) => {
          t.setRng(a.toRange());
        });
      }) : w.none()).getOr(w.none());
    }, dz = (e, t) => {
      const n = ne.fromDom(t), o = et(_o, e);
      return Ci(n, tu, o).isSome();
    }, t4 = (e, t) => dz(e, t.startContainer) || dz(e, t.endContainer), n4 = (e, t) => {
      const n = ec(e.dom, je.fromRangeStart(t)).isNone(), o = va(e.dom, je.fromRangeEnd(t)).isNone();
      return !t4(e, t) && n && o;
    }, o4 = (e) => w.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), s4 = (e) => {
      const t = ne.fromDom(e.getBody()), n = e.selection.getRng();
      return n4(t, n) ? o4(e) : e4(t, e.selection);
    }, OC = (e, t) => e.selection.isCollapsed() ? w.none() : s4(e), r4 = ca, a4 = ns, Fl = (e, t, n, o, s) => w.from(t._selectionOverrides.showCaret(e, n, o, s)), c4 = (e) => {
      const t = e.ownerDocument.createRange();
      return t.selectNode(e), t;
    }, ch = (e, t) => e.dispatch("BeforeObjectSelected", { target: t }).isDefaultPrevented() ? w.none() : w.some(c4(t)), i4 = (e, t, n) => {
      const o = If(1, e.getBody(), t), s = je.fromRangeStart(o), a = s.getNode();
      if (El(a))
        return Fl(1, e, a, !s.isAtEnd(), !1);
      const i = s.getNode(!0);
      if (El(i))
        return Fl(1, e, i, !1, !1);
      const u = e.dom.getParent(s.getNode(), (d) => a4(d) || r4(d));
      return El(u) ? Fl(1, e, u, !1, n) : w.none();
    }, PC = (e, t, n) => t.collapsed ? i4(e, t, n).getOr(t) : t, l4 = (e) => Gu(e) || Jg(e), u4 = (e) => Ku(e) || eh(e), f4 = (e, t) => {
      Ft(t) && t.data.length === 0 && e.remove(t);
    }, mz = (e, t, n, o, s, a) => {
      Fl(o, e, a.getNode(!s), s, !0).each((i) => {
        if (t.collapsed) {
          const u = t.cloneRange();
          s ? u.setEnd(i.startContainer, i.startOffset) : u.setStart(i.endContainer, i.endOffset), u.deleteContents();
        } else
          t.deleteContents();
        e.selection.setRng(i);
      }), f4(e.dom, n);
    }, d4 = (e, t) => {
      const n = e.selection.getRng();
      if (!Ft(n.commonAncestorContainer))
        return w.none();
      const o = t ? $s.Forwards : $s.Backwards, s = jr(e.getBody()), a = et(bm, t ? s.next : s.prev), i = t ? l4 : u4, u = Su(o, e.getBody(), n), d = nc(t, a(u));
      if (!d || !Mf(u, d))
        return w.none();
      if (i(d))
        return w.some(() => mz(e, n, u.getNode(), o, t, d));
      const y = a(d);
      return y && i(y) && Mf(d, y) ? w.some(() => mz(e, n, u.getNode(), o, t, y)) : w.none();
    }, BC = (e, t) => d4(e, t), $C = (e, t) => {
      const n = e.getBody();
      return t ? _r(n).filter(Gu) : qa(n).filter(Ku);
    }, FC = (e) => {
      const t = e.selection.getRng();
      return !t.collapsed && ($C(e, !0).exists((n) => n.isEqual(je.fromRangeStart(t))) || $C(e, !1).exists((n) => n.isEqual(je.fromRangeEnd(t))));
    }, m4 = (e) => tu(ne.fromDom(e)) || dl(ne.fromDom(e)), Ga = bc.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), p4 = (e, t) => {
      const n = t.getNode(e === !1), o = e ? "after" : "before";
      return dn(n) && n.getAttribute("data-mce-caret") === o;
    }, g4 = (e, t, n, o) => {
      const s = (a) => mf(ne.fromDom(a)) && !kc(n, o, e);
      return bg(!t, n).fold(() => bg(t, o).fold(cn, s), s);
    }, pz = (e, t, n, o) => {
      const s = o.getNode(t === !1);
      return _1(ne.fromDom(e), ne.fromDom(n.getNode())).map((a) => Bs(a) ? Ga.remove(a.dom) : Ga.moveToElement(s)).orThunk(() => w.some(Ga.moveToElement(s)));
    }, gz = (e, t, n) => _a(t, e, n).bind((o) => m4(o.getNode()) || g4(e, t, n, o) ? w.none() : t && ns(o.getNode()) || t === !1 && ns(o.getNode(!0)) ? pz(e, t, n, o) : t && Ku(n) || t === !1 && Gu(n) ? w.some(Ga.moveToPosition(o)) : w.none()), h4 = (e, t) => e && ns(t.nextSibling) ? w.some(Ga.moveToElement(t.nextSibling)) : e === !1 && ns(t.previousSibling) ? w.some(Ga.moveToElement(t.previousSibling)) : w.none(), y4 = (e, t, n) => n.fold((o) => w.some(Ga.remove(o)), (o) => w.some(Ga.moveToElement(o)), (o) => kc(t, o, e) ? w.none() : w.some(Ga.moveToPosition(o))), b4 = (e, t, n) => p4(t, n) ? h4(t, n.getNode(t === !1)).fold(() => gz(e, t, n), w.some) : gz(e, t, n).bind((o) => y4(e, n, o)), k4 = (e, t, n) => {
      const o = If(t ? 1 : -1, e, n), s = je.fromRangeStart(o), a = ne.fromDom(e);
      return t === !1 && Ku(s) ? w.some(Ga.remove(s.getNode(!0))) : t && Gu(s) ? w.some(Ga.remove(s.getNode())) : t === !1 && Gu(s) && Rv(a, s) ? BR(a, s).map((i) => Ga.remove(i.getNode())) : t && Ku(s) && Nv(a, s) ? $R(a, s).map((i) => Ga.remove(i.getNode())) : b4(e, t, s);
    }, w4 = (e, t) => (n) => (e._selectionOverrides.hideFakeCaret(), Qf(e, t, ne.fromDom(n)), !0), _4 = (e, t) => (n) => {
      const o = t ? je.before(n) : je.after(n);
      return e.selection.setRng(o.toRange()), !0;
    }, v4 = (e) => (t) => (e.selection.setRng(t.toRange()), !0), hz = (e, t) => w.from(Jm(e.getBody(), t)), C4 = (e, t) => {
      const n = e.selection.getNode();
      return hz(e, n).filter(ns).fold(() => k4(e.getBody(), t, e.selection.getRng()).map((o) => () => o.fold(w4(e, t), _4(e, t), v4(e))), () => w.some(ye));
    }, S4 = (e) => {
      M(br(e, ".mce-offscreen-selection"), Do);
    }, x4 = (e, t) => {
      const n = e.selection.getNode();
      return ns(n) && !fl(n) ? hz(e, n.parentNode).filter(ns).fold(() => w.some(() => {
        S4(ne.fromDom(e.getBody())), Qf(e, t, ne.fromDom(e.selection.getNode())), $v(e);
      }), () => w.some(ye)) : FC(e) ? w.some(() => {
        dE(e, e.selection.getRng(), ne.fromDom(e.getBody()));
      }) : w.none();
    }, yz = (e) => {
      const t = e.dom, n = e.selection, o = Jm(e.getBody(), n.getNode());
      if (ca(o) && t.isBlock(o) && t.isEmpty(o)) {
        const s = t.create("br", { "data-mce-bogus": "1" });
        t.setHTML(o, ""), o.appendChild(s), n.setRng(je.before(s).toRange());
      }
      return !0;
    }, IC = (e, t) => e.selection.isCollapsed() ? C4(e, t) : x4(e, t), E4 = (e, t) => {
      const n = je.fromRangeStart(e.selection.getRng());
      return _a(t, e.getBody(), n).filter((o) => t ? zR(o) : AR(o)).bind((o) => w.from(yg(t ? 0 : -1, o))).map((o) => () => e.selection.select(o));
    }, LC = (e, t) => e.selection.isCollapsed() ? E4(e, t) : w.none(), ap = Ft, bz = (e) => ap(e) && e.data[0] === m, kz = (e) => ap(e) && e.data[e.data.length - 1] === m, wz = (e) => e.ownerDocument.createTextNode(m), T4 = (e) => {
      if (ap(e.previousSibling))
        return kz(e.previousSibling) || e.previousSibling.appendData(m), e.previousSibling;
      if (ap(e))
        return bz(e) || e.insertData(0, m), e;
      {
        const t = wz(e);
        return e.parentNode.insertBefore(t, e), t;
      }
    }, z4 = (e) => {
      if (ap(e.nextSibling))
        return bz(e.nextSibling) || e.nextSibling.insertData(0, m), e.nextSibling;
      if (ap(e))
        return kz(e) || e.appendData(m), e;
      {
        const t = wz(e);
        return e.nextSibling ? e.parentNode.insertBefore(t, e.nextSibling) : e.parentNode.appendChild(t), t;
      }
    }, H1 = (e, t) => e ? T4(t) : z4(t), A4 = et(H1, !0), N4 = et(H1, !1), _z = (e, t) => Ft(e.container()) ? H1(t, e.container()) : H1(t, e.getNode()), vz = (e, t) => {
      const n = t.get();
      return n && e.container() === n && mt(n);
    }, MC = (e, t) => t.fold((n) => {
      xl(e.get());
      const o = A4(n);
      return e.set(o), w.some(je(o, o.length - 1));
    }, (n) => _r(n).map((o) => {
      if (vz(o, e))
        return je(e.get(), 1);
      {
        xl(e.get());
        const s = _z(o, !0);
        return e.set(s), je(s, 1);
      }
    }), (n) => qa(n).map((o) => {
      if (vz(o, e))
        return je(e.get(), e.get().length - 1);
      {
        xl(e.get());
        const s = _z(o, !1);
        return e.set(s), je(s, s.length - 1);
      }
    }), (n) => {
      xl(e.get());
      const o = N4(n);
      return e.set(o), w.some(je(o, 1));
    }), Cz = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const o = e[n].apply(null, t);
        if (o.isSome())
          return o;
      }
      return w.none();
    }, Wr = bc.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), Sz = (e, t) => {
      const n = Pi(t, e);
      return n || e;
    }, R4 = (e, t, n) => {
      const o = iE(n), s = Sz(t, o.container());
      return Yu(e, s, o).fold(() => va(s, o).bind(et(Yu, e, s)).map((a) => Wr.before(a)), w.none);
    }, D4 = (e, t) => Eu(e, t) === null, xz = (e, t, n) => Yu(e, t, n).filter(et(D4, t)), O4 = (e, t, n) => {
      const o = lE(n);
      return xz(e, t, o).bind((s) => ec(s, o).isNone() ? w.some(Wr.start(s)) : w.none());
    }, P4 = (e, t, n) => {
      const o = iE(n);
      return xz(e, t, o).bind((s) => va(s, o).isNone() ? w.some(Wr.end(s)) : w.none());
    }, B4 = (e, t, n) => {
      const o = lE(n), s = Sz(t, o.container());
      return Yu(e, s, o).fold(() => ec(s, o).bind(et(Yu, e, s)).map((a) => Wr.after(a)), w.none);
    }, Ez = (e) => hD(jC(e)) === !1, Mi = (e, t, n) => Cz([
      R4,
      O4,
      P4,
      B4
    ], [
      e,
      t,
      n
    ]).filter(Ez), jC = (e) => e.fold(Pe, Pe, Pe, Pe), Tz = (e) => e.fold(Z("before"), Z("start"), Z("end"), Z("after")), W1 = (e) => e.fold(Wr.before, Wr.before, Wr.after, Wr.after), UC = (e) => e.fold(Wr.start, Wr.start, Wr.end, Wr.end), $4 = (e, t) => Tz(e) === Tz(t) && jC(e) === jC(t), F4 = (e, t, n, o, s, a) => zo(Yu(t, n, o), Yu(t, n, s), (i, u) => i !== u && bD(n, i, u) ? Wr.after(e ? i : u) : a).getOr(a), I4 = (e, t) => e.fold(wn, (n) => !$4(n, t)), L4 = (e, t, n, o, s) => {
      const a = nc(e, s);
      return _a(e, n, a).map(et(nc, e)).fold(() => o.map(W1), (d) => Mi(t, n, d).map(et(F4, e, t, n, a, d)).filter(et(I4, o))).filter(Ez);
    }, M4 = (e, t) => e ? t.fold(Ze(w.some, Wr.start), w.none, Ze(w.some, Wr.after), w.none) : t.fold(w.none, Ze(w.some, Wr.before), w.none, Ze(w.some, Wr.end)), j4 = (e, t, n, o) => {
      const s = nc(e, o), a = Mi(t, n, s);
      return Mi(t, n, s).bind(et(M4, e)).orThunk(() => L4(e, t, n, a, o));
    }, U4 = (e) => Wt(e.selection.getSel().modify), zz = (e, t, n) => {
      const o = e ? 1 : -1;
      return t.setRng(je(n.container(), n.offset() + o).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, H4 = (e, t) => {
      const n = t.selection.getRng(), o = e ? je.fromRangeEnd(n) : je.fromRangeStart(n);
      return U4(t) ? e && ss(o) ? zz(!0, t.selection, o) : !e && uo(o) ? zz(!1, t.selection, o) : !1 : !1;
    };
    var ji;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(ji || (ji = {}));
    const q1 = (e, t) => e === $s.Backwards ? io(t) : t, W4 = (e, t, n) => e === $s.Forwards ? t.next(n) : t.prev(n), q4 = (e, t, n, o) => ds(o.getNode(t === $s.Forwards)) ? ji.Br : kc(n, o) === !1 ? ji.Block : ji.Wrap, Az = (e, t, n, o) => {
      const s = jr(n);
      let a = o;
      const i = [];
      for (; a; ) {
        const u = W4(t, s, a);
        if (!u)
          break;
        if (ds(u.getNode(!1)))
          return t === $s.Forwards ? {
            positions: q1(t, i).concat([u]),
            breakType: ji.Br,
            breakAt: w.some(u)
          } : {
            positions: q1(t, i),
            breakType: ji.Br,
            breakAt: w.some(u)
          };
        if (!u.isVisible()) {
          a = u;
          continue;
        }
        if (e(a, u)) {
          const d = q4(n, t, a, u);
          return {
            positions: q1(t, i),
            breakType: d,
            breakAt: w.some(u)
          };
        }
        i.push(u), a = u;
      }
      return {
        positions: q1(t, i),
        breakType: ji.Eol,
        breakAt: w.none()
      };
    }, Nz = (e, t, n, o) => t(n, o).breakAt.map((s) => {
      const a = t(n, s).positions;
      return e === $s.Backwards ? a.concat(s) : [s].concat(a);
    }).getOr([]), HC = (e, t) => En(e, (n, o) => n.fold(() => w.some(o), (s) => zo(Tn(s.getClientRects()), Tn(o.getClientRects()), (a, i) => {
      const u = Math.abs(t - a.left);
      return Math.abs(t - i.left) <= u ? o : s;
    }).or(n)), w.none()), V1 = (e, t) => Tn(t.getClientRects()).bind((n) => HC(e, n.left)), ih = et(Az, je.isAbove, -1), lh = et(Az, je.isBelow, 1), Rz = et(Nz, -1, ih), Dz = et(Nz, 1, lh), V4 = (e, t) => ih(e, t).breakAt.isNone(), G4 = (e, t) => lh(e, t).breakAt.isNone(), K4 = (e) => _r(e).map((t) => [t].concat(lh(e, t).positions)).getOr([]), Y4 = (e) => qa(e).map((t) => ih(e, t).positions.concat(t)).getOr([]), X4 = (e, t) => V1(Rz(e, t), t), Z4 = (e, t) => V1(Dz(e, t), t), Q4 = ns, Oz = (e, t) => Math.abs(e.left - t), Pz = (e, t) => Math.abs(e.right - t), J4 = (e) => qo(e, "node"), Bz = (e, t) => G(e, (n, o) => {
      const s = Math.min(Oz(n, t), Pz(n, t)), a = Math.min(Oz(o, t), Pz(o, t));
      return a === s && J4(o) && Q4(o.node) || a < s ? o : n;
    }), e8 = (e) => {
      const t = (n) => W(n, (o) => {
        const s = _l(o);
        return s.node = e, s;
      });
      if (dn(e))
        return t(e.getClientRects());
      if (Ft(e)) {
        const n = e.ownerDocument.createRange();
        return n.setStart(e, 0), n.setEnd(e, e.data.length), t(n.getClientRects());
      } else
        return [];
    }, $z = (e) => Xt(e, e8);
    var uh;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(uh || (uh = {}));
    const t8 = (e, t, n, o) => {
      for (; o = $f(o, e, Ua, t); )
        if (n(o))
          return;
    }, Fz = (e, t, n, o, s, a) => {
      let i = 0;
      const u = [], d = (T) => {
        let N = $z([T]);
        e === -1 && (N = N.reverse());
        for (let F = 0; F < N.length; F++) {
          const U = N[F];
          if (!n(U, y)) {
            if (u.length > 0 && t(U, dt(u)) && i++, U.line = i, s(U))
              return !0;
            u.push(U);
          }
        }
      }, y = dt(a.getClientRects());
      if (!y)
        return u;
      const v = a.getNode();
      return d(v), t8(e, o, d, v), u;
    }, n8 = (e, t) => t.line > e, o8 = (e, t) => t.line === e, s8 = et(Fz, uh.Up, Jd, Di), r8 = et(Fz, uh.Down, Di, Jd), a8 = (e, t, n, o) => {
      const s = jr(t);
      let a, i, u, d;
      const y = [];
      let v = 0;
      const T = (F) => dt(F.getClientRects());
      e === 1 ? (a = s.next, i = Di, u = Jd, d = je.after(o)) : (a = s.prev, i = Jd, u = Di, d = je.before(o));
      const N = T(d);
      do {
        if (!d.isVisible())
          continue;
        const F = T(d);
        if (u(F, N))
          continue;
        y.length > 0 && i(F, dt(y)) && v++;
        const U = _l(F);
        if (U.position = d, U.line = v, n(U))
          return y;
        y.push(U);
      } while (d = a(d));
      return y;
    }, Iz = (e) => (t) => n8(e, t), WC = (e) => (t) => o8(e, t), Il = (e, t) => {
      e.selection.setRng(t), Uu(e, e.selection.getRng());
    }, qC = (e, t, n) => w.some(PC(e, t, n)), Lz = (e, t, n, o, s, a) => {
      const i = t === $s.Forwards, u = jr(e.getBody()), d = et(bm, i ? u.next : u.prev), y = i ? o : s;
      if (!n.collapsed) {
        const U = em(n);
        if (a(U))
          return Fl(t, e, U, t === $s.Backwards, !1);
        if (FC(e)) {
          const j = n.cloneRange();
          return j.collapse(t === $s.Backwards), w.from(j);
        }
      }
      const v = Su(t, e.getBody(), n);
      if (y(v))
        return ch(e, v.getNode(!i));
      const T = nc(i, d(v)), N = ru(n);
      if (!T)
        return N ? w.some(n) : w.none();
      if (y(T))
        return Fl(t, e, T.getNode(!i), i, !1);
      const F = d(T);
      return F && y(F) && Mf(T, F) ? Fl(t, e, F.getNode(!i), i, !1) : N ? qC(e, T.toRange(), !1) : w.none();
    }, Mz = (e, t, n, o, s, a) => {
      const i = Su(t, e.getBody(), n), u = dt(i.getClientRects()), d = t === uh.Down, y = e.getBody();
      if (!u)
        return w.none();
      if (FC(e)) {
        const H = d ? je.fromRangeEnd(n) : je.fromRangeStart(n);
        return (d ? Z4 : X4)(y, H).orThunk(() => w.from(H)).map((ve) => ve.toRange());
      }
      const T = (d ? r8 : s8)(y, Iz(1), i), N = Qe(T, WC(1)), F = u.left, U = Bz(N, F);
      if (U && a(U.node)) {
        const H = Math.abs(F - U.left), se = Math.abs(F - U.right);
        return Fl(t, e, U.node, H < se, !1);
      }
      let j;
      if (o(i) ? j = i.getNode() : s(i) ? j = i.getNode(!0) : j = em(n), j) {
        const H = a8(t, y, Iz(1), j);
        let se = Bz(Qe(H, WC(1)), F);
        if (se || (se = dt(Qe(H, WC(0))), se))
          return qC(e, se.position.toRange(), !1);
      }
      return N.length === 0 ? VC(e, d).filter(d ? s : o).map((H) => PC(e, H.toRange(), !1)) : w.none();
    }, VC = (e, t) => {
      const n = e.selection.getRng(), o = t ? je.fromRangeEnd(n) : je.fromRangeStart(n), s = W_(o.container(), e.getBody());
      if (t) {
        const a = lh(s, o);
        return Pn(a.positions);
      } else {
        const a = ih(s, o);
        return Tn(a.positions);
      }
    }, jz = (e, t, n) => VC(e, t).filter(n).exists((o) => (e.selection.setRng(o.toRange()), !0)), G1 = (e, t) => {
      const n = e.dom.createRng();
      n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n);
    }, Uz = (e, t) => {
      e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected");
    }, Hz = (e, t, n) => MC(t, n).map((o) => (G1(e, o), n)), c8 = (e, t, n) => {
      const o = je.fromRangeStart(e);
      if (e.collapsed)
        return o;
      {
        const s = je.fromRangeEnd(e);
        return n ? ec(t, s).getOr(s) : va(t, o).getOr(o);
      }
    }, i8 = (e, t, n) => {
      const o = e.getBody(), s = c8(e.selection.getRng(), o, n), a = et(Jf, e);
      return j4(n, a, o, s).bind((u) => Hz(e, t, u));
    }, l8 = (e, t, n) => {
      const o = W(br(ne.fromDom(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (i) => i.dom), s = Qe(o, e), a = Qe(n, e);
      M(Fe(s, a), et(Uz, !1)), M(Fe(a, s), et(Uz, !0));
    }, u8 = (e, t) => {
      if (e.selection.isCollapsed() && e.composing !== !0 && t.get()) {
        const n = je.fromRangeStart(e.selection.getRng());
        je.isTextPosition(n) && kD(n) === !1 && (G1(e, L_(t.get(), n)), t.set(null));
      }
    }, f8 = (e, t, n, o) => {
      if (t.selection.isCollapsed()) {
        const s = Qe(o, e);
        M(s, (a) => {
          const i = je.fromRangeStart(t.selection.getRng());
          Mi(e, t.getBody(), i).bind((u) => Hz(t, n, u));
        });
      }
    }, Wz = (e, t, n) => Of(e) ? i8(e, t, n).isSome() : !1, qz = (e, t, n) => Of(t) ? H4(e, t) : !1, d8 = (e) => {
      const t = vs(null), n = et(Jf, e);
      return e.on("NodeChange", (o) => {
        Of(e) && (l8(n, e.dom, o.parents), u8(e, t), f8(n, e, t, o.parents));
      }), t;
    }, m8 = et(qz, !0), p8 = et(qz, !1), K1 = (e, t, n) => {
      if (Of(e)) {
        const o = VC(e, t).getOrThunk(() => {
          const s = e.selection.getRng();
          return t ? je.fromRangeEnd(s) : je.fromRangeStart(s);
        });
        return Mi(et(Jf, e), e.getBody(), o).exists((s) => {
          const a = W1(s);
          return MC(n, a).exists((i) => (G1(e, i), !0));
        });
      } else
        return !1;
    }, g8 = (e, t) => {
      const n = document.createRange();
      return n.setStart(e.container(), e.offset()), n.setEnd(t.container(), t.offset()), n;
    }, h8 = (e) => zo(_r(e), qa(e), (t, n) => {
      const o = nc(!0, t), s = nc(!1, n);
      return va(e, o).forall((a) => a.isEqual(s));
    }).getOr(!0), Vz = (e, t) => (n) => MC(t, n).map((o) => () => G1(e, o)), Gz = (e, t, n, o) => {
      const s = e.getBody(), a = et(Jf, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(g8(n, o)), Bv(e), Mi(a, s, je.fromRangeStart(e.selection.getRng())).map(UC).bind(Vz(e, t)).each(en);
      }), e.nodeChanged();
    }, y8 = (e, t) => {
      const n = Pi(t, e);
      return n || e;
    }, b8 = (e, t, n, o) => {
      const s = y8(e.getBody(), o.container()), a = et(Jf, e), i = Mi(a, s, o);
      return i.bind((d) => n ? d.fold(Z(w.some(UC(d))), w.none, Z(w.some(W1(d))), w.none) : d.fold(w.none, Z(w.some(W1(d))), w.none, Z(w.some(UC(d))))).map(Vz(e, t)).getOrThunk(() => {
        const d = wm(n, s, o), y = d.bind((v) => Mi(a, s, v));
        return zo(i, y, () => Yu(a, s, o).bind((v) => h8(v) ? w.some(() => {
          Qf(e, n, ne.fromDom(v));
        }) : w.none())).getOrThunk(() => y.bind(() => d.map((v) => () => {
          n ? Gz(e, t, o, v) : Gz(e, t, v, o);
        })));
      });
    }, GC = (e, t, n) => {
      if (e.selection.isCollapsed() && Of(e)) {
        const o = je.fromRangeStart(e.selection.getRng());
        return b8(e, t, n, o);
      }
      return w.none();
    }, k8 = (e, t) => {
      const n = Bl(t, e);
      return Yn(n, ia).fold(Z(n), (o) => n.slice(0, o));
    }, w8 = (e) => ol(e) === 1, _8 = (e, t, n, o) => {
      const s = et(n3, t), a = W(Qe(o, s), (i) => i.dom);
      if (a.length === 0)
        Qf(t, e, n);
      else {
        const i = t3(n.dom, a);
        t.selection.setRng(i.toRange());
      }
    }, v8 = (e, t) => {
      const n = ne.fromDom(e.getBody()), o = ne.fromDom(e.selection.getStart()), s = Qe(k8(n, o), w8);
      return Pn(s).bind((a) => {
        const i = je.fromRangeStart(e.selection.getRng());
        return CD(t, i, a.dom) && !o3(a) ? w.some(() => _8(t, e, a, s)) : w.none();
      });
    }, KC = (e, t) => e.selection.isCollapsed() ? v8(e, t) : w.none(), YC = (e, t, n) => w.some(() => {
      e._selectionOverrides.hideFakeCaret(), Qf(e, t, ne.fromDom(n));
    }), C8 = (e, t) => {
      const n = t ? Jg : eh, o = t ? $s.Forwards : $s.Backwards, s = Su(o, e.getBody(), e.selection.getRng());
      return n(s) ? YC(e, t, s.getNode(!t)) : w.from(nc(t, s)).filter((a) => n(a) && Mf(s, a)).map((a) => () => YC(e, t, a.getNode(!t)));
    }, S8 = (e, t) => {
      const n = e.selection.getNode();
      return dc(n) ? YC(e, t, n) : w.none();
    }, XC = (e, t) => e.selection.isCollapsed() ? C8(e, t) : S8(e, t), x8 = (e) => Oc(e, (t) => ca(t.dom) || ns(t.dom)).exists((t) => ca(t.dom)), ZC = (e) => {
      const t = parseInt(e, 10);
      return isNaN(t) ? 0 : t;
    }, Kz = (e, t) => {
      const n = e || Tp(t) ? "margin" : "padding", o = Hs(t, "direction") === "rtl" ? "-right" : "-left";
      return n + o;
    }, E8 = (e, t, n, o, s, a) => {
      const i = Kz(n, ne.fromDom(a));
      if (t === "outdent") {
        const u = Math.max(0, ZC(a.style[i]) - o);
        e.setStyle(a, i, u ? u + s : "");
      } else {
        const u = ZC(a.style[i]) + o + s;
        e.setStyle(a, i, u);
      }
    }, T8 = (e, t) => ro(t, (n) => {
      const o = Kz($y(e), n), s = gi(n, o).map(ZC).getOr(0);
      return e.dom.getContentEditable(n.dom) !== "false" && s > 0;
    }), Yz = (e) => {
      const t = Zz(e);
      return !e.mode.isReadOnly() && (t.length > 1 || T8(e, t));
    }, Xz = (e) => gf(e) || dl(e), z8 = (e) => er(e).exists(Xz), Zz = (e) => Qe(_s(e.selection.getSelectedBlocks()), (t) => !Xz(t) && !z8(t) && x8(t)), Qz = (e, t) => {
      const { dom: n } = e, o = s_(e), s = /[a-z%]+$/i.exec(o)[0], a = parseInt(o, 10), i = $y(e);
      M(Zz(e), (u) => {
        E8(n, t, i, a, s, u.dom);
      });
    }, A8 = (e) => Qz(e, "indent"), Jz = (e) => Qz(e, "outdent"), e2 = (e) => {
      if (e.selection.isCollapsed() && Yz(e)) {
        const t = e.dom, n = e.selection.getRng(), o = je.fromRangeStart(n), s = t.getParent(n.startContainer, t.isBlock);
        if (s !== null && Av(ne.fromDom(s), o))
          return w.some(() => Jz(e));
      }
      return w.none();
    }, t2 = (e, t, n) => Bo([
      e2,
      IC,
      BC,
      (o, s) => GC(o, t, s),
      DC,
      Wv,
      LC,
      XC,
      OC,
      KC
    ], (o) => o(e, n)), N8 = (e, t) => {
      t2(e, t, !1).fold(() => {
        Bv(e), $v(e);
      }, en);
    }, R8 = (e, t) => {
      t2(e, t, !0).fold(() => wD(e), en);
    }, D8 = (e, t) => {
      e.addCommand("delete", () => {
        N8(e, t);
      }), e.addCommand("forwardDelete", () => {
        R8(e, t);
      });
    }, n2 = 5, O8 = 400, o2 = (e) => e.touches === void 0 || e.touches.length !== 1 ? w.none() : w.some(e.touches[0]), P8 = (e, t) => {
      const n = Math.abs(e.clientX - t.x), o = Math.abs(e.clientY - t.y);
      return n > n2 || o > n2;
    }, B8 = (e) => {
      const t = jc(), n = vs(!1), o = Xd((s) => {
        e.dispatch("longpress", {
          ...s,
          type: "longpress"
        }), n.set(!0);
      }, O8);
      e.on("touchstart", (s) => {
        o2(s).each((a) => {
          o.cancel();
          const i = {
            x: a.clientX,
            y: a.clientY,
            target: s.target
          };
          o.throttle(s), n.set(!1), t.set(i);
        });
      }, !0), e.on("touchmove", (s) => {
        o.cancel(), o2(s).each((a) => {
          t.on((i) => {
            P8(a, i) && (t.clear(), n.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (s) => {
        o.cancel(), s.type !== "touchcancel" && t.get().filter((a) => a.target.isEqualNode(s.target)).each(() => {
          n.get() ? s.preventDefault() : e.dispatch("tap", {
            ...s,
            type: "tap"
          });
        });
      }, !0);
    }, QC = (e, t) => gn(e, t.nodeName), $8 = (e, t) => Ft(t) ? !0 : dn(t) ? !QC(e, t) && !fa(t) : !1, F8 = (e, t, n) => Ce(Gx(ne.fromDom(n), ne.fromDom(t)), (o) => QC(e, o.dom)), I8 = (e, t) => {
      if (Ft(t)) {
        if (t.nodeValue.length === 0)
          return !0;
        if (/^\s+$/.test(t.nodeValue) && (!t.nextSibling || QC(e, t.nextSibling)))
          return !0;
      }
      return !1;
    }, s2 = (e) => e.dom.create(la(e), Df(e)), L8 = (e) => {
      const t = e.dom, n = e.selection, o = e.schema, s = o.getBlockElements();
      let a = n.getStart();
      const i = e.getBody();
      let u, d, y;
      const v = la(e);
      if (!a || !dn(a))
        return;
      const T = i.nodeName.toLowerCase();
      if (!o.isValidChild(T, v.toLowerCase()) || F8(s, i, a))
        return;
      const N = n.getRng(), F = N.startContainer, U = N.startOffset, j = N.endContainer, H = N.endOffset, se = Yo(e);
      for (a = i.firstChild; a; )
        if ($8(s, a)) {
          if (I8(s, a)) {
            d = a, a = a.nextSibling, t.remove(d);
            continue;
          }
          u || (u = s2(e), a.parentNode.insertBefore(u, a), y = !0), d = a, a = a.nextSibling, u.appendChild(d);
        } else
          u = null, a = a.nextSibling;
      y && se && (N.setStart(F, U), N.setEnd(j, H), n.setRng(N), e.nodeChanged());
    }, r2 = (e, t, n) => {
      const o = ne.fromDom(s2(e)), s = pc();
      ls(o, s), n(t, o);
      const a = document.createRange();
      return a.setStartBefore(s.dom), a.setEndBefore(s.dom), a;
    }, M8 = (e) => {
      e.on("NodeChange", et(L8, e));
    }, a2 = (e) => (t) => (" " + t.attr("class") + " ").indexOf(e) !== -1, j8 = (e, t, n) => function(o) {
      const s = arguments, a = s[s.length - 2], i = a > 0 ? t.charAt(a - 1) : "";
      if (i === '"')
        return o;
      if (i === ">") {
        const u = t.lastIndexOf("<", a);
        if (u !== -1 && t.substring(u, a).indexOf('contenteditable="false"') !== -1)
          return o;
      }
      return '<span class="' + n + '" data-mce-content="' + e.dom.encode(s[0]) + '">' + e.dom.encode(typeof s[1] == "string" ? s[1] : s[0]) + "</span>";
    }, U8 = (e, t, n) => {
      let o = t.length, s = n.content;
      if (n.format !== "raw") {
        for (; o--; )
          s = s.replace(t[o], j8(e, s, Zy(e)));
        n.content = s;
      }
    }, H8 = (e) => {
      const t = "contenteditable", n = " " + nt.trim(N_(e)) + " ", o = " " + nt.trim(Zy(e)) + " ", s = a2(n), a = a2(o), i = R_(e);
      i.length > 0 && e.on("BeforeSetContent", (u) => {
        U8(e, i, u);
      }), e.parser.addAttributeFilter("class", (u) => {
        let d = u.length;
        for (; d--; ) {
          const y = u[d];
          s(y) ? y.attr(t, "true") : a(y) && y.attr(t, "false");
        }
      }), e.serializer.addAttributeFilter(t, (u) => {
        let d = u.length;
        for (; d--; ) {
          const y = u[d];
          !s(y) && !a(y) || (i.length > 0 && y.attr("data-mce-content") ? (y.name = "#text", y.type = 3, y.raw = !0, y.value = y.attr("data-mce-content")) : y.attr(t, null));
        }
      });
    }, W8 = (e) => Pc(ne.fromDom(e.getBody()), "*[data-mce-caret]").map((t) => t.dom).getOrNull(), c2 = (e, t) => {
      t.hasAttribute("data-mce-caret") && (ja(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t));
    }, q8 = (e, t) => {
      const n = W8(e);
      if (!!n) {
        if (t.type === "compositionstart") {
          t.preventDefault(), t.stopPropagation(), c2(e, n);
          return;
        }
        vn(n) && (c2(e, n), e.undoManager.add());
      }
    }, V8 = (e) => {
      e.on("keyup compositionstart", et(q8, e));
    }, i2 = ns, G8 = (e, t, n) => Lz(t, e, n, Gu, Ku, i2), K8 = (e, t, n) => Mz(t, e, n, (a) => Gu(a) || qx(a), (a) => Ku(a) || Vx(a), i2), Y8 = (e) => {
      const t = e.dom.create(la(e));
      return t.innerHTML = '<br data-mce-bogus="1">', t;
    }, l2 = (e, t, n) => {
      const o = jr(e.getBody()), s = et(bm, t === 1 ? o.next : o.prev);
      if (n.collapsed) {
        const a = e.dom.getParent(n.startContainer, "PRE");
        if (!a)
          return;
        if (!s(je.fromRangeStart(n))) {
          const u = ne.fromDom(Y8(e));
          t === 1 ? ra(ne.fromDom(a), u) : yr(ne.fromDom(a), u), e.selection.select(u.dom, !0), e.selection.collapse();
        }
      }
    }, X8 = (e, t) => {
      const n = t ? $s.Forwards : $s.Backwards, o = e.selection.getRng();
      return G8(n, e, o).orThunk(() => (l2(e, n, o), w.none()));
    }, Z8 = (e, t) => {
      const n = t ? 1 : -1, o = e.selection.getRng();
      return K8(n, e, o).orThunk(() => (l2(e, n, o), w.none()));
    }, u2 = (e, t) => X8(e, t).exists((n) => (Il(e, n), !0)), f2 = (e, t) => Z8(e, t).exists((n) => (Il(e, n), !0)), d2 = (e, t) => jz(e, t, t ? Ku : Gu), Y1 = (e, t) => $C(e, !t).map((n) => {
      const o = n.toRange(), s = e.selection.getRng();
      return t ? o.setStart(s.startContainer, s.startOffset) : o.setEnd(s.endContainer, s.endOffset), o;
    }).exists((n) => (Il(e, n), !0)), Q8 = (e) => ce(["figcaption"], tn(e)), J8 = (e, t) => {
      const n = et(_o, t);
      return Oc(ne.fromDom(e.container()), ia, n).filter(Q8);
    }, e$ = (e, t, n) => t ? G4(e.dom, n) : V4(e.dom, n), t$ = (e, t) => {
      const n = ne.fromDom(e.getBody()), o = je.fromRangeStart(e.selection.getRng());
      return J8(o, n).exists(() => {
        if (e$(n, t, o)) {
          const a = r2(e, n, t ? ls : yd);
          return e.selection.setRng(a), !0;
        } else
          return !1;
      });
    }, m2 = (e, t) => e.selection.isCollapsed() ? t$(e, t) : !1, p2 = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, n$ = (e) => W(e, (t) => ({
      ...p2,
      action: ye,
      ...t
    })), o$ = (e) => W(e, (t) => ({
      ...p2,
      action: () => w.none(),
      ...t
    })), g2 = (e, t) => t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey, s$ = (e, t) => Xt(n$(e), (n) => g2(n, t) ? [n] : []), r$ = (e, t) => Xt(o$(e), (n) => g2(n, t) ? [n] : []), Kn = (e, ...t) => () => e.apply(null, t), fh = (e, t) => oo(s$(e, t), (n) => n.action()), h2 = (e, t) => Bo(r$(e, t), (n) => n.action()), y2 = (e, t) => {
      const n = t ? $s.Forwards : $s.Backwards, o = e.selection.getRng();
      return Lz(e, n, o, Jg, eh, dc).exists((s) => (Il(e, s), !0));
    }, b2 = (e, t) => {
      const n = t ? 1 : -1, o = e.selection.getRng();
      return Mz(e, n, o, Jg, eh, dc).exists((s) => (Il(e, s), !0));
    }, k2 = (e, t) => jz(e, t, t ? eh : Jg), w2 = bc.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), dh = {
      ...w2,
      none: (e) => w2.none(e)
    }, a$ = (e, t) => _2(e, t, wn), _2 = (e, t, n) => Xt(fs(e), (o) => sa(o, t) ? n(o) ? [o] : [] : _2(o, t, n)), c$ = (e, t, n = cn) => {
      if (n(t))
        return w.none();
      if (ce(e, tn(t)))
        return w.some(t);
      const o = (s) => sa(s, "table") || n(s);
      return Si(t, e.join(","), o);
    }, i$ = (e, t) => c$([
      "td",
      "th"
    ], e, t), l$ = (e) => a$(e, "th,td"), v2 = (e, t) => Ma(e, "table", t), JC = (e, t, n, o, s = wn) => {
      const a = o === 1;
      if (!a && n <= 0)
        return dh.first(e[0]);
      if (a && n >= e.length - 1)
        return dh.last(e[e.length - 1]);
      {
        const i = n + o, u = e[i];
        return s(u) ? dh.middle(t, u) : JC(e, t, i, o, s);
      }
    }, C2 = (e, t) => v2(e, t).bind((n) => {
      const o = l$(n);
      return Yn(o, (a) => _o(e, a)).map((a) => ({
        index: a,
        all: o
      }));
    }), u$ = (e, t, n) => C2(e, n).fold(() => dh.none(e), (s) => JC(s.all, e, s.index, 1, t)), f$ = (e, t, n) => C2(e, n).fold(() => dh.none(), (s) => JC(s.all, e, s.index, -1, t)), d$ = (e) => Ma(e, "[contenteditable]"), S2 = (e, t = !1) => On(e) ? e.dom.isContentEditable : d$(e).fold(Z(t), (n) => m$(n) === "true"), m$ = (e) => e.dom.contentEditable, p$ = (e, t) => ({
      left: e.left - t,
      top: e.top - t,
      right: e.right + t * 2,
      bottom: e.bottom + t * 2,
      width: e.width + t,
      height: e.height + t
    }), g$ = (e, t) => Xt(t, (n) => {
      const o = p$(_l(n.getBoundingClientRect()), -1);
      return [
        {
          x: o.left,
          y: e(o),
          cell: n
        },
        {
          x: o.right,
          y: e(o),
          cell: n
        }
      ];
    }), h$ = (e, t, n) => En(e, (o, s) => o.fold(() => w.some(s), (a) => {
      const i = Math.sqrt(Math.abs(a.x - t) + Math.abs(a.y - n)), u = Math.sqrt(Math.abs(s.x - t) + Math.abs(s.y - n));
      return w.some(u < i ? s : a);
    }), w.none()), x2 = (e, t, n, o, s) => {
      const a = br(ne.fromDom(n), "td,th,caption").map((u) => u.dom), i = Qe(g$(e, a), (u) => t(u, s));
      return h$(i, o, s).map((u) => u.cell);
    }, y$ = (e) => e.bottom, b$ = (e) => e.top, k$ = (e, t) => e.y < t, w$ = (e, t) => e.y > t, _$ = et(x2, y$, k$), v$ = et(x2, b$, w$), C$ = (e, t) => Tn(t.getClientRects()).bind((n) => _$(e, n.left, n.top)).bind((n) => V1(Y4(n), t)), S$ = (e, t) => Pn(t.getClientRects()).bind((n) => v$(e, n.left, n.top)).bind((n) => V1(K4(n), t)), x$ = (e, t, n) => n.breakAt.exists((o) => e(t, o).breakAt.isSome()), E$ = (e) => e.breakType === ji.Wrap && e.positions.length === 0, T$ = (e) => e.breakType === ji.Br && e.positions.length === 1, E2 = (e, t, n) => {
      const o = e(t, n);
      return E$(o) || !ds(n.getNode()) && T$(o) ? !x$(e, t, o) : o.breakAt.isNone();
    }, z$ = et(E2, ih), A$ = et(E2, lh), N$ = (e, t, n) => {
      const o = je.fromRangeStart(t);
      return Al(!e, n).exists((s) => s.isEqual(o));
    }, R$ = (e, t, n, o) => {
      const s = e.selection.getRng(), a = t ? 1 : -1;
      return wu() && N$(t, s, n) ? (Fl(a, e, n, !t, !1).each((i) => {
        Il(e, i);
      }), !0) : !1;
    }, D$ = (e, t, n) => C$(t, n).orThunk(() => Tn(n.getClientRects()).bind((o) => HC(Rz(e, je.before(t)), o.left))).getOr(je.before(t)), O$ = (e, t, n) => S$(t, n).orThunk(() => Tn(n.getClientRects()).bind((o) => HC(Dz(e, je.after(t)), o.left))).getOr(je.after(t)), T2 = (e, t) => {
      const n = t.getNode(e);
      return La(n) ? w.some(n) : w.none();
    }, P$ = (e, t, n) => {
      t.undoManager.transact(() => {
        const o = e ? ra : yr, s = r2(t, ne.fromDom(n), o);
        Il(t, s);
      });
    }, z2 = (e, t, n) => {
      const o = T2(!!t, n), s = t === !1;
      o.fold(() => Il(e, n.toRange()), (a) => Al(s, e.getBody()).filter((i) => i.isEqual(n)).fold(() => Il(e, n.toRange()), (i) => P$(t, e, a)));
    }, B$ = (e, t, n, o) => {
      const s = e.selection.getRng(), a = je.fromRangeStart(s), i = e.getBody();
      if (!t && z$(o, a)) {
        const u = D$(i, n, a);
        return z2(e, t, u), !0;
      } else if (t && A$(o, a)) {
        const u = O$(i, n, a);
        return z2(e, t, u), !0;
      } else
        return !1;
    }, A2 = (e, t, n) => w.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((o) => w.from(e.dom.getParent(o, "table")).map((s) => n(e, t, s, o))).getOr(!1), N2 = (e, t) => A2(e, t, R$), R2 = (e, t) => A2(e, t, B$), $$ = (e) => {
      const t = Iu.exact(e, 0, e, 0);
      return jg(t);
    }, D2 = (e, t, n) => n.fold(w.none, w.none, (o, s) => _v(s).map((a) => $$(a)), (o) => (e.execCommand("mceTableInsertRowAfter"), O2(e, t, o))), O2 = (e, t, n) => D2(e, t, u$(n, S2)), F$ = (e, t, n) => D2(e, t, f$(n, S2)), P2 = (e, t) => {
      const n = [
        "table",
        "li",
        "dl"
      ], o = ne.fromDom(e.getBody()), s = (u) => {
        const d = tn(u);
        return _o(u, o) || ce(n, d);
      }, a = e.selection.getRng(), i = ne.fromDom(t ? a.endContainer : a.startContainer);
      return i$(i, s).map((u) => (v2(u, s).each((v) => {
        e.model.table.clearSelectedCells(v.dom);
      }), e.selection.collapse(!t), (t ? O2 : F$)(e, s, u).each((v) => {
        e.selection.setRng(v);
      }), !0)).getOr(!1);
    }, I$ = (e, t, n) => {
      const o = Gn.os.isMacOS() || Gn.os.isiOS();
      fh([
        {
          keyCode: sn.RIGHT,
          action: Kn(u2, e, !0)
        },
        {
          keyCode: sn.LEFT,
          action: Kn(u2, e, !1)
        },
        {
          keyCode: sn.UP,
          action: Kn(f2, e, !1)
        },
        {
          keyCode: sn.DOWN,
          action: Kn(f2, e, !0)
        },
        ...o ? [
          {
            keyCode: sn.UP,
            action: Kn(Y1, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: sn.DOWN,
            action: Kn(Y1, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: sn.RIGHT,
          action: Kn(N2, e, !0)
        },
        {
          keyCode: sn.LEFT,
          action: Kn(N2, e, !1)
        },
        {
          keyCode: sn.UP,
          action: Kn(R2, e, !1)
        },
        {
          keyCode: sn.DOWN,
          action: Kn(R2, e, !0)
        },
        {
          keyCode: sn.RIGHT,
          action: Kn(y2, e, !0)
        },
        {
          keyCode: sn.LEFT,
          action: Kn(y2, e, !1)
        },
        {
          keyCode: sn.UP,
          action: Kn(b2, e, !1)
        },
        {
          keyCode: sn.DOWN,
          action: Kn(b2, e, !0)
        },
        {
          keyCode: sn.RIGHT,
          action: Kn(Wz, e, t, !0)
        },
        {
          keyCode: sn.LEFT,
          action: Kn(Wz, e, t, !1)
        },
        {
          keyCode: sn.RIGHT,
          ctrlKey: !o,
          altKey: o,
          action: Kn(m8, e, t)
        },
        {
          keyCode: sn.LEFT,
          ctrlKey: !o,
          altKey: o,
          action: Kn(p8, e, t)
        },
        {
          keyCode: sn.UP,
          action: Kn(m2, e, !1)
        },
        {
          keyCode: sn.DOWN,
          action: Kn(m2, e, !0)
        }
      ], n).each((s) => {
        n.preventDefault();
      });
    }, L$ = (e, t) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() === !1 && I$(e, t, n);
      });
    }, ti = (e, t) => ({
      container: e,
      offset: t
    }), X1 = Uo.DOM, Z1 = (e) => (t) => e === t ? -1 : 0, M$ = (e) => (t) => e.isBlock(t) || ce([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], t.nodeName) || e.getContentEditable(t) === "false", eS = (e, t, n) => {
      if (Ft(e) && t >= 0)
        return w.some(ti(e, t));
      {
        const o = Ri(X1);
        return w.from(o.backwards(e, t, Z1(e), n)).map((s) => ti(s.container, s.container.data.length));
      }
    }, j$ = (e, t, n) => {
      if (Ft(e) && t >= e.length)
        return w.some(ti(e, t));
      {
        const o = Ri(X1);
        return w.from(o.forwards(e, t, Z1(e), n)).map((s) => ti(s.container, 0));
      }
    }, tS = (e, t, n) => {
      if (!Ft(e))
        return w.none();
      const o = e.textContent;
      if (t >= 0 && t <= o.length)
        return w.some(ti(e, t));
      {
        const s = Ri(X1);
        return w.from(s.backwards(e, t, Z1(e), n)).bind((a) => {
          const i = a.container.data;
          return tS(a.container, t + i.length, n);
        });
      }
    }, B2 = (e, t, n) => {
      if (!Ft(e))
        return w.none();
      const o = e.textContent;
      if (t <= o.length)
        return w.some(ti(e, t));
      {
        const s = Ri(X1);
        return w.from(s.forwards(e, t, Z1(e), n)).bind((a) => B2(a.container, t - o.length, n));
      }
    }, nS = (e, t, n, o, s) => {
      const a = Ri(e, M$(e));
      return w.from(a.backwards(t, n, o, s));
    }, U$ = (e) => e.collapsed && e.startContainer.nodeType === 3, $2 = (e) => e.toString().replace(/\u00A0/g, " ").replace(/\uFEFF/g, ""), F2 = (e) => e !== "" && ` \xA0\f
\r	\v`.indexOf(e) !== -1, oS = (e, t) => e.substring(t.length), H$ = (e, t, n) => {
      let o;
      for (o = t - 1; o >= 0; o--) {
        const s = e.charAt(o);
        if (F2(s))
          return w.none();
        if (s === n)
          break;
      }
      return w.some(o);
    }, W$ = (e, t, n, o = 0) => {
      if (!U$(t))
        return w.none();
      const s = (i, u, d) => H$(d, u, n).getOr(u), a = e.getParent(t.startContainer, e.isBlock) || e.getRoot();
      return nS(e, t.startContainer, t.startOffset, s, a).bind((i) => {
        const u = t.cloneRange();
        if (u.setStart(i.container, i.offset), u.setEnd(t.endContainer, t.endOffset), u.collapsed)
          return w.none();
        const d = $2(u);
        return d.lastIndexOf(n) !== 0 || oS(d, n).length < o ? w.none() : w.some({
          text: oS(d, n),
          range: u,
          triggerChar: n
        });
      });
    }, I2 = (e, t, n, o = 0) => Qg(ne.fromDom(t.startContainer)).fold(() => W$(e, t, n, o), (s) => {
      const a = e.createRng();
      a.selectNode(s.dom);
      const i = $2(a);
      return w.some({
        range: a,
        text: oS(i, n),
        triggerChar: n
      });
    }), q$ = (e) => e.nodeType === Zt, V$ = (e) => e.nodeType === He, L2 = (e) => {
      if (q$(e))
        return ti(e, e.data.length);
      {
        const t = e.childNodes;
        return t.length > 0 ? L2(t[t.length - 1]) : ti(e, t.length);
      }
    }, M2 = (e, t) => {
      const n = e.childNodes;
      return n.length > 0 && t < n.length ? M2(n[t], 0) : n.length > 0 && V$(e) && n.length === t ? L2(n[n.length - 1]) : ti(e, t);
    }, G$ = (e, t) => {
      const n = e.getParent(t.container, e.isBlock);
      return nS(e, t.container, t.offset, (o, s) => s === 0 ? -1 : s, n).filter((o) => {
        const s = o.container.data.charAt(o.offset - 1);
        return !F2(s);
      }).isSome();
    }, K$ = (e) => (t) => {
      const n = M2(t.startContainer, t.startOffset);
      return !G$(e, n);
    }, Y$ = (e, t, n) => Bo(n.triggerChars, (o) => I2(e, t, o)), X$ = (e, t) => {
      const n = t(), o = e.selection.getRng();
      return Y$(e.dom, o, n).bind((s) => j2(e, t, s));
    }, j2 = (e, t, n, o = {}) => {
      const s = t(), i = e.selection.getRng().startContainer.nodeValue, u = Qe(s.lookupByChar(n.triggerChar), (y) => n.text.length >= y.minChars && y.matches.getOrThunk(() => K$(e.dom))(n.range, i, n.text));
      if (u.length === 0)
        return w.none();
      const d = Promise.all(W(u, (y) => y.fetch(n.text, y.maxResults, o).then((T) => ({
        matchText: n.text,
        items: T,
        columns: y.columns,
        onAction: y.onAction,
        highlightOn: y.highlightOn
      }))));
      return w.some({
        lookupData: d,
        context: n
      });
    };
    var ni;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(ni || (ni = {}));
    const sS = (e, t, n) => e.stype === ni.Error ? t(e.serror) : n(e.svalue), Z$ = (e) => {
      const t = [], n = [];
      return M(e, (o) => {
        sS(o, (s) => n.push(s), (s) => t.push(s));
      }), {
        values: t,
        errors: n
      };
    }, Q$ = (e, t) => e.stype === ni.Error ? {
      stype: ni.Error,
      serror: t(e.serror)
    } : e, J$ = (e, t) => e.stype === ni.Value ? {
      stype: ni.Value,
      svalue: t(e.svalue)
    } : e, eF = (e, t) => e.stype === ni.Value ? t(e.svalue) : e, tF = (e, t) => e.stype === ni.Error ? t(e.serror) : e, U2 = (e) => ({
      stype: ni.Value,
      svalue: e
    }), H2 = (e) => ({
      stype: ni.Error,
      serror: e
    }), pr = {
      fromResult: (e) => e.fold(H2, U2),
      toResult: (e) => sS(e, Dr.error, Dr.value),
      svalue: U2,
      partition: Z$,
      serror: H2,
      bind: eF,
      bindError: tF,
      map: J$,
      mapError: Q$,
      fold: sS
    }, rS = (e) => zt(e) && ze(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), nF = (e) => {
      const t = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: Z("... (only showing first ten failures)")
      }]) : e;
      return W(t, (n) => "Failed path: (" + n.path.join(" > ") + `)
` + n.getErrorInfo());
    }, Q1 = (e, t) => pr.serror([{
      path: e,
      getErrorInfo: t
    }]), oF = (e, t, n) => Q1(e, () => 'Could not find valid *required* value for "' + t + '" in ' + rS(n)), sF = (e, t) => Q1(e, () => 'Choice schema did not contain choice key: "' + t + '"'), rF = (e, t, n) => Q1(e, () => 'The chosen schema: "' + n + '" did not exist in branches: ' + rS(t)), aF = (e, t) => Q1(e, Z(t)), cF = (e, t, n, o) => Vn(n, o).fold(() => rF(e, n, o), (a) => a.extract(e.concat(["branch: " + o]), t)), iF = (e, t) => ({
      extract: (s, a) => Vn(a, e).fold(() => sF(s, e), (u) => cF(s, a, t, u)),
      toString: () => "chooseOn(" + e + "). Possible values: " + ze(t)
    }), lF = (e, t) => t, uF = (e, t) => ot(e) && ot(t) ? J1(e, t) : t, W2 = (e) => (...t) => {
      if (t.length === 0)
        throw new Error("Can't merge zero objects");
      const n = {};
      for (let o = 0; o < t.length; o++) {
        const s = t[o];
        for (const a in s)
          gn(s, a) && (n[a] = e(n[a], s[a]));
      }
      return n;
    }, J1 = W2(uF), fF = W2(lF), q2 = () => ({
      tag: "required",
      process: {}
    }), dF = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), V2 = (e) => dF(Z(e)), mF = () => ({
      tag: "option",
      process: {}
    }), pF = (e, t) => e.length > 0 ? pr.svalue(J1(t, fF.apply(void 0, e))) : pr.svalue(t), G2 = (e) => Ze(pr.serror, eo)(e), gF = {
      consolidateObj: (e, t) => {
        const n = pr.partition(e);
        return n.errors.length > 0 ? G2(n.errors) : pF(n.values, t);
      },
      consolidateArr: (e) => {
        const t = pr.partition(e);
        return t.errors.length > 0 ? G2(t.errors) : pr.svalue(t.values);
      }
    }, hF = (e, t, n, o) => ({
      tag: "field",
      key: e,
      newKey: t,
      presence: n,
      prop: o
    }), yF = (e, t) => ({
      tag: "custom",
      newKey: e,
      instantiator: t
    }), K2 = (e, t, n) => {
      switch (e.tag) {
        case "field":
          return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return n(e.newKey, e.instantiator);
      }
    }, aS = (e) => {
      const t = (o, s) => pr.bindError(e(s), (a) => aF(o, a)), n = Z("val");
      return {
        extract: t,
        toString: n
      };
    }, bF = aS(pr.svalue), kF = (e, t, n, o) => Vn(t, n).fold(() => oF(e, n, t), o), Y2 = (e, t, n, o) => {
      const s = Vn(e, t).getOrThunk(() => n(e));
      return o(s);
    }, wF = (e, t, n) => n(Vn(e, t)), _F = (e, t, n, o) => {
      const s = Vn(e, t).map((a) => a === !0 ? n(e) : a);
      return o(s);
    }, vF = (e, t, n, o, s) => {
      const a = (u) => s.extract(t.concat([o]), u), i = (u) => u.fold(() => pr.svalue(w.none()), (d) => {
        const y = s.extract(t.concat([o]), d);
        return pr.map(y, w.some);
      });
      switch (e.tag) {
        case "required":
          return kF(t, n, o, a);
        case "defaultedThunk":
          return Y2(n, o, e.process, a);
        case "option":
          return wF(n, o, i);
        case "defaultedOptionThunk":
          return _F(n, o, e.process, i);
        case "mergeWithThunk":
          return Y2(n, o, Z({}), (u) => {
            const d = J1(e.process(n), u);
            return a(d);
          });
      }
    }, CF = (e, t, n) => {
      const o = {}, s = [];
      for (const a of n)
        K2(a, (i, u, d, y) => {
          const v = vF(d, e, t, i, y);
          pr.fold(v, (T) => {
            s.push(...T);
          }, (T) => {
            o[u] = T;
          });
        }, (i, u) => {
          o[i] = u(t);
        });
      return s.length > 0 ? pr.serror(s) : pr.svalue(o);
    }, cS = (e) => ({
      extract: (o, s) => CF(o, s, e),
      toString: () => {
        const o = W(e, (s) => K2(s, (a, i, u, d) => a + " -> " + d.toString(), (a, i) => "state(" + a + ")"));
        return `obj{
` + o.join(`
`) + "}";
      }
    }), X2 = (e) => ({
      extract: (o, s) => {
        const a = W(s, (i, u) => e.extract(o.concat(["[" + u + "]"]), i));
        return gF.consolidateArr(a);
      },
      toString: () => "array(" + e.toString() + ")"
    }), SF = (e) => aS((t) => e(t).fold(pr.serror, pr.svalue)), xF = (e, t, n) => {
      const o = t.extract([e], n);
      return pr.mapError(o, (s) => ({
        input: n,
        errors: s
      }));
    }, EF = (e, t, n) => pr.toResult(xF(e, t, n)), TF = (e) => `Errors: 
` + nF(e.errors).join(`
`) + `

Input object: ` + rS(e.input), Z2 = (e, t) => iF(e, hn(t, cS)), zF = Z(bF), ek = (e, t) => aS((n) => {
      const o = typeof n;
      return e(n) ? pr.svalue(n) : pr.serror(`Expected type: ${t} but got: ${o}`);
    }), AF = ek(Je, "number"), tk = ek(ge, "string"), NF = ek(ft, "boolean"), iS = ek(Wt, "function"), mh = hF, Q2 = yF, RF = (e) => SF((t) => ce(e, t) ? Dr.value(t) : Dr.error(`Unsupported value: "${t}", choose one of "${e.join(", ")}".`)), J2 = (e, t) => mh(e, e, q2(), t), eA = (e) => J2(e, tk), tA = (e) => J2(e, iS), DF = (e, t) => mh(e, e, q2(), X2(t)), lS = (e, t) => mh(e, e, mF(), t), nk = (e) => lS(e, tk), OF = (e) => lS(e, iS), PF = (e, t) => mh(e, e, V2(t), zF()), cp = (e, t, n) => mh(e, e, V2(t), n), nA = (e, t) => cp(e, t, AF), BF = (e, t) => cp(e, t, tk), oA = (e, t, n) => cp(e, t, RF(n)), uS = (e, t) => cp(e, t, NF), fS = (e, t) => cp(e, t, iS), $F = (e, t, n) => cp(e, t, X2(n)), FF = eA("type"), IF = tA("fetch"), dS = tA("onAction"), LF = fS("onSetup", () => ye), MF = nk("text"), jF = nk("icon"), UF = nk("tooltip"), HF = nk("label"), WF = uS("active", !1), qF = uS("enabled", !0), sA = uS("primary", !1), VF = (e) => PF("columns", e), ph = (e) => BF("type", e), GF = cS([
      FF,
      eA("ch"),
      nA("minChars", 1),
      VF(1),
      nA("maxResults", 10),
      OF("matches"),
      IF,
      dS,
      $F("highlightOn", [], tk)
    ]), KF = (e) => EF("Autocompleter", GF, e), mS = [
      qF,
      UF,
      jF,
      MF,
      LF
    ], rA = [WF].concat(mS), YF = [
      fS("predicate", cn),
      oA("scope", "node", [
        "node",
        "editor"
      ]),
      oA("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], XF = mS.concat([
      ph("contextformbutton"),
      sA,
      dS,
      Q2("original", Pe)
    ]), ZF = rA.concat([
      ph("contextformbutton"),
      sA,
      dS,
      Q2("original", Pe)
    ]), QF = mS.concat([ph("contextformbutton")]), JF = rA.concat([ph("contextformtogglebutton")]), eI = Z2("type", {
      contextformbutton: XF,
      contextformtogglebutton: ZF
    });
    cS([
      ph("contextform"),
      fS("initValue", Z("")),
      HF,
      DF("commands", eI),
      lS("launch", Z2("type", {
        contextformbutton: QF,
        contextformtogglebutton: JF
      }))
    ].concat(YF));
    const tI = (e) => {
      const t = e.ui.registry.getAll().popups, n = hn(t, (i) => KF(i).fold((u) => {
        throw new Error(TF(u));
      }, Pe)), o = Io(wo(n, (i) => i.ch)), s = os(n);
      return {
        dataset: n,
        triggerChars: o,
        lookupByChar: (i) => Qe(s, (u) => u.ch === i)
      };
    }, nI = (e, t) => {
      const n = Xd(t.load, 50);
      e.on("keypress compositionend", (o) => {
        o.which !== 27 && n.throttle();
      }), e.on("keydown", (o) => {
        const s = o.which;
        s === 8 ? n.throttle() : s === 27 && t.cancelIfNecessary();
      }), e.on("remove", n.cancel);
    }, oI = (e) => {
      const t = jc(), n = vs(!1), o = t.isSet, s = () => {
        o() && (a9(e), qb(e), n.set(!1), t.clear());
      }, a = (y) => {
        o() || (r9(e, y.range), t.set({
          triggerChar: y.triggerChar,
          matchLength: y.text.length
        }));
      }, i = rn(() => tI(e)), u = (y) => t.get().map((v) => I2(e.dom, e.selection.getRng(), v.triggerChar).bind((T) => j2(e, i, T, y))).getOrThunk(() => X$(e, i)), d = (y) => {
        u(y).fold(s, (v) => {
          a(v.context), v.lookupData.then((T) => {
            t.get().map((N) => {
              const F = v.context;
              N.triggerChar === F.triggerChar && (F.text.length - N.matchLength >= 10 ? s() : (t.set({
                ...N,
                matchLength: F.text.length
              }), n.get() ? Wb(e, { lookupData: T }) : (n.set(!0), Hb(e, { lookupData: T }))));
            });
          });
        });
      };
      e.addCommand("mceAutocompleterReload", (y, v) => {
        const T = zt(v) ? v.fetchOptions : {};
        d(T);
      }), e.addCommand("mceAutocompleterClose", s), nI(e, {
        cancelIfNecessary: s,
        load: d
      });
    }, aA = (e) => (t, n, o = {}) => {
      const s = t.getBody(), a = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: s,
        currentTarget: s,
        eventPhase: Event.AT_TARGET,
        originalTarget: s,
        explicitOriginalTarget: s,
        isTrusted: !1,
        srcElement: s,
        cancelable: !1,
        preventDefault: ye,
        inputType: n
      }, i = Lp(new InputEvent(e));
      return t.dispatch(e, {
        ...i,
        ...a,
        ...o
      });
    }, pS = aA("input"), gS = aA("beforeinput"), sI = (e, t, n) => {
      const o = n.keyCode === sn.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
      h2([
        {
          keyCode: sn.BACKSPACE,
          action: Kn(e2, e)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(IC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(IC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(BC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(BC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(GC, e, t, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(GC, e, t, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(Wv, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(Wv, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(LC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(LC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(XC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(XC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(OC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(OC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(DC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(DC, e, !0)
        },
        {
          keyCode: sn.BACKSPACE,
          action: Kn(KC, e, !1)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(KC, e, !0)
        }
      ], n).each((s) => {
        n.preventDefault(), gS(e, o).isDefaultPrevented() || (s(), pS(e, o));
      });
    }, rI = (e, t) => {
      fh([
        {
          keyCode: sn.BACKSPACE,
          action: Kn(yz, e)
        },
        {
          keyCode: sn.DELETE,
          action: Kn(yz, e)
        }
      ], t);
    }, aI = (e, t) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() === !1 && sI(e, t, n);
      }), e.on("keyup", (n) => {
        n.isDefaultPrevented() === !1 && rI(e, n);
      });
    }, cI = (e) => {
      for (; e; ) {
        if (e.nodeType === 1 || e.nodeType === 3 && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
    }, gh = (e, t) => {
      let n, o = t;
      const s = e.dom, a = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!t)
        return;
      if (/^(LI|DT|DD)$/.test(t.nodeName)) {
        const u = cI(t.firstChild);
        u && /^(UL|OL|DL)$/.test(u.nodeName) && t.insertBefore(s.doc.createTextNode(Ws), t.firstChild);
      }
      const i = s.createRng();
      if (t.normalize(), t.hasChildNodes()) {
        const u = new hs(t, t);
        for (; n = u.current(); ) {
          if (Ft(n)) {
            i.setStart(n, 0), i.setEnd(n, 0);
            break;
          }
          if (a[n.nodeName.toLowerCase()]) {
            i.setStartBefore(n), i.setEndBefore(n);
            break;
          }
          o = n, n = u.next();
        }
        n || (i.setStart(o, 0), i.setEnd(o, 0));
      } else
        ds(t) ? t.nextSibling && s.isBlock(t.nextSibling) ? (i.setStartBefore(t), i.setEndBefore(t)) : (i.setStartAfter(t), i.setEndAfter(t)) : (i.setStart(t, 0), i.setEnd(t, 0));
      e.selection.setRng(i), Uu(e, i);
    }, iI = (e, t) => {
      const n = e.getRoot();
      let o, s;
      for (o = t; o !== n && e.getContentEditable(o) !== "false"; )
        e.getContentEditable(o) === "true" && (s = o), o = o.parentNode;
      return o !== n ? s : n;
    }, hS = (e) => w.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), lI = (e) => hS(e).fold(Z(""), (t) => t.nodeName.toUpperCase()), uI = (e) => hS(e).filter((t) => dl(ne.fromDom(t))).isSome(), fI = (e, t) => e.firstChild && e.firstChild.nodeName === t, dI = (e) => {
      var t;
      return ((t = e.parentNode) === null || t === void 0 ? void 0 : t.firstChild) === e;
    }, cA = (e, t) => e && e.parentNode && e.parentNode.nodeName === t, iA = (e) => e && /^(OL|UL|LI)$/.test(e.nodeName), mI = (e) => iA(e) && iA(e.parentNode), ok = (e) => {
      const t = e.parentNode;
      return /^(LI|DT|DD)$/.test(t.nodeName) ? t : e;
    }, sk = (e, t, n) => {
      let o = e[n ? "firstChild" : "lastChild"];
      for (; o && !dn(o); )
        o = o[n ? "nextSibling" : "previousSibling"];
      return o === t;
    }, pI = (e, t, n, o, s) => {
      const a = e.dom, i = e.selection.getRng();
      if (n === e.getBody())
        return;
      mI(n) && (s = "LI");
      let u = t(s);
      if (sk(n, o, !0) && sk(n, o, !1))
        if (cA(n, "LI")) {
          const d = ok(n);
          a.insertAfter(u, d), dI(n) ? a.remove(d) : a.remove(n);
        } else
          a.replace(u, n);
      else if (sk(n, o, !0))
        cA(n, "LI") ? (a.insertAfter(u, ok(n)), u.appendChild(a.doc.createTextNode(" ")), u.appendChild(n)) : n.parentNode.insertBefore(u, n), a.remove(o);
      else if (sk(n, o, !1))
        a.insertAfter(u, ok(n)), a.remove(o);
      else {
        n = ok(n);
        const d = i.cloneRange();
        d.setStartAfter(o), d.setEndAfter(n);
        const y = d.extractContents();
        s === "LI" && fI(y, "LI") ? (u = y.firstChild, a.insertAfter(y, n)) : (a.insertAfter(y, n), a.insertAfter(u, n)), a.remove(o);
      }
      gh(e, u);
    }, gI = (e) => {
      M(kf(ne.fromDom(e), ko), (t) => {
        const n = t.dom;
        n.nodeValue = E(n.nodeValue);
      });
    }, hI = (e, t) => t && t.nodeName === "A" && e.isEmpty(t), yI = (e) => e && /^(TD|TH|CAPTION)$/.test(e.nodeName), yS = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, bS = (e, t) => e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t, lA = (e, t) => t && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && e.getContentEditable(t) !== "true", bI = (e, t, n) => {
      let o = n;
      const s = [];
      let a;
      if (!!o) {
        for (; o = o.firstChild; ) {
          if (e.isBlock(o))
            return;
          dn(o) && !t[o.nodeName.toLowerCase()] && s.push(o);
        }
        for (a = s.length; a--; )
          o = s[a], (!o.hasChildNodes() || o.firstChild === o.lastChild && o.firstChild.nodeValue === "" || hI(e, o)) && e.remove(o);
      }
    }, kS = (e, t, n) => Ft(t) === !1 ? n : e ? n === 1 && t.data.charAt(n - 1) === m ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === m ? t.data.length : n, kI = (e) => {
      const t = e.cloneRange();
      return t.setStart(e.startContainer, kS(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, kS(!1, e.endContainer, e.endOffset)), t;
    }, wI = (e) => {
      do
        Ft(e) && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, "")), e = e.firstChild;
      while (e);
    }, uA = (e, t) => {
      const n = e.getRoot();
      let o, s;
      for (o = t; o !== n && e.getContentEditable(o) !== "false"; )
        e.getContentEditable(o) === "true" && (s = o), o = o.parentNode;
      return o !== n ? s : n;
    }, _I = (e, t, n) => {
      const o = e.dom;
      w.from(n.style).map(o.parseStyle).each((d) => {
        const v = {
          ...hd(ne.fromDom(t)),
          ...d
        };
        o.setStyles(t, v);
      });
      const s = w.from(n.class).map((d) => d.split(/\s+/)), a = w.from(t.className).map((d) => Qe(d.split(/\s+/), (y) => y !== ""));
      zo(s, a, (d, y) => {
        const v = Qe(y, (N) => !ce(d, N)), T = [
          ...d,
          ...v
        ];
        o.setAttrib(t, "class", T.join(" "));
      });
      const i = [
        "style",
        "class"
      ], u = rs(n, (d, y) => !ce(i, y));
      o.setAttribs(t, u);
    }, hh = (e, t) => {
      if (la(e).toLowerCase() === t.tagName.toLowerCase()) {
        const o = Df(e);
        _I(e, t, o);
      }
    }, vI = (e, t, n, o, s) => {
      let a, i, u, d, y, v;
      const T = e.dom, N = uA(T, o);
      if (i = T.getParent(o, T.isBlock), !i || !lA(T, i)) {
        if (i = i || N, i === e.getBody() || yI(i) ? v = i.nodeName.toLowerCase() : v = i.parentNode.nodeName.toLowerCase(), !i.hasChildNodes())
          return a = T.create(t), hh(e, a), i.appendChild(a), n.setStart(a, 0), n.setEnd(a, 0), a;
        for (d = o; d.parentNode !== i; )
          d = d.parentNode;
        for (; d && !T.isBlock(d); )
          u = d, d = d.previousSibling;
        if (u && e.schema.isValidChild(v, t.toLowerCase())) {
          for (a = T.create(t), hh(e, a), u.parentNode.insertBefore(a, u), d = u; d && !T.isBlock(d); )
            y = d.nextSibling, a.appendChild(d), d = y;
          n.setStart(o, s), n.setEnd(o, s);
        }
      }
      return o;
    }, CI = (e, t) => {
      t.normalize();
      const n = t.lastChild;
      (!n || /^(left|right)$/gi.test(e.getStyle(n, "float", !0))) && e.add(t, "br");
    }, SI = (e, t) => {
      const n = t_(e);
      return Ve(t) ? !1 : ge(n) ? ce(nt.explode(n), t.nodeName.toLowerCase()) : n;
    }, fA = {
      insert: (e, t) => {
        let n, o, s, a, i, u, d, y, v;
        const T = e.dom, N = e.schema, F = N.getNonEmptyElements(), U = e.selection.getRng(), j = la(e), H = (lt) => {
          let gt = o, Dt, Pt, bn;
          const nn = N.getTextInlineElements();
          if (lt || y === "TABLE" || y === "HR" ? Dt = T.create(lt || j) : Dt = a.cloneNode(!1), bn = Dt, e_(e) === !1)
            T.setAttrib(Dt, "style", null), T.setAttrib(Dt, "class", null);
          else
            do
              if (nn[gt.nodeName]) {
                if (ua(gt) || fa(gt))
                  continue;
                Pt = gt.cloneNode(!1), T.setAttrib(Pt, "id", ""), Dt.hasChildNodes() ? (Pt.appendChild(Dt.firstChild), Dt.appendChild(Pt)) : (bn = Pt, Dt.appendChild(Pt));
              }
            while ((gt = gt.parentNode) && gt !== at);
          return hh(e, Dt), yS(bn), Dt;
        }, se = (lt) => {
          let gt, Dt;
          const Pt = kS(lt, o, s);
          if (Ft(o) && (lt ? Pt > 0 : Pt < o.nodeValue.length))
            return !1;
          if (o.parentNode === a && v && !lt || lt && dn(o) && o === a.firstChild)
            return !0;
          if (bS(o, "TABLE") || bS(o, "HR"))
            return v && !lt || !v && lt;
          const bn = new hs(o, a);
          for (Ft(o) && (lt && Pt === 0 ? bn.prev() : !lt && Pt === o.nodeValue.length && bn.next()); gt = bn.current(); ) {
            if (dn(gt)) {
              if (!gt.getAttribute("data-mce-bogus") && (Dt = gt.nodeName.toLowerCase(), F[Dt] && Dt !== "br"))
                return !1;
            } else if (Ft(gt) && !gc(gt.nodeValue))
              return !1;
            lt ? bn.prev() : bn.next();
          }
          return !0;
        }, ve = () => {
          /^(H[1-6]|PRE|FIGURE)$/.test(y) && Vt !== "HGROUP" ? i = H(j) : i = H(), SI(e, d) && lA(T, d) && T.isEmpty(a) ? i = T.split(d, a) : T.insertAfter(i, a), gh(e, i);
        };
        Vm(T, U).each((lt) => {
          U.setStart(lt.startContainer, lt.startOffset), U.setEnd(lt.endContainer, lt.endOffset);
        }), o = U.startContainer, s = U.startOffset;
        const Se = !!(t && t.shiftKey), Be = !!(t && t.ctrlKey);
        dn(o) && o.hasChildNodes() && (v = s > o.childNodes.length - 1, o = o.childNodes[Math.min(s, o.childNodes.length - 1)] || o, v && Ft(o) ? s = o.nodeValue.length : s = 0);
        const at = uA(T, o);
        if (!at)
          return;
        Se || (o = vI(e, j, U, o, s)), a = T.getParent(o, T.isBlock), d = a ? T.getParent(a.parentNode, T.isBlock) : null, y = a ? a.nodeName.toUpperCase() : "";
        const Vt = d ? d.nodeName.toUpperCase() : "";
        if (Vt === "LI" && !Be && (a = d, d = d.parentNode, y = Vt), /^(LI|DT|DD)$/.test(y) && T.isEmpty(a)) {
          pI(e, H, d, a, j);
          return;
        }
        a !== e.getBody() && (Me(a) ? (i = ja(a), T.isEmpty(a) && yS(a), hh(e, i), gh(e, i)) : se() ? ve() : se(!0) ? (i = a.parentNode.insertBefore(H(), a), gh(e, bS(a, "HR") ? i : a)) : (n = kI(U).cloneRange(), n.setEndAfter(a), u = n.extractContents(), gI(u), wI(u), i = u.firstChild, T.insertAfter(u, a), bI(T, F, i), CI(T, a), T.isEmpty(a) && yS(a), i.normalize(), T.isEmpty(i) ? (T.remove(i), ve()) : (hh(e, i), gh(e, i))), T.setAttrib(i, "id", ""), e.dispatch("NewBlock", { newBlock: i }));
      },
      fakeEventName: "insertParagraph"
    }, xI = (e, t, n) => {
      const o = new hs(t, n);
      let s;
      const a = e.getNonEmptyElements();
      for (; s = o.next(); )
        if (a[s.nodeName.toLowerCase()] || s.length > 0)
          return !0;
    }, dA = (e, t, n) => {
      const o = e.dom.createRng();
      n ? (o.setStartBefore(t), o.setEndBefore(t)) : (o.setStartAfter(t), o.setEndAfter(t)), e.selection.setRng(o), Uu(e, o);
    }, EI = (e, t) => {
      const n = e.selection, o = e.dom, s = n.getRng();
      let a, i;
      Vm(o, s).each((F) => {
        s.setStart(F.startContainer, F.startOffset), s.setEnd(F.endContainer, F.endOffset);
      });
      let u = s.startOffset, d = s.startContainer;
      if (d.nodeType === 1 && d.hasChildNodes()) {
        const F = u > d.childNodes.length - 1;
        d = d.childNodes[Math.min(u, d.childNodes.length - 1)] || d, F && d.nodeType === 3 ? u = d.nodeValue.length : u = 0;
      }
      let y = o.getParent(d, o.isBlock);
      const v = y ? o.getParent(y.parentNode, o.isBlock) : null, T = v ? v.nodeName.toUpperCase() : "", N = !!(t && t.ctrlKey);
      T === "LI" && !N && (y = v), d && d.nodeType === 3 && u >= d.nodeValue.length && (xI(e.schema, d, y) || (a = o.create("br"), s.insertNode(a), s.setStartAfter(a), s.setEndAfter(a), i = !0)), a = o.create("br"), fy(o, s, a), dA(e, a, i), e.undoManager.add();
    }, TI = (e, t) => {
      const n = ne.fromTag("br");
      yr(ne.fromDom(t), n), e.undoManager.add();
    }, zI = (e, t) => {
      NI(e.getBody(), t) || ra(ne.fromDom(t), ne.fromTag("br"));
      const n = ne.fromTag("br");
      ra(ne.fromDom(t), n), dA(e, n.dom, !1), e.undoManager.add();
    }, AI = (e) => ds(e.getNode()), NI = (e, t) => AI(je.after(t)) ? !0 : va(e, je.after(t)).map((n) => ds(n.getNode())).getOr(!1), mA = (e) => e && e.nodeName === "A" && "href" in e, RI = (e) => e.fold(cn, mA, mA, cn), DI = (e) => {
      const t = et(Jf, e), n = je.fromRangeStart(e.selection.getRng());
      return Mi(t, e.getBody(), n).filter(RI);
    }, OI = (e, t) => {
      t.fold(ye, et(TI, e), et(zI, e), ye);
    }, pA = {
      insert: (e, t) => {
        const n = DI(e);
        n.isSome() ? n.each(et(OI, e)) : EI(e, t);
      },
      fakeEventName: "insertLineBreak"
    }, gA = (e, t) => hS(e).filter((n) => t.length > 0 && sa(ne.fromDom(n), t)).isSome(), PI = (e) => gA(e, Qw(e)), BI = (e) => gA(e, Jw(e)), vc = bc.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), $I = (e, t) => BI(e), hA = (e) => (t, n) => uI(t) === e, yA = (e, t) => (n, o) => lI(n) === e.toUpperCase() === t, rk = (e) => yA("pre", e), FI = () => yA("summary", !0), ak = (e) => (t, n) => cm(t) === e, II = (e, t) => PI(e), ck = (e, t) => t, LI = (e) => {
      const t = la(e), n = iI(e.dom, e.selection.getStart());
      return n && e.schema.isValidChild(n.nodeName, t);
    }, oi = (e, t) => (n, o) => En(e, (a, i) => a && i(n, o), !0) ? w.some(t) : w.none(), MI = (e, t) => Cz([
      oi([$I], vc.none()),
      oi([FI()], vc.br()),
      oi([
        rk(!0),
        ak(!1),
        ck
      ], vc.br()),
      oi([
        rk(!0),
        ak(!1)
      ], vc.block()),
      oi([
        rk(!0),
        ak(!0),
        ck
      ], vc.block()),
      oi([
        rk(!0),
        ak(!0)
      ], vc.br()),
      oi([
        hA(!0),
        ck
      ], vc.br()),
      oi([hA(!0)], vc.block()),
      oi([II], vc.br()),
      oi([ck], vc.br()),
      oi([LI], vc.block())
    ], [
      e,
      !!(t && t.shiftKey)
    ]).getOr(vc.none()), ik = (e, t, n) => {
      t.selection.isCollapsed() || Bv(t), !(L(n) && gS(t, e.fakeEventName).isDefaultPrevented()) && (e.insert(t, n), L(n) && pS(t, e.fakeEventName));
    }, bA = (e, t) => {
      const n = () => ik(pA, e, t), o = () => ik(fA, e, t), s = MI(e, t);
      switch (Zw(e)) {
        case "linebreak":
          s.fold(n, n, ye);
          break;
        case "block":
          s.fold(o, o, ye);
          break;
        case "invert":
          s.fold(o, n, ye);
          break;
        default:
          s.fold(n, o, ye);
          break;
      }
    }, jI = (e, t) => {
      t.isDefaultPrevented() || (t.preventDefault(), yP(e.undoManager), e.undoManager.transact(() => {
        bA(e, t);
      }));
    }, UI = (e) => {
      e.on("keydown", (t) => {
        t.keyCode === sn.ENTER && jI(e, t);
      });
    }, HI = (e, t, n) => {
      const o = Gn.os.isMacOS() || Gn.os.isiOS();
      fh([
        {
          keyCode: sn.END,
          action: Kn(d2, e, !0)
        },
        {
          keyCode: sn.HOME,
          action: Kn(d2, e, !1)
        },
        ...o ? [] : [
          {
            keyCode: sn.HOME,
            action: Kn(Y1, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: sn.END,
            action: Kn(Y1, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: sn.END,
          action: Kn(k2, e, !0)
        },
        {
          keyCode: sn.HOME,
          action: Kn(k2, e, !1)
        },
        {
          keyCode: sn.END,
          action: Kn(K1, e, !0, t)
        },
        {
          keyCode: sn.HOME,
          action: Kn(K1, e, !1, t)
        }
      ], n).each((s) => {
        n.preventDefault();
      });
    }, WI = (e, t) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() === !1 && HI(e, t, n);
      });
    }, qI = (e) => {
      e.on("input", (t) => {
        t.isComposing === !1 && QR(e);
      });
    }, VI = Ro(), GI = (e, t, n) => {
      fh([
        {
          keyCode: sn.PAGE_UP,
          action: Kn(K1, e, !1, t)
        },
        {
          keyCode: sn.PAGE_DOWN,
          action: Kn(K1, e, !0, t)
        }
      ], n);
    }, kA = (e) => e.stopImmediatePropagation(), wA = (e) => e.keyCode === sn.PAGE_UP || e.keyCode === sn.PAGE_DOWN, _A = (e, t, n) => {
      n && !e.get() ? t.on("NodeChange", kA, !0) : !n && e.get() && t.off("NodeChange", kA), e.set(n);
    }, KI = (e, t) => {
      if (VI.os.isMacOS())
        return;
      const n = vs(!1);
      e.on("keydown", (o) => {
        wA(o) && _A(n, e, !0);
      }), e.on("keyup", (o) => {
        o.isDefaultPrevented() === !1 && GI(e, t, o), wA(o) && n.get() && (_A(n, e, !1), e.nodeChanged());
      });
    }, vA = (e, t) => {
      const n = t.container(), o = t.offset();
      return Ft(n) ? (n.insertData(o, e), w.some(je(n, o + e.length))) : Lf(t).map((s) => {
        const a = ne.fromText(e);
        return t.isAtEnd() ? ra(s, a) : yr(s, a), je(a.dom, e.length);
      });
    }, YI = et(vA, Ws), XI = et(vA, " "), ZI = (e) => (t) => t.fold((n) => ec(e.dom, je.before(n)), (n) => _r(n), (n) => qa(n), (n) => va(e.dom, je.after(n))), QI = (e, t) => (n) => WR(e, n) ? YI(t) : XI(t), JI = (e) => (t) => (e.selection.setRng(t.toRange()), e.nodeChanged(), !0), e7 = (e) => {
      const t = je.fromRangeStart(e.selection.getRng()), n = ne.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const o = et(Jf, e), s = je.fromRangeStart(e.selection.getRng());
        return Mi(o, e.getBody(), s).bind(ZI(n)).map((a) => () => QI(n, t)(a).each(JI(e)));
      } else
        return w.none();
    }, t7 = (e, t) => {
      h2([{
        keyCode: sn.SPACEBAR,
        action: Kn(e7, e)
      }], t).each((n) => {
        t.preventDefault(), gS(e, "insertText", { data: " " }).isDefaultPrevented() || (n(), pS(e, "insertText", { data: " " }));
      });
    }, n7 = (e) => {
      e.on("keydown", (t) => {
        t.isDefaultPrevented() === !1 && t7(e, t);
      });
    }, o7 = (e) => Sl(e) ? [
      {
        keyCode: sn.TAB,
        action: Kn(P2, e, !0)
      },
      {
        keyCode: sn.TAB,
        shiftKey: !0,
        action: Kn(P2, e, !1)
      }
    ] : [], s7 = (e, t) => {
      fh([...o7(e)], t).each((n) => {
        t.preventDefault();
      });
    }, r7 = (e) => {
      e.on("keydown", (t) => {
        t.isDefaultPrevented() === !1 && s7(e, t);
      });
    }, a7 = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), oI(e), $l(e))
        return vs(null);
      {
        const t = d8(e);
        return V8(e), L$(e, t), aI(e, t), UI(e), n7(e), qI(e), r7(e), WI(e, t), KI(e, t), t;
      }
    };
    class c7 {
      constructor(t) {
        this.lastPath = [], this.editor = t;
        let n;
        const o = this;
        "onselectionchange" in t.getDoc() || t.on("NodeChange click mouseup keyup focus", (s) => {
          const a = t.selection.getRng(), i = {
            startContainer: a.startContainer,
            startOffset: a.startOffset,
            endContainer: a.endContainer,
            endOffset: a.endOffset
          };
          (s.type === "nodechange" || !Zc(i, n)) && t.dispatch("SelectionChange"), n = i;
        }), t.on("contextmenu", () => {
          t.dispatch("SelectionChange");
        }), t.on("SelectionChange", () => {
          const s = t.selection.getStart(!0);
          !s || Om(t) && !o.isSameElementPath(s) && t.dom.isChildOf(s, t.getBody()) && t.nodeChanged({ selectionChange: !0 });
        }), t.on("mouseup", (s) => {
          !s.isDefaultPrevented() && Om(t) && (t.selection.getNode().nodeName === "IMG" ? xa.setEditorTimeout(t, () => {
            t.nodeChanged();
          }) : t.nodeChanged());
        });
      }
      nodeChanged(t) {
        const n = this.editor.selection;
        let o, s, a;
        this.editor.initialized && n && !dm(this.editor) && !this.editor.mode.isReadOnly() && (a = this.editor.getBody(), o = n.getStart(!0) || a, (o.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(o, a)) && (o = a), s = [], this.editor.dom.getParent(o, (i) => {
          if (i === a)
            return !0;
          s.push(i);
        }), t = t || {}, t.element = o, t.parents = s, this.editor.dispatch("NodeChange", t));
      }
      isSameElementPath(t) {
        let n;
        const o = this.editor, s = io(o.dom.getParents(t, wn, o.getBody()));
        if (s.length === this.lastPath.length) {
          for (n = s.length; n >= 0 && s[n] === this.lastPath[n]; n--)
            ;
          if (n === -1)
            return this.lastPath = s, !0;
        }
        return this.lastPath = s, !1;
      }
    }
    const CA = "x-tinymce/html", lk = Z(CA), wS = "<!-- " + CA + " -->", i7 = (e) => wS + e, l7 = (e) => e.replace(wS, ""), SA = (e) => e.indexOf(wS) !== -1, u7 = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), f7 = (e, t) => {
      let n = "<" + e;
      const o = wo(t, (s, a) => a + '="' + zi.encodeAllRaw(s) + '"');
      return o.length && (n += " " + o.join(" ")), n + ">";
    }, d7 = (e, t, n) => {
      const o = e.split(/\n\n/), s = f7(t, n), a = "</" + t + ">", i = W(o, (d) => d.split(/\n/).join("<br />")), u = (d) => s + d + a;
      return i.length === 1 ? i[0] : W(i, u).join("");
    }, xA = "%MCEPASTEBIN%", m7 = (e, t) => {
      const { dom: n, selection: o } = e, s = e.getBody();
      t.set(o.getRng());
      const a = n.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, xA);
      Gn.browser.isFirefox() && n.setStyle(a, "left", n.getStyle(s, "direction", !0) === "rtl" ? 65535 : -65535), n.bind(a, "beforedeactivate focusin focusout", (i) => {
        i.stopPropagation();
      }), a.focus(), o.select(a, !0);
    }, p7 = (e, t) => {
      const n = e.dom;
      if (_S(e)) {
        let o;
        const s = t.get();
        for (; o = _S(e); )
          n.remove(o), n.unbind(o);
        s && e.selection.setRng(s);
      }
      t.set(null);
    }, _S = (e) => e.dom.get("mcepastebin"), g7 = (e) => e && e.id === "mcepastebin", h7 = (e) => {
      const t = e.dom, n = (i, u) => {
        i.appendChild(u), t.remove(u, !0);
      }, [o, ...s] = Qe(e.getBody().childNodes, g7);
      M(s, (i) => {
        n(o, i);
      });
      const a = t.select("div[id=mcepastebin]", o);
      for (let i = a.length - 1; i >= 0; i--) {
        const u = t.create("div");
        o.insertBefore(u, a[i]), n(u, a[i]);
      }
      return o ? o.innerHTML : "";
    }, EA = (e) => e === xA, y7 = (e) => {
      const t = vs(null);
      return {
        create: () => m7(e, t),
        remove: () => p7(e, t),
        getEl: () => _S(e),
        getHtml: () => h7(e),
        getLastRng: t.get
      };
    }, TA = (e, t) => (nt.each(t, (n) => {
      ke(n, RegExp) ? e = e.replace(n, "") : e = e.replace(n[0], n[1]);
    }), e), b7 = (e) => {
      const t = Ai(), n = np({}, t);
      let o = "";
      const s = t.getVoidElements(), a = nt.makeMap("script noscript style textarea video audio iframe object", " "), i = t.getBlockElements(), u = (d) => {
        const y = d.name, v = d;
        if (y === "br") {
          o += `
`;
          return;
        }
        if (y !== "wbr") {
          if (s[y] && (o += " "), a[y]) {
            o += " ";
            return;
          }
          if (d.type === 3 && (o += d.value), !(d.name in t.getVoidElements()) && (d = d.firstChild))
            do
              u(d);
            while (d = d.next);
          i[y] && v.next && (o += `
`, y === "p" && (o += `
`));
        }
      };
      return e = TA(e, [/<!\[[^\]]+\]>/g]), u(n.parse(e)), o;
    }, zA = (e) => (e = TA(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (n, o, s) => !o && !s ? " " : Ws
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), k7 = (e) => {
      let t = 0;
      return () => e + t++;
    }, w7 = (e) => {
      const t = e.toLowerCase(), n = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return nt.hasOwn(n, t) ? "image/" + n[t] : "image/" + t;
    }, _7 = (e, t) => {
      const n = np({}, e.schema);
      n.addNodeFilter("meta", (s) => {
        nt.each(s, (a) => {
          a.remove();
        });
      });
      const o = n.parse(t, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return qu({ validate: !0 }, e.schema).serialize(o);
    }, AA = (e, t) => ({
      content: e,
      cancelled: t
    }), v7 = (e, t, n) => {
      const o = e.dom.create("div", { style: "display:none" }, t), s = N0(e, o, n);
      return AA(s.node.innerHTML, s.isDefaultPrevented());
    }, C7 = (e, t, n) => {
      const o = Vb(e, t, n), s = _7(e, o.content);
      return e.hasEventListeners("PastePostProcess") && !o.isDefaultPrevented() ? v7(e, s, n) : AA(s, o.isDefaultPrevented());
    }, S7 = (e, t, n) => C7(e, t, n), vS = (e, t) => (e.insertContent(t, {
      merge: T_(e),
      paste: !0
    }), !0), CS = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), x7 = (e, t) => CS(t) && Ce(O_(e), (n) => Xn(t.toLowerCase(), `.${n.toLowerCase()}`)), E7 = (e, t, n) => (e.undoManager.extra(() => {
      n(e, t);
    }, () => {
      e.insertContent('<img src="' + t + '">');
    }), !0), T7 = (e, t, n) => (e.undoManager.extra(() => {
      n(e, t);
    }, () => {
      e.execCommand("mceInsertLink", !1, t);
    }), !0), z7 = (e, t, n) => !e.selection.isCollapsed() && CS(t) ? T7(e, t, n) : !1, A7 = (e, t, n) => x7(e, t) ? E7(e, t, n) : !1, N7 = (e, t) => {
      nt.each([
        z7,
        A7,
        vS
      ], (n) => n(e, t, vS) !== !0);
    }, R7 = (e, t, n) => {
      n || !z_(e) ? vS(e, t) : N7(e, t);
    }, D7 = k7("mceclip"), NA = (e, t, n, o) => {
      const s = S7(e, t, n);
      s.cancelled === !1 && R7(e, s.content, o);
    }, uk = (e, t, n) => {
      const o = n || SA(t);
      NA(e, l7(t), o, !1);
    }, SS = (e, t) => {
      const n = e.dom.encode(t).replace(/\r\n/g, `
`), o = Ph(n, A_(e)), s = d7(o, la(e), Df(e));
      NA(e, s, !1, !0);
    }, RA = (e) => {
      const t = {};
      if (e && e.types)
        for (let n = 0; n < e.types.length; n++) {
          const o = e.types[n];
          try {
            t[o] = e.getData(o);
          } catch {
            t[o] = "";
          }
        }
      return t;
    }, ip = (e, t) => t in e && e[t].length > 0, DA = (e) => ip(e, "text/html") || ip(e, "text/plain"), O7 = (e, t) => {
      const n = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return L(n) ? e.dom.encode(n[1]) : null;
    }, P7 = (e, t, n, o) => {
      const s = D7(), a = lm(e) && L(n.name), i = a ? O7(e, n.name) : s, u = a ? n.name : void 0, d = t.create(s, n, o, i, u);
      return t.add(d), d;
    }, B7 = (e, t) => {
      kC(t.uri).each(({ data: n, type: o, base64Encoded: s }) => {
        const a = s ? n : btoa(n), i = t.file, u = e.editorUpload.blobCache, d = u.getByData(a, o), y = d != null ? d : P7(e, u, i, a);
        uk(e, `<img src="${y.blobUri()}">`, !1);
      });
    }, $7 = (e) => e.type === "paste", F7 = (e) => Promise.all(W(e, (t) => dT(t).then((n) => ({
      file: t,
      uri: n
    })))), I7 = (e) => {
      const t = O_(e);
      return (n) => un(n.type, "image/") && Ce(t, (o) => w7(o) === n.type);
    }, L7 = (e, t) => {
      const n = t.items ? Xt(ho(t.items), (s) => s.kind === "file" ? [s.getAsFile()] : []) : [], o = t.files ? ho(t.files) : [];
      return Qe(n.length > 0 ? n : o, I7(e));
    }, OA = (e, t, n) => {
      const o = $7(t) ? t.clipboardData : t.dataTransfer;
      if (Vc(e) && o) {
        const s = L7(e, o);
        if (s.length > 0)
          return t.preventDefault(), F7(s).then((a) => {
            n && e.selection.setRng(n), M(a, (i) => {
              B7(e, i);
            });
          }), !0;
      }
      return !1;
    }, M7 = (e) => {
      var t, n;
      return Gn.os.isAndroid() && ((n = (t = e.clipboardData) === null || t === void 0 ? void 0 : t.items) === null || n === void 0 ? void 0 : n.length) === 0;
    }, j7 = (e) => sn.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, PA = (e, t, n, o) => {
      let s = zA(n);
      const a = ip(t, lk()) || SA(n), i = !a && u7(s), u = CS(s);
      (EA(s) || !s.length || i && !u) && (o = !0), (o || u) && (ip(t, "text/plain") && i ? s = t["text/plain"] : s = b7(s)), !EA(s) && (o ? SS(e, s) : uk(e, s, a));
    }, U7 = (e, t, n) => {
      let o;
      const s = () => t.getLastRng() || e.selection.getRng();
      e.on("keydown", (a) => {
        j7(a) && !a.isDefaultPrevented() && (o = a.shiftKey && a.keyCode === 86);
      }), e.on("paste", (a) => {
        if (a.isDefaultPrevented() || M7(a))
          return;
        const i = n.get() === "text" || o;
        o = !1;
        const u = RA(a.clipboardData);
        !DA(u) && OA(e, a, s()) || (ip(u, "text/html") ? (a.preventDefault(), PA(e, u, u["text/html"], i)) : (t.create(), xa.setEditorTimeout(e, () => {
          const d = t.getHtml();
          t.remove(), PA(e, u, d, i);
        }, 0)));
      });
    }, H7 = (e) => {
      const t = (s) => un(s, "webkit-fake-url"), n = (s) => un(s, "data:"), o = (s) => {
        var a;
        return ((a = s.data) === null || a === void 0 ? void 0 : a.paste) === !0;
      };
      e.parser.addNodeFilter("img", (s, a, i) => {
        if (!Vc(e) && o(i))
          for (const u of s) {
            const d = u.attr("src");
            ge(d) && !u.attr("data-mce-object") && d !== Gn.transparentSrc && (t(d) || !Xy(e) && n(d)) && u.remove();
          }
      });
    }, W7 = (e, t, n) => {
      U7(e, t, n), H7(e);
    }, q7 = (e, t) => {
      t.get() === "text" ? (t.set("html"), Fg(e, !1)) : (t.set("text"), Fg(e, !0)), e.focus();
    }, V7 = (e, t) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        q7(e, t);
      }), e.addCommand("mceInsertClipboardContent", (n, o) => {
        o.html && uk(e, o.html, o.internal), o.text && SS(e, o.text);
      });
    }, G7 = (e, t, n) => {
      try {
        return e.clearData(), e.setData("text/html", t), e.setData("text/plain", n), e.setData(lk(), t), !0;
      } catch {
        return !1;
      }
    }, BA = (e, t, n, o) => {
      G7(e.clipboardData, t.html, t.text) ? (e.preventDefault(), o()) : n(t.html, o);
    }, $A = (e) => (t, n) => {
      const { dom: o, selection: s } = e, a = o.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), i = o.create("div", { contenteditable: "true" }, t);
      o.setStyles(a, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), a.appendChild(i), o.add(e.getBody(), a);
      const u = s.getRng();
      i.focus();
      const d = o.createRng();
      d.selectNodeContents(i), s.setRng(d), xa.setEditorTimeout(e, () => {
        s.setRng(u), o.remove(a), n();
      }, 0);
    }, FA = (e) => ({
      html: i7(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), K7 = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), IA = (e) => !e.selection.isCollapsed() || K7(e), Y7 = (e) => (t) => {
      !t.isDefaultPrevented() && IA(e) && BA(t, FA(e), $A(e), () => {
        if (Gn.browser.isChromium() || Gn.browser.isFirefox()) {
          const n = e.selection.getRng();
          xa.setEditorTimeout(e, () => {
            e.selection.setRng(n), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, X7 = (e) => (t) => {
      !t.isDefaultPrevented() && IA(e) && BA(t, FA(e), $A(e), ye);
    }, Z7 = (e) => {
      e.on("cut", Y7(e)), e.on("copy", X7(e));
    }, LA = (e, t) => {
      var n, o;
      return ju.getCaretRangeFromPoint((n = t.clientX) !== null && n !== void 0 ? n : 0, (o = t.clientY) !== null && o !== void 0 ? o : 0, e.getDoc());
    }, Q7 = (e) => {
      const t = e["text/plain"];
      return t ? t.indexOf("file://") === 0 : !1;
    }, MA = (e, t) => {
      e.focus(), t && e.selection.setRng(t);
    }, J7 = (e) => Ce(e.files, (t) => /^image\//.test(t.type)), eL = (e, t) => {
      mm(e) && e.on("dragend dragover draggesture dragdrop drop drag", (n) => {
        n.preventDefault(), n.stopPropagation();
      }), Vc(e) || e.on("drop", (n) => {
        const o = n.dataTransfer;
        o && J7(o) && n.preventDefault();
      }), e.on("drop", (n) => {
        if (n.isDefaultPrevented() || t.get())
          return;
        const o = LA(e, n);
        if (Ve(o))
          return;
        const s = RA(n.dataTransfer), a = ip(s, lk());
        if ((!DA(s) || Q7(s)) && OA(e, n, o))
          return;
        const i = s[lk()], u = i || s["text/html"] || s["text/plain"];
        u && (n.preventDefault(), xa.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            i && e.execCommand("Delete"), MA(e, o);
            const d = zA(u);
            s["text/html"] ? uk(e, d, a) : SS(e, d);
          });
        }));
      }), e.on("dragstart", (n) => {
        t.set(!0);
      }), e.on("dragover dragend", (n) => {
        Vc(e) && t.get() === !1 && (n.preventDefault(), MA(e, LA(e, n))), n.type === "dragend" && t.set(!1);
      });
    }, tL = (e) => {
      const t = (s) => (a) => {
        s(e, a);
      }, n = Pf(e);
      Wt(n) && e.on("PastePreProcess", t(n));
      const o = x_(e);
      Wt(o) && e.on("PastePostProcess", t(o));
    }, nL = (e, t) => {
      e.on("PastePreProcess", (n) => {
        n.content = t(e, n.content, n.internal);
      });
    }, oL = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, jA = (e) => nt.trim(e).replace(oL, Gc).toLowerCase(), sL = (e, t, n) => {
      const o = Ky(e);
      if (n || o === "all" || !E_(e))
        return t;
      const s = o ? o.split(/[, ]/) : [];
      if (s && o !== "none") {
        const a = e.dom, i = e.selection.getNode();
        t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (u, d, y, v) => {
          const T = a.parseStyle(a.decode(y)), N = {};
          for (let U = 0; U < s.length; U++) {
            const j = T[s[U]];
            let H = j, se = a.getStyle(i, s[U], !0);
            /color/.test(s[U]) && (H = jA(H), se = jA(se)), se !== H && (N[s[U]] = j);
          }
          const F = a.serializeStyle(N, "span");
          return F ? d + ' style="' + F + '"' + v : d + v;
        });
      } else
        t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (a, i, u, d) => i + ' style="' + u + '"' + d), t;
    }, rL = (e) => {
      (Gn.browser.isChromium() || Gn.browser.isSafari()) && nL(e, sL);
    }, aL = (e) => {
      const t = vs(!1), n = vs(Yy(e) ? "text" : "html"), o = y7(e);
      rL(e), V7(e, n), tL(e), e.on("PreInit", () => {
        Z7(e), eL(e, t), W7(e, o, n);
      });
    }, cL = (e) => {
      e.on("click", (t) => {
        e.dom.getParent(t.target, "details") && t.preventDefault();
      });
    }, iL = (e) => {
      e.parser.addNodeFilter("details", (t) => {
        M(t, (n) => {
          n.attr("data-mce-open", n.attr("open")), n.attr("open", "open");
        });
      }), e.serializer.addNodeFilter("details", (t) => {
        M(t, (n) => {
          const o = n.attr("data-mce-open");
          n.attr("open", ge(o) ? o : null), n.attr("data-mce-open", null);
        });
      });
    }, lL = (e) => {
      cL(e), iL(e);
    }, uL = ds, UA = Ft, fL = (e) => ns(e.dom), dL = (e) => ca(e.dom), HA = (e) => (t) => _o(ne.fromDom(e), t), mL = (e, t) => Oc(ne.fromDom(e), (n) => dL(n) || ia(n), HA(t)).getOr(ne.fromDom(t)).dom, WA = (e, t) => Oc(ne.fromDom(e), fL, HA(t)), qA = (e, t, n) => {
      const o = new hs(e, t), s = n ? o.next.bind(o) : o.prev.bind(o);
      let a = e;
      for (let i = n ? e : s(); i && !uL(i); i = s())
        $n(i) && (a = i);
      return a;
    }, pL = (e, t) => {
      const o = je.fromRangeStart(e).getNode(), s = mL(o, t), a = qA(o, s, !1), i = qA(o, s, !0), u = document.createRange();
      return WA(a, s).fold(() => {
        UA(a) ? u.setStart(a, 0) : u.setStartBefore(a);
      }, (d) => u.setStartBefore(d.dom)), WA(i, s).fold(() => {
        UA(i) ? u.setEnd(i, i.data.length) : u.setEndAfter(i);
      }, (d) => u.setEndAfter(d.dom)), u;
    }, gL = (e) => {
      const t = pL(e.selection.getRng(), e.getBody());
      e.selection.setRng(Yv(t));
    }, hL = (e) => {
      e.on("mousedown", (t) => {
        t.detail >= 3 && (t.preventDefault(), gL(e));
      });
    };
    var yh;
    (function(e) {
      e.Before = "before", e.After = "after";
    })(yh || (yh = {}));
    const yL = (e, t) => Math.abs(e.left - t), bL = (e, t) => Math.abs(e.right - t), kL = (e, t) => e >= t.top && e <= t.bottom, wL = (e, t) => e.top < t.bottom && e.bottom > t.top, _L = (e, t) => {
      const n = Yp(e, t) / Math.min(e.height, t.height);
      return wL(e, t) && n > 0.5;
    }, vL = (e, t) => {
      const n = Qe(e, (o) => kL(t, o));
      return ey(n).fold(() => [
        [],
        e
      ], (o) => {
        const {
          pass: s,
          fail: a
        } = kt(e, (i) => _L(i, o));
        return [
          s,
          a
        ];
      });
    }, CL = (e, t) => ({
      node: e.node,
      position: yL(e, t) < bL(e, t) ? yh.Before : yh.After
    }), SL = (e, t, n) => t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t)), xS = (e, t, n) => {
      const o = (v) => $n(v.node) ? w.some(v) : dn(v.node) ? xS(ho(v.node.childNodes), t, n) : w.none(), s = (v, T) => {
        if (v.length >= 2) {
          const N = o(v[0]).getOr(v[0]), F = o(v[1]).getOr(v[1]);
          if (Math.abs(T(N, t, n) - T(F, t, n)) < 2) {
            if (Ft(N.node))
              return w.some(N);
            if (Ft(F.node))
              return w.some(F);
          }
        }
        return w.none();
      }, a = (v, T) => {
        const N = Qt(v, (F, U) => T(F, t, n) - T(U, t, n));
        return s(N, T).orThunk(() => Bo(N, o));
      }, [i, u] = vL($z(e), n), {
        pass: d,
        fail: y
      } = kt(u, (v) => v.top < n);
      return a(i, SL).orThunk(() => a(y, Kp)).orThunk(() => a(d, Kp));
    }, xL = (e, t, n, o) => {
      const s = (a, i) => i.fold(() => xS(ho(a.dom.childNodes), n, o), (u) => {
        const d = Qe(ho(a.dom.childNodes), (y) => y !== u.dom);
        return xS(d, n, o);
      }).orThunk(() => (_o(a, e) ? w.none() : Ji(a)).bind((d) => s(d, w.some(a))));
      return s(t, w.none());
    }, EL = (e, t, n) => {
      const o = ne.fromDom(e), s = wa(o), i = ne.fromPoint(s, t, n).filter((u) => ws(o, u)).getOr(o);
      return xL(o, i, t, n);
    }, TL = (e, t, n) => EL(e, t, n).filter((o) => _u(o.node)).map((o) => CL(o, t)), VA = (e) => {
      const t = e.getBoundingClientRect(), n = e.ownerDocument, o = n.documentElement, s = n.defaultView;
      return {
        top: t.top + s.pageYOffset - o.clientTop,
        left: t.left + s.pageXOffset - o.clientLeft
      };
    }, zL = (e) => e.inline ? VA(e.getBody()) : {
      left: 0,
      top: 0
    }, AL = (e) => {
      const t = e.getBody();
      return e.inline ? {
        left: t.scrollLeft,
        top: t.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, NL = (e) => {
      const t = e.getBody(), n = e.getDoc().documentElement, o = {
        left: t.scrollLeft,
        top: t.scrollTop
      }, s = {
        left: t.scrollLeft || n.scrollLeft,
        top: t.scrollTop || n.scrollTop
      };
      return e.inline ? o : s;
    }, RL = (e, t) => {
      if (t.target.ownerDocument !== e.getDoc()) {
        const n = VA(e.getContentAreaContainer()), o = NL(e);
        return {
          left: t.pageX - n.left + o.left,
          top: t.pageY - n.top + o.top
        };
      }
      return {
        left: t.pageX,
        top: t.pageY
      };
    }, DL = (e, t, n) => ({
      pageX: n.left - e.left + t.left,
      pageY: n.top - e.top + t.top
    }), OL = (e, t) => DL(zL(e), AL(e), RL(e, t)), ES = ns, PL = ca, BL = (e, t) => ES(t) && t !== e, $L = (e, t, n) => t === n || e.dom.isChildOf(t, n) ? !1 : !ES(t), FL = (e) => {
      const t = e.cloneNode(!0);
      return t.removeAttribute("data-mce-selected"), t;
    }, IL = (e, t, n, o) => {
      const s = e.dom, a = t.cloneNode(!0);
      s.setStyles(a, {
        width: n,
        height: o
      }), s.setAttrib(a, "data-mce-selected", null);
      const i = s.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return s.setStyles(i, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: n,
        height: o
      }), s.setStyles(a, {
        margin: 0,
        boxSizing: "border-box"
      }), i.appendChild(a), i;
    }, LL = (e, t) => {
      e.parentNode !== t && t.appendChild(e);
    }, ML = (e, t, n, o, s, a) => {
      let i = 0, u = 0;
      e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + n > s && (i = t.pageX + n - s), t.pageY + o > a && (u = t.pageY + o - a), e.style.width = n - i + "px", e.style.height = o - u + "px";
    }, GA = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, jL = (e) => e.button === 0, UL = (e, t) => ({
      pageX: t.pageX - e.relX,
      pageY: t.pageY + 5
    }), HL = (e, t) => (n) => {
      if (jL(n)) {
        const o = oo(t.dom.getParents(n.target), Tw(ES, PL)).getOr(null);
        if (BL(t.getBody(), o)) {
          const s = t.dom.getPos(o), a = t.getBody(), i = t.getDoc().documentElement;
          e.set({
            element: o,
            dragging: !1,
            screenX: n.screenX,
            screenY: n.screenY,
            maxX: (t.inline ? a.scrollWidth : i.offsetWidth) - 2,
            maxY: (t.inline ? a.scrollHeight : i.offsetHeight) - 2,
            relX: n.pageX - s.x,
            relY: n.pageY - s.y,
            width: o.offsetWidth,
            height: o.offsetHeight,
            ghost: IL(t, o, o.offsetWidth, o.offsetHeight)
          });
        }
      }
    }, WL = (e, t) => {
      const n = Ni((o, s) => {
        t._selectionOverrides.hideFakeCaret(), t.selection.placeCaretAt(o, s);
      }, 0);
      return t.on("remove", n.cancel), (o) => e.on((s) => {
        const a = Math.max(Math.abs(o.screenX - s.screenX), Math.abs(o.screenY - s.screenY));
        if (!s.dragging && a > 10) {
          if (t.dispatch("dragstart", { target: s.element }).isDefaultPrevented())
            return;
          s.dragging = !0, t.focus();
        }
        if (s.dragging) {
          const i = UL(s, OL(t, o));
          LL(s.ghost, t.getBody()), ML(s.ghost, i, s.width, s.height, s.maxX, s.maxY), n.throttle(o.clientX, o.clientY);
        }
      });
    }, qL = (e) => {
      const n = e.getSel().getRangeAt(0).startContainer;
      return n.nodeType === 3 ? n.parentNode : n;
    }, VL = (e, t) => (n) => {
      e.on((o) => {
        if (o.dragging) {
          if ($L(t, qL(t.selection), o.element)) {
            const s = FL(o.element);
            t.dispatch("drop", {
              clientX: n.clientX,
              clientY: n.clientY
            }).isDefaultPrevented() || t.undoManager.transact(() => {
              GA(o.element), t.insertContent(t.dom.getOuterHTML(s)), t._selectionOverrides.hideFakeCaret();
            });
          }
          t.dispatch("dragend");
        }
      }), KA(e);
    }, GL = (e, t) => () => {
      e.on((n) => {
        n.dragging && t.dispatch("dragend");
      }), KA(e);
    }, KA = (e) => {
      e.on((t) => {
        GA(t.ghost);
      }), e.clear();
    }, KL = (e) => {
      const t = jc(), n = Uo.DOM, o = document, s = HL(t, e), a = WL(t, e), i = VL(t, e), u = GL(t, e);
      e.on("mousedown", s), e.on("mousemove", a), e.on("mouseup", i), n.bind(o, "mousemove", a), n.bind(o, "mouseup", u), e.on("remove", () => {
        n.unbind(o, "mousemove", a), n.unbind(o, "mouseup", u);
      }), e.on("keydown", (d) => {
        d.keyCode === sn.ESC && u();
      });
    }, YL = (e) => {
      const t = (s) => {
        if (!s.isDefaultPrevented()) {
          const a = s.dataTransfer;
          a && (ce(a.types, "Files") || a.files.length > 0) && (s.preventDefault(), s.type === "drop" && M1(e, "Dropped file type is not supported"));
        }
      }, n = (s) => {
        I(e, s.target) && t(s);
      }, o = () => {
        const s = Uo.DOM, a = e.dom, i = document, u = e.inline ? e.getBody() : e.getDoc(), d = [
          "drop",
          "dragover"
        ];
        M(d, (y) => {
          s.bind(i, y, n), a.bind(u, y, t);
        }), e.on("remove", () => {
          M(d, (y) => {
            s.unbind(i, y, n), a.unbind(u, y, t);
          });
        });
      };
      e.on("init", () => {
        xa.setEditorTimeout(e, o, 0);
      });
    }, XL = (e) => {
      KL(e), Uy(e) && YL(e);
    }, ZL = (e) => {
      const t = Ni(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const n = e.selection.getRng();
          if (n.collapsed) {
            const o = PC(e, n, !1);
            e.selection.setRng(o);
          }
        }
      }, 0);
      e.on("focus", () => {
        t.throttle();
      }), e.on("blur", () => {
        t.cancel();
      });
    }, QL = (e) => {
      e.on("init", () => {
        e.on("focusin", (t) => {
          const n = t.target;
          if (dc(n)) {
            const o = Jm(e.getBody(), n), s = ns(o) ? o : n;
            e.selection.getNode() !== s && ch(e, s).each((a) => e.selection.setRng(a));
          }
        });
      });
    }, lp = ns, TS = (e, t) => Jm(e.getBody(), t), JL = (e) => {
      const t = e.selection, n = e.dom, o = n.isBlock, s = e.getBody(), a = gm(e, s, o, () => Yo(e)), i = "sel-" + n.uniqueId(), u = "data-mce-selected";
      let d;
      const y = (gt) => n.hasClass(gt, "mce-offscreen-selection"), v = (gt) => gt !== s && (lp(gt) || dc(gt)) && n.isChildOf(gt, s), T = (gt) => {
        gt && t.setRng(gt);
      }, N = (gt, Dt, Pt, bn = !0) => e.dispatch("ShowCaret", {
        target: Dt,
        direction: gt,
        before: Pt
      }).isDefaultPrevented() ? null : (bn && t.scrollIntoView(Dt, gt === -1), a.show(Pt, Dt)), F = (gt) => {
        gt.hasAttribute("data-mce-caret") && (ja(gt), t.scrollIntoView(gt));
      }, U = () => {
        e.on("click", (Dt) => {
          const Pt = TS(e, Dt.target);
          Pt && lp(Pt) && (Dt.preventDefault(), e.focus());
        }), e.on("blur NewBlock", at), e.on("ResizeWindow FullscreenStateChanged", a.reposition), e.on("tap", (Dt) => {
          const Pt = Dt.target, bn = TS(e, Pt);
          lp(bn) ? (Dt.preventDefault(), ch(e, bn).each(Be)) : v(Pt) && ch(e, Pt).each(Be);
        }, !0), e.on("mousedown", (Dt) => {
          const Pt = Dt.target;
          if (Pt !== s && Pt.nodeName !== "HTML" && !n.isChildOf(Pt, s) || Q9(e, Dt.clientX, Dt.clientY) === !1)
            return;
          at(), lt();
          const bn = TS(e, Pt);
          lp(bn) ? (Dt.preventDefault(), ch(e, bn).each(Be)) : TL(s, Dt.clientX, Dt.clientY).each((nn) => {
            Dt.preventDefault();
            const Ht = N(1, nn.node, nn.position === yh.Before, !1);
            T(Ht), dn(bn) ? bn.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (Dt) => {
          sn.modifierPressed(Dt) || lp(t.getNode()) && Dt.preventDefault();
        }), e.on("GetSelectionRange", (Dt) => {
          let Pt = Dt.range;
          if (d) {
            if (!d.parentNode) {
              d = null;
              return;
            }
            Pt = Pt.cloneRange(), Pt.selectNode(d), Dt.range = Pt;
          }
        }), e.on("SetSelectionRange", (Dt) => {
          Dt.range = se(Dt.range);
          const Pt = Be(Dt.range, Dt.forward);
          Pt && (Dt.range = Pt);
        });
        const gt = (Dt) => Dt.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (Dt) => {
          const Pt = Dt.range, bn = Pt.startContainer.parentNode;
          !H(Pt) && !gt(bn) && lt(), y(bn) || at();
        }), XL(e), ZL(e), QL(e);
      }, j = (gt) => xt(gt) || tr(gt) || Nr(gt), H = (gt) => j(gt.startContainer) || j(gt.endContainer), se = (gt) => {
        const Dt = e.schema.getVoidElements(), Pt = n.createRng(), bn = gt.startContainer, nn = gt.startOffset, Ht = gt.endContainer, fo = gt.endOffset;
        return gn(Dt, bn.nodeName.toLowerCase()) ? nn === 0 ? Pt.setStartBefore(bn) : Pt.setStartAfter(bn) : Pt.setStart(bn, nn), gn(Dt, Ht.nodeName.toLowerCase()) ? fo === 0 ? Pt.setEndBefore(Ht) : Pt.setEndAfter(Ht) : Pt.setEnd(Ht, fo), Pt;
      }, ve = (gt, Dt) => {
        const Pt = ne.fromDom(e.getBody()), bn = e.getDoc(), nn = Pc(Pt, "#" + i).getOrThunk(() => {
          const Co = ne.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', bn);
          return ao(Co, "id", i), ls(Pt, Co), Co;
        }), Ht = n.createRng();
        cl(nn), lc(nn, [
          ne.fromText(Ws, bn),
          ne.fromDom(Dt),
          ne.fromText(Ws, bn)
        ]), Ht.setStart(nn.dom.firstChild, 1), Ht.setEnd(nn.dom.lastChild, 0), Ir(nn, { top: n.getPos(gt, e.getBody()).y + "px" }), c1(nn);
        const fo = t.getSel();
        return fo.removeAllRanges(), fo.addRange(Ht), Ht;
      }, Se = (gt) => {
        const Dt = gt.cloneNode(!0), Pt = e.dispatch("ObjectSelected", {
          target: gt,
          targetClone: Dt
        });
        if (Pt.isDefaultPrevented())
          return null;
        const bn = ve(gt, Pt.targetClone), nn = ne.fromDom(gt);
        return M(br(ne.fromDom(e.getBody()), `*[${u}]`), (Ht) => {
          _o(nn, Ht) || as(Ht, u);
        }), n.getAttrib(gt, u) || gt.setAttribute(u, "1"), d = gt, lt(), bn;
      }, Be = (gt, Dt) => {
        if (!gt)
          return null;
        if (gt.collapsed) {
          if (!H(gt)) {
            const Ht = Dt ? 1 : -1, fo = Su(Ht, s, gt), Co = fo.getNode(!Dt);
            if (_u(Co))
              return N(Ht, Co, Dt ? !fo.isAtEnd() : !1, !1);
            const Fo = fo.getNode(Dt);
            if (_u(Fo))
              return N(Ht, Fo, Dt ? !1 : !fo.isAtEnd(), !1);
          }
          return null;
        }
        let Pt = gt.startContainer, bn = gt.startOffset;
        const nn = gt.endOffset;
        if (Pt.nodeType === 3 && bn === 0 && lp(Pt.parentNode) && (Pt = Pt.parentNode, bn = n.nodeIndex(Pt), Pt = Pt.parentNode), Pt.nodeType !== 1)
          return null;
        if (nn === bn + 1 && Pt === gt.endContainer) {
          const Ht = Pt.childNodes[bn];
          if (v(Ht))
            return Se(Ht);
        }
        return null;
      }, at = () => {
        d && d.removeAttribute(u), Pc(ne.fromDom(e.getBody()), "#" + i).each(Do), d = null;
      }, Vt = () => {
        a.destroy(), d = null;
      }, lt = () => {
        a.hide();
      };
      return $l(e) || U(), {
        showCaret: N,
        showBlockCaretContainer: F,
        hideFakeCaret: lt,
        destroy: Vt
      };
    }, YA = (e, t, n) => {
      if (Ft(t) && (n < 0 || n > t.data.length))
        return [];
      const o = [n];
      let s = t;
      for (; s !== e && s.parentNode; ) {
        const a = s.parentNode;
        for (let i = 0; i < a.childNodes.length; i++)
          if (a.childNodes[i] === s) {
            o.push(i);
            break;
          }
        s = a;
      }
      return s === e ? o.reverse() : [];
    }, zS = (e, t, n, o, s) => {
      const a = YA(e, t, n), i = YA(e, o, s);
      return {
        start: a,
        end: i
      };
    }, XA = (e, t) => {
      const n = t.slice(), o = n.pop();
      return En(n, (a, i) => a.bind((u) => w.from(u.childNodes[i])), w.some(e)).bind((a) => Ft(a) && (o < 0 || o > a.data.length) ? w.none() : w.some({
        node: a,
        offset: o
      }));
    }, ZA = (e, t) => XA(e, t.start).bind(({
      node: n,
      offset: o
    }) => XA(e, t.end).map(({
      node: s,
      offset: a
    }) => {
      const i = document.createRange();
      return i.setStart(n, o), i.setEnd(s, a), i;
    })), eM = (e, t) => zS(e, t.startContainer, t.startOffset, t.endContainer, t.endOffset), up = (e, t, n) => {
      if (t && e.isEmpty(t) && !n(t)) {
        const o = t.parentNode;
        e.remove(t), up(e, o, n);
      }
    }, fk = (e, t, n, o = !0) => {
      const s = t.startContainer.parentNode, a = t.endContainer.parentNode;
      t.deleteContents(), o && !n(t.startContainer) && (Ft(t.startContainer) && t.startContainer.data.length === 0 && e.remove(t.startContainer), Ft(t.endContainer) && t.endContainer.data.length === 0 && e.remove(t.endContainer), up(e, s, n), s !== a && up(e, a, n));
    }, AS = (e, t) => w.from(e.dom.getParent(t.startContainer, e.dom.isBlock)), QA = (e, t, n) => {
      j$(t, 0, t).each((s) => {
        const a = s.container;
        B2(a, n.start.length, t).each((i) => {
          const u = e.createRng();
          u.setStart(a, 0), u.setEnd(i.container, i.offset), fk(e, u, (d) => d === t);
        });
      });
    }, tM = (e, t) => {
      const n = e.dom, o = t.pattern, s = ZA(n.getRoot(), t.range).getOrDie("Unable to resolve path range"), a = (i, u) => {
        const d = u.get(i);
        return le(d) && Tn(d).exists((y) => gn(y, "block"));
      };
      return AS(e, s).each((i) => {
        o.type === "block-format" ? a(o.format, e.formatter) && e.undoManager.transact(() => {
          QA(e.dom, i, o), e.formatter.apply(o.format);
        }) : o.type === "block-command" && e.undoManager.transact(() => {
          QA(e.dom, i, o), e.execCommand(o.cmd, !1, o.value);
        });
      }), !0;
    }, nM = (e, t) => {
      const n = t.replace(Ws, " ");
      return oo(e, (o) => t.indexOf(o.start) === 0 || n.indexOf(o.start) === 0);
    }, oM = (e, t) => {
      const n = e.dom, o = e.selection.getRng();
      return AS(e, o).filter((s) => {
        const a = la(e), i = n.is(s, a);
        return s !== null && i;
      }).bind((s) => {
        const a = s.textContent;
        return nM(t, a).map((u) => nt.trim(a).length === u.start.length ? [] : [{
          pattern: u,
          range: zS(n.getRoot(), s, 0, s, 0)
        }]);
      }).getOr([]);
    }, sM = (e, t) => {
      if (t.length === 0)
        return;
      const n = e.selection.getBookmark();
      M(t, (o) => tM(e, o)), e.selection.moveToBookmark(n);
    }, JA = (e, t) => e.create("span", {
      "data-mce-type": "bookmark",
      id: t
    }), dk = (e, t) => {
      const n = e.createRng();
      return n.setStartAfter(t.start), n.setEndBefore(t.end), n;
    }, eN = (e, t, n) => {
      const o = ZA(e.getRoot(), n).getOrDie("Unable to resolve path range"), s = o.startContainer, a = o.endContainer, i = o.endOffset === 0 ? a : a.splitText(o.endOffset), u = o.startOffset === 0 ? s : s.splitText(o.startOffset);
      return {
        prefix: t,
        end: i.parentNode.insertBefore(JA(e, t + "-end"), i),
        start: u.parentNode.insertBefore(JA(e, t + "-start"), u)
      };
    }, tN = (e, t, n) => {
      up(e, e.get(t.prefix + "-end"), n), up(e, e.get(t.prefix + "-start"), n);
    }, NS = (e) => e.start.length === 0, rM = (e) => (t, n) => {
      const s = t.data.substring(0, n), a = s.lastIndexOf(e.charAt(e.length - 1)), i = s.lastIndexOf(e);
      return i !== -1 ? i + e.length : a !== -1 ? a + 1 : -1;
    }, nN = (e, t, n, o) => {
      const s = t.start;
      return nS(e, o.container, o.offset, rM(s), n).bind((i) => {
        if (i.offset >= s.length) {
          const u = e.createRng();
          return u.setStart(i.container, i.offset - s.length), u.setEnd(i.container, i.offset), w.some(u);
        } else {
          const u = i.offset - s.length;
          return tS(i.container, u, n).map((d) => {
            const y = e.createRng();
            return y.setStart(d.container, d.offset), y.setEnd(i.container, i.offset), y;
          }).filter((d) => d.toString() === s).orThunk(() => nN(e, t, n, ti(i.container, 0)));
        }
      });
    }, aM = (e, t, n, o, s, a = !1) => {
      if (t.start.length === 0 && !a) {
        const i = e.createRng();
        return i.setStart(n, o), i.setEnd(n, o), w.some(i);
      }
      return eS(n, o, s).bind((i) => nN(e, t, s, i).bind((d) => {
        if (a) {
          if (d.endContainer === i.container && d.endOffset === i.offset)
            return w.none();
          if (i.offset === 0 && d.endContainer.textContent.length === d.endOffset)
            return w.none();
        }
        return w.some(d);
      }));
    }, cM = (e, t, n) => {
      const o = e.dom, s = o.getRoot(), a = n.pattern, i = n.position.container, u = n.position.offset;
      return tS(i, u - n.pattern.end.length, t).bind((d) => {
        const y = zS(s, d.container, d.offset, i, u);
        if (NS(a))
          return w.some({
            matches: [{
              pattern: a,
              startRng: y,
              endRng: y
            }],
            position: d
          });
        {
          const v = oN(e, n.remainingPatterns, d.container, d.offset, t), T = v.getOr({
            matches: [],
            position: d
          }), N = T.position;
          return aM(o, a, N.container, N.offset, t, v.isNone()).map((U) => {
            const j = eM(s, U);
            return {
              matches: T.matches.concat([{
                pattern: a,
                startRng: j,
                endRng: y
              }]),
              position: ti(U.startContainer, U.startOffset)
            };
          });
        }
      });
    }, oN = (e, t, n, o, s) => {
      const a = e.dom;
      return eS(n, o, a.getRoot()).bind((i) => {
        const u = a.createRng();
        u.setStart(s, 0), u.setEnd(n, o);
        const d = u.toString();
        for (let y = 0; y < t.length; y++) {
          const v = t[y];
          if (!Xn(d, v.end))
            continue;
          const T = t.slice();
          T.splice(y, 1);
          const N = cM(e, s, {
            pattern: v,
            remainingPatterns: T,
            position: i
          });
          if (N.isSome())
            return N;
        }
        return w.none();
      });
    }, sN = (e, t, n) => {
      e.selection.setRng(n), t.type === "inline-format" ? M(t.format, (o) => {
        e.formatter.apply(o);
      }) : e.execCommand(t.cmd, !1, t.value);
    }, iM = (e, t, n, o) => {
      const s = dk(e.dom, n);
      fk(e.dom, s, o), sN(e, t, s);
    }, lM = (e, t, n, o, s) => {
      const a = e.dom, i = dk(a, o), u = dk(a, n);
      fk(a, u, s), fk(a, i, s);
      const d = {
        prefix: n.prefix,
        start: n.end,
        end: o.start
      }, y = dk(a, d);
      sN(e, t, y);
    }, uM = (e, t) => {
      const n = Xh("mce_textpattern"), o = pn(t, (s, a) => {
        const i = eN(e, n + `_end${s.length}`, a.endRng);
        return s.concat([{
          ...a,
          endMarker: i
        }]);
      }, []);
      return pn(o, (s, a) => {
        const i = o.length - s.length - 1, u = NS(a.pattern) ? a.endMarker : eN(e, n + `_start${i}`, a.startRng);
        return s.concat([{
          ...a,
          startMarker: u
        }]);
      }, []);
    }, rN = (e, t, n) => {
      const o = e.selection.getRng();
      return o.collapsed === !1 ? [] : AS(e, o).bind((s) => {
        const a = Math.max(0, o.startOffset - (n ? 1 : 0));
        return oN(e, t, o.startContainer, a, s);
      }).fold(() => [], (s) => s.matches);
    }, aN = (e, t) => {
      if (t.length === 0)
        return;
      const n = e.dom, o = e.selection.getBookmark(), s = uM(n, t);
      M(s, (a) => {
        const i = n.getParent(a.startMarker.start, n.isBlock), u = (d) => d === i;
        NS(a.pattern) ? iM(e, a.pattern, a.endMarker, u) : lM(e, a.pattern, a.startMarker, a.endMarker, u), tN(n, a.endMarker, u), tN(n, a.startMarker, u);
      }), e.selection.moveToBookmark(o);
    }, fM = (e) => e.inlinePatterns.length > 0 || e.blockPatterns.length > 0, dM = (e, t) => {
      if (!e.selection.isCollapsed() || !fM(t))
        return !1;
      const n = rN(e, t.inlinePatterns, !1), o = oM(e, t.blockPatterns);
      return o.length > 0 || n.length > 0 ? (e.undoManager.add(), e.undoManager.extra(() => {
        e.execCommand("mceInsertNewLine");
      }, () => {
        e.insertContent(ml), aN(e, n), sM(e, o);
        const s = e.selection.getRng(), a = eS(s.startContainer, s.startOffset, e.dom.getRoot());
        e.execCommand("mceInsertNewLine"), a.each((i) => {
          const u = i.container;
          u.data.charAt(i.offset - 1) === ml && (u.deleteData(i.offset - 1, 1), up(e.dom, u.parentNode, (d) => d === e.dom.getRoot()));
        });
      }), !0) : !1;
    }, cN = (e, t) => {
      if (t.length > 0) {
        const n = rN(e, t, !0);
        n.length > 0 && e.undoManager.transact(() => {
          aN(e, n);
        });
      }
    }, iN = (e, t, n) => {
      for (let o = 0; o < e.length; o++)
        if (n(e[o], t))
          return !0;
      return !1;
    }, mM = (e, t) => iN(e, t, (n, o) => n === o.keyCode && sn.modifierPressed(o) === !1), pM = (e, t) => iN(e, t, (n, o) => n.charCodeAt(0) === o.charCode), gM = (e) => {
      const t = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], n = [32], o = () => jw(dg(e)), s = () => Nf(dg(e));
      e.on("keydown", (a) => {
        a.keyCode === 13 && !sn.modifierPressed(a) && dM(e, o()) && a.preventDefault();
      }, !0), e.on("keyup", (a) => {
        mM(n, a) && cN(e, s());
      }), e.on("keypress", (a) => {
        pM(t, a) && xa.setEditorTimeout(e, () => {
          cN(e, s());
        });
      });
    }, hM = (e) => {
      gM(e);
    }, yM = (e) => {
      const t = nt.each, n = sn.BACKSPACE, o = sn.DELETE, s = e.dom, a = e.selection, i = e.parser, u = Gn.browser, d = u.isFirefox(), y = u.isChromium() || u.isSafari(), v = Gn.deviceType.isiPhone() || Gn.deviceType.isiPad(), T = Gn.os.isMacOS() || Gn.os.isiOS(), N = (Mt, _n) => {
        try {
          e.getDoc().execCommand(Mt, !1, _n);
        } catch {
        }
      }, F = (Mt) => Mt.isDefaultPrevented(), U = () => {
        const Mt = (on) => {
          const Bt = s.create("body"), Jn = on.cloneContents();
          return Bt.appendChild(Jn), a.serializer.serialize(Bt, { format: "html" });
        }, _n = (on) => {
          const Bt = Mt(on), Jn = s.createRng();
          Jn.selectNode(e.getBody());
          const co = Mt(Jn);
          return Bt === co;
        };
        e.on("keydown", (on) => {
          const Bt = on.keyCode;
          let Jn, co;
          if (!F(on) && (Bt === o || Bt === n)) {
            if (Jn = e.selection.isCollapsed(), co = e.getBody(), Jn && !s.isEmpty(co) || !Jn && !_n(e.selection.getRng()))
              return;
            on.preventDefault(), e.setContent(""), co.firstChild && s.isBlock(co.firstChild) ? e.selection.setCursorLocation(co.firstChild, 0) : e.selection.setCursorLocation(co, 0), e.nodeChanged();
          }
        });
      }, j = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, H = () => {
        e.inline || s.bind(e.getDoc(), "mousedown mouseup", (Mt) => {
          let _n;
          if (Mt.target === e.getDoc().documentElement)
            if (_n = a.getRng(), e.getBody().focus(), Mt.type === "mousedown") {
              if (xt(_n.startContainer))
                return;
              a.placeCaretAt(Mt.clientX, Mt.clientY);
            } else
              a.setRng(_n);
        });
      }, se = () => {
        e.on("keydown", (Mt) => {
          if (!F(Mt) && Mt.keyCode === n) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (a.isCollapsed() && a.getRng().startOffset === 0) {
              const _n = a.getNode(), on = _n.previousSibling;
              if (_n.nodeName === "HR") {
                s.remove(_n), Mt.preventDefault();
                return;
              }
              on && on.nodeName && on.nodeName.toLowerCase() === "hr" && (s.remove(on), Mt.preventDefault());
            }
          }
        });
      }, ve = () => {
        Range.prototype.getClientRects || e.on("mousedown", (Mt) => {
          if (!F(Mt) && Mt.target.nodeName === "HTML") {
            const _n = e.getBody();
            _n.blur(), xa.setEditorTimeout(e, () => {
              _n.focus();
            });
          }
        });
      }, Se = () => {
        const Mt = Hy(e);
        e.on("click", (_n) => {
          const on = _n.target;
          /^(IMG|HR)$/.test(on.nodeName) && s.getContentEditableParent(on) !== "false" && (_n.preventDefault(), e.selection.select(on), e.nodeChanged()), on.nodeName === "A" && s.hasClass(on, Mt) && on.childNodes.length === 0 && (_n.preventDefault(), a.select(on));
        });
      }, Be = () => {
        const Mt = () => {
          const on = s.getAttribs(a.getStart().cloneNode(!1));
          return () => {
            const Bt = a.getStart();
            Bt !== e.getBody() && (s.setAttrib(Bt, "style", null), t(on, (Jn) => {
              Bt.setAttributeNode(Jn.cloneNode(!0));
            }));
          };
        }, _n = () => !a.isCollapsed() && s.getParent(a.getStart(), s.isBlock) !== s.getParent(a.getEnd(), s.isBlock);
        e.on("keypress", (on) => {
          let Bt;
          if (!F(on) && (on.keyCode === 8 || on.keyCode === 46) && _n())
            return Bt = Mt(), e.getDoc().execCommand("delete", !1, null), Bt(), on.preventDefault(), !1;
        }), s.bind(e.getDoc(), "cut", (on) => {
          let Bt;
          !F(on) && _n() && (Bt = Mt(), xa.setEditorTimeout(e, () => {
            Bt();
          }));
        });
      }, at = () => {
        e.on("keydown", (Mt) => {
          if (!F(Mt) && Mt.keyCode === n && a.isCollapsed() && a.getRng().startOffset === 0) {
            const _n = a.getNode().previousSibling;
            if (_n && _n.nodeName && _n.nodeName.toLowerCase() === "table")
              return Mt.preventDefault(), !1;
          }
        });
      }, Vt = () => {
        e.on("keydown", (Mt) => {
          let _n, on;
          if (F(Mt) || Mt.keyCode !== sn.BACKSPACE)
            return;
          _n = a.getRng();
          const Bt = _n.startContainer, Jn = _n.startOffset, co = s.getRoot();
          if (on = Bt, !(!_n.collapsed || Jn !== 0)) {
            for (; on && on.parentNode && on.parentNode.firstChild === on && on.parentNode !== co; )
              on = on.parentNode;
            on.tagName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", null, on), _n = s.createRng(), _n.setStart(Bt, 0), _n.setEnd(Bt, 0), a.setRng(_n));
          }
        });
      }, lt = () => {
        const Mt = () => {
          N("StyleWithCSS", !1), N("enableInlineTableEditing", !1), Iy(e) || N("enableObjectResizing", !1);
        };
        Ts(e) || e.on("BeforeExecCommand mousedown", Mt);
      }, gt = () => {
        const Mt = () => {
          t(s.select("a"), (_n) => {
            let on = _n.parentNode;
            const Bt = s.getRoot();
            if (on.lastChild === _n) {
              for (; on && !s.isBlock(on); ) {
                if (on.parentNode.lastChild !== on || on === Bt)
                  return;
                on = on.parentNode;
              }
              s.add(on, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (_n) => {
          (_n.type === "setcontent" || _n.command === "mceInsertLink") && Mt();
        });
      }, Dt = () => {
        e.on("init", () => {
          N("DefaultParagraphSeparator", la(e));
        });
      }, Pt = (Mt) => {
        const _n = Mt.getBody(), on = Mt.selection.getRng();
        return on.startContainer === on.endContainer && on.startContainer === _n && on.startOffset === 0 && on.endOffset === _n.childNodes.length;
      }, bn = () => {
        e.on("keyup focusin mouseup", (Mt) => {
          !sn.modifierPressed(Mt) && !Pt(e) && a.normalize();
        }, !0);
      }, nn = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, Ht = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, fo = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (Mt) => {
          let _n;
          Mt.target.nodeName === "HTML" && (_n = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(_n), e.selection.normalize(), e.nodeChanged());
        }));
      }, Co = () => {
        T && e.on("keydown", (Mt) => {
          sn.metaKeyPressed(Mt) && !Mt.shiftKey && (Mt.keyCode === 37 || Mt.keyCode === 39) && (Mt.preventDefault(), e.selection.getSel().modify("move", Mt.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, Fo = () => {
        e.on("click", (Mt) => {
          let _n = Mt.target;
          do
            if (_n.tagName === "A") {
              Mt.preventDefault();
              return;
            }
          while (_n = _n.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, Ls = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (Mt) => {
            Mt.preventDefault();
          });
        });
      }, Nt = () => {
        i.addNodeFilter("br", (Mt) => {
          let _n = Mt.length;
          for (; _n--; )
            Mt[_n].attr("class") === "Apple-interchange-newline" && Mt[_n].remove();
        });
      }, fn = ye, no = () => {
        if (!d || e.removed)
          return !1;
        const Mt = e.selection.getSel();
        return !Mt || !Mt.rangeCount || Mt.rangeCount === 0;
      }, Qn = () => {
        y && (H(), Se(), Ls(), j(), v && (Ht(), fo(), Fo())), d && (ve(), lt(), nn(), Co());
      }, Gs = () => {
        Vt(), U(), Gn.windowsPhone || bn(), y && (H(), Se(), Dt(), Ls(), at(), Nt(), v ? (Ht(), fo(), Fo()) : j()), d && (se(), ve(), Be(), lt(), gt(), nn(), Co(), at());
      };
      return $l(e) ? Qn() : Gs(), {
        refreshContentEditable: fn,
        isHidden: no
      };
    }, RS = Uo.DOM, bM = (e, t) => {
      const n = ne.fromDom(e.getBody()), o = A(S(n)), s = ne.fromTag("style");
      ao(s, "type", "text/css"), ls(s, ne.fromText(t)), ls(o, s), e.on("remove", () => {
        Do(s);
      });
    }, kM = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, DS = (e) => rs(e, (t) => Le(t) === !1), lN = (e) => {
      const t = e.options.get, n = e.editorUpload.blobCache;
      return DS({
        allow_conditional_comments: t("allow_conditional_comments"),
        allow_html_data_urls: t("allow_html_data_urls"),
        allow_svg_data_urls: t("allow_svg_data_urls"),
        allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
        allow_script_urls: t("allow_script_urls"),
        allow_unsafe_link_target: t("allow_unsafe_link_target"),
        convert_fonts_to_spans: t("convert_fonts_to_spans"),
        fix_list_elements: t("fix_list_elements"),
        font_size_legacy_values: t("font_size_legacy_values"),
        forced_root_block: t("forced_root_block"),
        forced_root_block_attrs: t("forced_root_block_attrs"),
        preserve_cdata: t("preserve_cdata"),
        remove_trailing_brs: t("remove_trailing_brs"),
        inline_styles: t("inline_styles"),
        root_name: kM(e),
        validate: !0,
        blob_cache: n,
        document: e.getDoc()
      });
    }, uN = (e) => {
      const t = e.options.get;
      return DS({
        custom_elements: t("custom_elements"),
        extended_valid_elements: t("extended_valid_elements"),
        invalid_elements: t("invalid_elements"),
        invalid_styles: t("invalid_styles"),
        schema: t("schema"),
        valid_children: t("valid_children"),
        valid_classes: t("valid_classes"),
        valid_elements: t("valid_elements"),
        valid_styles: t("valid_styles"),
        verify_html: t("verify_html"),
        padd_empty_block_inline_children: t("format_empty_lines")
      });
    }, wM = (e) => {
      const t = e.options.get;
      return {
        ...lN(e),
        ...uN(e),
        ...DS({
          url_converter: t("url_converter"),
          url_converter_scope: t("url_converter_scope"),
          element_format: t("element_format"),
          entities: t("entities"),
          entity_encoding: t("entity_encoding"),
          indent: t("indent"),
          indent_after: t("indent_after"),
          indent_before: t("indent_before")
        })
      };
    }, _M = (e) => {
      const t = np(lN(e), e.schema);
      return t.addAttributeFilter("src,href,style,tabindex", (n, o) => {
        let s = n.length, a, i;
        const u = e.dom, d = "data-mce-" + o;
        for (; s--; )
          if (a = n[s], i = a.attr(o), i && !a.attr(d)) {
            if (i.indexOf("data:") === 0 || i.indexOf("blob:") === 0)
              continue;
            o === "style" ? (i = u.serializeStyle(u.parseStyle(i), a.name), i.length || (i = null), a.attr(d, i), a.attr(o, i)) : o === "tabindex" ? (a.attr(d, i), a.attr(o, null)) : a.attr(d, e.convertURL(i, o, a.name));
          }
      }), t.addNodeFilter("script", (n) => {
        let o = n.length;
        for (; o--; ) {
          const s = n[o], a = s.attr("type") || "no/type";
          a.indexOf("mce-") !== 0 && s.attr("type", "mce-" + a);
        }
      }), e.options.get("preserve_cdata") && t.addNodeFilter("#cdata", (n) => {
        let o = n.length;
        for (; o--; ) {
          const s = n[o];
          s.type = 8, s.name = "#comment", s.value = "[CDATA[" + e.dom.encode(s.value) + "]]";
        }
      }), t.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (n) => {
        let o = n.length;
        const s = e.schema.getNonEmptyElements();
        for (; o--; ) {
          const a = n[o];
          a.isEmpty(s) && a.getAll("br").length === 0 && a.append(new da("br", 1));
        }
      }), t;
    }, vM = (e) => {
      const t = Vy(e);
      t && xa.setEditorTimeout(e, () => {
        let n;
        t === !0 ? n = e : n = e.editorManager.get(t), n.destroyed || n.focus();
      }, 100);
    }, CM = (e) => {
      const t = e.dom.getRoot();
      !e.inline && (!Om(e) || e.selection.getStart(!0) === t) && _r(t).each((n) => {
        const o = n.getNode(), s = La(o) ? _r(o).getOr(n) : n;
        e.selection.setRng(s.toRange());
      });
    }, SM = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, Lm(e), e.focus(!0), CM(e), e.nodeChanged({ initial: !0 });
      const t = qy(e);
      Wt(t) && t.call(e, e), vM(e);
    }, fN = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, xM = (e, t, n) => {
      const o = [fN(e).loadAll(t)];
      return e.inline ? o : o.concat([e.ui.styleSheetLoader.loadAll(n)]);
    }, dN = (e) => {
      const t = fN(e), n = Fy(e), o = e.contentCSS, s = () => {
        t.unloadAll(o), e.inline || e.ui.styleSheetLoader.unloadAll(n);
      }, a = () => {
        e.removed ? s() : e.on("remove", s);
      };
      if (e.contentStyles.length > 0) {
        let d = "";
        nt.each(e.contentStyles, (y) => {
          d += y + `\r
`;
        }), e.dom.addStyle(d);
      }
      const i = Promise.all(xM(e, o, n)).then(a).catch(a), u = a_(e);
      return u && bM(e, u), i;
    }, EM = (e) => {
      const t = e.getDoc(), n = e.getBody();
      T0(e), Gy(e) || (t.body.spellcheck = !1, RS.setAttrib(n, "spellcheck", "false")), e.quirks = yM(e), z0(e);
      const o = c_(e);
      o !== void 0 && (n.dir = o);
      const s = fg(e);
      s && e.on("BeforeSetContent", (a) => {
        nt.each(s, (i) => {
          a.content = a.content.replace(i, (u) => "<!--mce:protected " + escape(u) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (a) => {
        e.composing = a.type === "compositionstart";
      });
    }, TM = (e) => {
      $l(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, OS = (e) => {
      e.removed !== !0 && (TM(e), SM(e));
    }, mN = (e) => {
      const t = e.getElement();
      let n = e.getDoc();
      e.inline && (RS.addClass(t, "mce-content-body"), e.contentDocument = n = document, e.contentWindow = window, e.bodyElement = t, e.contentAreaContainer = t);
      const o = e.getBody();
      o.disabled = !0, e.readonly = Ts(e), e.readonly || (e.inline && RS.getStyle(o, "position", !0) === "static" && (o.style.position = "relative"), o.contentEditable = "true"), o.disabled = !1, e.editorUpload = SB(e), e.schema = Ai(uN(e)), e.dom = Uo(n, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: () => e.inline,
        schema: e.schema,
        contentCssCors: um(e),
        referrerPolicy: ig(e),
        onSetAttrib: (i) => {
          e.dispatch("SetAttrib", i);
        }
      }), e.parser = _M(e), e.serializer = HT(wM(e), e), e.selection = UT(e.dom, e.getWin(), e.serializer, e), e.annotator = Ib(e), e.formatter = tz(e), e.undoManager = oz(e), e._nodeChangeDispatcher = new c7(e), e._selectionOverrides = JL(e), B8(e), lL(e), H8(e), $l(e) || (hL(e), hM(e));
      const s = a7(e);
      D8(e, s), M8(e), LB(e), aL(e);
      const a = OP(e);
      EM(e), a.fold(() => {
        dN(e).then(() => OS(e));
      }, (i) => {
        e.setProgressState(!0), dN(e).then(() => {
          i().then((u) => {
            e.setProgressState(!1), OS(e), FT(e);
          }, (u) => {
            e.notificationManager.open({
              type: "error",
              text: String(u)
            }), OS(e), FT(e);
          });
        });
      });
    }, pN = (e, t) => {
      if (e.inline || (e.getElement().style.visibility = e.orgVisibility), !t && !e.inline) {
        const n = e.iframeElement, o = gB(ne.fromDom(n), "load", () => {
          o.unbind(), e.contentDocument = n.contentDocument, mN(e);
        });
        if (Gn.browser.isFirefox()) {
          const s = e.getDoc();
          s.open(), s.write(e.iframeHTML), s.close();
        } else
          n.srcdoc = e.iframeHTML;
      } else
        mN(e);
    }, mk = Uo.DOM, zM = (e, t, n, o) => {
      const s = ne.fromTag("iframe");
      return o.each((a) => ao(s, "tabindex", a)), es(s, n), es(s, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: t
      }), ka(s, "tox-edit-area__iframe"), s;
    }, AM = (e) => {
      let t = Kw(e) + "<html><head>";
      Ay(e) !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const n = Yw(e), o = Xw(e), s = e.translate(Wy(e));
      return Ny(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + Ny(e) + '" />'), t += `</head><body id="${n}" class="mce-content-body ${o}" data-id="${e.id}" aria-label="${s}"><br></body></html>`, t;
    }, NM = (e, t) => {
      const n = e.translate("Rich Text Area"), o = Jr(ne.fromDom(e.getElement()), "tabindex").bind(Jo), s = zM(e.id, n, Gw(e), o).dom;
      s.onload = () => {
        s.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = t.iframeContainer, e.iframeElement = s, e.iframeHTML = AM(e), mk.add(t.iframeContainer, s);
    }, RM = (e, t) => {
      NM(e, t), t.editorContainer && (mk.get(t.editorContainer).style.display = e.orgDisplay, e.hidden = mk.isHidden(t.editorContainer)), e.getElement().style.display = "none", mk.setAttrib(e.id, "aria-hidden", "true"), pN(e);
    }, gN = Uo.DOM, DM = (e, t, n) => {
      const o = sp.get(n), s = sp.urls[n] || e.documentBaseUrl.replace(/\/$/, "");
      if (n = nt.trim(n), o && nt.inArray(t, n) === -1) {
        if (e.plugins[n])
          return;
        try {
          const a = o(e, s) || {};
          e.plugins[n] = a, Wt(a.init) && (a.init(e, s), t.push(n));
        } catch (a) {
          lB(e, n, a);
        }
      }
    }, OM = (e) => e.replace(/^\-/, ""), PM = (e) => {
      const t = [];
      M(qc(e), (n) => {
        DM(e, t, OM(n));
      });
    }, BM = (e) => {
      const t = nt.trim(ag(e)), n = e.ui.registry.getAll().icons, o = {
        ...L1.get("default").icons,
        ...L1.get(t).icons
      };
      Ot(o, (s, a) => {
        gn(n, a) || e.ui.registry.addIcon(a, s);
      });
    }, $M = (e) => {
      const t = ku(e);
      if (ge(t)) {
        const n = nd.get(t);
        e.theme = n(e, nd.urls[t]) || {}, Wt(e.theme.init) && e.theme.init(e, nd.urls[t] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, FM = (e) => {
      const t = lg(e), n = op.get(t);
      e.model = n(e, op.urls[t]);
    }, IM = (e) => e.theme.renderUI(), LM = (e) => {
      const t = e.getElement(), o = ku(e)(e, t);
      return o.editorContainer.nodeType && (o.editorContainer.id = o.editorContainer.id || e.id + "_parent"), o.iframeContainer && o.iframeContainer.nodeType && (o.iframeContainer.id = o.iframeContainer.id || e.id + "_iframecontainer"), o.height = o.iframeHeight ? o.iframeHeight : t.offsetHeight, o;
    }, hN = (e) => ({
      editorContainer: e,
      iframeContainer: e,
      api: {}
    }), MM = (e) => {
      const t = gN.create("div");
      return gN.insertAfter(t, e), hN(t);
    }, jM = (e) => {
      const t = e.getElement();
      return e.inline ? hN(null) : MM(t);
    }, UM = (e) => {
      const t = e.getElement();
      return e.orgDisplay = t.style.display, ge(ku(e)) ? IM(e) : Wt(ku(e)) ? LM(e) : jM(e);
    }, HM = (e, t) => {
      const n = {
        show: w.from(t.show).getOr(ye),
        hide: w.from(t.hide).getOr(ye),
        isEnabled: w.from(t.isEnabled).getOr(wn),
        setEnabled: (o) => {
          e.mode.isReadOnly() || w.from(t.setEnabled).each((s) => s(o));
        }
      };
      e.ui = {
        ...e.ui,
        ...n
      };
    }, WM = (e) => {
      e.dispatch("ScriptsLoaded"), BM(e), $M(e), FM(e), PM(e);
      const t = UM(e);
      HM(e, w.from(t.api).getOr({}));
      const n = {
        editorContainer: t.editorContainer,
        iframeContainer: t.iframeContainer
      };
      return e.editorContainer = n.editorContainer ? n.editorContainer : null, mB(e), e.inline ? pN(e) : RM(e, n);
    }, od = Uo.DOM, yN = (e) => e.charAt(0) === "-", qM = (e, t) => {
      const n = By(t), o = o_(t);
      if (Mr.hasCode(n) === !1 && n !== "en") {
        const s = Bn(o) ? o : `${t.editorManager.baseURL}/langs/${n}.js`;
        e.add(s).catch(() => {
          aB(t, s, n);
        });
      }
    }, VM = (e, t) => {
      const n = ku(e);
      if (ge(n) && !yN(n) && !gn(nd.urls, n)) {
        const o = d_(e), s = o ? e.documentBaseURI.toAbsolute(o) : `themes/${n}/theme${t}.js`;
        nd.load(n, s).catch(() => {
          cB(e, s, n);
        });
      }
    }, GM = (e, t) => {
      const n = lg(e);
      if (n !== "plugin" && !gn(op.urls, n)) {
        const o = m_(e), s = ge(o) ? e.documentBaseURI.toAbsolute(o) : `models/${n}/model${t}.js`;
        op.load(n, s).catch(() => {
          iB(e, s, n);
        });
      }
    }, KM = (e) => w.from(Dy(e)).filter(Bn).map((t) => ({
      url: t,
      name: w.none()
    })), bN = (e, t, n) => w.from(t).filter((o) => Bn(o) && !L1.has(o)).map((o) => ({
      url: `${e.editorManager.baseURL}/icons/${o}/icons${n}.js`,
      name: w.some(o)
    })), YM = (e, t, n) => {
      const o = bN(t, "default", n), s = KM(t).orThunk(() => bN(t, ag(t), ""));
      M(Tr([
        o,
        s
      ]), (a) => {
        e.add(a.url).catch(() => {
          rB(t, a.url, a.name.getOrUndefined());
        });
      });
    }, XM = (e, t) => {
      const n = (o, s) => {
        sp.load(o, s).catch(() => {
          sB(e, s, o);
        });
      };
      Ot(jy(e), (o, s) => {
        n(s, o), e.options.set("plugins", qc(e).concat(s));
      }), M(qc(e), (o) => {
        o = nt.trim(o), o && !sp.urls[o] && !yN(o) && n(o, `plugins/${o}/plugin${t}.js`);
      });
    }, ZM = (e) => {
      const t = ku(e);
      return !ge(t) || L(nd.get(t));
    }, QM = (e) => {
      const t = lg(e);
      return L(op.get(t));
    }, JM = (e, t) => {
      const n = Wa.ScriptLoader, o = () => {
        !e.removed && ZM(e) && QM(e) && WM(e);
      };
      VM(e, t), GM(e, t), qM(n, e), YM(n, e, t), XM(e, t), n.loadQueue().then(o, o);
    }, ej = (e, t) => Td.forElement(e, {
      contentCssCors: __(t),
      referrerPolicy: ig(t)
    }), tj = (e) => {
      const t = e.id;
      Mr.setCode(By(e));
      const n = () => {
        od.unbind(window, "ready", n), e.render();
      };
      if (!Ja.Event.domLoaded) {
        od.bind(window, "ready", n);
        return;
      }
      if (!e.getElement())
        return;
      const o = ne.fromDom(e.getElement()), s = ea(o);
      e.on("remove", () => {
        Ue(o.dom.attributes, (i) => as(o, i.name)), es(o, s);
      }), e.ui.styleSheetLoader = ej(o, e), fm(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const a = e.getElement().form || od.getParent(t, "form");
      a && (e.formElement = a, Cl(e) && !ll(e.getElement()) && (od.insertAfter(od.create("input", {
        type: "hidden",
        name: t
      }), t), e.hasHiddenInput = !0), e.formEventDelegate = (i) => {
        e.dispatch(i.type, i);
      }, od.bind(a, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), y_(e) && !a.submit.nodeType && !a.submit.length && !a._mceOldSubmit && (a._mceOldSubmit = a.submit, a.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), a._mceOldSubmit(a)))), e.windowManager = GT(e), e.notificationManager = VT(e), Qy(e) && e.on("GetContent", (i) => {
        i.save && (i.content = od.encode(i.content));
      }), b_(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), k_(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), JM(e, e.suffix);
    }, nj = (e, t) => ({
      sections: Z(e),
      options: Z(t)
    }), kN = Ro().deviceType, wN = kN.isPhone(), oj = kN.isTablet(), bh = (e) => {
      if (Ve(e))
        return [];
      {
        const t = le(e) ? e : e.split(/[ ,]/), n = W(t, Dn);
        return Qe(n, Bn);
      }
    }, sj = (e, t) => {
      const n = To(t, (o, s) => ce(e, s));
      return nj(n.t, n.f);
    }, rj = (e, t, n = {}) => {
      const o = e.sections(), s = Vn(o, t).getOr({});
      return nt.extend({}, n, s);
    }, PS = (e, t) => gn(e.sections(), t), aj = (e, t) => PS(e, t) ? e.sections()[t] : {}, cj = (e, t) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: Vn(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...t ? { menubar: !1 } : {}
    }), ij = (e, t) => {
      var n;
      const o = (n = t.external_plugins) !== null && n !== void 0 ? n : {};
      return e && e.external_plugins ? nt.extend({}, e.external_plugins, o) : o;
    }, lj = (e, t) => [].concat(bh(e)).concat(bh(t)), uj = (e, t, n, o) => e && PS(t, "mobile") ? o : n, fj = (e, t, n, o) => {
      const s = bh(n.forced_plugins), a = bh(o.plugins), i = aj(t, "mobile"), u = i.plugins ? bh(i.plugins) : a, d = uj(e, t, a, u), y = lj(s, d);
      return nt.extend(o, {
        forced_plugins: s,
        plugins: y
      });
    }, dj = (e, t) => e && PS(t, "mobile"), mj = (e, t, n, o, s) => {
      var a;
      const i = e ? { mobile: cj((a = s.mobile) !== null && a !== void 0 ? a : {}, t) } : {}, u = sj(["mobile"], J1(i, s)), d = nt.extend(n, o, u.options(), dj(e, u) ? rj(u, "mobile") : {}, { external_plugins: ij(o, u.options()) });
      return fj(e, u, o, d);
    }, pj = (e, t) => mj(wN || oj, wN, t, e, t), gj = (e, t) => s9(e, t), hj = (e) => {
      const t = (o, s) => {
        e.formatter.toggle(o, s), e.nodeChanged();
      }, n = (o) => () => {
        M("left,center,right,justify".split(","), (s) => {
          o !== s && e.formatter.remove("align" + s);
        }), o !== "none" && t("align" + o);
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("left"),
        JustifyCenter: n("center"),
        JustifyRight: n("right"),
        JustifyFull: n("justify"),
        JustifyNone: n("none")
      });
    }, yj = (e) => {
      const t = (n) => () => {
        const o = e.selection, s = o.isCollapsed() ? [e.dom.getParent(o.getNode(), e.dom.isBlock)] : o.getSelectedBlocks();
        return Ce(s, (a) => L(e.formatter.matchNode(a, n)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: t("alignleft"),
        JustifyCenter: t("aligncenter"),
        JustifyRight: t("alignright"),
        JustifyFull: t("alignjustify")
      }, "state");
    }, bj = (e) => {
      hj(e), yj(e);
    }, kj = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (t) => {
          const n = e.getDoc();
          let o;
          try {
            n.execCommand(t);
          } catch {
            o = !0;
          }
          if (t === "paste" && !n.queryCommandEnabled(t) && (o = !0), o || !n.queryCommandSupported(t)) {
            let s = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (Gn.os.isMacOS() || Gn.os.isiOS()) && (s = s.replace(/Ctrl\+/g, "\u2318+")), e.notificationManager.open({
              text: s,
              type: "error"
            });
          }
        }
      });
    }, wj = (e, t, n) => {
      const o = ne.fromDom(e.getRoot());
      return b1(o, je.fromRangeStart(t)) ? n = n.replace(/^ /, "&nbsp;") : n = n.replace(/^&nbsp;/, " "), k1(o, je.fromRangeEnd(t)) ? n = n.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : n = n.replace(/&nbsp;(<br( \/)?>)?$/, " "), n;
    }, _j = (e) => {
      if (typeof e != "string") {
        const t = nt.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: t
        };
      }
      return {
        content: e,
        details: {}
      };
    }, vj = (e, t) => {
      const n = e.selection, o = e.dom;
      return /^ | $/.test(t) ? wj(o, n.getRng(), t) : t;
    }, pk = (e, t) => {
      const { content: n, details: o } = _j(t);
      _C(e, {
        content: vj(e, n),
        format: "html",
        set: !1,
        selection: !0,
        paste: o.paste
      }).each((s) => {
        const a = n9(e, s.content, o);
        vC(e, a, s), e.addVisual();
      });
    }, Cj = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const t = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(t);
        },
        insertImage: (t, n, o) => {
          pk(e, e.dom.createHTML("img", { src: o }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (t, n, o) => {
          pk(e, e.dom.encode(o));
        },
        insertHTML: (t, n, o) => {
          pk(e, o);
        },
        mceInsertContent: (t, n, o) => {
          pk(e, o);
        },
        mceSetContent: (t, n, o) => {
          e.setContent(o);
        },
        mceReplaceContent: (t, n, o) => {
          e.execCommand("mceInsertContent", !1, o.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent("");
        }
      });
    }, Sj = {
      "font-size": "size",
      "font-family": "face"
    }, xj = (e, t, n) => {
      const o = (a) => gi(a, e).orThunk(() => tn(a) === "font" ? Vn(Sj, e).bind((i) => Jr(a, i)) : w.none()), s = (a) => _o(ne.fromDom(t), a);
      return Jv(ne.fromDom(n), (a) => o(a), s);
    }, Ej = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), Tj = (e, t) => w.from(Uo.DOM.getStyle(t, e, !0)), _N = (e) => (t, n) => w.from(n).map(ne.fromDom).filter(qn).bind((o) => xj(e, t, o.dom).or(Tj(e, o.dom))).getOr(""), zj = _N("font-size"), Aj = Ze(Ej, _N("font-family")), Nj = (e) => _r(e.getBody()).map((t) => {
      const n = t.container();
      return Ft(n) ? n.parentNode : n;
    }), Rj = (e) => w.from(e.selection.getRng()).bind((t) => {
      const n = e.getBody();
      return t.startContainer === n && t.startOffset === 0 ? w.none() : w.from(e.selection.getStart(!0));
    }), Dj = (e, t) => Rj(e).orThunk(et(Nj, e)).map(ne.fromDom).filter(qn).bind(t), BS = (e, t) => Dj(e, qt(w.some, t)), vN = (e, t) => {
      if (/^[0-9.]+$/.test(t)) {
        const n = parseInt(t, 10);
        if (n >= 1 && n <= 7) {
          const o = D_(e), s = Bf(e);
          return s ? s[n - 1] || t : o[n - 1] || t;
        } else
          return t;
      } else
        return t;
    }, Oj = (e) => {
      const t = e.split(/\s*,\s*/);
      return W(t, (n) => n.indexOf(" ") !== -1 && !(un(n, '"') || un(n, "'")) ? `'${n}'` : n).join(",");
    }, Pj = (e, t) => {
      const n = vN(e, t);
      e.formatter.toggle("fontname", { value: Oj(n) }), e.nodeChanged();
    }, Bj = (e) => BS(e, (t) => Aj(e.getBody(), t.dom)).getOr(""), $j = (e, t) => {
      e.formatter.toggle("fontsize", { value: vN(e, t) }), e.nodeChanged();
    }, Fj = (e) => BS(e, (t) => zj(e.getBody(), t.dom)).getOr(""), Ij = (e) => BS(e, (t) => {
      const n = ne.fromDom(e.getBody()), o = Jv(t, (a) => gi(a, "line-height"), et(_o, n)), s = () => {
        const a = parseFloat(Hs(t, "line-height")), i = parseFloat(Hs(t, "font-size"));
        return String(a / i);
      };
      return o.getOrThunk(s);
    }).getOr(""), Lj = (e, t) => {
      e.formatter.toggle("lineheight", { value: String(t) }), e.nodeChanged();
    }, Mj = (e) => {
      const t = (n, o) => {
        e.formatter.toggle(n, o), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (n) => {
          t(n);
        },
        "ForeColor,HiliteColor": (n, o, s) => {
          t(n, { value: s });
        },
        BackColor: (n, o, s) => {
          t("hilitecolor", { value: s });
        },
        FontName: (n, o, s) => {
          Pj(e, s);
        },
        FontSize: (n, o, s) => {
          $j(e, s);
        },
        LineHeight: (n, o, s) => {
          Lj(e, s);
        },
        Lang: (n, o, s) => {
          t(n, {
            value: s.code,
            customValue: s.customCode
          });
        },
        RemoveFormat: (n) => {
          e.formatter.remove(n);
        },
        mceBlockQuote: () => {
          t("blockquote");
        },
        FormatBlock: (n, o, s) => {
          t(ge(s) ? s : "p");
        },
        mceToggleFormat: (n, o, s) => {
          t(s);
        }
      });
    }, jj = (e) => {
      const t = (n) => e.formatter.match(n);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (n) => t(n),
        mceBlockQuote: () => t("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => Bj(e)), e.editorCommands.addQueryValueHandler("FontSize", () => Fj(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => Ij(e));
    }, Uj = (e) => {
      Mj(e), jj(e);
    }, Hj = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, Wj = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          A8(e);
        },
        Outdent: () => {
          Jz(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => Yz(e) }, "state");
    }, qj = (e) => {
      const t = (n, o, s) => {
        const a = ge(s) ? { href: s } : s, i = e.dom.getParent(e.selection.getNode(), "a");
        zt(a) && ge(a.href) && (a.href = a.href.replace(/ /g, "%20"), (!i || !a.href) && e.formatter.remove("link"), a.href && e.formatter.apply("link", a, i));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isCollapsed()) {
            const n = e.dom.getParent(e.selection.getStart(), "a");
            n && e.dom.remove(n, !0);
            return;
          }
          e.formatter.remove("link");
        },
        mceInsertLink: t,
        createLink: t
      });
    }, Vj = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (t) => {
          e.getDoc().execCommand(t);
          const n = e.dom.getParent(e.selection.getNode(), "ol,ul");
          if (n) {
            const o = n.parentNode;
            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(o.nodeName)) {
              const s = e.selection.getBookmark();
              e.dom.split(o, n), e.selection.moveToBookmark(s);
            }
          }
        }
      });
    }, Gj = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (t) => {
          const n = e.dom.getParent(e.selection.getNode(), "ul,ol");
          return n && (t === "insertunorderedlist" && n.tagName === "UL" || t === "insertorderedlist" && n.tagName === "OL");
        }
      }, "state");
    }, Kj = (e) => {
      Vj(e), Gj(e);
    }, Yj = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          ik(fA, e);
        },
        mceInsertNewLine: (t, n, o) => {
          bA(e, o);
        },
        InsertLineBreak: (t, n, o) => {
          ik(pA, e);
        }
      });
    }, Xj = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (t, n, o) => {
          let s = 0;
          e.dom.getParent(e.selection.getNode(), (a) => {
            if (a.nodeType === 1 && s++ === o)
              return e.selection.select(a), !1;
          }, e.getBody());
        },
        mceSelectNode: (t, n, o) => {
          e.selection.select(o);
        },
        selectAll: () => {
          const t = e.dom.getParent(e.selection.getStart(), ca);
          if (t) {
            const n = e.dom.createRng();
            n.selectNodeContents(t), e.selection.setRng(n);
          }
        }
      });
    }, Zj = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (t, n, o) => {
          const s = o != null ? o : e.selection.getNode();
          if (s !== e.getBody()) {
            const a = e.selection.getBookmark();
            e.dom.remove(s, !0), e.selection.moveToBookmark(a);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (t, n, o) => {
          m1(e, o);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, Qj = (e) => {
      bj(e), kj(e), Hj(e), Xj(e), Cj(e), qj(e), Wj(e), Yj(e), Kj(e), Uj(e), Zj(e);
    };
    class CN {
      constructor(t) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = t;
      }
      execCommand(t, n, o, s) {
        const a = this.editor, i = t.toLowerCase(), u = s == null ? void 0 : s.skip_focus;
        if (a.removed || (i !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(i) && !u ? a.focus() : Xg(a)), a.dispatch("BeforeExecCommand", {
          command: t,
          ui: n,
          value: o
        }).isDefaultPrevented()))
          return !1;
        const y = this.commands.exec[i];
        return Wt(y) ? (y(i, n, o), a.dispatch("ExecCommand", {
          command: t,
          ui: n,
          value: o
        }), !0) : !1;
      }
      queryCommandState(t) {
        if (this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const n = t.toLowerCase(), o = this.commands.state[n];
        return Wt(o) ? o(n) : !1;
      }
      queryCommandValue(t) {
        if (this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const n = t.toLowerCase(), o = this.commands.value[n];
        return Wt(o) ? o(n) : "";
      }
      addCommands(t, n = "exec") {
        const o = this.commands;
        Ot(t, (s, a) => {
          M(a.toLowerCase().split(","), (i) => {
            o[n][i] = s;
          });
        });
      }
      addCommand(t, n, o) {
        const s = t.toLowerCase();
        this.commands.exec[s] = (a, i, u) => n.call(o != null ? o : this.editor, i, u);
      }
      queryCommandSupported(t) {
        const n = t.toLowerCase();
        return !!this.commands.exec[n];
      }
      addQueryStateHandler(t, n, o) {
        this.commands.state[t.toLowerCase()] = () => n.call(o != null ? o : this.editor);
      }
      addQueryValueHandler(t, n, o) {
        this.commands.value[t.toLowerCase()] = () => n.call(o != null ? o : this.editor);
      }
    }
    const sd = "data-mce-contenteditable", Jj = (e, t, n) => {
      Ec(e, t) && n === !1 ? xc(e, t) : n && ka(e, t);
    }, $S = (e, t, n) => {
      try {
        e.getDoc().execCommand(t, !1, String(n));
      } catch {
      }
    }, gk = (e, t) => {
      e.dom.contentEditable = t ? "true" : "false";
    }, eU = (e) => {
      M(br(e, '*[contenteditable="true"]'), (t) => {
        ao(t, sd, "true"), gk(t, !1);
      });
    }, tU = (e) => {
      M(br(e, `*[${sd}="true"]`), (t) => {
        as(t, sd), gk(t, !0);
      });
    }, nU = (e) => {
      w.from(e.selection.getNode()).each((t) => {
        t.removeAttribute("data-mce-selected");
      });
    }, oU = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, sU = (e, t) => {
      const n = ne.fromDom(e.getBody());
      Jj(n, "mce-content-readonly", t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), nU(e), e.readonly = !0, gk(n, !1), eU(n)) : (e.readonly = !1, gk(n, !0), tU(n), $S(e, "StyleWithCSS", !1), $S(e, "enableInlineTableEditing", !1), $S(e, "enableObjectResizing", !1), Hr(e) && e.focus(), oU(e), e.nodeChanged());
    }, rd = (e) => e.readonly, SN = (e) => {
      e.parser.addAttributeFilter("contenteditable", (t) => {
        rd(e) && M(t, (n) => {
          n.attr(sd, n.attr("contenteditable")), n.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(sd, (t) => {
        rd(e) && M(t, (n) => {
          n.attr("contenteditable", n.attr(sd));
        });
      }), e.serializer.addTempAttr(sd);
    }, rU = (e) => {
      e.serializer ? SN(e) : e.on("PreInit", () => {
        SN(e);
      });
    }, aU = (e) => e.type === "click", cU = ["copy"], iU = (e) => ce(cU, e.type), lU = (e, t) => Ma(t, "a", (o) => _o(o, ne.fromDom(e.getBody()))).bind((o) => Jr(o, "href")), uU = (e, t) => {
      if (aU(t) && !sn.metaKeyPressed(t)) {
        const n = ne.fromDom(t.target);
        lU(e, n).each((o) => {
          if (t.preventDefault(), /^#/.test(o)) {
            const s = e.dom.select(`${o},[name="${It(o, "#")}"]`);
            s.length && e.selection.scrollIntoView(s[0], !0);
          } else
            window.open(o, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else
        iU(t) && e.dispatch(t.type, t);
    }, fU = (e) => {
      e.on("ShowCaret", (t) => {
        rd(e) && t.preventDefault();
      }), e.on("ObjectSelected", (t) => {
        rd(e) && t.preventDefault();
      });
    }, dU = nt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class FS {
      constructor(t) {
        this.bindings = {}, this.settings = t || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || cn;
      }
      static isNative(t) {
        return !!dU[t.toLowerCase()];
      }
      fire(t, n) {
        return this.dispatch(t, n);
      }
      dispatch(t, n) {
        const o = t.toLowerCase(), s = Mp(o, n != null ? n : {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(s);
        const a = this.bindings[o];
        if (a)
          for (let i = 0, u = a.length; i < u; i++) {
            const d = a[i];
            if (!d.removed) {
              if (d.once && this.off(o, d.func), s.isImmediatePropagationStopped())
                return s;
              if (d.func.call(this.scope, s) === !1)
                return s.preventDefault(), s;
            }
          }
        return s;
      }
      on(t, n, o, s) {
        if (n === !1 && (n = cn), n) {
          const a = {
            func: n,
            removed: !1
          };
          s && nt.extend(a, s);
          const i = t.toLowerCase().split(" ");
          let u = i.length;
          for (; u--; ) {
            const d = i[u];
            let y = this.bindings[d];
            y || (y = [], this.toggleEvent(d, !0)), o ? y = [
              a,
              ...y
            ] : y = [
              ...y,
              a
            ], this.bindings[d] = y;
          }
        }
        return this;
      }
      off(t, n) {
        if (t) {
          const o = t.toLowerCase().split(" ");
          let s = o.length;
          for (; s--; ) {
            const a = o[s];
            let i = this.bindings[a];
            if (!a)
              return Ot(this.bindings, (u, d) => {
                this.toggleEvent(d, !1), delete this.bindings[d];
              }), this;
            if (i) {
              if (!n)
                i.length = 0;
              else {
                const u = kt(i, (d) => d.func === n);
                i = u.fail, this.bindings[a] = i, M(u.pass, (d) => {
                  d.removed = !0;
                });
              }
              i.length || (this.toggleEvent(t, !1), delete this.bindings[a]);
            }
          }
        } else
          Ot(this.bindings, (o, s) => {
            this.toggleEvent(s, !1);
          }), this.bindings = {};
        return this;
      }
      once(t, n, o) {
        return this.on(t, n, o, { once: !0 });
      }
      has(t) {
        return t = t.toLowerCase(), !(!this.bindings[t] || this.bindings[t].length === 0);
      }
    }
    const kh = (e) => (e._eventDispatcher || (e._eventDispatcher = new FS({
      scope: e,
      toggleEvent: (t, n) => {
        FS.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, n);
      }
    })), e._eventDispatcher), IS = {
      fire(e, t, n) {
        return this.dispatch(e, t, n);
      },
      dispatch(e, t, n) {
        const o = this;
        if (o.removed && e !== "remove" && e !== "detach")
          return Mp(e.toLowerCase(), t != null ? t : {}, o);
        const s = kh(o).dispatch(e, t);
        if (n !== !1 && o.parent) {
          let a = o.parent();
          for (; a && !s.isPropagationStopped(); )
            a.dispatch(e, s, !1), a = a.parent();
        }
        return s;
      },
      on(e, t, n) {
        return kh(this).on(e, t, n);
      },
      off(e, t) {
        return kh(this).off(e, t);
      },
      once(e, t) {
        return kh(this).once(e, t);
      },
      hasEventListeners(e) {
        return kh(this).has(e);
      }
    }, hk = Uo.DOM;
    let ad;
    const yk = (e, t) => {
      if (t === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(t))
        return e.getDoc().documentElement;
      const n = Ly(e);
      return n ? (e.eventRoot || (e.eventRoot = hk.select(n)[0]), e.eventRoot) : e.getBody();
    }, mU = (e) => !e.hidden && !rd(e), xN = (e, t, n) => {
      mU(e) ? e.dispatch(t, n) : rd(e) && uU(e, n);
    }, EN = (e, t) => {
      let n;
      if (e.delegates || (e.delegates = {}), e.delegates[t] || e.removed)
        return;
      const o = yk(e, t);
      if (Ly(e)) {
        if (ad || (ad = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || ad && (Ot(ad, (s, a) => {
            e.dom.unbind(yk(e, a));
          }), ad = null);
        })), ad[t])
          return;
        n = (s) => {
          const a = s.target, i = e.editorManager.get();
          let u = i.length;
          for (; u--; ) {
            const d = i[u].getBody();
            (d === a || hk.isChildOf(a, d)) && xN(i[u], t, s);
          }
        }, ad[t] = n, hk.bind(o, t, n);
      } else
        n = (s) => {
          xN(e, t, s);
        }, hk.bind(o, t, n), e.delegates[t] = n;
    }, TN = {
      ...IS,
      bindPendingEventDelegates() {
        const e = this;
        nt.each(e._pendingNativeEvents, (t) => {
          EN(e, t);
        });
      },
      toggleNativeEvent(e, t) {
        const n = this;
        e === "focus" || e === "blur" || n.removed || (t ? n.initialized ? EN(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [e] : n.initialized && (n.dom.unbind(yk(n, e), e, n.delegates[e]), delete n.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, t = e.getBody(), n = e.dom;
        e.delegates && (Ot(e.delegates, (o, s) => {
          e.dom.unbind(yk(e, s), s, o);
        }), delete e.delegates), !e.inline && t && n && (t.onload = null, n.unbind(e.getWin()), n.unbind(e.getDoc())), n && (n.unbind(t), n.unbind(e.getContainer()));
      }
    }, pU = (e) => ge(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : jt(e, ge) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, gU = (e) => {
      const t = (() => {
        switch (e) {
          case "array":
            return le;
          case "boolean":
            return ft;
          case "function":
            return Wt;
          case "number":
            return Je;
          case "object":
            return zt;
          case "string":
            return ge;
          case "string[]":
            return pU;
          case "object[]":
            return (n) => jt(n, zt);
          case "regexp":
            return (n) => ke(n, RegExp);
        }
      })();
      return (n) => LS(n, t, `The value must be a ${e}.`);
    }, hU = (e) => ge(e.processor), zN = (e, t) => {
      const n = to(t.message) ? "" : `. ${t.message}`;
      return e + n;
    }, AN = (e) => e.valid, LS = (e, t, n = "") => {
      const o = t(e);
      return ft(o) ? o ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: n
      } : o;
    }, yU = (e, t, n) => {
      if (!Le(t)) {
        const o = LS(t, n);
        if (AN(o))
          return o.value;
        console.error(zN(`Invalid default value passed for the "${e}" option`, o));
      }
    }, bU = (e, t) => {
      const n = {}, o = {}, s = (T, N, F) => {
        const U = LS(N, F);
        return AN(U) ? (o[T] = U.value, !0) : (console.warn(zN(`Invalid value passed for the ${T} option`, U)), !1);
      }, a = (T, N) => {
        const F = hU(N) ? gU(N.processor) : N.processor, U = yU(T, N.default, F);
        n[T] = {
          ...N,
          default: U,
          processor: F
        }, Vn(o, T).orThunk(() => Vn(t, T)).each((H) => s(T, H, F));
      }, i = (T) => gn(n, T);
      return {
        register: a,
        isRegistered: i,
        get: (T) => Vn(o, T).orThunk(() => Vn(n, T).map((N) => N.default)).getOrUndefined(),
        set: (T, N) => {
          if (i(T)) {
            const F = n[T];
            return F.immutable ? (console.error(`"${T}" is an immutable option and cannot be updated`), !1) : s(T, N, F.processor);
          } else
            return console.warn(`"${T}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (T) => {
          const N = i(T);
          return N && delete o[T], N;
        },
        isSet: (T) => gn(o, T)
      };
    }, kU = [
      "design",
      "readonly"
    ], NN = (e, t, n, o) => {
      const s = n[t.get()], a = n[o];
      try {
        a.activate();
      } catch (i) {
        console.error(`problem while activating editor mode ${o}:`, i);
        return;
      }
      s.deactivate(), s.editorReadOnly !== a.editorReadOnly && sU(e, a.editorReadOnly), t.set(o), $u(e, o);
    }, wU = (e, t, n, o) => {
      if (o !== n.get()) {
        if (!gn(t, o))
          throw new Error(`Editor mode '${o}' is invalid`);
        e.initialized ? NN(e, n, t, o) : e.on("init", () => NN(e, n, t, o));
      }
    }, _U = (e, t, n) => {
      if (ce(kU, t))
        throw new Error(`Cannot override default mode ${t}`);
      return {
        ...e,
        [t]: {
          ...n,
          deactivate: () => {
            try {
              n.deactivate();
            } catch (o) {
              console.error(`problem while deactivating editor mode ${t}:`, o);
            }
          }
        }
      };
    }, vU = (e) => {
      const t = vs("design"), n = vs({
        design: {
          activate: ye,
          deactivate: ye,
          editorReadOnly: !1
        },
        readonly: {
          activate: ye,
          deactivate: ye,
          editorReadOnly: !0
        }
      });
      return rU(e), fU(e), {
        isReadOnly: () => rd(e),
        set: (o) => wU(e, n.get(), t, o),
        get: () => t.get(),
        register: (o, s) => {
          n.set(_U(n.get(), o, s));
        }
      };
    }, MS = nt.each, jS = nt.explode, CU = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, RN = nt.makeMap("alt,ctrl,shift,meta,access"), SU = (e) => {
      let t;
      const n = {}, o = Gn.os.isMacOS() || Gn.os.isiOS();
      MS(jS(e.toLowerCase(), "+"), (a) => {
        a in RN ? n[a] = !0 : /^[0-9]{2,}$/.test(a) ? n.keyCode = parseInt(a, 10) : (n.charCode = a.charCodeAt(0), n.keyCode = CU[a] || a.toUpperCase().charCodeAt(0));
      });
      const s = [n.keyCode];
      for (t in RN)
        n[t] ? s.push(t) : n[t] = !1;
      return n.id = s.join(","), n.access && (n.alt = !0, o ? n.ctrl = !0 : n.shift = !0), n.meta && (o ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
    };
    class DN {
      constructor(t) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = t;
        const n = this;
        t.on("keyup keypress keydown", (o) => {
          (n.hasModifier(o) || n.isFunctionKey(o)) && !o.isDefaultPrevented() && (MS(n.shortcuts, (s) => {
            if (n.matchShortcut(o, s))
              return n.pendingPatterns = s.subpatterns.slice(0), o.type === "keydown" && n.executeShortcutAction(s), !0;
          }), n.matchShortcut(o, n.pendingPatterns[0]) && (n.pendingPatterns.length === 1 && o.type === "keydown" && n.executeShortcutAction(n.pendingPatterns[0]), n.pendingPatterns.shift()));
        });
      }
      add(t, n, o, s) {
        const a = this, i = a.normalizeCommandFunc(o);
        return MS(jS(nt.trim(t)), (u) => {
          const d = a.createShortcut(u, n, i, s);
          a.shortcuts[d.id] = d;
        }), !0;
      }
      remove(t) {
        const n = this.createShortcut(t);
        return this.shortcuts[n.id] ? (delete this.shortcuts[n.id], !0) : !1;
      }
      normalizeCommandFunc(t) {
        const n = this, o = t;
        return typeof o == "string" ? () => {
          n.editor.execCommand(o, !1, null);
        } : nt.isArray(o) ? () => {
          n.editor.execCommand(o[0], o[1], o[2]);
        } : o;
      }
      createShortcut(t, n, o, s) {
        const a = nt.map(jS(t, ">"), SU);
        return a[a.length - 1] = nt.extend(a[a.length - 1], {
          func: o,
          scope: s || this.editor
        }), nt.extend(a[0], {
          desc: this.editor.translate(n),
          subpatterns: a.slice(1)
        });
      }
      hasModifier(t) {
        return t.altKey || t.ctrlKey || t.metaKey;
      }
      isFunctionKey(t) {
        return t.type === "keydown" && t.keyCode >= 112 && t.keyCode <= 123;
      }
      matchShortcut(t, n) {
        return !n || n.ctrl !== t.ctrlKey || n.meta !== t.metaKey || n.alt !== t.altKey || n.shift !== t.shiftKey ? !1 : t.keyCode === n.keyCode || t.charCode && t.charCode === n.charCode ? (t.preventDefault(), !0) : !1;
      }
      executeShortcutAction(t) {
        return t.func ? t.func.call(t.scope) : null;
      }
    }
    const xU = () => {
      const e = {}, t = {}, n = {}, o = {}, s = {}, a = {}, i = {}, u = (y, v) => (T, N) => y[T.toLowerCase()] = {
        ...N,
        type: v
      }, d = (y, v) => o[y.toLowerCase()] = v;
      return {
        addButton: u(e, "button"),
        addGroupToolbarButton: u(e, "grouptoolbarbutton"),
        addToggleButton: u(e, "togglebutton"),
        addMenuButton: u(e, "menubutton"),
        addSplitButton: u(e, "splitbutton"),
        addMenuItem: u(t, "menuitem"),
        addNestedMenuItem: u(t, "nestedmenuitem"),
        addToggleMenuItem: u(t, "togglemenuitem"),
        addAutocompleter: u(n, "autocompleter"),
        addContextMenu: u(s, "contextmenu"),
        addContextToolbar: u(a, "contexttoolbar"),
        addContextForm: u(a, "contextform"),
        addSidebar: u(i, "sidebar"),
        addIcon: d,
        getAll: () => ({
          buttons: e,
          menuItems: t,
          icons: o,
          popups: n,
          contextMenus: s,
          contextToolbars: a,
          sidebars: i
        })
      };
    }, EU = () => {
      const e = xU();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        getAll: e.getAll
      };
    }, cd = Uo.DOM, ON = nt.extend, TU = nt.each;
    class bk {
      constructor(t, n, o) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.editorManager = o, this.documentBaseUrl = o.documentBaseURL, ON(this, TN);
        const s = this;
        this.id = t, this.hidden = !1;
        const a = pj(o.defaultOptions, n);
        this.options = bU(s, a), Vw(s);
        const i = this.options.get;
        i("deprecation_warnings") && L9(n, a);
        const u = i("suffix");
        u && (o.suffix = u), this.suffix = o.suffix;
        const d = i("base_url");
        d && o._setBaseUrl(d), this.baseUri = o.baseURI;
        const y = ig(s);
        y && (Wa.ScriptLoader._setReferrerPolicy(y), Uo.DOM.styleSheetLoader._setReferrerPolicy(y)), fr.languageLoad = i("language_load"), fr.baseURL = o.baseURL, this.setDirty(!1), this.documentBaseURI = new ei(Ay(s), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = fm(s), this.shortcuts = new DN(this), this.editorCommands = new CN(this), Qj(this);
        const v = i("cache_suffix");
        v && (Gn.cacheSuffix = v.replace(/^[\?\&]+/, "")), this.ui = {
          registry: EU(),
          styleSheetLoader: void 0,
          show: ye,
          hide: ye,
          setEnabled: ye,
          isEnabled: wn
        }, this.mode = vU(s), o.dispatch("SetupEditor", { editor: this });
        const T = S_(s);
        Wt(T) && T.call(s, s);
      }
      render() {
        tj(this);
      }
      focus(t) {
        this.execCommand("mceFocus", !1, t);
      }
      hasFocus() {
        return Yo(this);
      }
      translate(t) {
        return Mr.translate(t);
      }
      getParam(t, n, o) {
        const s = this.options;
        return s.isRegistered(t) || (L(o) ? s.register(t, {
          processor: o,
          default: n
        }) : s.register(t, {
          processor: wn,
          default: n
        })), !s.isSet(t) && !Le(n) ? n : s.get(t);
      }
      hasPlugin(t, n) {
        return ce(qc(this), t) ? n ? sp.get(t) !== void 0 : !0 : !1;
      }
      nodeChanged(t) {
        this._nodeChangeDispatcher.nodeChanged(t);
      }
      addCommand(t, n, o) {
        this.editorCommands.addCommand(t, n, o);
      }
      addQueryStateHandler(t, n, o) {
        this.editorCommands.addQueryStateHandler(t, n, o);
      }
      addQueryValueHandler(t, n, o) {
        this.editorCommands.addQueryValueHandler(t, n, o);
      }
      addShortcut(t, n, o, s) {
        this.shortcuts.add(t, n, o, s);
      }
      execCommand(t, n, o, s) {
        return this.editorCommands.execCommand(t, n, o, s);
      }
      queryCommandState(t) {
        return this.editorCommands.queryCommandState(t);
      }
      queryCommandValue(t) {
        return this.editorCommands.queryCommandValue(t);
      }
      queryCommandSupported(t) {
        return this.editorCommands.queryCommandSupported(t);
      }
      show() {
        const t = this;
        t.hidden && (t.hidden = !1, t.inline ? t.getBody().contentEditable = "true" : (cd.show(t.getContainer()), cd.hide(t.id)), t.load(), t.dispatch("show"));
      }
      hide() {
        const t = this;
        t.hidden || (t.save(), t.inline ? (t.getBody().contentEditable = "false", t === t.editorManager.focusedEditor && (t.editorManager.focusedEditor = null)) : (cd.hide(t.getContainer()), cd.setStyle(t.id, "display", t.orgDisplay)), t.hidden = !0, t.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(t, n) {
        this.dispatch("ProgressState", {
          state: t,
          time: n
        });
      }
      load(t) {
        const n = this;
        let o = n.getElement(), s;
        if (n.removed)
          return "";
        if (o) {
          t = t || {}, t.load = !0;
          const a = ll(o) ? o.value : o.innerHTML;
          return s = n.setContent(a, t), t.element = o, t.no_events || n.dispatch("LoadContent", t), t.element = o = null, s;
        }
      }
      save(t) {
        const n = this;
        let o = n.getElement(), s, a;
        if (!(!o || !n.initialized || n.removed))
          return t = t || {}, t.save = !0, t.element = o, s = t.content = n.getContent(t), t.no_events || n.dispatch("SaveContent", t), t.format === "raw" && n.dispatch("RawSaveContent", t), s = t.content, ll(o) ? o.value = s : ((t.is_removing || !n.inline) && (o.innerHTML = s), (a = cd.getParent(n.id, "form")) && TU(a.elements, (i) => {
            if (i.name === n.id)
              return i.value = s, !1;
          })), t.element = o = null, t.set_dirty !== !1 && n.setDirty(!1), s;
      }
      setContent(t, n) {
        return NC(this, t, n);
      }
      getContent(t) {
        return R9(this, t);
      }
      insertContent(t, n) {
        n && (t = ON({ content: t }, n)), this.execCommand("mceInsertContent", !1, t);
      }
      resetContent(t) {
        t === void 0 ? NC(this, this.startContent, { format: "raw" }) : NC(this, t), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(t) {
        const n = !this.isNotDirty;
        this.isNotDirty = !t, t && t !== n && this.dispatch("dirty");
      }
      getContainer() {
        const t = this;
        return t.container || (t.container = cd.get(t.editorContainer || t.id + "_parent")), t.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = cd.get(this.id)), this.targetElm;
      }
      getWin() {
        const t = this;
        let n;
        return t.contentWindow || (n = t.iframeElement, n && (t.contentWindow = n.contentWindow)), t.contentWindow;
      }
      getDoc() {
        const t = this;
        let n;
        return t.contentDocument || (n = t.getWin(), n && (t.contentDocument = n.document)), t.contentDocument;
      }
      getBody() {
        const t = this.getDoc();
        return this.bodyElement || (t ? t.body : null);
      }
      convertURL(t, n, o) {
        const s = this, a = s.options.get, i = ug(s);
        return Wt(i) ? i.call(s, t, o, !0, n) : !a("convert_urls") || o && o.nodeName === "LINK" || t.indexOf("file:") === 0 || t.length === 0 ? t : a("relative_urls") ? s.documentBaseURI.toRelative(t) : (t = s.documentBaseURI.toAbsolute(t, a("remove_script_host")), t);
      }
      addVisual(t) {
        gj(this, t);
      }
      remove() {
        H9(this);
      }
      destroy(t) {
        W9(this, t);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const fp = Uo.DOM, kk = nt.each;
    let PN = !1, wk, ma = [];
    const _k = (e) => {
      const t = e.type;
      kk(Zu.get(), (n) => {
        switch (t) {
          case "scroll":
            n.dispatch("ScrollWindow", e);
            break;
          case "resize":
            n.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, BN = (e) => {
      if (e !== PN) {
        const t = Uo.DOM;
        e ? (t.bind(window, "resize", _k), t.bind(window, "scroll", _k)) : (t.unbind(window, "resize", _k), t.unbind(window, "scroll", _k)), PN = e;
      }
    }, $N = (e) => {
      const t = ma;
      return ma = Qe(ma, (n) => e !== n), Zu.activeEditor === e && (Zu.activeEditor = ma.length > 0 ? ma[0] : null), Zu.focusedEditor === e && (Zu.focusedEditor = null), t.length !== ma.length;
    }, zU = (e) => (e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && ($N(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0, e = null), e), AU = document.compatMode !== "CSS1Compat", Zu = {
      ...IS,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "6",
      minorVersion: "1.2",
      releaseDate: "2022-07-29",
      i18n: Mr,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let t, n, o = "";
        n = ei.getDocumentBaseUrl(document.location), /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/"));
        const s = window.tinymce || window.tinyMCEPreInit;
        if (s)
          t = s.base || s.baseURL, o = s.suffix;
        else {
          const a = document.getElementsByTagName("script");
          for (let i = 0; i < a.length; i++) {
            const u = a[i].src || "";
            if (u === "")
              continue;
            const d = u.substring(u.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(u)) {
              d.indexOf(".min") !== -1 && (o = ".min"), t = u.substring(0, u.lastIndexOf("/"));
              break;
            }
          }
          if (!t && document.currentScript) {
            const i = document.currentScript.src;
            i.indexOf(".min") !== -1 && (o = ".min"), t = i.substring(0, i.lastIndexOf("/"));
          }
        }
        e.baseURL = new ei(n).toAbsolute(t), e.documentBaseURL = n, e.baseURI = new ei(e.baseURL), e.suffix = o, Tt(e);
      },
      overrideDefaults(e) {
        const t = e.base_url;
        t && this._setBaseUrl(t);
        const n = e.suffix;
        e.suffix && (this.suffix = n), this.defaultOptions = e;
        const o = e.plugin_base_urls;
        o !== void 0 && Ot(o, (s, a) => {
          fr.PluginManager.urls[a] = s;
        });
      },
      init(e) {
        const t = this;
        let n;
        const o = nt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), s = (v, T) => v.inline && T.tagName.toLowerCase() in o, a = (v) => {
          let T = v.id;
          return T || (T = Vn(v, "name").filter((N) => !fp.get(N)).getOrThunk(fp.uniqueId), v.setAttribute("id", T)), T;
        }, i = (v) => {
          const T = e[v];
          if (!!T)
            return T.apply(t, []);
        }, u = (v) => Gn.browser.isIE() || Gn.browser.isEdge() ? (j1("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : AU ? (j1("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : ge(v.selector) ? fp.select(v.selector) : L(v.target) ? [v.target] : [];
        let d = (v) => {
          n = v;
        };
        const y = () => {
          let v = 0;
          const T = [];
          let N;
          const F = (U, j, H) => {
            const se = new bk(U, j, t);
            T.push(se), se.on("init", () => {
              ++v === N.length && d(T);
            }), se.targetElm = se.targetElm || H, se.render();
          };
          fp.unbind(window, "ready", y), i("onpageload"), N = ue(u(e)), nt.each(N, (U) => {
            zU(t.get(U.id));
          }), N = nt.grep(N, (U) => !t.get(U.id)), N.length === 0 ? d([]) : kk(N, (U) => {
            s(e, U) ? j1("Could not initialize inline editor on invalid inline target element", U) : F(a(U), e, U);
          });
        };
        return fp.bind(window, "ready", y), new Promise((v) => {
          n ? v(n) : d = (T) => {
            v(T);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? ma.slice(0) : ge(e) ? oo(ma, (t) => t.id === e).getOr(null) : Je(e) && ma[e] ? ma[e] : null;
      },
      add(e) {
        const t = this, n = t.get(e.id);
        return n === e || (n === null && ma.push(e), BN(!0), t.activeEditor = e, t.dispatch("AddEditor", { editor: e }), wk || (wk = (o) => {
          const s = t.dispatch("BeforeUnload");
          if (s.returnValue)
            return o.preventDefault(), o.returnValue = s.returnValue, s.returnValue;
        }, window.addEventListener("beforeunload", wk))), e;
      },
      createEditor(e, t) {
        return this.add(new bk(e, t, this));
      },
      remove(e) {
        const t = this;
        let n, o;
        if (!e) {
          for (n = ma.length - 1; n >= 0; n--)
            t.remove(ma[n]);
          return;
        }
        if (ge(e)) {
          kk(fp.select(e), (s) => {
            o = t.get(s.id), o && t.remove(o);
          });
          return;
        }
        return o = e, it(t.get(o.id)) ? null : ($N(o) && t.dispatch("RemoveEditor", { editor: o }), ma.length === 0 && window.removeEventListener("beforeunload", wk), o.remove(), BN(ma.length > 0), o);
      },
      execCommand(e, t, n) {
        var o;
        const s = this, a = zt(n) ? (o = n.id) !== null && o !== void 0 ? o : n.index : n;
        switch (e) {
          case "mceAddEditor": {
            if (!s.get(a)) {
              const i = n.options;
              new bk(a, i, s).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const i = s.get(a);
            return i && i.remove(), !0;
          }
          case "mceToggleEditor": {
            const i = s.get(a);
            return i ? (i.isHidden() ? i.show() : i.hide(), !0) : (s.execCommand("mceAddEditor", !1, n), !0);
          }
        }
        return s.activeEditor ? s.activeEditor.execCommand(e, t, n) : !1;
      },
      triggerSave: () => {
        kk(ma, (e) => {
          e.save();
        });
      },
      addI18n: (e, t) => {
        Mr.add(e, t);
      },
      translate: (e) => Mr.translate(e),
      setActive(e) {
        const t = this.activeEditor;
        this.activeEditor !== e && (t && t.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: t })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new ei(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new ei(this.baseURL);
      }
    };
    Zu.setup();
    const NU = (() => {
      const e = jc(), t = (a) => ({
        items: a,
        types: ze(a),
        getType: (i) => Vn(a, i).getOrUndefined()
      }), n = (a) => {
        e.set(a);
      }, o = () => e.get().getOrUndefined(), s = e.clear;
      return {
        FakeClipboardItem: t,
        write: n,
        read: o,
        clear: s
      };
    })(), FN = Math.min, dp = Math.max, vk = Math.round, IN = (e, t, n) => {
      let o = t.x, s = t.y;
      const a = e.w, i = e.h, u = t.w, d = t.h, y = (n || "").split("");
      return y[0] === "b" && (s += d), y[1] === "r" && (o += u), y[0] === "c" && (s += vk(d / 2)), y[1] === "c" && (o += vk(u / 2)), y[3] === "b" && (s -= i), y[4] === "r" && (o -= a), y[3] === "c" && (s -= vk(i / 2)), y[4] === "c" && (o -= vk(a / 2)), mp(o, s, a, i);
    }, RU = (e, t, n, o) => {
      let s, a;
      for (a = 0; a < o.length; a++)
        if (s = IN(e, t, o[a]), s.x >= n.x && s.x + s.w <= n.w + n.x && s.y >= n.y && s.y + s.h <= n.h + n.y)
          return o[a];
      return null;
    }, DU = (e, t, n) => mp(e.x - t, e.y - n, e.w + t * 2, e.h + n * 2), OU = (e, t) => {
      const n = dp(e.x, t.x), o = dp(e.y, t.y), s = FN(e.x + e.w, t.x + t.w), a = FN(e.y + e.h, t.y + t.h);
      return s - n < 0 || a - o < 0 ? null : mp(n, o, s - n, a - o);
    }, PU = (e, t, n) => {
      let o = e.x, s = e.y, a = e.x + e.w, i = e.y + e.h;
      const u = t.x + t.w, d = t.y + t.h, y = dp(0, t.x - o), v = dp(0, t.y - s), T = dp(0, a - u), N = dp(0, i - d);
      return o += y, s += v, n && (a += y, i += v, o -= T, s -= N), a -= T, i -= N, mp(o, s, a - o, i - s);
    }, mp = (e, t, n, o) => ({
      x: e,
      y: t,
      w: n,
      h: o
    }), BU = {
      inflate: DU,
      relativePosition: IN,
      findBestRelativePosition: RU,
      intersect: OU,
      clamp: PU,
      create: mp,
      fromClientRect: (e) => mp(e.left, e.top, e.width, e.height)
    }, $U = (e, t, n = 1e3) => {
      let o = !1, s = null;
      const a = (y) => (...v) => {
        o || (o = !0, s !== null && (clearTimeout(s), s = null), y.apply(null, v));
      }, i = a(e), u = a(t);
      return {
        start: (...y) => {
          !o && s === null && (s = setTimeout(() => u.apply(null, y), n));
        },
        resolve: i,
        reject: u
      };
    }, FU = (() => {
      const e = {}, t = {};
      return {
        load: (a, i) => {
          const u = `Script at URL "${i}" failed to load`, d = `Script at URL "${i}" did not call \`tinymce.Resource.add('${a}', data)\` within 1 second`;
          if (e[a] !== void 0)
            return e[a];
          {
            const y = new Promise((v, T) => {
              const N = $U(v, T);
              t[a] = N.resolve, Wa.ScriptLoader.loadScript(i).then(() => N.start(d), () => N.reject(u));
            });
            return e[a] = y, y;
          }
        },
        add: (a, i) => {
          t[a] !== void 0 && (t[a](i), delete t[a]), e[a] = Promise.resolve(i);
        },
        unload: (a) => {
          delete e[a];
        }
      };
    })(), IU = () => (() => {
      let e = {}, t = [];
      const n = {
        getItem: (o) => {
          const s = e[o];
          return s || null;
        },
        setItem: (o, s) => {
          t.push(o), e[o] = String(s);
        },
        key: (o) => t[o],
        removeItem: (o) => {
          t = t.filter((s) => s === o), delete e[o];
        },
        clear: () => {
          t = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(n, "length", {
        get: () => t.length,
        configurable: !1,
        enumerable: !1
      }), n;
    })();
    let wh;
    try {
      const e = "__storage_test__";
      wh = window.localStorage, wh.setItem(e, e), wh.removeItem(e);
    } catch {
      wh = IU();
    }
    var LU = wh;
    const MU = {
      geom: { Rect: BU },
      util: {
        Delay: xa,
        Tools: nt,
        VK: sn,
        URI: ei,
        EventDispatcher: FS,
        Observable: IS,
        I18n: Mr,
        LocalStorage: LU,
        ImageUploader: CB
      },
      dom: {
        EventUtils: Ja,
        TreeWalker: hs,
        TextSeeker: Ri,
        DOMUtils: Uo,
        ScriptLoader: Wa,
        RangeUtils: ju,
        Serializer: HT,
        StyleSheetLoader: Ed,
        ControlSelection: Kb,
        BookmarkManager: Wf,
        Selection: UT,
        Event: Ja.Event
      },
      html: {
        Styles: Mc,
        Entities: zi,
        Node: da,
        Schema: Ai,
        DomParser: np,
        Writer: Lx,
        Serializer: qu
      },
      Env: Gn,
      AddOnManager: fr,
      Annotator: Ib,
      Formatter: tz,
      UndoManager: oz,
      EditorCommands: CN,
      WindowManager: GT,
      NotificationManager: VT,
      EditorObservable: TN,
      Shortcuts: DN,
      Editor: bk,
      FocusManager: d1,
      EditorManager: Zu,
      DOM: Uo.DOM,
      ScriptLoader: Wa.ScriptLoader,
      PluginManager: sp,
      ThemeManager: nd,
      ModelManager: op,
      IconManager: L1,
      Resource: FU,
      FakeClipboard: NU,
      trim: nt.trim,
      isArray: nt.isArray,
      is: nt.is,
      toArray: nt.toArray,
      makeMap: nt.makeMap,
      each: nt.each,
      map: nt.map,
      grep: nt.grep,
      inArray: nt.inArray,
      extend: nt.extend,
      walk: nt.walk,
      resolve: nt.resolve,
      explode: nt.explode,
      _addCacheSuffix: nt._addCacheSuffix
    }, LN = nt.extend(Zu, MU), jU = (e) => {
      try {
        g.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(LN), jU(LN);
  })();
})(iR);
const gY = iR.exports;
const T6 = z6({
  setup: () => () => ha("div", { class: "sk-cube-grid" }, [
    ha("div", { class: "sk-cube sk-cube1" }),
    ha("div", { class: "sk-cube sk-cube2" }),
    ha("div", { class: "sk-cube sk-cube3" }),
    ha("div", { class: "sk-cube sk-cube4" }),
    ha("div", { class: "sk-cube sk-cube5" }),
    ha("div", { class: "sk-cube sk-cube6" }),
    ha("div", { class: "sk-cube sk-cube7" }),
    ha("div", { class: "sk-cube sk-cube8" }),
    ha("div", { class: "sk-cube sk-cube9" })
  ])
});
/*!
 * TinyMCE Language Pack
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 */
const lR = { Redo: "\u91CD\u505A", Undo: "\u64A4\u9500", Cut: "\u526A\u5207", Copy: "\u590D\u5236", Paste: "\u7C98\u8D34", "Select all": "\u5168\u9009", "New document": "\u65B0\u6587\u4EF6", Ok: "\u786E\u5B9A", Cancel: "\u53D6\u6D88", "Visual aids": "\u7F51\u683C\u7EBF", Bold: "\u7C97\u4F53", Italic: "\u659C\u4F53", Underline: "\u4E0B\u5212\u7EBF", Strikethrough: "\u5220\u9664\u7EBF", Superscript: "\u4E0A\u6807", Subscript: "\u4E0B\u6807", "Clear formatting": "\u6E05\u9664\u683C\u5F0F", Remove: "\u79FB\u9664", "Align left": "\u5DE6\u8FB9\u5BF9\u9F50", "Align center": "\u4E2D\u95F4\u5BF9\u9F50", "Align right": "\u53F3\u8FB9\u5BF9\u9F50", "No alignment": "\u672A\u5BF9\u9F50", Justify: "\u4E24\u7AEF\u5BF9\u9F50", "Bullet list": "\u65E0\u5E8F\u5217\u8868", "Numbered list": "\u7F16\u53F7\u5217\u8868", "Decrease indent": "\u51CF\u5C11\u7F29\u8FDB", "Increase indent": "\u589E\u52A0\u7F29\u8FDB", Close: "\u5173\u95ED", Formats: "\u683C\u5F0F", "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": "\u4F60\u7684\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u6253\u5F00\u526A\u8D34\u677F\uFF0C\u8BF7\u4F7F\u7528Ctrl+X/C/V\u7B49\u5FEB\u6377\u952E\u3002", Headings: "\u6807\u9898", "Heading 1": "\u6807\u98981", "Heading 2": "\u6807\u98982", "Heading 3": "\u6807\u98983", "Heading 4": "\u6807\u98984", "Heading 5": "\u6807\u98985", "Heading 6": "\u6807\u98986", Preformatted: "\u9884\u5148\u683C\u5F0F\u5316\u7684", Div: "\u5206\u533A", Pre: "\u524D\u8A00", Code: "\u4EE3\u7801", Paragraph: "\u6BB5\u843D", Blockquote: "\u5F15\u6587\u533A\u5757", Inline: "\u6587\u672C", Blocks: "\u57FA\u5757", "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "\u5F53\u524D\u4E3A\u7EAF\u6587\u672C\u7C98\u8D34\u6A21\u5F0F\uFF0C\u518D\u6B21\u70B9\u51FB\u53EF\u4EE5\u56DE\u5230\u666E\u901A\u7C98\u8D34\u6A21\u5F0F\u3002", Fonts: "\u5B57\u4F53", "Font sizes": "\u5B57\u4F53\u5927\u5C0F", Class: "\u7C7B\u578B", "Browse for an image": "\u6D4F\u89C8\u56FE\u50CF", OR: "\u6216", "Drop an image here": "\u62D6\u653E\u4E00\u5F20\u56FE\u50CF\u81F3\u6B64", Upload: "\u4E0A\u4F20", "Uploading image": "\u4E0A\u4F20\u56FE\u7247", Block: "\u5757", Align: "\u5BF9\u9F50", Default: "\u9884\u8BBE", Circle: "\u7A7A\u5FC3\u5706", Disc: "\u5B9E\u5FC3\u5706", Square: "\u5B9E\u5FC3\u65B9\u5757", "Lower Alpha": "\u5C0F\u5199\u82F1\u6587\u5B57\u6BCD", "Lower Greek": "\u5C0F\u5199\u5E0C\u814A\u5B57\u6BCD", "Lower Roman": "\u5C0F\u5199\u7F57\u9A6C\u6570\u5B57", "Upper Alpha": "\u5927\u5199\u82F1\u6587\u5B57\u6BCD", "Upper Roman": "\u5927\u5199\u7F57\u9A6C\u6570\u5B57", "Anchor...": "\u951A\u70B9...", Anchor: "\u951A\u70B9", Name: "\u540D\u79F0", ID: "ID", "ID should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "ID\u5E94\u8BE5\u4EE5\u82F1\u6587\u5B57\u6BCD\u5F00\u5934\uFF0C\u540E\u9762\u53EA\u80FD\u6709\u82F1\u6587\u5B57\u6BCD\u3001\u6570\u5B57\u3001\u7834\u6298\u53F7\u3001\u70B9\u3001\u5192\u53F7\u6216\u4E0B\u5212\u7EBF\u3002", "You have unsaved changes are you sure you want to navigate away?": "\u4F60\u8FD8\u6709\u6587\u6863\u5C1A\u672A\u4FDD\u5B58\uFF0C\u786E\u5B9A\u8981\u79BB\u5F00\uFF1F", "Restore last draft": "\u6062\u590D\u4E0A\u6B21\u7684\u8349\u7A3F", "Special character...": "\u7279\u6B8A\u5B57\u7B26...", "Special Character": "\u7279\u6B8A\u5B57\u7B26", "Source code": "\u6E90\u4EE3\u7801", "Insert/Edit code sample": "\u63D2\u5165/\u7F16\u8F91\u4EE3\u7801\u793A\u4F8B", Language: "\u8BED\u8A00", "Code sample...": "\u793A\u4F8B\u4EE3\u7801...", "Left to right": "\u7531\u5DE6\u5230\u53F3", "Right to left": "\u7531\u53F3\u5230\u5DE6", Title: "\u6807\u9898", Fullscreen: "\u5168\u5C4F\u5E55", Action: "\u52A8\u4F5C", Shortcut: "\u5FEB\u6377\u65B9\u5F0F", Help: "\u5E2E\u52A9", Address: "\u5730\u5740", "Focus to menubar": "\u79FB\u52A8\u7126\u70B9\u5230\u83DC\u5355\u680F", "Focus to toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u5DE5\u5177\u680F", "Focus to element path": "\u79FB\u52A8\u7126\u70B9\u5230\u5143\u7D20\u8DEF\u5F84", "Focus to contextual toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u4E0A\u4E0B\u6587\u83DC\u5355", "Insert link (if link plugin activated)": "\u63D2\u5165\u94FE\u63A5 (\u5982\u679C\u94FE\u63A5\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)", "Save (if save plugin activated)": "\u4FDD\u5B58(\u5982\u679C\u4FDD\u5B58\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)", "Find (if searchreplace plugin activated)": "\u67E5\u627E(\u5982\u679C\u67E5\u627E\u66FF\u6362\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)", "Plugins installed ({0}):": "\u5DF2\u5B89\u88C5\u63D2\u4EF6 ({0}):", "Premium plugins:": "\u4F18\u79C0\u63D2\u4EF6\uFF1A", "Learn more...": "\u4E86\u89E3\u66F4\u591A...", "You are using {0}": "\u4F60\u6B63\u5728\u4F7F\u7528 {0}", Plugins: "\u5168\u90E8\u5916\u6302\u7A0B\u5E8F", "Handy Shortcuts": "\u5FEB\u6377\u952E", "Horizontal line": "\u6C34\u5E73\u5206\u5272\u7EBF", "Insert/edit image": "\u63D2\u5165/\u7F16\u8F91\u56FE\u7247", "Alternative description": "\u66FF\u4EE3\u63CF\u8FF0", Accessibility: "\u8F85\u52A9\u529F\u80FD", "Image is decorative": "\u56FE\u50CF\u662F\u88C5\u9970\u6027\u7684", Source: "\u539F\u59CB\u7801", Dimensions: "\u5C3A\u5BF8", "Constrain proportions": "\u4FDD\u6301\u6BD4\u4F8B", General: "\u4E00\u822C", Advanced: "\u9AD8\u7EA7", Style: "\u6837\u5F0F", "Vertical space": "\u5782\u76F4\u95F4\u8DDD", "Horizontal space": "\u6C34\u5E73\u95F4\u8DDD", Border: "\u6846\u7EBF", "Insert image": "\u63D2\u5165\u56FE\u7247", "Image...": "\u56FE\u7247...", "Image list": "\u56FE\u7247\u6E05\u5355", Resize: "\u8C03\u6574\u5927\u5C0F", "Insert date/time": "\u63D2\u5165\u65E5\u671F/\u65F6\u95F4", "Date/time": "\u65E5\u671F/\u65F6\u95F4", "Insert/edit link": "\u63D2\u5165/\u7F16\u8F91\u94FE\u63A5", "Text to display": "\u8981\u663E\u793A\u7684\u6587\u672C", Url: "\u5730\u5740", "Open link in...": "\u94FE\u63A5\u6253\u5F00\u4F4D\u7F6E...", "Current window": "\u5F53\u524D\u7A97\u53E3", None: "\u65E0", "New window": "\u65B0\u7A97\u53E3", "Open link": "\u6253\u5F00\u94FE\u63A5", "Remove link": "\u79FB\u9664\u94FE\u63A5", Anchors: "\u951A\u70B9", "Link...": "\u94FE\u63A5...", "Paste or type a link": "\u7C98\u8D34\u6216\u8F93\u5165\u94FE\u63A5", "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u4E3A\u90AE\u4EF6\u5730\u5740\uFF0C\u9700\u8981\u52A0\u4E0Amailto:\u524D\u7F00\u5417\uFF1F", "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u5C5E\u4E8E\u5916\u90E8\u94FE\u63A5\uFF0C\u9700\u8981\u52A0\u4E0Ahttp://:\u524D\u7F00\u5417\uFF1F", "The URL you entered seems to be an external link. Do you want to add the required https:// prefix?": "\u60A8\u8F93\u5165\u7684 URL \u4F3C\u4E4E\u662F\u4E00\u4E2A\u5916\u90E8\u94FE\u63A5\u3002\u60A8\u60F3\u6DFB\u52A0\u6240\u9700\u7684 https:// \u524D\u7F00\u5417\uFF1F", "Link list": "\u94FE\u63A5\u6E05\u5355", "Insert video": "\u63D2\u5165\u89C6\u9891", "Insert/edit video": "\u63D2\u5165/\u7F16\u8F91\u89C6\u9891", "Insert/edit media": "\u63D2\u5165/\u7F16\u8F91\u5A92\u4F53", "Alternative source": "\u955C\u50CF", "Alternative source URL": "\u66FF\u4EE3\u6765\u6E90\u7F51\u5740", "Media poster (Image URL)": "\u5C01\u9762(\u56FE\u7247\u5730\u5740)", "Paste your embed code below:": "\u5C06\u5185\u5D4C\u4EE3\u7801\u7C98\u8D34\u5728\u4E0B\u9762:", Embed: "\u5185\u5D4C", "Media...": "\u591A\u5A92\u4F53...", "Nonbreaking space": "\u4E0D\u95F4\u65AD\u7A7A\u683C", "Page break": "\u5206\u9875\u7B26", "Paste as text": "\u7C98\u8D34\u4E3A\u6587\u672C", Preview: "\u9884\u89C8", Print: "\u6253\u5370", "Print...": "\u6253\u5370...", Save: "\u4FDD\u5B58", Find: "\u5BFB\u627E", "Replace with": "\u66FF\u6362\u4E3A", Replace: "\u66FF\u6362", "Replace all": "\u66FF\u6362\u5168\u90E8", Previous: "\u4E0A\u4E00\u4E2A", Next: "\u4E0B\u4E00\u4E2A", "Find and Replace": "\u67E5\u627E\u548C\u66FF\u6362", "Find and replace...": "\u67E5\u627E\u5E76\u66FF\u6362...", "Could not find the specified string.": "\u672A\u627E\u5230\u641C\u7D22\u5185\u5BB9\u3002", "Match case": "\u5927\u5C0F\u5199\u5339\u914D", "Find whole words only": "\u5168\u5B57\u5339\u914D", "Find in selection": "\u5728\u9009\u533A\u4E2D\u67E5\u627E", "Insert table": "\u63D2\u5165\u8868\u683C", "Table properties": "\u8868\u683C\u5C5E\u6027", "Delete table": "\u5220\u9664\u8868\u683C", Cell: "\u50A8\u5B58\u683C", Row: "\u884C", Column: "\u680F\u76EE", "Cell properties": "\u5355\u5143\u683C\u5C5E\u6027", "Merge cells": "\u5408\u5E76\u5355\u5143\u683C", "Split cell": "\u62C6\u5206\u5355\u5143\u683C", "Insert row before": "\u5728\u4E0A\u65B9\u63D2\u5165\u884C", "Insert row after": "\u5728\u4E0B\u65B9\u63D2\u5165\u884C", "Delete row": "\u5220\u9664\u884C", "Row properties": "\u884C\u5C5E\u6027", "Cut row": "\u526A\u5207\u884C", "Cut column": "\u526A\u5207\u5217", "Copy row": "\u590D\u5236\u884C", "Copy column": "\u590D\u5236\u5217", "Paste row before": "\u7C98\u8D34\u884C\u5230\u4E0A\u65B9", "Paste column before": "\u7C98\u8D34\u6B64\u5217\u524D", "Paste row after": "\u7C98\u8D34\u884C\u5230\u4E0B\u65B9", "Paste column after": "\u7C98\u8D34\u540E\u9762\u7684\u5217", "Insert column before": "\u5728\u5DE6\u4FA7\u63D2\u5165\u5217", "Insert column after": "\u5728\u53F3\u4FA7\u63D2\u5165\u5217", "Delete column": "\u5220\u9664\u5217", Cols: "\u5217", Rows: "\u884C\u6570", Width: "\u5BBD\u5EA6", Height: "\u9AD8\u5EA6", "Cell spacing": "\u5355\u5143\u683C\u5916\u95F4\u8DDD", "Cell padding": "\u5355\u5143\u683C\u5185\u8FB9\u8DDD", "Row clipboard actions": "\u884C\u526A\u8D34\u677F\u64CD\u4F5C", "Column clipboard actions": "\u5217\u526A\u8D34\u677F\u64CD\u4F5C", "Table styles": "\u8868\u683C\u6837\u5F0F", "Cell styles": "\u5355\u5143\u683C\u6837\u5F0F", "Column header": "\u5217\u6807\u9898", "Row header": "\u884C\u5934", "Table caption": "\u8868\u683C\u6807\u9898", Caption: "\u6807\u9898", "Show caption": "\u663E\u793A\u6807\u9898", Left: "\u5DE6", Center: "\u5C45\u4E2D", Right: "\u53F3", "Cell type": "\u50A8\u5B58\u683C\u522B", Scope: "\u8303\u56F4", Alignment: "\u5BF9\u9F50", "Horizontal align": "\u6C34\u5E73\u5BF9\u9F50", "Vertical align": "\u5782\u76F4\u5BF9\u9F50", Top: "\u4E0A\u65B9\u5BF9\u9F50", Middle: "\u5C45\u4E2D\u5BF9\u9F50", Bottom: "\u4E0B\u65B9\u5BF9\u9F50", "Header cell": "\u8868\u5934\u5355\u5143\u683C", "Row group": "\u884C\u7EC4", "Column group": "\u5217\u7EC4", "Row type": "\u884C\u7C7B\u578B", Header: "\u8868\u5934", Body: "\u8868\u4F53", Footer: "\u8868\u5C3E", "Border color": "\u6846\u7EBF\u989C\u8272", Solid: "\u5B9E\u7EBF", Dotted: "\u865A\u7EBF", Dashed: "\u865A\u7EBF", Double: "\u53CC\u7CBE\u5EA6", Groove: "\u51F9\u69FD", Ridge: "\u6D77\u810A\u5EA7", Inset: "\u5D4C\u5165", Outset: "\u5916\u7F6E", Hidden: "\u9690\u85CF", "Insert template...": "\u63D2\u5165\u6A21\u677F...", Templates: "\u6A21\u677F", Template: "\u6A21\u677F", "Insert Template": "\u63D2\u5165\u6A21\u677F", "Text color": "\u6587\u672C\u989C\u8272", "Background color": "\u80CC\u666F\u989C\u8272", "Custom...": "\u81EA\u5B9A\u4E49......", "Custom color": "\u81EA\u5B9A\u4E49\u989C\u8272", "No color": "\u65E0", "Remove color": "\u79FB\u9664\u989C\u8272", "Show blocks": "\u663E\u793A\u533A\u5757\u8FB9\u6846", "Show invisible characters": "\u663E\u793A\u4E0D\u53EF\u89C1\u5B57\u7B26", "Word count": "\u5B57\u6570", Count: "\u8BA1\u6570", Document: "\u6587\u6863", Selection: "\u9009\u62E9", Words: "\u5355\u8BCD", "Words: {0}": "\u5B57\u6570\uFF1A{0}", "{0} words": "{0} \u5B57", File: "\u6587\u4EF6", Edit: "\u7F16\u8F91", Insert: "\u63D2\u5165", View: "\u67E5\u770B", Format: "\u683C\u5F0F", Table: "\u8868\u683C", Tools: "\u5DE5\u5177", "Powered by {0}": "\u7531{0}\u9A71\u52A8", "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "\u7F16\u8F91\u533A\u3002\u6309ALT-F9\u6253\u5F00\u83DC\u5355\uFF0C\u6309ALT-F10\u6253\u5F00\u5DE5\u5177\u680F\uFF0C\u6309ALT-0\u67E5\u770B\u5E2E\u52A9", "Image title": "\u56FE\u7247\u6807\u9898", "Border width": "\u8FB9\u6846\u5BBD\u5EA6", "Border style": "\u8FB9\u6846\u6837\u5F0F", Error: "\u9519\u8BEF", Warn: "\u8B66\u544A", Valid: "\u6709\u6548", "To open the popup, press Shift+Enter": "\u6309Shitf+Enter\u952E\u6253\u5F00\u5BF9\u8BDD\u6846", "Rich Text Area": "\u5BCC\u6587\u672C\u533A\u57DF", "Rich Text Area. Press ALT-0 for help.": "\u7F16\u8F91\u533A\u3002\u6309Alt+0\u952E\u6253\u5F00\u5E2E\u52A9\u3002", "System Font": "\u7CFB\u7EDF\u5B57\u4F53", "Failed to upload image: {0}": "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25: {0}", "Failed to load plugin: {0} from url {1}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25: {0} \u6765\u81EA\u94FE\u63A5 {1}", "Failed to load plugin url: {0}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25 \u94FE\u63A5: {0}", "Failed to initialize plugin: {0}": "\u63D2\u4EF6\u521D\u59CB\u5316\u5931\u8D25: {0}", example: "\u793A\u4F8B", Search: "\u641C\u7D22", All: "\u5168\u90E8", Currency: "\u8D27\u5E01", Text: "\u6587\u5B57", Quotations: "\u5F15\u7528", Mathematical: "\u6570\u5B66", "Extended Latin": "\u62C9\u4E01\u8BED\u6269\u5145", Symbols: "\u7B26\u53F7", Arrows: "\u7BAD\u5934", "User Defined": "\u81EA\u5B9A\u4E49", "dollar sign": "\u7F8E\u5143\u7B26\u53F7", "currency sign": "\u8D27\u5E01\u7B26\u53F7", "euro-currency sign": "\u6B27\u5143\u7B26\u53F7", "colon sign": "\u5192\u53F7", "cruzeiro sign": "\u514B\u9C81\u8D5B\u7F57\u5E01\u7B26\u53F7", "french franc sign": "\u6CD5\u90CE\u7B26\u53F7", "lira sign": "\u91CC\u62C9\u7B26\u53F7", "mill sign": "\u5BC6\u5C14\u7B26\u53F7", "naira sign": "\u5948\u62C9\u7B26\u53F7", "peseta sign": "\u6BD4\u585E\u5854\u7B26\u53F7", "rupee sign": "\u5362\u6BD4\u7B26\u53F7", "won sign": "\u97E9\u5143\u7B26\u53F7", "new sheqel sign": "\u65B0\u8C22\u514B\u5C14\u7B26\u53F7", "dong sign": "\u8D8A\u5357\u76FE\u7B26\u53F7", "kip sign": "\u8001\u631D\u57FA\u666E\u7B26\u53F7", "tugrik sign": "\u56FE\u683C\u91CC\u514B\u7B26\u53F7", "drachma sign": "\u5FB7\u62C9\u514B\u9A6C\u7B26\u53F7", "german penny symbol": "\u5FB7\u56FD\u4FBF\u58EB\u7B26\u53F7", "peso sign": "\u6BD4\u7D22\u7B26\u53F7", "guarani sign": "\u74DC\u62C9\u5C3C\u7B26\u53F7", "austral sign": "\u6FB3\u5143\u7B26\u53F7", "hryvnia sign": "\u683C\u91CC\u592B\u5C3C\u4E9A\u7B26\u53F7", "cedi sign": "\u585E\u5730\u7B26\u53F7", "livre tournois sign": "\u91CC\u5F17\u5F17\u5C14\u7B26\u53F7", "spesmilo sign": "spesmilo\u7B26\u53F7", "tenge sign": "\u575A\u6208\u7B26\u53F7", "indian rupee sign": "\u5370\u5EA6\u5362\u6BD4", "turkish lira sign": "\u571F\u8033\u5176\u91CC\u62C9", "nordic mark sign": "\u5317\u6B27\u9A6C\u514B", "manat sign": "\u9A6C\u7EB3\u7279\u7B26\u53F7", "ruble sign": "\u5362\u5E03\u7B26\u53F7", "yen character": "\u65E5\u5143\u5B57\u6837", "yuan character": "\u4EBA\u6C11\u5E01\u5143\u5B57\u6837", "yuan character, in hong kong and taiwan": "\u5143\u5B57\u6837\uFF08\u6E2F\u53F0\u5730\u533A\uFF09", "yen/yuan character variant one": "\u5143\u5B57\u6837\uFF08\u5927\u5199\uFF09", Emojis: "Emojis", "Emojis...": "Emojis...", "Loading emojis...": "\u6B63\u5728\u52A0\u8F7DEmojis...", "Could not load emojis": "\u65E0\u6CD5\u52A0\u8F7DEmojis", People: "\u4EBA\u7C7B", "Animals and Nature": "\u52A8\u7269\u548C\u81EA\u7136", "Food and Drink": "\u98DF\u7269\u548C\u996E\u54C1", Activity: "\u6D3B\u52A8", "Travel and Places": "\u65C5\u6E38\u548C\u5730\u70B9", Objects: "\u7269\u4EF6", Flags: "\u65D7\u5E1C", Characters: "\u5B57\u7B26", "Characters (no spaces)": "\u5B57\u7B26(\u65E0\u7A7A\u683C)", "{0} characters": "{0} \u4E2A\u5B57\u7B26", "Error: Form submit field collision.": "\u9519\u8BEF: \u8868\u5355\u63D0\u4EA4\u5B57\u6BB5\u51B2\u7A81\u3002", "Error: No form element found.": "\u9519\u8BEF: \u6CA1\u6709\u8868\u5355\u63A7\u4EF6\u3002", "Color swatch": "\u989C\u8272\u6837\u672C", "Color Picker": "\u9009\u8272\u5668", "Invalid hex color code: {0}": "\u5341\u516D\u8FDB\u5236\u989C\u8272\u4EE3\u7801\u65E0\u6548\uFF1A {0}", "Invalid input": "\u65E0\u6548\u8F93\u5165", R: "R", "Red component": "\u7EA2\u8272\u90E8\u5206", G: "G", "Green component": "\u7EFF\u8272\u90E8\u5206", B: "B", "Blue component": "\u767D\u8272\u90E8\u5206", "#": "#", "Hex color code": "\u5341\u516D\u8FDB\u5236\u989C\u8272\u4EE3\u7801", "Range 0 to 255": "\u8303\u56F40\u81F3255", Turquoise: "\u9752\u7EFF\u8272", Green: "\u7EFF\u8272", Blue: "\u84DD\u8272", Purple: "\u7D2B\u8272", "Navy Blue": "\u6D77\u519B\u84DD", "Dark Turquoise": "\u6DF1\u84DD\u7EFF\u8272", "Dark Green": "\u6DF1\u7EFF\u8272", "Medium Blue": "\u4E2D\u84DD\u8272", "Medium Purple": "\u4E2D\u7D2B\u8272", "Midnight Blue": "\u6DF1\u84DD\u8272", Yellow: "\u9EC4\u8272", Orange: "\u6A59\u8272", Red: "\u7EA2\u8272", "Light Gray": "\u6D45\u7070\u8272", Gray: "\u7070\u8272", "Dark Yellow": "\u6697\u9EC4\u8272", "Dark Orange": "\u6DF1\u6A59\u8272", "Dark Red": "\u6DF1\u7EA2\u8272", "Medium Gray": "\u4E2D\u7070\u8272", "Dark Gray": "\u6DF1\u7070\u8272", "Light Green": "\u6D45\u7EFF\u8272", "Light Yellow": "\u6D45\u9EC4\u8272", "Light Red": "\u6D45\u7EA2\u8272", "Light Purple": "\u6D45\u7D2B\u8272", "Light Blue": "\u6D45\u84DD\u8272", "Dark Purple": "\u6DF1\u7D2B\u8272", "Dark Blue": "\u6DF1\u84DD\u8272", Black: "\u9ED1\u8272", White: "\u767D\u8272", "Switch to or from fullscreen mode": "\u5207\u6362\u5168\u5C4F\u6A21\u5F0F", "Open help dialog": "\u6253\u5F00\u5E2E\u52A9\u5BF9\u8BDD\u6846", history: "\u5386\u53F2", styles: "\u6837\u5F0F", formatting: "\u683C\u5F0F\u5316", alignment: "\u5BF9\u9F50", indentation: "\u7F29\u8FDB", Font: "\u5B57\u4F53", Size: "\u5B57\u53F7", "More...": "\u66F4\u591A...", "Select...": "\u9009\u62E9...", Preferences: "\u9996\u9009\u9879", Yes: "\u662F", No: "\u5426", "Keyboard Navigation": "\u952E\u76D8\u6307\u5F15", Version: "\u7248\u672C", "Code view": "\u4EE3\u7801\u89C6\u56FE", "Open popup menu for split buttons": "\u6253\u5F00\u5F39\u51FA\u5F0F\u83DC\u5355\uFF0C\u7528\u4E8E\u62C6\u5206\u6309\u94AE", "List Properties": "\u5217\u8868\u5C5E\u6027", "List properties...": "\u6807\u9898\u5B57\u4F53\u5C5E\u6027", "Start list at number": "\u4EE5\u6570\u5B57\u5F00\u59CB\u5217\u8868", "Line height": "\u884C\u9AD8", "Dropped file type is not supported": "\u6B64\u6587\u4EF6\u7C7B\u578B\u4E0D\u652F\u6301\u62D6\u653E", "Loading...": "\u52A0\u8F7D\u4E2D...", "ImageProxy HTTP error: Rejected request": "", "ImageProxy HTTP error: Could not find Image Proxy": "", "ImageProxy HTTP error: Incorrect Image Proxy URL": "", "ImageProxy HTTP error: Unknown ImageProxy error": "" };
tinymce.addI18n("zh_CN", lR);
tinymce.addI18n("zh-Hans", lR);
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const _ = (r, c, l) => {
    var f;
    return l(r, c.prototype) ? !0 : ((f = r.constructor) === null || f === void 0 ? void 0 : f.name) === c.name;
  }, D = (r) => {
    const c = typeof r;
    return r === null ? "null" : c === "object" && Array.isArray(r) ? "array" : c === "object" && _(r, String, (l, f) => f.isPrototypeOf(l)) ? "string" : c;
  }, X = (r) => (c) => D(c) === r, _e = (r) => (c) => typeof c === r, Ae = (r) => (c) => r === c, We = X("string"), Ke = X("object"), Ee = X("array"), Ie = Ae(null), pt = _e("boolean"), _t = (r) => r == null, $e = (r) => !_t(r), Ne = _e("function"), tt = _e("number"), xe = () => {
  }, rt = (r, c) => (...l) => r(c.apply(null, l)), ae = (r, c) => (l) => r(c(l)), ke = (r) => () => r, ge = (r) => r, zt = (r, c) => r === c;
  function ot(r, ...c) {
    return (...l) => {
      const f = c.concat(l);
      return r.apply(null, f);
    };
  }
  const le = (r) => (c) => !r(c), it = (r) => () => {
    throw new Error(r);
  }, ft = (r) => r(), Le = ke(!1), Ve = ke(!0);
  class L {
    constructor(c, l) {
      this.tag = c, this.value = l;
    }
    static some(c) {
      return new L(!0, c);
    }
    static none() {
      return L.singletonNone;
    }
    fold(c, l) {
      return this.tag ? l(this.value) : c();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(c) {
      return this.tag ? L.some(c(this.value)) : L.none();
    }
    bind(c) {
      return this.tag ? c(this.value) : L.none();
    }
    exists(c) {
      return this.tag && c(this.value);
    }
    forall(c) {
      return !this.tag || c(this.value);
    }
    filter(c) {
      return !this.tag || c(this.value) ? this : L.none();
    }
    getOr(c) {
      return this.tag ? this.value : c;
    }
    or(c) {
      return this.tag ? this : c;
    }
    getOrThunk(c) {
      return this.tag ? this.value : c();
    }
    orThunk(c) {
      return this.tag ? this : c();
    }
    getOrDie(c) {
      if (this.tag)
        return this.value;
      throw new Error(c != null ? c : "Called getOrDie on None");
    }
    static from(c) {
      return $e(c) ? L.some(c) : L.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(c) {
      this.tag && c(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  L.singletonNone = new L(!1);
  const Wt = Array.prototype.slice, Je = Array.prototype.indexOf, jt = Array.prototype.push, ye = (r, c) => Je.call(r, c), Ze = (r, c) => ye(r, c) > -1, qt = (r, c) => {
    for (let l = 0, f = r.length; l < f; l++) {
      const p = r[l];
      if (c(p, l))
        return !0;
    }
    return !1;
  }, Z = (r, c) => {
    const l = [];
    for (let f = 0; f < r; f++)
      l.push(c(f));
    return l;
  }, Pe = (r, c) => {
    const l = r.length, f = new Array(l);
    for (let p = 0; p < l; p++) {
      const k = r[p];
      f[p] = c(k, p);
    }
    return f;
  }, yt = (r, c) => {
    for (let l = 0, f = r.length; l < f; l++) {
      const p = r[l];
      c(p, l);
    }
  }, et = (r, c) => {
    for (let l = r.length - 1; l >= 0; l--) {
      const f = r[l];
      c(f, l);
    }
  }, kn = (r, c) => {
    const l = [], f = [];
    for (let p = 0, k = r.length; p < k; p++) {
      const C = r[p];
      (c(C, p) ? l : f).push(C);
    }
    return {
      pass: l,
      fail: f
    };
  }, Rn = (r, c) => {
    const l = [];
    for (let f = 0, p = r.length; f < p; f++) {
      const k = r[f];
      c(k, f) && l.push(k);
    }
    return l;
  }, an = (r, c, l) => (et(r, (f, p) => {
    l = c(l, f, p);
  }), l), en = (r, c, l) => (yt(r, (f, p) => {
    l = c(l, f, p);
  }), l), cn = (r, c, l) => {
    for (let f = 0, p = r.length; f < p; f++) {
      const k = r[f];
      if (c(k, f))
        return L.some(k);
      if (l(k, f))
        break;
    }
    return L.none();
  }, wn = (r, c) => cn(r, c, Le), w = (r, c) => {
    for (let l = 0, f = r.length; l < f; l++) {
      const p = r[l];
      if (c(p, l))
        return L.some(l);
    }
    return L.none();
  }, ie = (r) => {
    const c = [];
    for (let l = 0, f = r.length; l < f; ++l) {
      if (!Ee(r[l]))
        throw new Error("Arr.flatten item " + l + " was not an array, input: " + r);
      jt.apply(c, r[l]);
    }
    return c;
  }, re = (r, c) => ie(Pe(r, c)), we = (r, c) => {
    for (let l = 0, f = r.length; l < f; ++l) {
      const p = r[l];
      if (c(p, l) !== !0)
        return !1;
    }
    return !0;
  }, J = (r) => {
    const c = Wt.call(r, 0);
    return c.reverse(), c;
  }, me = (r, c) => {
    const l = {};
    for (let f = 0, p = r.length; f < p; f++) {
      const k = r[f];
      l[String(k)] = c(k, f);
    }
    return l;
  }, ce = (r, c) => {
    const l = Wt.call(r, 0);
    return l.sort(c), l;
  }, Ce = (r, c) => c >= 0 && c < r.length ? L.some(r[c]) : L.none(), W = (r) => Ce(r, 0), M = (r) => Ce(r, r.length - 1), Ue = (r, c) => {
    for (let l = 0; l < r.length; l++) {
      const f = c(r[l], l);
      if (f.isSome())
        return f;
    }
    return L.none();
  }, kt = Object.keys, Qe = Object.hasOwnProperty, pn = (r, c) => {
    const l = kt(r);
    for (let f = 0, p = l.length; f < p; f++) {
      const k = l[f], C = r[k];
      c(C, k);
    }
  }, En = (r, c) => Eo(r, (l, f) => ({
    k: f,
    v: c(l, f)
  })), Eo = (r, c) => {
    const l = {};
    return pn(r, (f, p) => {
      const k = c(f, p);
      l[k.k] = k.v;
    }), l;
  }, oo = (r) => (c, l) => {
    r[l] = c;
  }, Yn = (r, c, l, f) => {
    const p = {};
    return pn(r, (k, C) => {
      (c(k, C) ? l : f)(k, C);
    }), p;
  }, eo = (r, c) => {
    const l = {};
    return Yn(r, c, oo(l), xe), l;
  }, Xt = (r, c) => {
    const l = [];
    return pn(r, (f, p) => {
      l.push(c(f, p));
    }), l;
  }, ro = (r) => Xt(r, ge), io = (r, c) => Fe(r, c) ? L.from(r[c]) : L.none(), Fe = (r, c) => Qe.call(r, c), st = (r, c) => Fe(r, c) && r[c] !== void 0 && r[c] !== null, Qt = (r) => {
    for (const c in r)
      if (Qe.call(r, c))
        return !1;
    return !0;
  };
  typeof window < "u" || Function("return this;")();
  const Ut = 8, Tn = 9, Pn = 11, ho = 1, Bo = 3, ue = (r) => r.dom.nodeName.toLowerCase(), ze = (r) => r.dom.nodeType, At = (r) => (c) => ze(c) === r, Ot = (r) => ze(r) === Ut || ue(r) === "#comment", hn = At(ho), Ao = At(Bo), xs = At(Tn), zs = At(Pn), To = (r) => (c) => hn(c) && ue(c) === r, rs = (r, c, l) => {
    if (We(l) || pt(l) || tt(l))
      r.setAttribute(c, l + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", c, ":: Value ", l, ":: Element ", r), new Error("Attribute value was not simple");
  }, wo = (r, c, l) => {
    rs(r.dom, c, l);
  }, os = (r, c) => {
    const l = r.dom;
    pn(c, (f, p) => {
      rs(l, p, f);
    });
  }, Vn = (r, c) => {
    pn(c, (l, f) => {
      l.fold(() => {
        lo(r, f);
      }, (p) => {
        rs(r.dom, f, p);
      });
    });
  }, gn = (r, c) => {
    const l = r.dom.getAttribute(c);
    return l === null ? void 0 : l;
  }, qo = (r, c) => L.from(gn(r, c)), lo = (r, c) => {
    r.dom.removeAttribute(c);
  }, Io = (r) => en(r.dom.attributes, (c, l) => (c[l.name] = l.value, c), {}), Ks = (r, c) => {
    const f = (c || document).createElement("div");
    if (f.innerHTML = r, !f.hasChildNodes() || f.childNodes.length > 1) {
      const p = "HTML does not have a single root node";
      throw console.error(p, r), new Error(p);
    }
    return Lo(f.childNodes[0]);
  }, As = (r, c) => {
    const f = (c || document).createElement(r);
    return Lo(f);
  }, cs = (r, c) => {
    const f = (c || document).createTextNode(r);
    return Lo(f);
  }, Lo = (r) => {
    if (r == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: r };
  }, O = {
    fromHtml: Ks,
    fromTag: As,
    fromText: cs,
    fromDom: Lo,
    fromPoint: (r, c, l) => L.from(r.dom.elementFromPoint(c, l)).map(Lo)
  }, G = (r, c) => {
    const l = r.dom;
    if (l.nodeType !== ho)
      return !1;
    {
      const f = l;
      if (f.matches !== void 0)
        return f.matches(c);
      if (f.msMatchesSelector !== void 0)
        return f.msMatchesSelector(c);
      if (f.webkitMatchesSelector !== void 0)
        return f.webkitMatchesSelector(c);
      if (f.mozMatchesSelector !== void 0)
        return f.mozMatchesSelector(c);
      throw new Error("Browser lacks native selectors");
    }
  }, de = (r) => r.nodeType !== ho && r.nodeType !== Tn && r.nodeType !== Pn || r.childElementCount === 0, dt = (r, c) => {
    const l = c === void 0 ? document : c.dom;
    return de(l) ? [] : Pe(l.querySelectorAll(r), O.fromDom);
  }, rn = (r, c) => {
    const l = c === void 0 ? document : c.dom;
    return de(l) ? L.none() : L.from(l.querySelector(r)).map(O.fromDom);
  }, Et = (r, c) => r.dom === c.dom, An = (r, c) => {
    const l = r.dom, f = c.dom;
    return l === f ? !1 : l.contains(f);
  }, Po = G, ln = (r) => O.fromDom(r.dom.ownerDocument), jn = (r) => xs(r) ? r : ln(r), Mo = (r) => O.fromDom(jn(r).dom.documentElement), No = (r) => O.fromDom(jn(r).dom.defaultView), q = (r) => L.from(r.dom.parentNode).map(O.fromDom), ee = (r) => L.from(r.dom.parentElement).map(O.fromDom), Ge = (r, c) => {
    const l = Ne(c) ? c : Le;
    let f = r.dom;
    const p = [];
    for (; f.parentNode !== null && f.parentNode !== void 0; ) {
      const k = f.parentNode, C = O.fromDom(k);
      if (p.push(C), l(C) === !0)
        break;
      f = k;
    }
    return p;
  }, St = (r) => L.from(r.dom.previousSibling).map(O.fromDom), vt = (r) => L.from(r.dom.nextSibling).map(O.fromDom), wt = (r) => Pe(r.dom.childNodes, O.fromDom), It = (r, c) => {
    const l = r.dom.childNodes;
    return L.from(l[c]).map(O.fromDom);
  }, Lt = (r) => It(r, 0), un = (r, c) => {
    q(r).each((f) => {
      f.dom.insertBefore(c.dom, r.dom);
    });
  }, Xn = (r, c) => {
    vt(r).fold(() => {
      q(r).each((p) => {
        Dn(p, c);
      });
    }, (f) => {
      un(f, c);
    });
  }, yo = (r, c) => {
    Lt(r).fold(() => {
      Dn(r, c);
    }, (f) => {
      r.dom.insertBefore(c.dom, f.dom);
    });
  }, Dn = (r, c) => {
    r.dom.appendChild(c.dom);
  }, sr = (r, c, l) => {
    It(r, l).fold(() => {
      Dn(r, c);
    }, (f) => {
      un(f, c);
    });
  }, bs = (r, c) => {
    un(r, c), Dn(c, r);
  }, Bn = (r, c) => {
    yt(c, (l, f) => {
      const p = f === 0 ? r : c[f - 1];
      Xn(p, l);
    });
  }, to = (r, c) => {
    yt(c, (l) => {
      Dn(r, l);
    });
  }, Qo = (r) => {
    r.dom.textContent = "", yt(wt(r), (c) => {
      Jo(c);
    });
  }, Jo = (r) => {
    const c = r.dom;
    c.parentNode !== null && c.parentNode.removeChild(c);
  }, Ns = (r) => {
    const c = wt(r);
    c.length > 0 && Bn(r, c), Jo(r);
  }, Rs = (r, c) => O.fromDom(r.dom.cloneNode(c)), Yr = (r) => Rs(r, !1), js = (r) => Rs(r, !0), vr = (r, c) => {
    const l = O.fromTag(c), f = Io(r);
    return os(l, f), l;
  }, rr = (r, c) => {
    const l = vr(r, c), f = wt(js(r));
    return to(l, f), l;
  }, Ra = (r, c) => {
    const l = vr(r, c);
    Xn(r, l);
    const f = wt(r);
    return to(l, f), Jo(r), l;
  }, Cr = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], $r = (r) => Ze(Cr, r), Xr = (r, c) => ({
    rows: r,
    columns: c
  }), Fr = (r, c) => ({
    row: r,
    column: c
  }), Xs = (r, c, l) => ({
    element: r,
    rowspan: c,
    colspan: l
  }), Da = (r, c, l, f) => ({
    element: r,
    rowspan: c,
    colspan: l,
    isNew: f
  }), ar = (r, c, l, f, p, k) => ({
    element: r,
    rowspan: c,
    colspan: l,
    row: f,
    column: p,
    isLocked: k
  }), Sr = (r, c, l) => ({
    element: r,
    cells: c,
    section: l
  }), Zr = (r, c, l, f) => ({
    element: r,
    cells: c,
    section: l,
    isNew: f
  }), is = (r, c, l) => ({
    element: r,
    isNew: c,
    isLocked: l
  }), R = (r, c, l, f) => ({
    element: r,
    cells: c,
    section: l,
    isNew: f
  }), Q = (r, c, l, f) => ({
    startRow: r,
    startCol: c,
    finishRow: l,
    finishCol: f
  }), fe = (r, c, l) => ({
    element: r,
    colspan: c,
    column: l
  }), qe = (r, c) => ({
    element: r,
    columns: c
  }), bt = (r) => zs(r) && $e(r.dom.host), Nn = Ne(Element.prototype.attachShadow) && Ne(Node.prototype.getRootNode), bo = ke(Nn), Vo = Nn ? (r) => O.fromDom(r.dom.getRootNode()) : jn, po = (r) => {
    const c = Vo(r);
    return bt(c) ? L.some(c) : L.none();
  }, ms = (r) => O.fromDom(r.dom.host), ks = (r) => {
    if (bo() && $e(r.target)) {
      const c = O.fromDom(r.target);
      if (hn(c) && xr(c) && r.composed && r.composedPath) {
        const l = r.composedPath();
        if (l)
          return W(l);
      }
    }
    return L.from(r.target);
  }, xr = (r) => $e(r.dom.shadowRoot), Ro = (r) => {
    const c = Ao(r) ? r.dom.parentNode : r.dom;
    if (c == null || c.ownerDocument === null)
      return !1;
    const l = c.ownerDocument;
    return po(O.fromDom(c)).fold(() => l.body.contains(c), ae(Ro, ms));
  }, Oa = () => ya(O.fromDom(document)), ya = (r) => {
    const c = r.dom.body;
    if (c == null)
      throw new Error("Body is not available yet");
    return O.fromDom(c);
  }, cr = (r, c, l) => Rn(Ge(r, l), c), ps = (r, c) => Rn(wt(r), c), hr = (r, c) => {
    let l = [];
    return yt(wt(r), (f) => {
      c(f) && (l = l.concat([f])), l = l.concat(hr(f, c));
    }), l;
  }, Er = (r, c, l) => cr(r, (f) => G(f, c), l), Gn = (r, c) => ps(r, (l) => G(l, c)), Ds = (r, c) => dt(c, r);
  var Pa = (r, c, l, f, p) => r(l, f) ? L.some(l) : Ne(p) && p(l) ? L.none() : c(l, f, p);
  const Qr = (r, c, l) => {
    let f = r.dom;
    const p = Ne(l) ? l : Le;
    for (; f.parentNode; ) {
      f = f.parentNode;
      const k = O.fromDom(f);
      if (c(k))
        return L.some(k);
      if (p(k))
        break;
    }
    return L.none();
  }, x = (r, c, l) => Pa((p, k) => k(p), Qr, r, c, l), B = (r, c) => {
    const l = (p) => c(O.fromDom(p));
    return wn(r.dom.childNodes, l).map(O.fromDom);
  }, K = (r, c) => {
    const l = (f) => {
      for (let p = 0; p < f.childNodes.length; p++) {
        const k = O.fromDom(f.childNodes[p]);
        if (c(k))
          return L.some(k);
        const C = l(f.childNodes[p]);
        if (C.isSome())
          return C;
      }
      return L.none();
    };
    return l(r.dom);
  }, Re = (r, c, l) => Qr(r, (f) => G(f, c), l), Gt = (r, c) => B(r, (l) => G(l, c)), Un = (r, c) => rn(c, r), Zn = (r, c, l) => Pa((p, k) => G(p, k), Re, r, c, l), nt = (r, c, l = zt) => r.exists((f) => l(f, c)), Xo = (r) => {
    const c = [], l = (f) => {
      c.push(f);
    };
    for (let f = 0; f < r.length; f++)
      r[f].each(l);
    return c;
  }, Tr = (r, c) => r != null ? c(r) : L.none(), zo = (r, c) => r ? L.some(c) : L.none(), zr = (r, c, l) => c === "" || r.length >= c.length && r.substr(l, l + c.length) === c, gs = (r, c) => r.indexOf(c) !== -1, $ = (r, c) => zr(r, c, 0), V = (r, c) => zr(r, c, r.length - c.length), He = ((r) => (c) => c.replace(r, ""))(/^\s+|\s+$/g), Zt = (r) => r.length > 0, tn = (r) => {
    const c = parseFloat(r);
    return isNaN(c) ? L.none() : L.some(c);
  }, vo = (r) => r.style !== void 0 && Ne(r.style.getPropertyValue), jo = (r, c, l) => {
    if (!We(l))
      throw console.error("Invalid call to CSS.set. Property ", c, ":: Value ", l, ":: Element ", r), new Error("CSS value must be a string: " + l);
    vo(r) && r.style.setProperty(c, l);
  }, Zs = (r, c) => {
    vo(r) && r.style.removeProperty(c);
  }, qn = (r, c, l) => {
    const f = r.dom;
    jo(f, c, l);
  }, ko = (r, c) => {
    const l = r.dom;
    pn(c, (f, p) => {
      jo(l, p, f);
    });
  }, Qs = (r, c) => {
    const l = r.dom, p = window.getComputedStyle(l).getPropertyValue(c);
    return p === "" && !Ro(r) ? Js(l, c) : p;
  }, Js = (r, c) => vo(r) ? r.style.getPropertyValue(c) : "", Ya = (r, c) => {
    const l = r.dom, f = Js(l, c);
    return L.from(f).filter((p) => p.length > 0);
  }, ir = (r, c) => {
    const l = r.dom;
    Zs(l, c), nt(qo(r, "style").map(He), "") && lo(r, "style");
  }, ao = (r, c) => {
    const l = r.dom, f = c.dom;
    vo(l) && vo(f) && (f.style.cssText = l.style.cssText);
  }, es = (r, c, l = 0) => qo(r, c).map((f) => parseInt(f, 10)).getOr(l), Os = (r, c) => es(r, c, 1), Jr = (r) => To("col")(r) ? es(r, "span", 1) > 1 : Os(r, "colspan") > 1, Ba = (r) => Os(r, "rowspan") > 1, as = (r, c) => parseInt(Qs(r, c), 10), ba = ke(10), ea = ke(10), rc = (r, c) => Ki(r, c, Ve), Ki = (r, c, l) => re(wt(r), (f) => G(f, c) ? l(f) ? [f] : [] : Ki(f, c, l)), ta = (r, c, l = Le) => {
    if (l(c))
      return L.none();
    if (Ze(r, ue(c)))
      return L.some(c);
    const f = (p) => G(p, "table") || l(p);
    return Re(c, r.join(","), f);
  }, na = (r, c) => ta([
    "td",
    "th"
  ], r, c), Xa = (r) => rc(r, "th,td"), ac = (r) => G(r, "colgroup") ? Gn(r, "col") : re(ka(r), (c) => Gn(c, "col")), Us = (r, c) => Zn(r, "table", c), Yi = (r) => rc(r, "tr"), ka = (r) => Us(r).fold(ke([]), (c) => Gn(c, "colgroup")), Sc = (r, c) => Pe(r, (l) => {
    if (ue(l) === "colgroup") {
      const f = Pe(ac(l), (p) => {
        const k = es(p, "span", 1);
        return Xs(p, 1, k);
      });
      return Sr(l, f, "colgroup");
    } else {
      const f = Pe(Xa(l), (p) => {
        const k = es(p, "rowspan", 1), C = es(p, "colspan", 1);
        return Xs(p, k, C);
      });
      return Sr(l, f, c(l));
    }
  }), xc = (r) => q(r).map((c) => {
    const l = ue(c);
    return $r(l) ? l : "tbody";
  }).getOr("tbody"), ui = (r) => {
    const c = Yi(r), f = [
      ...ka(r),
      ...c
    ];
    return Sc(f, xc);
  }, Ec = (r, c) => Sc(r, () => c), oa = (r) => {
    let c = !1, l;
    return (...f) => (c || (c = !0, l = r.apply(null, f)), l);
  }, tf = (r, c, l, f) => {
    const p = r.isiOS() && /ipad/i.test(l) === !0, k = r.isiOS() && !p, C = r.isiOS() || r.isAndroid(), z = C || f("(pointer:coarse)"), I = p || !k && C && f("(min-device-width:768px)"), Y = k || C && !I, he = c.isSafari() && r.isiOS() && /safari/i.test(l) === !1, ct = !Y && !I && !he;
    return {
      isiPad: ke(p),
      isiPhone: ke(k),
      isTablet: ke(I),
      isPhone: ke(Y),
      isTouch: ke(z),
      isAndroid: r.isAndroid,
      isiOS: r.isiOS,
      isWebView: ke(he),
      isDesktop: ke(ct)
    };
  }, Tc = (r, c) => {
    for (let l = 0; l < r.length; l++) {
      const f = r[l];
      if (f.test(c))
        return f;
    }
  }, Xi = (r, c) => {
    const l = Tc(r, c);
    if (!l)
      return {
        major: 0,
        minor: 0
      };
    const f = (p) => Number(c.replace(l, "$" + p));
    return ne(f(1), f(2));
  }, lr = (r, c) => {
    const l = String(c).toLowerCase();
    return r.length === 0 ? Zi() : Xi(r, l);
  }, Zi = () => ne(0, 0), ne = (r, c) => ({
    major: r,
    minor: c
  }), cc = {
    nu: ne,
    detect: lr,
    unknown: Zi
  }, sa = (r, c) => Ue(c.brands, (l) => {
    const f = l.brand.toLowerCase();
    return wn(r, (p) => {
      var k;
      return f === ((k = p.brand) === null || k === void 0 ? void 0 : k.toLowerCase());
    }).map((p) => ({
      current: p.name,
      version: cc.nu(parseInt(l.version, 10), 0)
    }));
  }), Qi = (r, c) => {
    const l = String(c).toLowerCase();
    return wn(r, (f) => f.search(l));
  }, nf = (r, c) => Qi(r, c).map((l) => {
    const f = cc.detect(l.versionRegexes, c);
    return {
      current: l.name,
      version: f
    };
  }), ql = (r, c) => Qi(r, c).map((l) => {
    const f = cc.detect(l.versionRegexes, c);
    return {
      current: l.name,
      version: f
    };
  }), _o = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ws = (r) => (c) => gs(c, r), fi = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (r) => gs(r, "edge/") && gs(r, "chrome") && gs(r, "safari") && gs(r, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        _o
      ],
      search: (r) => gs(r, "chrome") && !gs(r, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (r) => gs(r, "msie") || gs(r, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        _o,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: ws("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: ws("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        _o,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (r) => (gs(r, "safari") || gs(r, "mobile/")) && gs(r, "applewebkit")
    }
  ], wa = [
    {
      name: "Windows",
      search: ws("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (r) => gs(r, "iphone") || gs(r, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: ws("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: ws("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: ws("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: ws("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: ws("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: ws("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Vl = {
    browsers: ke(fi),
    oses: ke(wa)
  }, $a = "Edge", er = "Chromium", Ji = "IE", Gl = "Opera", el = "Firefox", Fa = "Safari", di = () => mi({
    current: void 0,
    version: cc.unknown()
  }), mi = (r) => {
    const c = r.current, l = r.version, f = (p) => () => c === p;
    return {
      current: c,
      version: l,
      isEdge: f($a),
      isChromium: f(er),
      isIE: f(Ji),
      isOpera: f(Gl),
      isFirefox: f(el),
      isSafari: f(Fa)
    };
  }, tl = {
    unknown: di,
    nu: mi,
    edge: ke($a),
    chromium: ke(er),
    ie: ke(Ji),
    opera: ke(Gl),
    firefox: ke(el),
    safari: ke(Fa)
  }, fs = "Windows", ic = "iOS", nl = "Android", pi = "Linux", ol = "macOS", Kl = "Solaris", sl = "FreeBSD", rl = "ChromeOS", b = () => S({
    current: void 0,
    version: cc.unknown()
  }), S = (r) => {
    const c = r.current, l = r.version, f = (p) => () => c === p;
    return {
      current: c,
      version: l,
      isWindows: f(fs),
      isiOS: f(ic),
      isAndroid: f(nl),
      isMacOS: f(ol),
      isLinux: f(pi),
      isSolaris: f(Kl),
      isFreeBSD: f(sl),
      isChromeOS: f(rl)
    };
  }, A = {
    unknown: b,
    nu: S,
    windows: ke(fs),
    ios: ke(ic),
    android: ke(nl),
    linux: ke(pi),
    macos: ke(ol),
    solaris: ke(Kl),
    freebsd: ke(sl),
    chromeos: ke(rl)
  }, be = { detect: (r, c, l) => {
    const f = Vl.browsers(), p = Vl.oses(), k = c.bind((I) => sa(f, I)).orThunk(() => nf(f, r)).fold(tl.unknown, tl.nu), C = ql(p, r).fold(A.unknown, A.nu), z = tf(C, k, r, l);
    return {
      browser: k,
      os: C,
      deviceType: z
    };
  } }, $t = (r) => window.matchMedia(r).matches;
  let yn = oa(() => be.detect(navigator.userAgent, L.from(navigator.userAgentData), $t));
  const On = () => yn(), Hn = (r, c) => {
    const l = (z, I) => {
      if (!tt(I) && !I.match(/^[0-9]+$/))
        throw new Error(r + ".set accepts only positive integer values. Value was " + I);
      const Y = z.dom;
      vo(Y) && (Y.style[r] = I + "px");
    }, f = (z) => {
      const I = c(z);
      if (I <= 0 || I === null) {
        const Y = Qs(z, r);
        return parseFloat(Y) || 0;
      }
      return I;
    }, p = f, k = (z, I) => en(I, (Y, he) => {
      const ct = Qs(z, he), Tt = ct === void 0 ? 0 : parseInt(ct, 10);
      return isNaN(Tt) ? Y : Y + Tt;
    }, 0);
    return {
      set: l,
      get: f,
      getOuter: p,
      aggregate: k,
      max: (z, I, Y) => {
        const he = k(z, Y);
        return I > he ? I - he : 0;
      }
    };
  }, Mn = (r, c) => tn(r).getOr(c), ts = (r, c, l) => Mn(Qs(r, c), l), Ir = (r, c, l, f) => {
    const p = ts(r, `padding-${l}`, 0), k = ts(r, `padding-${f}`, 0), C = ts(r, `border-${l}-width`, 0), z = ts(r, `border-${f}-width`, 0);
    return c - p - k - C - z;
  }, Hs = (r, c) => {
    const l = r.dom, f = l.getBoundingClientRect().width || l.offsetWidth;
    return c === "border-box" ? f : Ir(r, f, "left", "right");
  }, gd = (r) => ts(r, "height", r.dom.offsetHeight), gi = (r) => ts(r, "width", r.dom.offsetWidth), hd = (r) => Hs(r, "content-box"), Yl = Hn("width", (r) => r.dom.offsetWidth), Ia = (r) => Yl.get(r), yr = (r) => Yl.getOuter(r), ra = hd, yd = gi, ls = (r, c, l) => {
    const f = r.cells, p = f.slice(0, c), k = f.slice(c), C = p.concat(l).concat(k);
    return lc(r, C);
  }, bd = (r, c, l) => ls(r, c, [l]), al = (r, c, l) => {
    const f = r.cells;
    f[c] = l;
  }, lc = (r, c) => R(r.element, c, r.section, r.isNew), cl = (r, c) => {
    const l = r.cells, f = Pe(l, c);
    return R(r.element, f, r.section, r.isNew);
  }, Do = (r, c) => r.cells[c], Es = (r, c) => Do(r, c).element, Ar = (r) => r.cells.length, _s = (r) => {
    const c = kn(r, (l) => l.section === "colgroup");
    return {
      rows: c.fail,
      cols: c.pass
    };
  }, of = (r, c, l) => {
    const f = Pe(r.cells, l);
    return R(c(r.element), f, r.section, !0);
  }, hi = "data-snooker-locked-cols", sf = (r) => qo(r, hi).bind((c) => L.from(c.match(/\d+/g))).map((c) => me(c, Ve)), uc = (r) => {
    const c = en(_s(r).rows, (f, p) => (yt(p.cells, (k, C) => {
      k.isLocked && (f[C] = !0);
    }), f), {}), l = Xt(c, (f, p) => parseInt(p, 10));
    return ce(l);
  }, Xl = (r, c) => r + "," + c, bp = (r, c, l) => L.from(r.access[Xl(c, l)]), kp = (r, c, l) => {
    const f = Zl(r, (p) => l(c, p.element));
    return f.length > 0 ? L.some(f[0]) : L.none();
  }, Zl = (r, c) => {
    const l = re(r.all, (f) => f.cells);
    return Rn(l, c);
  }, wp = (r) => {
    const c = {};
    let l = 0;
    return yt(r.cells, (f) => {
      const p = f.colspan;
      Z(p, (k) => {
        const C = l + k;
        c[C] = fe(f.element, p, C);
      }), l += p;
    }), c;
  }, rf = (r) => {
    const c = {}, l = [], p = W(r).map((Ct) => Ct.element).bind(Us).bind(sf).getOr({});
    let k = 0, C = 0, z = 0;
    const {
      pass: I,
      fail: Y
    } = kn(r, (Ct) => Ct.section === "colgroup");
    yt(Y, (Ct) => {
      const Ye = [];
      yt(Ct.cells, (Rt) => {
        let Xe = 0;
        for (; c[Xl(z, Xe)] !== void 0; )
          Xe++;
        const Kt = st(p, Xe.toString()), Cn = ar(Rt.element, Rt.rowspan, Rt.colspan, z, Xe, Kt);
        for (let Fn = 0; Fn < Rt.colspan; Fn++)
          for (let Zo = 0; Zo < Rt.rowspan; Zo++) {
            const Is = z + Zo, Yo = Xe + Fn, Hr = Xl(Is, Yo);
            c[Hr] = Cn, C = Math.max(C, Yo + 1);
          }
        Ye.push(Cn);
      }), k++, l.push(Sr(Ct.element, Ye, Ct.section)), z++;
    });
    const { columns: he, colgroups: ct } = M(I).map((Ct) => {
      const Ye = wp(Ct);
      return {
        colgroups: [qe(Ct.element, ro(Ye))],
        columns: Ye
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Xr(k, C),
      access: c,
      all: l,
      columns: he,
      colgroups: ct
    };
  }, In = {
    fromTable: (r) => {
      const c = ui(r);
      return rf(c);
    },
    generate: rf,
    getAt: bp,
    findItem: kp,
    filterItems: Zl,
    justCells: (r) => re(r.all, (c) => c.cells),
    justColumns: (r) => ro(r.columns),
    hasColumns: (r) => kt(r.columns).length > 0,
    getColumnAt: (r, c) => L.from(r.columns[c])
  }, fc = (r, c = Ve) => {
    const l = r.grid, f = Z(l.columns, ge), p = Z(l.rows, ge);
    return Pe(f, (k) => bi(() => re(p, (Y) => In.getAt(r, Y, k).filter((he) => he.column === k).toArray()), (Y) => Y.colspan === 1 && c(Y.element), () => In.getAt(r, 0, k)));
  }, bi = (r, c, l) => {
    const f = r();
    return wn(f, c).orThunk(() => L.from(f[0]).orThunk(l)).map((C) => C.element);
  }, af = (r) => {
    const c = r.grid, l = Z(c.rows, ge), f = Z(c.columns, ge);
    return Pe(l, (p) => bi(() => re(f, (I) => In.getAt(r, p, I).filter((Y) => Y.row === p).fold(ke([]), (Y) => [Y])), (I) => I.rowspan === 1, () => In.getAt(r, p, 0)));
  }, cf = (r, c) => {
    if (c < 0 || c >= r.length - 1)
      return L.none();
    const l = r[c].fold(() => {
      const p = J(r.slice(0, c));
      return Ue(p, (k, C) => k.map((z) => ({
        value: z,
        delta: C + 1
      })));
    }, (p) => L.some({
      value: p,
      delta: 0
    })), f = r[c + 1].fold(() => {
      const p = r.slice(c + 1);
      return Ue(p, (k, C) => k.map((z) => ({
        value: z,
        delta: C + 1
      })));
    }, (p) => L.some({
      value: p,
      delta: 1
    }));
    return l.bind((p) => f.map((k) => {
      const C = k.delta + p.delta;
      return Math.abs(k.value - p.value) / C;
    }));
  }, lf = (r, c) => (l) => Nc(l) === "rtl" ? c : r, Nc = (r) => Qs(r, "direction") === "rtl" ? "rtl" : "ltr", ki = Hn("height", (r) => {
    const c = r.dom;
    return Ro(r) ? c.getBoundingClientRect().height : c.offsetHeight;
  }), dn = (r) => ki.get(r), aa = (r) => ki.getOuter(r), wi = gd, uf = (r, c) => ({
    left: r,
    top: c,
    translate: (f, p) => uf(r + f, c + p)
  }), Za = uf, Rc = (r) => {
    const c = r.getBoundingClientRect();
    return Za(c.left, c.top);
  }, Ql = (r, c) => r !== void 0 ? r : c !== void 0 ? c : 0, La = (r) => {
    const c = r.dom.ownerDocument, l = c.body, f = c.defaultView, p = c.documentElement;
    if (l === r.dom)
      return Za(l.offsetLeft, l.offsetTop);
    const k = Ql(f == null ? void 0 : f.pageYOffset, p.scrollTop), C = Ql(f == null ? void 0 : f.pageXOffset, p.scrollLeft), z = Ql(p.clientTop, l.clientTop), I = Ql(p.clientLeft, l.clientLeft);
    return wd(r).translate(C - I, k - z);
  }, wd = (r) => {
    const c = r.dom, f = c.ownerDocument.body;
    return f === c ? Za(f.offsetLeft, f.offsetTop) : Ro(r) ? Rc(c) : Za(0, 0);
  }, ll = (r, c) => ({
    row: r,
    y: c
  }), Ft = (r, c) => ({
    col: r,
    x: c
  }), _d = (r) => La(r).left + yr(r), vd = (r) => La(r).left, ul = (r, c) => Ft(r, vd(c)), Jl = (r, c) => Ft(r, _d(c)), _i = (r) => La(r).top, ds = (r, c) => ll(r, _i(c)), Cd = (r, c) => ll(r, _i(c) + aa(c)), ca = (r, c, l) => {
    if (l.length === 0)
      return [];
    const f = Pe(l.slice(1), (k, C) => k.map((z) => r(C, z))), p = l[l.length - 1].map((k) => c(l.length - 1, k));
    return f.concat([p]);
  }, ns = (r) => -r, fl = {
    delta: ge,
    positions: (r) => ca(ds, Cd, r),
    edge: _i
  }, Dc = lf({
    delta: ge,
    edge: vd,
    positions: (r) => ca(ul, Jl, r)
  }, {
    delta: ns,
    edge: _d,
    positions: (r) => ca(Jl, ul, r)
  }), vi = {
    delta: (r, c) => Dc(c).delta(r, c),
    positions: (r, c) => Dc(c).positions(r, c),
    edge: (r) => Dc(r).edge(r)
  }, ff = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, Sd = (() => {
    const r = "[0-9]+", c = "[+-]?" + r, l = "[eE]" + c, f = "\\.", p = (z) => `(?:${z})?`, C = `[+-]?(?:${[
      "Infinity",
      r + f + p(r) + p(l),
      f + r + p(l),
      r + p(l)
    ].join("|")})`;
    return new RegExp(`^(${C})(.*)$`);
  })(), eu = (r, c) => qt(c, (l) => qt(ff[l], (f) => r === f)), Ci = (r, c) => L.from(Sd.exec(r)).bind((f) => {
    const p = Number(f[1]), k = f[2];
    return eu(k, c) ? L.some({
      value: p,
      unit: k
    }) : L.none();
  }), Oc = /(\d+(\.\d+)?)%/, _p = /(\d+(\.\d+)?)px|em/, vp = To("col"), xd = (r, c, l) => {
    const f = ee(r).getOrThunk(() => ya(ln(r)));
    return c(r) / l(f) * 100;
  }, Si = (r, c) => {
    qn(r, "width", c + "px");
  }, Pc = (r, c) => {
    qn(r, "width", c + "%");
  }, Ma = (r, c) => {
    qn(r, "height", c + "px");
  }, Ed = (r) => wi(r) + "px", Rh = (r, c, l, f) => {
    const p = Us(r).map((k) => {
      const C = l(k);
      return Math.floor(c / 100 * C);
    }).getOr(c);
    return f(r, p), p;
  }, Td = (r, c, l, f) => {
    const p = parseFloat(r);
    return V(r, "%") && ue(c) !== "table" ? Rh(c, p, l, f) : p;
  }, hs = (r) => {
    const c = Ed(r);
    return c ? Td(c, r, dn, Ma) : dn(r);
  }, Cp = (r, c, l) => {
    const f = l(r), p = Os(r, c);
    return f / p;
  }, zd = (r, c) => Ya(r, c).orThunk(() => qo(r, c).map((l) => l + "px")), xi = (r) => zd(r, "width"), Sp = (r) => zd(r, "height"), xp = (r) => xd(r, Ia, ra), df = (r) => vp(r) ? Ia(r) : yd(r), Ad = (r) => Cp(r, "rowspan", hs), Ep = (r) => xi(r).bind((l) => Ci(l, [
    "fixed",
    "relative",
    "empty"
  ])), Nd = (r, c, l) => {
    qn(r, "width", c + l);
  }, mc = (r) => Ia(r) + "px", ia = (r) => xd(r, Ia, ra) + "%", Tp = (r) => xi(r).exists((c) => Oc.test(c)), mf = (r) => xi(r).exists((c) => _p.test(c)), Ei = (r) => xi(r).isNone(), pf = ke(Oc), gf = To("col"), dl = (r) => xi(r).getOrThunk(() => df(r) + "px"), Rd = (r) => Sp(r).getOrThunk(() => Ad(r) + "px"), tu = (r) => Pe(In.justColumns(r), (c) => L.from(c.element)), nu = (r) => {
    const c = On().browser, l = c.isChromium() || c.isFirefox();
    return gf(r) ? l : !0;
  }, hf = (r, c, l, f, p, k) => r.filter(f).fold(() => k(cf(l, c)), (C) => p(C)), yf = (r, c, l, f) => {
    const p = fc(r), k = In.hasColumns(r) ? tu(r) : p, C = [L.some(vi.edge(c))].concat(Pe(vi.positions(p, c), (I) => I.map((Y) => Y.x))), z = le(Jr);
    return Pe(k, (I, Y) => hf(I, Y, C, z, (he) => {
      if (nu(he))
        return l(he);
      {
        const ct = Tr(p[Y], ge);
        return hf(ct, Y, C, z, (Tt) => f(L.some(Ia(Tt))), f);
      }
    }, f));
  }, bf = (r) => r.map((c) => c + "px").getOr(""), ml = (r, c) => yf(r, c, dl, bf), Ws = (r, c, l) => yf(r, c, xp, (f) => f.fold(() => l.minCellWidth(), (p) => p / l.pixelWidth() * 100)), ou = (r, c, l) => yf(r, c, df, (f) => f.getOrThunk(l.minCellWidth)), Dd = (r, c, l, f, p) => {
    const k = af(r), C = [L.some(l.edge(c))].concat(Pe(l.positions(k, c), (z) => z.map((I) => I.y)));
    return Pe(k, (z, I) => hf(z, I, C, le(Ba), f, p));
  }, kf = (r, c, l) => Dd(r, c, l, Ad, (f) => f.getOrThunk(ea)), br = (r, c, l) => Dd(r, c, l, Rd, bf), wf = (r, c) => () => Ro(r) ? c(r) : parseFloat(Ya(r, "width").getOr("0")), su = (r) => {
    const c = wf(r, Ia), l = ke(0);
    return {
      width: c,
      pixelWidth: c,
      getWidths: (p, k) => ou(p, r, k),
      getCellDelta: l,
      singleColumnWidth: ke([0]),
      minCellWidth: l,
      setElementWidth: xe,
      adjustTableWidth: xe,
      isRelative: !0,
      label: "none"
    };
  }, Bc = (r) => {
    const c = wf(r, (I) => parseFloat(ia(I))), l = wf(r, Ia);
    return {
      width: c,
      pixelWidth: l,
      getWidths: (I, Y) => Ws(I, r, Y),
      getCellDelta: (I) => I / l() * 100,
      singleColumnWidth: (I, Y) => [100 - I],
      minCellWidth: () => ba() / l() * 100,
      setElementWidth: Pc,
      adjustTableWidth: (I) => {
        const Y = c(), he = I / 100 * Y, ct = Y + he;
        Pc(r, ct);
      },
      isRelative: !0,
      label: "percent"
    };
  }, Ti = (r) => {
    const c = wf(r, Ia);
    return {
      width: c,
      pixelWidth: c,
      getWidths: (C, z) => ou(C, r, z),
      getCellDelta: ge,
      singleColumnWidth: (C, z) => [Math.max(ba(), C + z) - C],
      minCellWidth: ba,
      setElementWidth: Si,
      adjustTableWidth: (C) => {
        const z = c() + C;
        Si(r, z);
      },
      isRelative: !1,
      label: "pixel"
    };
  }, zp = (r, c) => pf().exec(c) !== null ? Bc(r) : Ti(r), pc = {
    getTableSize: (r) => xi(r).fold(() => su(r), (l) => zp(r, l)),
    pixelSize: Ti,
    percentageSize: Bc,
    noneSize: su
  }, $c = (r, c, l, f, p, k) => ({
    minRow: r,
    minCol: c,
    maxRow: l,
    maxCol: f,
    allCells: p,
    selectedCells: k
  }), Ap = (r, c) => {
    const l = r.grid.columns;
    let p = r.grid.rows, k = l, C = 0, z = 0;
    const I = [], Y = [];
    return pn(r.access, (he) => {
      if (I.push(he), c(he)) {
        Y.push(he);
        const ct = he.row, Tt = ct + he.rowspan - 1, Ct = he.column, Ye = Ct + he.colspan - 1;
        ct < p ? p = ct : Tt > C && (C = Tt), Ct < k ? k = Ct : Ye > z && (z = Ye);
      }
    }), $c(p, k, C, z, I, Y);
  }, m = (r, c, l) => {
    const f = r[l].element, p = O.fromTag("td");
    Dn(p, O.fromTag("br")), (c ? Dn : yo)(f, p);
  }, h = (r, c, l, f) => {
    const p = Rn(r, (z) => z.section !== "colgroup"), k = c.grid.columns, C = c.grid.rows;
    for (let z = 0; z < C; z++) {
      let I = !1;
      for (let Y = 0; Y < k; Y++)
        z < l.minRow || z > l.maxRow || Y < l.minCol || Y > l.maxCol || (In.getAt(c, z, Y).filter(f).isNone() ? m(p, I, z) : I = !0);
    }
  }, E = (r, c, l, f) => {
    pn(l.columns, (C) => {
      (C.column < c.minCol || C.column > c.maxCol) && Jo(C.element);
    });
    const p = Rn(rc(r, "tr"), (C) => C.dom.childElementCount === 0);
    yt(p, Jo), (c.minCol === c.maxCol || c.minRow === c.maxRow) && yt(rc(r, "th,td"), (C) => {
      lo(C, "rowspan"), lo(C, "colspan");
    }), lo(r, hi), lo(r, "data-snooker-col-series"), pc.getTableSize(r).adjustTableWidth(f);
  }, P = (r, c, l, f) => {
    if (f.minCol === 0 && c.grid.columns === f.maxCol + 1)
      return 0;
    const p = ou(c, r, l), k = en(p, (Y, he) => Y + he, 0), I = en(p.slice(f.minCol, f.maxCol + 1), (Y, he) => Y + he, 0) / k * l.pixelWidth() - l.pixelWidth();
    return l.getCellDelta(I);
  }, oe = (r, c) => {
    const l = (Tt) => G(Tt.element, c), f = js(r), p = ui(f), k = pc.getTableSize(r), C = In.generate(p), z = Ap(C, l), I = "th:not(" + c + "),td:not(" + c + ")", Y = Ki(f, "th,td", (Tt) => G(Tt, I));
    yt(Y, Jo), h(p, C, z, l);
    const he = In.fromTable(r), ct = P(r, he, k, z);
    return E(f, z, C, ct), f;
  }, Me = "\xA0", xt = ((r, c) => {
    const l = (k) => {
      if (!r(k))
        throw new Error("Can only get " + c + " value of a " + c + " node");
      return f(k).getOr("");
    }, f = (k) => r(k) ? L.from(k.dom.nodeValue) : L.none();
    return {
      get: l,
      getOption: f,
      set: (k, C) => {
        if (!r(k))
          throw new Error("Can only set raw " + c + " value of a " + c + " node");
        k.dom.nodeValue = C;
      }
    };
  })(Ao, "text"), vn = (r) => xt.get(r), Ln = (r) => xt.getOption(r), ss = (r, c) => xt.set(r, c), uo = (r) => ue(r) === "img" ? 1 : Ln(r).fold(() => wt(r).length, (c) => c.length), Go = (r) => Ln(r).filter((c) => c.trim().length !== 0 || c.indexOf(Me) > -1).isSome(), tr = [
    "img",
    "br"
  ], Nr = (r) => Go(r) || Ze(tr, ue(r)), Qa = (r) => K(r, Nr), ja = (r) => ru(r, Nr), ru = (r, c) => {
    const l = (f) => {
      const p = wt(f);
      for (let k = p.length - 1; k >= 0; k--) {
        const C = p[k];
        if (c(C))
          return L.some(C);
        const z = l(C);
        if (z.isSome())
          return z;
      }
      return L.none();
    };
    return l(r);
  }, pl = {
    scope: [
      "row",
      "col"
    ]
  }, Fc = (r) => () => {
    const c = O.fromTag("td", r.dom);
    return Dn(c, O.fromTag("br", r.dom)), c;
  }, Ic = (r) => () => O.fromTag("col", r.dom), au = (r) => () => O.fromTag("colgroup", r.dom), gl = (r) => () => O.fromTag("tr", r.dom), hl = (r, c, l) => {
    const f = rr(r, c);
    return pn(l, (p, k) => {
      p === null ? lo(f, k) : wo(f, k, p);
    }), f;
  }, Np = (r) => r, Rp = (r, c, l) => Qa(r).map((p) => {
    const k = l.join(","), C = Er(p, k, (z) => Et(z, r));
    return an(C, (z, I) => {
      const Y = Yr(I);
      return lo(Y, "contenteditable"), Dn(z, Y), Y;
    }, c);
  }).getOr(c), $n = (r, c) => {
    pn(pl, (l, f) => qo(r, f).filter((p) => Ze(l, p)).each((p) => wo(c, f, p)));
  }, Ko = (r, c, l) => {
    const f = (C, z) => {
      ao(C.element, z), ir(z, "height"), C.colspan !== 1 && ir(z, "width");
    }, p = (C) => {
      const z = O.fromTag(ue(C.element), c.dom), I = l.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]), Y = I.length > 0 ? Rp(C.element, z, I) : z;
      return Dn(Y, O.fromTag("br")), f(C, z), $n(C.element, z), r(C.element, z), z;
    };
    return {
      col: (C) => {
        const z = O.fromTag(ue(C.element), c.dom);
        return f(C, z), r(C.element, z), z;
      },
      colgroup: au(c),
      row: gl(c),
      cell: p,
      replace: hl,
      colGap: Ic(c),
      gap: Fc(c)
    };
  }, Ps = (r) => ({
    col: Ic(r),
    colgroup: au(r),
    row: gl(r),
    cell: Fc(r),
    replace: Np,
    colGap: Ic(r),
    gap: Fc(r)
  }), Lr = (r, c) => {
    const f = (c || document).createElement("div");
    return f.innerHTML = r, wt(O.fromDom(f));
  }, Dp = (r) => Pe(r, O.fromDom), cu = (r) => O.fromDom(r.getBody()), Ua = (r) => (c) => Et(c, cu(r)), Ha = (r) => {
    lo(r, "data-mce-style");
    const c = (l) => lo(l, "data-mce-style");
    yt(Xa(r), c), yt(ac(r), c), yt(Yi(r), c);
  }, gc = (r) => O.fromDom(r.selection.getStart()), Oh = (r) => r.getBoundingClientRect().width, Op = (r) => r.getBoundingClientRect().height, Wk = (r, c) => {
    const l = r.dom.getStyle(c, "width") || r.dom.getAttrib(c, "width");
    return L.from(l).filter(Zt);
  }, Ph = (r) => /^(\d+(\.\d+)?)%$/.test(r), qk = (r) => /^(\d+(\.\d+)?)px$/.test(r), Vk = (r, c) => {
    const l = c.column, f = c.column + c.colspan - 1, p = c.row, k = c.row + c.rowspan - 1;
    return l <= r.finishCol && f >= r.startCol && p <= r.finishRow && k >= r.startRow;
  }, Gk = (r, c) => c.column >= r.startCol && c.column + c.colspan - 1 <= r.finishCol && c.row >= r.startRow && c.row + c.rowspan - 1 <= r.finishRow, Od = (r, c) => {
    let l = !0;
    const f = ot(Gk, c);
    for (let p = c.startRow; p <= c.finishRow; p++)
      for (let k = c.startCol; k <= c.finishCol; k++)
        l = l && In.getAt(r, p, k).exists(f);
    return l ? L.some(c) : L.none();
  }, Kk = (r, c) => Q(Math.min(r.row, c.row), Math.min(r.column, c.column), Math.max(r.row + r.rowspan - 1, c.row + c.rowspan - 1), Math.max(r.column + r.colspan - 1, c.column + c.colspan - 1)), Bh = (r, c, l) => {
    const f = In.findItem(r, c, Et), p = In.findItem(r, l, Et);
    return f.bind((k) => p.map((C) => Kk(k, C)));
  }, Yk = (r, c, l) => Bh(r, c, l).bind((f) => Od(r, f)), Xk = (r, c, l, f) => In.findItem(r, c, Et).bind((p) => {
    const k = l > 0 ? p.row + p.rowspan - 1 : p.row, C = f > 0 ? p.column + p.colspan - 1 : p.column;
    return In.getAt(r, k + l, C + f).map((I) => I.element);
  }), Bs = (r, c, l) => Bh(r, c, l).map((f) => {
    const p = In.filterItems(r, ot(Vk, f));
    return Pe(p, (k) => k.element);
  }), $h = (r, c) => {
    const l = (f, p) => An(p, f);
    return In.findItem(r, c, l).map((f) => f.element);
  }, Fh = (r, c, l) => Us(r).bind((f) => {
    const p = Bd(f);
    return Xk(p, r, c, l);
  }), Zk = (r, c, l) => {
    const f = Bd(r);
    return Bs(f, c, l);
  }, Pd = (r, c, l, f, p) => {
    const k = Bd(r), C = Et(r, l) ? L.some(c) : $h(k, c), z = Et(r, p) ? L.some(f) : $h(k, f);
    return C.bind((I) => z.bind((Y) => Bs(k, I, Y)));
  }, Qk = (r, c, l) => {
    const f = Bd(r);
    return Yk(f, c, l);
  }, Bd = In.fromTable;
  var Jk = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], iu = () => {
    const r = (Y) => O.fromDom(Y.dom.cloneNode(!1)), c = (Y) => jn(Y).dom, l = (Y) => hn(Y) ? ue(Y) === "body" ? !0 : Ze(Jk, ue(Y)) : !1, f = (Y) => hn(Y) ? Ze([
      "br",
      "img",
      "hr",
      "input"
    ], ue(Y)) : !1, p = (Y) => hn(Y) && gn(Y, "contenteditable") === "false", k = (Y, he) => Y.dom.compareDocumentPosition(he.dom), C = (Y, he) => {
      const ct = Io(Y);
      os(he, ct);
    }, z = (Y) => {
      const he = ue(Y);
      return Ze([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], he);
    }, I = (Y) => hn(Y) ? qo(Y, "lang") : L.none();
    return {
      up: ke({
        selector: Re,
        closest: Zn,
        predicate: Qr,
        all: Ge
      }),
      down: ke({
        selector: Ds,
        predicate: hr
      }),
      styles: ke({
        get: Qs,
        getRaw: Ya,
        set: qn,
        remove: ir
      }),
      attrs: ke({
        get: gn,
        set: wo,
        remove: lo,
        copyTo: C
      }),
      insert: ke({
        before: un,
        after: Xn,
        afterAll: Bn,
        append: Dn,
        appendAll: to,
        prepend: yo,
        wrap: bs
      }),
      remove: ke({
        unwrap: Ns,
        remove: Jo
      }),
      create: ke({
        nu: O.fromTag,
        clone: r,
        text: O.fromText
      }),
      query: ke({
        comparePosition: k,
        prevSibling: St,
        nextSibling: vt
      }),
      property: ke({
        children: wt,
        name: ue,
        parent: q,
        document: c,
        isText: Ao,
        isComment: Ot,
        isElement: hn,
        isSpecial: z,
        getLanguage: I,
        getText: vn,
        setText: ss,
        isBoundary: l,
        isEmptyTag: f,
        isNonEditable: p
      }),
      eq: Et,
      is: Po
    };
  };
  const ew = (r, c, l, f) => {
    const p = l[0], k = l.slice(1);
    return f(r, c, p, k);
  }, $d = (r, c, l) => l.length > 0 ? ew(r, c, l, Fd) : L.none(), Fd = (r, c, l, f) => {
    const p = c(r, l);
    return an(f, (k, C) => {
      const z = c(r, C);
      return tw(r, k, z);
    }, p);
  }, tw = (r, c, l) => c.bind((f) => l.filter(ot(r.eq, f))), nw = (r, c) => ot(r.eq, c), ow = (r, c, l, f = Le) => {
    const p = [c].concat(r.up().all(c)), k = [l].concat(r.up().all(l)), C = (he) => w(he, f).fold(() => he, (Tt) => he.slice(0, Tt + 1)), z = C(p), I = C(k), Y = wn(z, (he) => qt(I, nw(r, he)));
    return {
      firstpath: z,
      secondpath: I,
      shared: Y
    };
  }, yl = $d, sw = ow, Ih = iu(), Id = (r, c) => yl(Ih, (l, f) => r(f), c), Pp = (r, c, l) => sw(Ih, r, c, l), Ld = (r) => Re(r, "table"), Md = (r, c, l) => {
    const f = (p) => (k) => l !== void 0 && l(k) || Et(k, p);
    return Et(r, c) ? L.some({
      boxes: L.some([r]),
      start: r,
      finish: c
    }) : Ld(r).bind((p) => Ld(c).bind((k) => {
      if (Et(p, k))
        return L.some({
          boxes: Zk(p, r, c),
          start: r,
          finish: c
        });
      if (An(p, k)) {
        const C = Er(c, "td,th", f(p)), z = C.length > 0 ? C[C.length - 1] : c;
        return L.some({
          boxes: Pd(p, r, p, c, k),
          start: r,
          finish: z
        });
      } else if (An(k, p)) {
        const C = Er(r, "td,th", f(k)), z = C.length > 0 ? C[C.length - 1] : r;
        return L.some({
          boxes: Pd(k, r, p, c, k),
          start: r,
          finish: z
        });
      } else
        return Pp(r, c).shared.bind((C) => Zn(C, "table", l).bind((z) => {
          const I = Er(c, "td,th", f(z)), Y = I.length > 0 ? I[I.length - 1] : c, he = Er(r, "td,th", f(z)), ct = he.length > 0 ? he[he.length - 1] : r;
          return L.some({
            boxes: Pd(z, r, p, c, k),
            start: ct,
            finish: Y
          });
        }));
    }));
  }, jd = (r, c) => {
    const l = Ds(r, c);
    return l.length > 0 ? L.some(l) : L.none();
  }, Bp = (r, c) => wn(r, (l) => G(l, c)), rw = (r, c, l) => Un(r, c).bind((f) => Un(r, l).bind((p) => Id(Ld, [
    f,
    p
  ]).map((k) => ({
    first: f,
    last: p,
    table: k
  })))), kx = (r, c) => Re(r, "table").bind((l) => Un(l, c).bind((f) => Md(f, r).bind((p) => p.boxes.map((k) => ({
    boxes: k,
    start: p.start,
    finish: p.finish
  }))))), zi = (r, c, l, f, p) => Bp(r, p).bind((k) => Fh(k, c, l).bind((C) => kx(C, f))), Lc = (r, c) => jd(r, c), aw = (r, c, l) => rw(r, c, l).bind((f) => {
    const p = (I) => Et(r, I), k = "thead,tfoot,tbody,table", C = Re(f.first, k, p), z = Re(f.last, k, p);
    return C.bind((I) => z.bind((Y) => Et(I, Y) ? Qk(f.table, f.first, f.last) : L.none()));
  }), bl = ge, ur = (r) => {
    const c = (f, p) => qo(f, p).exists((k) => parseInt(k, 10) > 1), l = (f) => c(f, "rowspan") || c(f, "colspan");
    return r.length > 0 && we(r, l) ? L.some(r) : L.none();
  }, $p = (r, c, l) => c.length <= 1 ? L.none() : aw(r, l.firstSelectedSelector, l.lastSelectedSelector).map((f) => ({
    bounds: f,
    cells: c
  })), _f = "data-mce-selected", cw = "td[" + _f + "],th[" + _f + "]", nr = "[" + _f + "]", Ud = "data-mce-first-selected", Lh = "td[" + Ud + "],th[" + Ud + "]", Fp = "data-mce-last-selected", Ip = "td[" + Fp + "],th[" + Fp + "]", Ai = nr, Mc = {
    selected: _f,
    selectedSelector: cw,
    firstSelected: Ud,
    firstSelectedSelector: Lh,
    lastSelected: Fp,
    lastSelectedSelector: Ip
  }, Hd = (r, c, l) => ({
    element: l,
    mergable: $p(c, r, Mc),
    unmergable: ur(r),
    selection: bl(r)
  }), iw = (r, c, l) => ({
    element: r,
    clipboard: c,
    generators: l
  }), lw = (r, c, l, f) => ({
    selection: bl(r),
    clipboard: l,
    generators: f
  }), uw = (r) => Us(r).bind((c) => Lc(c, Mc.firstSelectedSelector)).fold(ke(r), (c) => c[0]), Lp = (r) => (c, l) => {
    const f = ue(c), p = f === "col" || f === "colgroup" ? uw(c) : c;
    return Zn(p, r, l);
  }, Mp = Lp("th,td,caption"), jp = Lp("th,td"), hc = (r) => Dp(r.model.table.getSelectedCells()), Up = (r) => Rn(hc(r), (c) => G(c, Mc.selectedSelector)), Wd = (r) => Us(r[0]).map((c) => {
    const l = oe(c, Ai);
    return Ha(l), [l];
  }), fw = (r, c) => Pe(c, (l) => r.selection.serializer.serialize(l.dom, {})).join(""), lu = (r) => Pe(r, (c) => c.dom.innerText).join(""), dw = (r, c) => {
    r.on("BeforeGetContent", (l) => {
      const f = (p) => {
        l.preventDefault(), Wd(p).each((k) => {
          l.content = l.format === "text" ? lu(k) : fw(r, k);
        });
      };
      if (l.selection === !0) {
        const p = Up(r);
        p.length >= 1 && f(p);
      }
    }), r.on("BeforeSetContent", (l) => {
      if (l.selection === !0 && l.paste === !0) {
        const f = hc(r);
        W(f).each((p) => {
          Us(p).each((k) => {
            const C = Rn(Lr(l.content), (I) => ue(I) !== "meta"), z = To("table");
            if (C.length === 1 && z(C[0])) {
              l.preventDefault();
              const I = O.fromDom(r.getDoc()), Y = Ps(I), he = iw(p, C[0], Y);
              c.pasteCells(k, he).each(() => {
                r.focus();
              });
            }
          });
        });
      }
    });
  }, Ja = (r, c) => ({
    element: r,
    offset: c
  }), qd = (r, c, l) => r.property().isText(c) && r.property().getText(c).trim().length === 0 || r.property().isComment(c) ? l(c).bind((f) => qd(r, f, l).orThunk(() => L.some(f))) : L.none(), Mh = (r, c) => r.property().isText(c) ? r.property().getText(c).length : r.property().children(c).length, Vd = (r, c) => {
    const l = qd(r, c, r.query().prevSibling).getOr(c);
    if (r.property().isText(l))
      return Ja(l, Mh(r, l));
    const f = r.property().children(l);
    return f.length > 0 ? Vd(r, f[f.length - 1]) : Ja(l, Mh(r, l));
  }, vf = Vd, mw = iu(), pw = (r) => vf(mw, r), uu = (r, c) => {
    Jr(r) || Ep(r).each((f) => {
      const p = f.value / 2;
      Nd(r, p, f.unit), Nd(c, p, f.unit);
    });
  }, Gd = (r) => Pe(r, ke(0)), Hp = (r, c, l, f, p) => p(r.slice(0, c)).concat(f).concat(p(r.slice(l))), Uo = (r) => (c, l, f, p) => {
    if (r(f)) {
      const k = Math.max(p, c[l] - Math.abs(f)), C = Math.abs(k - c[l]);
      return f >= 0 ? C : -C;
    } else
      return f;
  }, Kd = Uo((r) => r < 0), gw = Uo(Ve), jh = () => {
    const r = (z, I, Y, he, ct) => {
      const Tt = Kd(z, I, he, ct);
      return Hp(z, I, Y + 1, [
        Tt,
        0
      ], Gd);
    }, c = (z, I, Y, he) => {
      const ct = (100 + Y) / 100, Tt = Math.max(he, (z[I] + Y) / ct);
      return Pe(z, (Ct, Ye) => (Ye === I ? Tt : Ct / ct) - Ct);
    }, l = (z, I, Y, he, ct, Tt) => Tt ? c(z, I, he, ct) : r(z, I, Y, he, ct);
    return {
      resizeTable: (z, I) => z(I),
      clampTableDelta: Kd,
      calcLeftEdgeDeltas: l,
      calcMiddleDeltas: (z, I, Y, he, ct, Tt, Ct) => l(z, Y, he, ct, Tt, Ct),
      calcRightEdgeDeltas: (z, I, Y, he, ct, Tt) => {
        if (Tt)
          return c(z, Y, he, ct);
        {
          const Ct = Kd(z, Y, he, ct);
          return Gd(z.slice(0, Y)).concat([Ct]);
        }
      },
      calcRedestributedWidths: (z, I, Y, he) => {
        if (he) {
          const Tt = (I + Y) / I, Ct = Pe(z, (Ye) => Ye / Tt);
          return {
            delta: Tt * 100 - 100,
            newSizes: Ct
          };
        } else
          return {
            delta: Y,
            newSizes: z
          };
      }
    };
  }, fu = () => {
    const r = (C, z, I, Y, he) => {
      const ct = Y >= 0 ? I : z, Tt = gw(C, ct, Y, he);
      return Hp(C, z, I + 1, [
        Tt,
        -Tt
      ], Gd);
    };
    return {
      resizeTable: (C, z, I) => {
        I && C(z);
      },
      clampTableDelta: (C, z, I, Y, he) => {
        if (he) {
          if (I >= 0)
            return I;
          {
            const ct = en(C, (Tt, Ct) => Tt + Ct - Y, 0);
            return Math.max(-ct, I);
          }
        } else
          return Kd(C, z, I, Y);
      },
      calcLeftEdgeDeltas: r,
      calcMiddleDeltas: (C, z, I, Y, he, ct) => r(C, I, Y, he, ct),
      calcRightEdgeDeltas: (C, z, I, Y, he, ct) => {
        if (ct)
          return Gd(C);
        {
          const Tt = Y / C.length;
          return Pe(C, ke(Tt));
        }
      },
      calcRedestributedWidths: (C, z, I, Y) => ({
        delta: 0,
        newSizes: C
      })
    };
  }, Yd = (r) => In.fromTable(r).grid, Wa = To("th"), vs = (r) => we(r, (c) => Wa(c.element)), hw = (r, c) => r && c ? "sectionCells" : r ? "section" : "cells", Uh = (r) => {
    const c = r.section === "thead", l = nt(kl(r.cells), "th");
    return r.section === "tfoot" ? { type: "footer" } : c || l ? {
      type: "header",
      subType: hw(c, l)
    } : { type: "body" };
  }, kl = (r) => {
    const c = Rn(r, (l) => Wa(l.element));
    return c.length === 0 ? L.some("td") : c.length === r.length ? L.some("th") : L.none();
  }, Wp = (r) => {
    const c = Pe(r, (p) => Uh(p).type), l = Ze(c, "header"), f = Ze(c, "footer");
    if (!l && !f)
      return L.some("body");
    {
      const p = Ze(c, "body");
      return l && !p && !f ? L.some("header") : !l && !p && f ? L.some("footer") : L.none();
    }
  }, Hh = (r) => Ue(r.all, (c) => {
    const l = Uh(c);
    return l.type === "header" ? L.from(l.subType) : L.none();
  }), Wh = (r, c, l) => is(l(r.element, c), !0, r.isLocked), qh = (r, c) => r.section !== c ? R(r.element, r.cells, c, r.isNew) : r, yw = () => ({
    transformRow: qh,
    transformCell: (r, c, l) => {
      const f = l(r.element, c), p = ue(f) !== "td" ? Ra(f, "td") : f;
      return is(p, r.isNew, r.isLocked);
    }
  }), bw = () => ({
    transformRow: qh,
    transformCell: Wh
  }), kw = () => ({
    transformRow: (r, c) => qh(r, c === "thead" ? "tbody" : c),
    transformCell: Wh
  }), Mr = {
    getTableSectionType: (r, c) => {
      const l = In.fromTable(r);
      switch (Hh(l).getOr(c)) {
        case "section":
          return yw();
        case "sectionCells":
          return bw();
        case "cells":
          return kw();
      }
    },
    section: yw,
    sectionCells: bw,
    cells: kw,
    fallback: () => ({
      transformRow: ge,
      transformCell: Wh
    })
  }, fr = (r) => Zn(r, "[contenteditable]"), Vh = (r, c = !1) => Ro(r) ? r.dom.isContentEditable : fr(r).fold(ke(c), (l) => jc(l) === "true"), jc = (r) => r.dom.contentEditable, Ni = (r, c, l, f) => {
    l === f ? lo(r, c) : wo(r, c, l);
  }, Xd = (r, c, l) => {
    M(Gn(r, c)).fold(() => yo(r, l), (f) => Xn(f, l));
  }, Cf = (r, c) => {
    const l = Gt(r, c).getOrThunk(() => {
      const f = O.fromTag(c, ln(r).dom);
      return c === "thead" ? Xd(r, "caption,colgroup", f) : c === "colgroup" ? Xd(r, "caption", f) : Dn(r, f), f;
    });
    return Qo(l), l;
  }, wl = (r, c) => {
    const l = [], f = [], p = (Ct) => Pe(Ct, (Ye) => {
      Ye.isNew && l.push(Ye.element);
      const Rt = Ye.element;
      return Qo(Rt), yt(Ye.cells, (Xe) => {
        Xe.isNew && f.push(Xe.element), Ni(Xe.element, "colspan", Xe.colspan, 1), Ni(Xe.element, "rowspan", Xe.rowspan, 1), Dn(Rt, Xe.element);
      }), Rt;
    }), k = (Ct) => re(Ct, (Ye) => Pe(Ye.cells, (Rt) => (Ni(Rt.element, "span", Rt.colspan, 1), Rt.element))), C = (Ct, Ye) => {
      const Rt = Cf(r, Ye), Kt = (Ye === "colgroup" ? k : p)(Ct);
      to(Rt, Kt);
    }, z = (Ct) => {
      Gt(r, Ct).each(Jo);
    }, I = (Ct, Ye) => {
      Ct.length > 0 ? C(Ct, Ye) : z(Ye);
    }, Y = [], he = [], ct = [], Tt = [];
    return yt(c, (Ct) => {
      switch (Ct.section) {
        case "thead":
          Y.push(Ct);
          break;
        case "tbody":
          he.push(Ct);
          break;
        case "tfoot":
          ct.push(Ct);
          break;
        case "colgroup":
          Tt.push(Ct);
          break;
      }
    }), I(Tt, "colgroup"), I(Y, "thead"), I(he, "tbody"), I(ct, "tfoot"), {
      newRows: l,
      newCells: f
    };
  }, du = (r) => Pe(r, (c) => {
    const l = Yr(c.element);
    return yt(c.cells, (f) => {
      const p = js(f.element);
      Ni(p, "colspan", f.colspan, 1), Ni(p, "rowspan", f.rowspan, 1), Dn(l, p);
    }), l;
  }), Sf = (r, c) => Pe(r, (l) => Do(l, c)), xf = (r, c) => r[c], mu = (r, c) => {
    if (r.length === 0)
      return 0;
    const l = r[0];
    return w(r, (p) => !c(l.element, p.element)).getOr(r.length);
  }, Gh = (r, c, l, f) => {
    const p = xf(r, c), k = p.section === "colgroup", C = mu(p.cells.slice(l), f), z = k ? 1 : mu(Sf(r.slice(c), l), f);
    return {
      colspan: C,
      rowspan: z
    };
  }, Kh = (r, c) => {
    const l = Pe(r, (p) => Pe(p.cells, Le)), f = (p, k, C, z) => {
      for (let I = p; I < p + C; I++)
        for (let Y = k; Y < k + z; Y++)
          l[I][Y] = !0;
    };
    return Pe(r, (p, k) => {
      const C = re(p.cells, (z, I) => {
        if (l[k][I] === !1) {
          const Y = Gh(r, k, I, c);
          return f(k, I, Y.rowspan, Y.colspan), [Da(z.element, Y.rowspan, Y.colspan, z.isNew)];
        } else
          return [];
      });
      return Zr(p.element, C, p.section, p.isNew);
    });
  }, Ef = (r, c, l) => {
    const f = [];
    yt(r.colgroups, (p) => {
      const k = [];
      for (let C = 0; C < r.grid.columns; C++) {
        const z = In.getColumnAt(r, C).map((I) => is(I.element, l, !1)).getOrThunk(() => is(c.colGap(), !0, !1));
        k.push(z);
      }
      f.push(R(p.element, k, "colgroup", l));
    });
    for (let p = 0; p < r.grid.rows; p++) {
      const k = [];
      for (let I = 0; I < r.grid.columns; I++) {
        const Y = In.getAt(r, p, I).map((he) => is(he.element, l, he.isLocked)).getOrThunk(() => is(c.gap(), !0, !1));
        k.push(Y);
      }
      const C = r.all[p], z = R(C.element, k, C.section, l);
      f.push(z);
    }
    return f;
  }, Yh = (r, c) => Ef(r, c, !1), Tf = (r) => Kh(r, Et), Zd = (r, c) => Ue(r.all, (l) => wn(l.cells, (f) => Et(c, f.element))), qp = (r, c, l) => {
    const f = Pe(c.selection, (k) => na(k).bind((C) => Zd(r, C)).filter(l)), p = Xo(f);
    return zo(p.length > 0, p);
  }, qs = (r, c, l, f, p) => (k, C, z, I) => {
    const Y = In.fromTable(k), he = L.from(I == null ? void 0 : I.section).getOrThunk(Mr.fallback);
    return c(Y, C).map((Tt) => {
      const Ct = Yh(Y, z), Ye = r(Ct, Tt, Et, p(z), he), Rt = uc(Ye.grid), Xe = Tf(Ye.grid);
      return {
        info: Tt,
        grid: Xe,
        cursor: Ye.cursor,
        lockedColumns: Rt
      };
    }).bind((Tt) => {
      const Ct = wl(k, Tt.grid), Ye = L.from(I == null ? void 0 : I.sizing).getOrThunk(() => pc.getTableSize(k)), Rt = L.from(I == null ? void 0 : I.resize).getOrThunk(fu);
      return l(k, Tt.grid, Tt.info, {
        sizing: Ye,
        resize: Rt,
        section: he
      }), f(k), lo(k, hi), Tt.lockedColumns.length > 0 && wo(k, hi, Tt.lockedColumns.join(",")), L.some({
        cursor: Tt.cursor,
        newRows: Ct.newRows,
        newCells: Ct.newCells
      });
    });
  }, ww = (r, c) => na(c.element).bind((l) => Zd(r, l).map((f) => ({
    ...f,
    generators: c.generators,
    clipboard: c.clipboard
  }))), Qd = (r, c) => qp(r, c, Ve).map((l) => ({
    cells: l,
    generators: c.generators,
    clipboard: c.clipboard
  })), Xh = (r, c) => c.mergable, _w = (r, c) => c.unmergable, Uc = (r, c) => qp(r, c, Ve), yc = (r, c) => qp(r, c, (l) => !l.isLocked), pu = (r, c) => Zd(r, c).exists((l) => !l.isLocked), Vp = (r, c) => we(c, (l) => pu(r, l)), vw = (r, c) => Xh(r, c).filter((l) => Vp(r, l.cells)), Cw = (r, c) => _w(r, c).filter((l) => Vp(r, l)), Zh = (r, c, l, f) => {
    const p = _s(r).rows;
    if (p.length === 0)
      return r;
    for (let k = c.startRow; k <= c.finishRow; k++)
      for (let C = c.startCol; C <= c.finishCol; C++) {
        const z = p[k], I = Do(z, C).isLocked;
        al(z, C, is(f(), !1, I));
      }
    return r;
  }, Ri = (r, c, l, f) => {
    const p = _s(r).rows;
    let k = !0;
    for (let C = 0; C < p.length; C++)
      for (let z = 0; z < Ar(p[0]); z++) {
        const I = p[C], Y = Do(I, z), he = Y.element, ct = l(he, c);
        ct && !k ? al(I, z, is(f(), !0, Y.isLocked)) : ct && (k = !1);
      }
    return r;
  }, gu = (r, c) => en(r, (l, f) => qt(l, (p) => c(p.element, f.element)) ? l : l.concat([f]), []), _l = (r, c, l, f) => (c > 0 && c < r[0].cells.length && yt(r, (p) => {
    const k = p.cells[c - 1];
    let C = 0;
    const z = f();
    for (; p.cells.length > c + C && l(k.element, p.cells[c + C].element); )
      al(p, c + C, is(z, !0, p.cells[c + C].isLocked)), C++;
  }), r), Qh = (r, c, l, f) => {
    const p = _s(r).rows;
    if (c > 0 && c < p.length) {
      const k = p[c - 1].cells, C = gu(k, l);
      yt(C, (z) => {
        let I = L.none();
        for (let Y = c; Y < p.length; Y++)
          for (let he = 0; he < Ar(p[0]); he++) {
            const ct = p[Y], Tt = Do(ct, he);
            l(Tt.element, z.element) && (I.isNone() && (I = L.some(f())), I.each((Ye) => {
              al(ct, he, is(Ye, !0, Tt.isLocked));
            }));
          }
      });
    }
    return r;
  }, Jh = (r) => {
    const c = (k) => k(r), l = ke(r), f = () => p, p = {
      tag: !0,
      inner: r,
      fold: (k, C) => C(r),
      isValue: Ve,
      isError: Le,
      map: (k) => Di.value(k(r)),
      mapError: f,
      bind: c,
      exists: c,
      forall: c,
      getOr: l,
      or: f,
      getOrThunk: l,
      orThunk: f,
      getOrDie: l,
      each: (k) => {
        k(r);
      },
      toOptional: () => L.some(r)
    };
    return p;
  }, Gp = (r) => {
    const c = () => l, l = {
      tag: !1,
      inner: r,
      fold: (f, p) => f(r),
      isValue: Le,
      isError: Ve,
      map: c,
      mapError: (f) => Di.error(f(r)),
      bind: c,
      exists: Le,
      forall: Ve,
      getOr: ge,
      or: ge,
      getOrThunk: ft,
      orThunk: ft,
      getOrDie: it(String(r)),
      each: xe,
      toOptional: L.none
    };
    return l;
  }, Di = {
    value: Jh,
    error: Gp,
    fromOption: (r, c) => r.fold(() => Gp(c), Jh)
  }, Sw = (r, c, l) => {
    if (r.row >= c.length || r.column > Ar(c[0]))
      return Di.error("invalid start address out of table bounds, row: " + r.row + ", column: " + r.column);
    const f = c.slice(r.row), p = f[0].cells.slice(r.column), k = Ar(l[0]), C = l.length;
    return Di.value({
      rowDelta: f.length - C,
      colDelta: p.length - k
    });
  }, ey = (r, c) => {
    const l = Ar(r[0]), f = Ar(c[0]);
    return {
      rowDelta: 0,
      colDelta: l - f
    };
  }, Kp = (r, c) => {
    const l = r.length, f = c.length;
    return {
      rowDelta: l - f,
      colDelta: 0
    };
  }, Yp = (r, c, l, f) => {
    const p = c.section === "colgroup" ? l.col : l.cell;
    return Z(r, (k) => is(p(), !0, f(k)));
  }, xw = (r, c, l, f) => {
    const p = r[r.length - 1];
    return r.concat(Z(c, () => {
      const k = p.section === "colgroup" ? l.colgroup : l.row, C = of(p, k, ge), z = Yp(C.cells.length, C, l, (I) => Fe(f, I.toString()));
      return lc(C, z);
    }));
  }, em = (r, c, l, f) => Pe(r, (p) => {
    const k = Yp(c, p, l, Le);
    return ls(p, f, k);
  }), Oi = (r, c, l) => Pe(r, (f) => en(l, (p, k) => {
    const C = Yp(1, f, c, Ve)[0];
    return bd(p, k, C);
  }, f)), zf = (r, c, l) => {
    const f = c.colDelta < 0 ? em : ge, p = c.rowDelta < 0 ? xw : ge, k = uc(r), C = Ar(r[0]), z = qt(k, (he) => he === C - 1), I = f(r, Math.abs(c.colDelta), l, z ? C - 1 : C), Y = uc(I);
    return p(I, Math.abs(c.rowDelta), l, me(Y, Ve));
  }, Ew = (r, c, l, f) => {
    const p = Do(r[c], l), k = ot(f, p.element), C = r[c];
    return r.length > 1 && Ar(C) > 1 && (l > 0 && k(Es(C, l - 1)) || l < C.cells.length - 1 && k(Es(C, l + 1)) || c > 0 && k(Es(r[c - 1], l)) || c < r.length - 1 && k(Es(r[c + 1], l)));
  }, ty = (r, c, l, f, p, k) => {
    const C = r.row, z = r.column, I = l.length, Y = Ar(l[0]), he = C + I, ct = z + Y + k.length, Tt = me(k, Ve);
    for (let Ct = C; Ct < he; Ct++) {
      let Ye = 0;
      for (let Rt = z; Rt < ct; Rt++) {
        if (Tt[Rt]) {
          Ye++;
          continue;
        }
        Ew(c, Ct, Rt, p) && Ri(c, Es(c[Ct], Rt), p, f.cell);
        const Xe = Rt - z - Ye, Kt = Do(l[Ct - C], Xe), Cn = Kt.element, Fn = f.replace(Cn);
        al(c[Ct], Rt, is(Fn, !0, Kt.isLocked));
      }
    }
    return c;
  }, Tw = (r, c, l) => {
    const f = Ar(c[0]), p = _s(c).cols.length + r.row, k = Z(f - r.column, (z) => z + r.column), C = wn(k, (z) => we(l, (I) => I !== z)).getOr(f - 1);
    return {
      row: p,
      column: C
    };
  }, ny = (r, c, l) => Rn(l, (f) => f >= r.column && f <= Ar(c[0]) + r.column), oy = (r, c, l, f, p) => {
    const k = uc(c), C = Tw(r, c, k), z = _s(l).rows, I = ny(C, z, k);
    return Sw(C, c, z).map((he) => {
      const ct = {
        ...he,
        colDelta: he.colDelta - I.length
      }, Tt = zf(c, ct, f), Ct = uc(Tt), Ye = ny(C, z, Ct);
      return ty(C, Tt, z, f, p, Ye);
    });
  }, sy = (r, c, l, f, p) => {
    _l(c, r, p, f.cell);
    const k = Kp(l, c), C = zf(l, k, f), z = Kp(c, C), I = zf(c, z, f);
    return Pe(I, (Y, he) => ls(Y, r, C[he].cells));
  }, Xp = (r, c, l, f, p) => {
    Qh(c, r, p, f.cell);
    const k = uc(c), C = ey(c, l), z = {
      ...C,
      colDelta: C.colDelta - k.length
    }, I = zf(c, z, f), {
      cols: Y,
      rows: he
    } = _s(I), ct = uc(I), Tt = ey(l, c), Ct = {
      ...Tt,
      colDelta: Tt.colDelta + ct.length
    }, Ye = Oi(l, f, ct), Rt = zf(Ye, Ct, f);
    return [
      ...Y,
      ...he.slice(0, r),
      ...Rt,
      ...he.slice(r, he.length)
    ];
  }, zw = (r, c, l, f) => of(r, (p) => f(p, l), c), hu = (r, c, l, f, p) => {
    const { rows: k, cols: C } = _s(r), z = k.slice(0, c), I = k.slice(c), Y = zw(k[l], (he, ct) => c > 0 && c < k.length && f(Es(k[c - 1], ct), Es(k[c], ct)) ? Do(k[c], ct) : is(p(he.element, f), !0, he.isLocked), f, p);
    return [
      ...C,
      ...z,
      Y,
      ...I
    ];
  }, Aw = (r, c, l, f, p, k, C) => {
    if (l === "colgroup" || !f) {
      const z = Do(r, p);
      return is(C(z.element, k), !0, !1);
    } else
      return Do(r, c);
  }, yu = (r, c, l, f, p) => Pe(r, (k) => {
    const C = c > 0 && c < Ar(k) && f(Es(k, c - 1), Es(k, c)), z = Aw(k, c, k.section, C, l, f, p);
    return bd(k, c, z);
  }), Zp = (r, c) => re(r, (l) => {
    const f = l.cells, p = an(c, (k, C) => C >= 0 && C < k.length ? k.slice(0, C).concat(k.slice(C + 1)) : k, f);
    return p.length > 0 ? [R(l.element, p, l.section, l.isNew)] : [];
  }), ry = (r, c, l) => {
    const { rows: f, cols: p } = _s(r);
    return [
      ...p,
      ...f.slice(0, c),
      ...f.slice(l + 1)
    ];
  }, tm = (r, c, l, f) => Es(r[c], l) !== void 0 && c > 0 && f(Es(r[c - 1], l), Es(r[c], l)), Qp = (r, c, l) => c > 0 && l(Es(r, c - 1), Es(r, c)), nm = (r, c, l, f) => tm(r, c, l, f) || Qp(r[c], l, f), ay = (r, c) => we(c, ge) && vs(r.cells) ? Ve : (f, p, k) => !(ue(f.element) === "th" && c[k]), Jp = (r, c) => we(c, ge) && vs(r) ? Ve : (f, p, k) => !(ue(f.element) === "th" && c[p]), cy = (r, c, l, f) => {
    const p = (C) => C === "row" ? Ba(c) : Jr(c), k = (C) => p(C) ? `${C}group` : C;
    return r ? Wa(c) ? k(l) : null : f && Wa(c) ? k(l === "row" ? "col" : "row") : null;
  }, Nw = (r, c) => (l, f, p) => L.some(cy(r, l.element, "col", c[p])), iy = (r, c) => (l, f) => L.some(cy(r, l.element, "row", c[f])), Hc = (r, c, l) => is(l(r.element, c), !0, r.isLocked), Wc = (r, c, l, f, p, k, C) => {
    const z = (I) => qt(c, (Y) => l(I.element, Y.element));
    return Pe(r, (I, Y) => cl(I, (he, ct) => {
      if (z(he)) {
        const Tt = C(he, Y, ct) ? p(he, l, f) : he;
        return k(Tt, Y, ct).each((Ct) => {
          Vn(Tt.element, { scope: L.from(Ct) });
        }), Tt;
      } else
        return he;
    }));
  }, ly = (r, c, l) => re(r, (f, p) => nm(r, p, c, l) ? [] : [Do(f, c)]), je = (r, c, l) => {
    const f = r[c];
    return re(f.cells, (p, k) => nm(r, c, k, l) ? [] : [p]);
  }, Af = (r, c, l, f, p) => {
    const k = _s(r).rows, C = re(c, (he) => ly(k, he, f)), z = Pe(k, (he) => vs(he.cells)), I = Jp(C, z), Y = iy(l, z);
    return Wc(r, C, f, p, Hc, Y, I);
  }, Rw = (r, c, l, f, p, k, C) => {
    const { cols: z, rows: I } = _s(r), Y = I[c[0]], he = re(c, (Xe) => je(I, Xe, p)), ct = Pe(Y.cells, (Xe, Kt) => vs(ly(I, Kt, p))), Tt = [...I];
    yt(c, (Xe) => {
      Tt[Xe] = C.transformRow(I[Xe], l);
    });
    const Ct = [
      ...z,
      ...Tt
    ], Ye = ay(Y, ct), Rt = Nw(f, ct);
    return Wc(Ct, he, p, k, C.transformCell, Rt, Ye);
  }, uy = (r, c, l, f) => {
    const p = _s(r).rows, k = Pe(c, (C) => Do(p[C.row], C.column));
    return Wc(r, k, l, f, Hc, L.none, Ve);
  }, kr = { generate: (r) => {
    if (!Ee(r))
      throw new Error("cases must be an array");
    if (r.length === 0)
      throw new Error("there must be at least one case");
    const c = [], l = {};
    return yt(r, (f, p) => {
      const k = kt(f);
      if (k.length !== 1)
        throw new Error("one and only one name per case");
      const C = k[0], z = f[C];
      if (l[C] !== void 0)
        throw new Error("duplicate key detected:" + C);
      if (C === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Ee(z))
        throw new Error("case arguments must be an array");
      c.push(C), l[C] = (...I) => {
        const Y = I.length;
        if (Y !== z.length)
          throw new Error("Wrong number of arguments to case " + C + ". Expected " + z.length + " (" + z + "), got " + Y);
        return {
          fold: (...ct) => {
            if (ct.length !== r.length)
              throw new Error("Wrong number of arguments to fold. Expected " + r.length + ", got " + ct.length);
            return ct[p].apply(null, I);
          },
          match: (ct) => {
            const Tt = kt(ct);
            if (c.length !== Tt.length)
              throw new Error("Wrong number of arguments to match. Expected: " + c.join(",") + `
Actual: ` + Tt.join(","));
            if (!we(c, (Ye) => Ze(Tt, Ye)))
              throw new Error("Not all branches were specified when using match. Specified: " + Tt.join(", ") + `
Required: ` + c.join(", "));
            return ct[C].apply(null, I);
          },
          log: (ct) => {
            console.log(ct, {
              constructors: c,
              constructor: C,
              params: I
            });
          }
        };
      };
    }), l;
  } }, vl = { ...kr.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) }, dy = (r, c) => r.length === 0 ? vl.none() : r.length === 1 ? vl.only(0) : c === 0 ? vl.left(0, 1) : c === r.length - 1 ? vl.right(c - 1, c) : c > 0 && c < r.length - 1 ? vl.middle(c - 1, c, c + 1) : vl.none(), eg = (r, c, l, f, p) => {
    const k = r.slice(0), C = dy(r, c), z = ke(Pe(k, ke(0))), I = (Tt) => f.singleColumnWidth(k[Tt], l), Y = (Tt, Ct) => p.calcLeftEdgeDeltas(k, Tt, Ct, l, f.minCellWidth(), f.isRelative), he = (Tt, Ct, Ye) => p.calcMiddleDeltas(k, Tt, Ct, Ye, l, f.minCellWidth(), f.isRelative), ct = (Tt, Ct) => p.calcRightEdgeDeltas(k, Tt, Ct, l, f.minCellWidth(), f.isRelative);
    return C.fold(z, I, Y, he, ct);
  }, my = (r, c, l) => {
    let f = 0;
    for (let p = r; p < c; p++)
      f += l[p] !== void 0 ? l[p] : 0;
    return f;
  }, py = (r, c) => {
    const l = In.justCells(r);
    return Pe(l, (f) => {
      const p = my(f.column, f.column + f.colspan, c);
      return {
        element: f.element,
        width: p,
        colspan: f.colspan
      };
    });
  }, Ow = (r, c) => {
    const l = In.justColumns(r);
    return Pe(l, (f, p) => ({
      element: f.element,
      width: c[p],
      colspan: f.colspan
    }));
  }, gy = (r, c) => {
    const l = In.justCells(r);
    return Pe(l, (f) => {
      const p = my(f.row, f.row + f.rowspan, c);
      return {
        element: f.element,
        height: p,
        rowspan: f.rowspan
      };
    });
  }, Pw = (r, c) => Pe(r.all, (l, f) => ({
    element: l.element,
    height: c[f]
  })), hy = (r) => an(r, (c, l) => c + l, 0), Bw = (r, c) => In.hasColumns(r) ? Ow(r, c) : py(r, c), tg = (r, c, l) => {
    const f = Bw(r, c);
    yt(f, (p) => {
      l.setElementWidth(p.element, p.width);
    });
  }, ng = (r, c, l, f, p) => {
    const k = In.fromTable(r), C = p.getCellDelta(c), z = p.getWidths(k, p), I = l === k.grid.columns - 1, Y = f.clampTableDelta(z, l, C, p.minCellWidth(), I), he = eg(z, l, Y, p, f), ct = Pe(he, (Tt, Ct) => Tt + z[Ct]);
    tg(k, ct, p), f.resizeTable(p.adjustTableWidth, Y, I);
  }, om = (r, c, l, f) => {
    const p = In.fromTable(r), k = kf(p, r, f), C = Pe(k, (he, ct) => l === ct ? Math.max(c + he, ea()) : he), z = gy(p, C), I = Pw(p, C);
    yt(I, (he) => {
      Ma(he.element, he.height);
    }), yt(z, (he) => {
      Ma(he.element, he.height);
    });
    const Y = hy(C);
    Ma(r, Y);
  }, $w = (r, c, l, f, p) => {
    const k = In.generate(c), C = f.getWidths(k, f), z = f.pixelWidth(), { newSizes: I, delta: Y } = p.calcRedestributedWidths(C, z, l.pixelDelta, f.isRelative);
    tg(k, I, f), f.adjustTableWidth(Y);
  }, yy = (r, c, l, f) => {
    const p = In.generate(c), k = f.getWidths(p, f);
    tg(p, k, f);
  }, bu = (r) => en(r, (l, f) => qt(l, (k) => k.column === f.column) ? l : l.concat([f]), []).sort((l, f) => l.column - f.column), sm = To("col"), og = To("colgroup"), sg = (r) => ue(r) === "tr" || og(r), by = (r) => {
    const c = es(r, "colspan", 1), l = es(r, "rowspan", 1);
    return {
      element: r,
      colspan: c,
      rowspan: l
    };
  }, Fw = (r, c = by) => {
    const l = (z) => sm(z.element) ? r.col(z) : r.cell(z), f = (z) => og(z.element) ? r.colgroup(z) : r.row(z), p = (z) => {
      if (sg(z))
        return f({ element: z });
      {
        const I = z, Y = l(c(I));
        return k = L.some({
          item: I,
          replacement: Y
        }), Y;
      }
    };
    let k = L.none();
    return { getOrInit: (z, I) => k.fold(() => p(z), (Y) => I(z, Y.item) ? Y.replacement : p(z)) };
  }, ky = (r) => (c) => {
    const l = [], f = (C, z) => wn(l, (I) => z(I.item, C)), p = (C) => {
      const z = r === "td" ? { scope: null } : {}, I = c.replace(C, r, z);
      return l.push({
        item: C,
        sub: I
      }), I;
    };
    return { replaceOrInit: (C, z) => {
      if (sg(C) || sm(C))
        return C;
      {
        const I = C;
        return f(I, z).fold(() => p(I), (Y) => z(C, Y.item) ? Y.sub : p(I));
      }
    } };
  }, wy = (r) => qo(r, "scope").map((c) => c.substr(0, 3)), Rr = {
    modification: Fw,
    transform: ky,
    merging: (r) => ({
      unmerge: (f) => {
        const p = wy(f);
        return p.each((k) => wo(f, "scope", k)), () => {
          const k = r.cell({
            element: f,
            colspan: 1,
            rowspan: 1
          });
          return ir(k, "width"), ir(f, "width"), p.each((C) => wo(k, "scope", C)), k;
        };
      },
      merge: (f) => {
        const p = () => {
          const k = Xo(Pe(f, wy));
          if (k.length === 0)
            return L.none();
          {
            const C = k[0], z = [
              "row",
              "col"
            ];
            return qt(k, (Y) => Y !== C && Ze(z, Y)) ? L.none() : L.from(C);
          }
        };
        return ir(f[0], "width"), p().fold(() => lo(f[0], "scope"), (k) => wo(f[0], "scope", k + "group")), ke(f[0]);
      }
    })
  }, _y = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Iw = (r, c) => {
    const l = r.property().name(c);
    return Ze([
      "ol",
      "ul"
    ], l);
  }, vy = (r, c) => {
    const l = r.property().name(c);
    return Ze(_y, l);
  }, Cy = (r, c) => Ze([
    "br",
    "img",
    "hr",
    "input"
  ], r.property().name(c)), rm = iu(), Sy = (r) => vy(rm, r), Dr = (r) => Iw(rm, r), _x = (r) => Cy(rm, r), bc = (r) => {
    const c = To("br"), l = (I) => we(I, (Y) => c(Y) || Ao(Y) && vn(Y).trim().length === 0), f = (I) => ue(I) === "li" || Qr(I, Dr).isSome(), p = (I) => vt(I).map((Y) => Sy(Y) ? !0 : _x(Y) ? ue(Y) !== "img" : !1).getOr(!1), k = (I) => ja(I).bind((Y) => {
      const he = p(Y);
      return q(Y).map((ct) => he === !0 || f(ct) || c(Y) || Sy(ct) && !Et(I, ct) ? [] : [O.fromTag("br")]);
    }).getOr([]), z = (() => {
      const I = re(r, (Y) => {
        const he = wt(Y);
        return l(he) ? [] : he.concat(k(Y));
      });
      return I.length === 0 ? [O.fromTag("br")] : I;
    })();
    Qo(r[0]), to(r[0], z);
  }, xy = (r) => Vh(r, !0), Ey = (r) => {
    Xa(r).length === 0 && Jo(r);
  }, am = (r, c) => ({
    grid: r,
    cursor: c
  }), Lw = (r) => Ue(r, (c) => Ue(c.cells, (l) => {
    const f = l.element;
    return zo(xy(f), f);
  })), Mw = (r, c, l) => {
    var f, p;
    const k = _s(r).rows;
    return L.from((p = (f = k[c]) === null || f === void 0 ? void 0 : f.cells[l]) === null || p === void 0 ? void 0 : p.element).filter(xy).orThunk(() => Lw(k));
  }, Or = (r, c, l) => {
    const f = Mw(r, c, l);
    return am(r, f);
  }, Nf = (r) => en(r, (l, f) => qt(l, (k) => k.row === f.row) ? l : l.concat([f]), []).sort((l, f) => l.row - f.row), jw = (r, c, l, f) => {
    const p = c[0].row, k = Nf(c), C = an(k, (z, I) => ({
      grid: hu(z.grid, p, I.row + z.delta, l, f.getOrInit),
      delta: z.delta + 1
    }), {
      grid: r,
      delta: 0
    }).grid;
    return Or(C, p, c[0].column);
  }, Uw = (r, c, l, f) => {
    const p = Nf(c), k = p[p.length - 1], C = k.row + k.rowspan, z = an(p, (I, Y) => hu(I, C, Y.row, l, f.getOrInit), r);
    return Or(z, C, c[0].column);
  }, rg = (r, c, l, f) => {
    const p = c.details, k = bu(p), C = k[0].column, z = an(k, (I, Y) => ({
      grid: yu(I.grid, C, Y.column + I.delta, l, f.getOrInit),
      delta: I.delta + 1
    }), {
      grid: r,
      delta: 0
    }).grid;
    return Or(z, p[0].row, C);
  }, Hw = (r, c, l, f) => {
    const p = c.details, k = p[p.length - 1], C = k.column + k.colspan, z = bu(p), I = an(z, (Y, he) => yu(Y, C, he.column, l, f.getOrInit), r);
    return Or(I, p[0].row, C);
  }, Ww = (r, c, l, f) => {
    const p = bu(c), k = Pe(p, (z) => z.column), C = Af(r, k, !0, l, f.replaceOrInit);
    return Or(C, c[0].row, c[0].column);
  }, qw = (r, c, l, f) => {
    const p = uy(r, c, l, f.replaceOrInit);
    return Or(p, c[0].row, c[0].column);
  }, Ty = (r, c, l, f) => {
    const p = bu(c), k = Pe(p, (z) => z.column), C = Af(r, k, !1, l, f.replaceOrInit);
    return Or(C, c[0].row, c[0].column);
  }, Jt = (r, c, l, f) => {
    const p = uy(r, c, l, f.replaceOrInit);
    return Or(p, c[0].row, c[0].column);
  }, Rf = (r, c) => (l, f, p, k, C) => {
    const z = Nf(f), I = Pe(z, (he) => he.row), Y = Rw(l, I, r, c, p, k.replaceOrInit, C);
    return Or(Y, f[0].row, f[0].column);
  }, zy = Rf("thead", !0), Vw = Rf("tbody", !1), Gw = Rf("tfoot", !1), Kw = (r, c, l, f) => {
    const p = bu(c.details), k = Zp(r, Pe(p, (z) => z.column)), C = k.length > 0 ? k[0].cells.length - 1 : 0;
    return Or(k, p[0].row, Math.min(p[0].column, C));
  }, Ay = (r, c, l, f) => {
    const p = Nf(c), k = ry(r, p[0].row, p[p.length - 1].row), C = k.length > 0 ? k.length - 1 : 0;
    return Or(k, Math.min(c[0].row, C), c[0].column);
  }, Yw = (r, c, l, f) => {
    const p = c.cells;
    bc(p);
    const k = Zh(r, c.bounds, l, f.merge(p));
    return am(k, L.from(p[0]));
  }, Xw = (r, c, l, f) => {
    const k = an(c, (C, z) => Ri(C, z, l, f.unmerge(z)), r);
    return am(k, L.from(c[0]));
  }, Ny = (r, c, l, f) => {
    const k = ((I, Y) => {
      const he = In.fromTable(I);
      return Ef(he, Y, !0);
    })(c.clipboard, c.generators), C = Fr(c.row, c.column);
    return oy(C, r, k, c.generators, l).fold(() => am(r, L.some(c.element)), (I) => Or(I, c.row, c.column));
  }, cm = (r, c, l) => {
    const f = Ec(r, l.section), p = In.generate(f);
    return Ef(p, c, !0);
  }, la = (r, c, l, f) => {
    const p = _s(r).rows, k = c.cells[0].column, C = p[c.cells[0].row], z = cm(c.clipboard, c.generators, C), I = sy(k, r, z, c.generators, l);
    return Or(I, c.cells[0].row, c.cells[0].column);
  }, Df = (r, c, l, f) => {
    const p = _s(r).rows, k = c.cells[c.cells.length - 1].column + c.cells[c.cells.length - 1].colspan, C = p[c.cells[0].row], z = cm(c.clipboard, c.generators, C), I = sy(k, r, z, c.generators, l);
    return Or(I, c.cells[0].row, c.cells[0].column);
  }, Zw = (r, c, l, f) => {
    const p = _s(r).rows, k = c.cells[0].row, C = p[k], z = cm(c.clipboard, c.generators, C), I = Xp(k, r, z, c.generators, l);
    return Or(I, c.cells[0].row, c.cells[0].column);
  }, Qw = (r, c, l, f) => {
    const p = _s(r).rows, k = c.cells[c.cells.length - 1].row + c.cells[c.cells.length - 1].rowspan, C = p[c.cells[0].row], z = cm(c.clipboard, c.generators, C), I = Xp(k, r, z, c.generators, l);
    return Or(I, c.cells[0].row, c.cells[0].column);
  }, Jw = (r, c) => {
    const l = In.fromTable(r);
    return Uc(l, c).bind((p) => {
      const k = p[p.length - 1], C = p[0].column, z = k.column + k.colspan, I = ie(Pe(l.all, (Y) => Rn(Y.cells, (he) => he.column >= C && he.column < z)));
      return kl(I);
    }).getOr("");
  }, e_ = (r, c) => {
    const l = In.fromTable(r);
    return Uc(l, c).bind(kl).getOr("");
  }, t_ = (r, c) => {
    const l = In.fromTable(r);
    return Uc(l, c).bind((p) => {
      const k = p[p.length - 1], C = p[0].row, z = k.row + k.rowspan, I = l.all.slice(C, z);
      return Wp(I);
    }).getOr("");
  }, im = (r, c, l, f) => yy(r, c, l, f.sizing), lm = (r, c, l, f) => $w(r, c, l, f.sizing, f.resize), Ry = (r, c) => qt(c, (l) => l.column === 0 && l.isLocked), ag = (r, c) => qt(c, (l) => l.column + l.colspan >= r.grid.columns && l.isLocked), Dy = (r, c) => {
    const l = fc(r), f = bu(c);
    return en(f, (p, k) => {
      const z = l[k.column].map(yr).getOr(0);
      return p + z;
    }, 0);
  }, Oy = (r) => (c, l) => Uc(c, l).filter((f) => !(r ? Ry : ag)(c, f)).map((f) => ({
    details: f,
    pixelDelta: Dy(c, f)
  })), n_ = (r, c) => yc(r, c).map((l) => ({
    details: l,
    pixelDelta: -Dy(r, l)
  })), Py = (r) => (c, l) => Qd(c, l).filter((f) => !(r ? Ry : ag)(c, f.cells)), cg = Rr.transform("th"), um = Rr.transform("td"), ig = qs(jw, Uc, xe, xe, Rr.modification), By = qs(Uw, Uc, xe, xe, Rr.modification), o_ = qs(rg, Oy(!0), lm, xe, Rr.modification), $y = qs(Hw, Oy(!1), lm, xe, Rr.modification), s_ = qs(Kw, n_, lm, Ey, Rr.modification), r_ = qs(Ay, Uc, xe, Ey, Rr.modification), a_ = qs(Ww, yc, xe, xe, cg), Fy = qs(Ty, yc, xe, xe, um), c_ = qs(zy, yc, xe, xe, cg), i_ = qs(Vw, yc, xe, xe, um), Iy = qs(Gw, yc, xe, xe, um), l_ = qs(qw, yc, xe, xe, cg), u_ = qs(Jt, yc, xe, xe, um), Ly = qs(Yw, vw, im, xe, Rr.merging), f_ = qs(Xw, Cw, im, xe, Rr.merging), ku = qs(Ny, ww, im, xe, Rr.modification), d_ = qs(la, Py(!0), xe, xe, Rr.modification), lg = qs(Df, Py(!1), xe, xe, Rr.modification), m_ = qs(Zw, Qd, xe, xe, Rr.modification), Of = qs(Qw, Qd, xe, xe, Rr.modification), p_ = Jw, g_ = e_, h_ = t_, My = (r, c) => r.dispatch("NewRow", { node: c }), fm = (r, c) => r.dispatch("NewCell", { node: c }), Cl = (r, c, l) => {
    r.dispatch("TableModified", {
      ...l,
      table: c
    });
  }, y_ = (r, c, l, f, p) => {
    r.dispatch("TableSelectionChange", {
      cells: c,
      start: l,
      finish: f,
      otherCells: p
    });
  }, b_ = (r) => {
    r.dispatch("TableSelectionClear");
  }, k_ = (r, c, l, f, p) => {
    r.dispatch("ObjectResizeStart", {
      target: c,
      width: l,
      height: f,
      origin: p
    });
  }, w_ = (r, c, l, f, p) => {
    r.dispatch("ObjectResized", {
      target: c,
      width: l,
      height: f,
      origin: p
    });
  }, dm = {
    structure: !1,
    style: !0
  }, Ts = {
    structure: !0,
    style: !1
  }, __ = {
    structure: !0,
    style: !0
  }, qc = (r) => (c) => c.options.get(r), jy = "100%", Uy = (r) => {
    var c;
    const l = r.dom, f = (c = l.getParent(r.selection.getStart(), l.isBlock)) !== null && c !== void 0 ? c : r.getBody();
    return ra(O.fromDom(f)) + "px";
  }, v_ = (r, c) => Pf(r) || !Ky(r) ? c : Vc(r) ? {
    ...c,
    width: Uy(r)
  } : {
    ...c,
    width: jy
  }, C_ = (r, c) => Pf(r) || Ky(r) ? c : Vc(r) ? {
    ...c,
    width: Uy(r)
  } : {
    ...c,
    width: jy
  }, Hy = (r) => {
    const c = r.options.register;
    c("table_clone_elements", { processor: "string[]" }), c("table_use_colgroups", {
      processor: "boolean",
      default: !0
    }), c("table_header_type", {
      processor: (l) => {
        const f = Ze([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], l);
        return f ? {
          value: l,
          valid: f
        } : {
          valid: !1,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    }), c("table_sizing_mode", {
      processor: "string",
      default: "auto"
    }), c("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    }), c("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    }), c("table_column_resizing", {
      processor: (l) => {
        const f = Ze([
          "preservetable",
          "resizetable"
        ], l);
        return f ? {
          value: l,
          valid: f
        } : {
          valid: !1,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    }), c("table_resize_bars", {
      processor: "boolean",
      default: !0
    }), c("table_style_by_css", {
      processor: "boolean",
      default: !0
    });
  }, Wy = (r) => L.from(r.options.get("table_clone_elements")), S_ = (r) => {
    const c = r.options.get("object_resizing");
    return Ze(c.split(","), "table");
  }, qy = qc("table_header_type"), ug = qc("table_column_resizing"), Vy = (r) => ug(r) === "preservetable", Gy = (r) => ug(r) === "resizetable", fg = qc("table_sizing_mode"), mm = (r) => fg(r) === "relative", Vc = (r) => fg(r) === "fixed", Pf = (r) => fg(r) === "responsive", x_ = qc("table_resize_bars"), Ky = qc("table_style_by_css"), E_ = (r) => {
    const c = r.options, l = c.get("table_default_attributes");
    return c.isSet("table_default_attributes") ? l : C_(r, l);
  }, T_ = (r) => {
    const c = r.options, l = c.get("table_default_styles");
    return c.isSet("table_default_styles") ? l : v_(r, l);
  }, z_ = qc("table_use_colgroups"), Yy = (r, c) => mm(r) ? pc.percentageSize(c) : Vc(r) ? pc.pixelSize(c) : pc.getTableSize(c), A_ = (r, c, l) => {
    const f = (or) => ue(cu(or)) === "table", p = (or) => f(r) === !1 || Yd(or).rows > 1, k = (or) => f(r) === !1 || Yd(or).columns > 1, C = Wy(r), z = Gy(r) ? xe : uu, I = (or) => {
      switch (qy(r)) {
        case "section":
          return Mr.section();
        case "sectionCells":
          return Mr.sectionCells();
        case "cells":
          return Mr.cells();
        default:
          return Mr.getTableSectionType(or, "section");
      }
    }, Y = (or, Zg) => Zg.cursor.fold(() => {
      const Xf = Xa(or);
      return W(Xf).filter(Ro).map((_c) => {
        l.clearSelectedCells(or.dom);
        const Vs = r.dom.createRng();
        return Vs.selectNode(_c.dom), r.selection.setRng(Vs), wo(_c, "data-mce-selected", "1"), Vs;
      });
    }, (Xf) => {
      const _c = pw(Xf), Vs = r.dom.createRng();
      return Vs.setStart(_c.element.dom, _c.offset), Vs.setEnd(_c.element.dom, _c.offset), r.selection.setRng(Vs), l.clearSelectedCells(or.dom), L.some(Vs);
    }), he = (or, Zg, Xf, _c) => (Vs, _v, vv = !1) => {
      Ha(Vs);
      const Cv = O.fromDom(r.getDoc()), p1 = Ko(Xf, Cv, C), Sv = {
        sizing: Yy(r, Vs),
        resize: Gy(r) ? jh() : fu(),
        section: I(Vs)
      };
      return Zg(Vs) ? or(Vs, _v, p1, Sv).bind((Qg) => {
        c.refresh(Vs.dom), yt(Qg.newRows, (Zf) => {
          My(r, Zf.dom);
        }), yt(Qg.newCells, (Zf) => {
          fm(r, Zf.dom);
        });
        const g1 = Y(Vs, Qg);
        return Ro(Vs) && (Ha(Vs), vv || Cl(r, Vs.dom, _c)), g1.map((Zf) => ({
          rng: Zf,
          effect: _c
        }));
      }) : L.none();
    }, ct = he(r_, p, xe, Ts), Tt = he(s_, k, xe, Ts), Ct = he(ig, Ve, xe, Ts), Ye = he(By, Ve, xe, Ts), Rt = he(o_, Ve, z, Ts), Xe = he($y, Ve, z, Ts), Kt = he(Ly, Ve, xe, Ts), Cn = he(f_, Ve, xe, Ts), Fn = he(d_, Ve, xe, Ts), Zo = he(lg, Ve, xe, Ts), Is = he(m_, Ve, xe, Ts), Yo = he(Of, Ve, xe, Ts), Hr = he(ku, Ve, xe, __), Hu = he(l_, Ve, xe, Ts), Yf = he(u_, Ve, xe, Ts), m1 = he(a_, Ve, xe, Ts), Qm = he(Fy, Ve, xe, Ts), Oo = he(c_, Ve, xe, Ts), dr = he(i_, Ve, xe, Ts), mr = he(Iy, Ve, xe, Ts);
    return {
      deleteRow: ct,
      deleteColumn: Tt,
      insertRowsBefore: Ct,
      insertRowsAfter: Ye,
      insertColumnsBefore: Rt,
      insertColumnsAfter: Xe,
      mergeCells: Kt,
      unmergeCells: Cn,
      pasteColsBefore: Fn,
      pasteColsAfter: Zo,
      pasteRowsBefore: Is,
      pasteRowsAfter: Yo,
      pasteCells: Hr,
      makeCellsHeader: Hu,
      unmakeCellsHeader: Yf,
      makeColumnsHeader: m1,
      unmakeColumnsHeader: Qm,
      makeRowsHeader: Oo,
      makeRowsBody: dr,
      makeRowsFooter: mr,
      getTableRowType: h_,
      getTableCellType: g_,
      getTableColType: p_
    };
  }, Xy = (r, c, l) => {
    const f = es(r, c, 1);
    l === 1 || f <= 1 ? lo(r, c) : wo(r, c, Math.min(l, f));
  }, dg = (r, c) => (l) => {
    const f = l.column + l.colspan - 1, p = l.column;
    return f >= r && p < c;
  }, Zy = (r, c, l) => {
    if (In.hasColumns(r)) {
      const f = Rn(In.justColumns(r), dg(c, l)), p = Pe(f, (C) => {
        const z = js(C.element);
        return Xy(z, "span", l - c), z;
      }), k = O.fromTag("colgroup");
      return to(k, p), [k];
    } else
      return [];
  }, N_ = (r, c, l) => Pe(r.all, (f) => {
    const p = Rn(f.cells, dg(c, l)), k = Pe(p, (z) => {
      const I = js(z.element);
      return Xy(I, "colspan", l - c), I;
    }), C = O.fromTag("tr");
    return to(C, k), C;
  }), R_ = (r, c) => {
    const l = In.fromTable(r);
    return yc(l, c).map((p) => {
      const k = p[p.length - 1], C = p[0].column, z = k.column + k.colspan, I = Zy(l, C, z), Y = N_(l, C, z);
      return [
        ...I,
        ...Y
      ];
    });
  }, D_ = (r, c, l) => {
    const f = In.fromTable(r);
    return Uc(f, c).bind((k) => {
      const C = Ef(f, l, !1), I = _s(C).rows.slice(k[0].row, k[k.length - 1].row + k[k.length - 1].rowspan), Y = re(I, (ct) => {
        const Tt = Rn(ct.cells, (Ct) => !Ct.isLocked);
        return Tt.length > 0 ? [{
          ...ct,
          cells: Tt
        }] : [];
      }), he = Tf(Y);
      return zo(he.length > 0, he);
    }).map((k) => du(k));
  }, Bf = kr.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]), Qy = (r, c, l) => {
    const f = l.substring(0, l.length - r.length), p = parseFloat(f);
    return f === p.toString() ? c(p) : Bf.invalid(l);
  }, Sl = {
    ...Bf,
    from: (r) => V(r, "%") ? Qy("%", Bf.percent, r) : V(r, "px") ? Qy("px", Bf.pixels, r) : Bf.invalid(r)
  }, P_ = (r, c) => Pe(r, (l) => Sl.from(l).fold(() => l, (p) => p / c * 100 + "%", (p) => p + "%")), Jy = (r, c, l) => {
    const f = l / c;
    return Pe(r, (p) => Sl.from(p).fold(() => p, (C) => C * f + "px", (C) => C / 100 * l + "px"));
  }, eb = (r, c) => {
    const l = r.fold(() => ke(""), (f) => {
      const p = f / c;
      return ke(p + "px");
    }, () => {
      const f = 100 / c;
      return ke(f + "%");
    });
    return Z(c, l);
  }, tb = (r, c, l) => r.fold(() => c, (f) => Jy(c, l, f), (f) => P_(c, l)), mg = (r, c, l) => {
    const f = Sl.from(l), p = we(r, (k) => k === "0px") ? eb(f, r.length) : tb(f, r, c);
    return F_(p);
  }, pm = (r, c) => r.length === 0 ? c : an(r, (l, f) => Sl.from(f).fold(ke(0), ge, ge) + l, 0), B_ = (r, c) => {
    const l = Math.floor(r);
    return {
      value: l + c,
      remainder: r - l
    };
  }, $_ = (r, c) => Sl.from(r).fold(ke(r), (l) => l + c + "px", (l) => l + c + "%"), F_ = (r) => {
    if (r.length === 0)
      return r;
    const c = an(r, (f, p) => {
      const k = Sl.from(p).fold(() => ({
        value: p,
        remainder: 0
      }), (C) => B_(C, "px"), (C) => ({
        value: C + "%",
        remainder: 0
      }));
      return {
        output: [k.value].concat(f.output),
        remainder: f.remainder + k.remainder
      };
    }, {
      output: [],
      remainder: 0
    }), l = c.output;
    return l.slice(0, l.length - 1).concat([$_(l[l.length - 1], Math.round(c.remainder))]);
  }, I_ = Sl.from, L_ = (r, c, l) => {
    yt(c, (f) => {
      const p = r.slice(f.column, f.colspan + f.column), k = pm(p, ba());
      qn(f.element, "width", k + l);
    });
  }, xl = (r, c, l) => {
    yt(c, (f, p) => {
      const k = pm([r[p]], ba());
      qn(f.element, "width", k + l);
    });
  }, M_ = (r, c, l, f) => {
    yt(l, (p) => {
      const k = r.slice(p.row, p.rowspan + p.row), C = pm(k, ea());
      qn(p.element, "height", C + f);
    }), yt(c, (p, k) => {
      qn(p.element, "height", r[k]);
    });
  }, nb = (r) => I_(r).fold(ke("px"), ke("px"), ke("%")), ob = (r, c, l) => {
    const f = In.fromTable(r), p = f.all, k = In.justCells(f), C = In.justColumns(f);
    c.each((z) => {
      const I = nb(z), Y = Ia(r), he = ml(f, r), ct = mg(he, Y, z);
      In.hasColumns(f) ? xl(ct, C, I) : L_(ct, k, I), qn(r, "width", z);
    }), l.each((z) => {
      const I = nb(z), Y = dn(r), he = br(f, r, fl), ct = mg(he, Y, z);
      M_(ct, p, k, I), qn(r, "height", z);
    });
  }, sb = Tp, pg = mf, rb = Ei, gm = (r) => {
    lo(r, "width");
  }, wu = (r) => {
    const c = ia(r);
    ob(r, L.some(c), L.none()), gm(r);
  }, El = (r) => {
    const c = mc(r);
    ob(r, L.some(c), L.none()), gm(r);
  }, _u = (r) => {
    ir(r, "width");
    const c = ac(r), l = c.length > 0 ? c : Xa(r);
    yt(l, (f) => {
      ir(f, "width"), gm(f);
    }), gm(r);
  }, j_ = {
    styles: {
      "border-collapse": "collapse",
      width: "100%"
    },
    attributes: { border: "1" },
    colGroups: !1
  }, gg = () => O.fromTag("th"), U_ = () => O.fromTag("td"), ab = () => O.fromTag("col"), cb = (r, c, l, f) => {
    const p = O.fromTag("tr");
    for (let k = 0; k < r; k++) {
      const C = f < c || k < l ? gg() : U_();
      k < l && wo(C, "scope", "row"), f < c && wo(C, "scope", "col"), Dn(C, O.fromTag("br")), Dn(p, C);
    }
    return p;
  }, ib = (r) => {
    const c = O.fromTag("colgroup");
    return Z(r, () => Dn(c, ab())), c;
  }, hg = (r, c, l, f) => Z(r, (p) => cb(c, l, f, p)), H_ = (r, c, l, f, p, k = j_) => {
    const C = O.fromTag("table"), z = p !== "cells";
    ko(C, k.styles), os(C, k.attributes), k.colGroups && Dn(C, ib(c));
    const I = Math.min(r, l);
    if (z && l > 0) {
      const Ct = O.fromTag("thead");
      Dn(C, Ct);
      const Rt = hg(l, c, p === "sectionCells" ? I : 0, f);
      to(Ct, Rt);
    }
    const Y = O.fromTag("tbody");
    Dn(C, Y);
    const he = z ? r - I : r, Tt = hg(he, c, z ? 0 : l, f);
    return to(Y, Tt), C;
  }, vu = (r) => r.dom.innerHTML, Tl = (r) => {
    const c = O.fromTag("div"), l = O.fromDom(r.dom.cloneNode(!0));
    return Dn(c, l), vu(c);
  }, hm = (r, c) => {
    r.selection.select(c.dom, !0), r.selection.collapse(!0);
  }, $f = (r, c) => {
    Un(c, "td,th").each(ot(hm, r));
  }, W_ = (r, c) => {
    yt(Ds(c, "tr"), (l) => {
      My(r, l.dom), yt(Ds(l, "th,td"), (f) => {
        fm(r, f.dom);
      });
    });
  }, Pi = (r) => We(r) && r.indexOf("%") !== -1, kc = (r, c, l, f, p) => {
    const k = T_(r), C = {
      styles: k,
      attributes: E_(r),
      colGroups: z_(r)
    };
    return r.undoManager.ignore(() => {
      const z = H_(l, c, p, f, qy(r), C);
      wo(z, "data-mce-id", "__mce");
      const I = Tl(z);
      r.insertContent(I), r.addVisual();
    }), Un(cu(r), 'table[data-mce-id="__mce"]').map((z) => (Vc(r) ? El(z) : Pf(r) ? _u(z) : (mm(r) || Pi(k.width)) && wu(z), Ha(z), lo(z, "data-mce-id"), W_(r, z), $f(r, z), z.dom)).getOr(null);
  }, yg = (r, c, l, f = {}) => {
    const p = (k) => tt(k) && k > 0;
    if (p(c) && p(l)) {
      const k = f.headerRows || 0, C = f.headerColumns || 0;
      return kc(r, l, c, C, k);
    } else
      return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
  };
  var Ff = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const lb = "x-tinymce/dom-table-", ym = lb + "rows", zl = lb + "columns", Cu = (r) => {
    const c = Ff.FakeClipboardItem(r);
    Ff.write([c]);
  }, If = (r) => {
    var c;
    const l = (c = Ff.read()) !== null && c !== void 0 ? c : [];
    return Ue(l, (f) => L.from(f.getType(r)));
  }, bg = (r) => {
    If(r).isSome() && Ff.clear();
  }, Su = (r) => {
    r.fold(q_, (c) => Cu({ [ym]: c }));
  }, Lf = () => If(ym), q_ = () => bg(ym), bm = (r) => {
    r.fold($s, (c) => Cu({ [zl]: c }));
  }, Mf = () => If(zl), $s = () => bg(zl), kg = (r) => Mp(gc(r), Ua(r)), wc = (r) => jp(gc(r), Ua(r)), ub = (r, c) => {
    const l = Ua(r), f = () => kg(r).each((Xe) => {
      Us(Xe, l).filter(le(l)).each((Kt) => {
        const Cn = O.fromText("");
        if (Xn(Kt, Cn), Jo(Kt), r.dom.isEmpty(r.getBody()))
          r.setContent(""), r.selection.setCursorLocation();
        else {
          const Fn = r.dom.createRng();
          Fn.setStart(Cn.dom, 0), Fn.setEnd(Cn.dom, 0), r.selection.setRng(Fn), r.nodeChanged();
        }
      });
    }), p = (Xe) => kg(r).each((Kt) => {
      Pf(r) || Vc(r) || mm(r) || Us(Kt, l).each((Fn) => {
        Xe === "relative" && !sb(Fn) ? wu(Fn) : Xe === "fixed" && !pg(Fn) ? El(Fn) : Xe === "responsive" && !rb(Fn) && _u(Fn), Ha(Fn), Cl(r, Fn.dom, Ts);
      });
    }), k = (Xe) => Us(Xe, l), C = (Xe) => wc(r).bind((Kt) => k(Kt).map((Cn) => Xe(Cn, Kt))), z = (Xe, Kt) => {
      C((Cn) => {
        r.formatter.toggle("tableclass", { value: Kt }, Cn.dom), Cl(r, Cn.dom, dm);
      });
    }, I = (Xe, Kt) => {
      C((Cn) => {
        const Fn = hc(r), Is = we(Fn, (Yo) => r.formatter.match("tablecellclass", { value: Kt }, Yo.dom)) ? r.formatter.remove : r.formatter.apply;
        yt(Fn, (Yo) => Is("tablecellclass", { value: Kt }, Yo.dom)), Cl(r, Cn.dom, dm);
      });
    }, Y = () => {
      kg(r).each((Xe) => {
        Us(Xe, l).each((Kt) => {
          Gt(Kt, "caption").fold(() => {
            const Cn = O.fromTag("caption");
            Dn(Cn, O.fromText("Caption")), sr(Kt, Cn, 0), r.selection.setCursorLocation(Cn.dom, 0);
          }, (Cn) => {
            To("caption")(Xe) && rn("td", Kt).each((Fn) => r.selection.setCursorLocation(Fn.dom, 0)), Jo(Cn);
          }), Cl(r, Kt.dom, Ts);
        });
      });
    }, he = (Xe) => {
      r.focus();
    }, ct = (Xe, Kt = !1) => C((Cn, Fn) => {
      const Zo = Hd(hc(r), Cn, Fn);
      Xe(Cn, Zo, Kt).each(he);
    }), Tt = () => C((Xe, Kt) => {
      const Cn = Hd(hc(r), Xe, Kt), Fn = Ko(xe, O.fromDom(r.getDoc()), L.none());
      return D_(Xe, Cn, Fn);
    }), Ct = () => C((Xe, Kt) => {
      const Cn = Hd(hc(r), Xe, Kt);
      return R_(Xe, Cn);
    }), Ye = (Xe, Kt) => Kt().each((Cn) => {
      const Fn = Pe(Cn, (Zo) => js(Zo));
      C((Zo, Is) => {
        const Yo = Ps(O.fromDom(r.getDoc())), Hr = lw(hc(r), Is, Fn, Yo);
        Xe(Zo, Hr).each(he);
      });
    }), Rt = (Xe) => (Kt, Cn) => io(Cn, "type").each((Fn) => {
      ct(Xe(Fn), Cn.no_events);
    });
    pn({
      mceTableSplitCells: () => ct(c.unmergeCells),
      mceTableMergeCells: () => ct(c.mergeCells),
      mceTableInsertRowBefore: () => ct(c.insertRowsBefore),
      mceTableInsertRowAfter: () => ct(c.insertRowsAfter),
      mceTableInsertColBefore: () => ct(c.insertColumnsBefore),
      mceTableInsertColAfter: () => ct(c.insertColumnsAfter),
      mceTableDeleteCol: () => ct(c.deleteColumn),
      mceTableDeleteRow: () => ct(c.deleteRow),
      mceTableCutCol: () => Ct().each((Xe) => {
        bm(Xe), ct(c.deleteColumn);
      }),
      mceTableCutRow: () => Tt().each((Xe) => {
        Su(Xe), ct(c.deleteRow);
      }),
      mceTableCopyCol: () => Ct().each((Xe) => bm(Xe)),
      mceTableCopyRow: () => Tt().each((Xe) => Su(Xe)),
      mceTablePasteColBefore: () => Ye(c.pasteColsBefore, Mf),
      mceTablePasteColAfter: () => Ye(c.pasteColsAfter, Mf),
      mceTablePasteRowBefore: () => Ye(c.pasteRowsBefore, Lf),
      mceTablePasteRowAfter: () => Ye(c.pasteRowsAfter, Lf),
      mceTableDelete: f,
      mceTableCellToggleClass: I,
      mceTableToggleClass: z,
      mceTableToggleCaption: Y,
      mceTableSizingMode: (Xe, Kt) => p(Kt),
      mceTableCellType: Rt((Xe) => Xe === "th" ? c.makeCellsHeader : c.unmakeCellsHeader),
      mceTableColType: Rt((Xe) => Xe === "th" ? c.makeColumnsHeader : c.unmakeColumnsHeader),
      mceTableRowType: Rt((Xe) => {
        switch (Xe) {
          case "header":
            return c.makeRowsHeader;
          case "footer":
            return c.makeRowsFooter;
          default:
            return c.makeRowsBody;
        }
      })
    }, (Xe, Kt) => r.addCommand(Kt, Xe)), r.addCommand("mceInsertTable", (Xe, Kt) => {
      yg(r, Kt.rows, Kt.columns, Kt.options);
    }), r.addCommand("mceTableApplyCellStyle", (Xe, Kt) => {
      const Cn = (Is) => "tablecell" + Is.toLowerCase().replace("-", "");
      if (!Ke(Kt))
        return;
      const Fn = hc(r);
      if (Fn.length === 0)
        return;
      const Zo = eo(Kt, (Is, Yo) => r.formatter.has(Cn(Yo)) && We(Is));
      Qt(Zo) || (pn(Zo, (Is, Yo) => {
        const Hr = Cn(Yo);
        yt(Fn, (Hu) => {
          Is === "" ? r.formatter.remove(Hr, { value: null }, Hu.dom, !0) : r.formatter.apply(Hr, { value: Is }, Hu.dom);
        });
      }), k(Fn[0]).each((Is) => Cl(r, Is.dom, dm)));
    });
  }, wg = (r, c) => {
    const l = Ua(r), f = (p) => jp(gc(r)).bind((k) => Us(k, l).map((C) => {
      const z = Hd(hc(r), C, k);
      return p(C, z);
    })).getOr("");
    pn({
      mceTableRowType: () => f(c.getTableRowType),
      mceTableCellType: () => f(c.getTableCellType),
      mceTableColType: () => f(c.getTableColType)
    }, (p, k) => r.addQueryValueHandler(k, p));
  }, Bi = kr.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), fb = (r, c, l, f) => r.fold(c, l, f), km = (r) => r.fold(ge, ge, ge), V_ = Bi.before, db = Bi.on, mb = Bi.after, wr = {
    before: V_,
    on: db,
    after: mb,
    cata: fb,
    getStart: km
  }, jr = { create: (r, c) => ({
    selection: r,
    kill: c
  }) }, G_ = (r, c) => {
    const l = r.document.createRange();
    return l.selectNode(c.dom), l;
  }, K_ = (r, c) => {
    const l = r.document.createRange();
    return gb(l, c), l;
  }, gb = (r, c) => r.selectNodeContents(c.dom), hb = (r, c) => {
    c.fold((l) => {
      r.setStartBefore(l.dom);
    }, (l, f) => {
      r.setStart(l.dom, f);
    }, (l) => {
      r.setStartAfter(l.dom);
    });
  }, yb = (r, c) => {
    c.fold((l) => {
      r.setEndBefore(l.dom);
    }, (l, f) => {
      r.setEnd(l.dom, f);
    }, (l) => {
      r.setEndAfter(l.dom);
    });
  }, bb = (r, c, l) => {
    const f = r.document.createRange();
    return hb(f, c), yb(f, l), f;
  }, _g = (r, c, l, f, p) => {
    const k = r.document.createRange();
    return k.setStart(c.dom, l), k.setEnd(f.dom, p), k;
  }, _a = (r) => ({
    left: r.left,
    top: r.top,
    right: r.right,
    bottom: r.bottom,
    width: r.width,
    height: r.height
  }), wm = (r) => {
    const c = r.getClientRects(), l = c.length > 0 ? c[0] : r.getBoundingClientRect();
    return l.width > 0 || l.height > 0 ? L.some(l).map(_a) : L.none();
  }, xu = kr.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Al = (r, c, l) => c(O.fromDom(l.startContainer), l.startOffset, O.fromDom(l.endContainer), l.endOffset), va = (r, c) => c.match({
    domRange: (l) => ({
      ltr: ke(l),
      rtl: L.none
    }),
    relative: (l, f) => ({
      ltr: oa(() => bb(r, l, f)),
      rtl: oa(() => L.some(bb(r, f, l)))
    }),
    exact: (l, f, p, k) => ({
      ltr: oa(() => _g(r, l, f, p, k)),
      rtl: oa(() => L.some(_g(r, p, k, l, f)))
    })
  }), ec = (r, c) => {
    const l = c.ltr();
    return l.collapsed ? c.rtl().filter((p) => p.collapsed === !1).map((p) => xu.rtl(O.fromDom(p.endContainer), p.endOffset, O.fromDom(p.startContainer), p.startOffset)).getOrThunk(() => Al(r, xu.ltr, l)) : Al(r, xu.ltr, l);
  }, _r = (r, c) => {
    const l = va(r, c);
    return ec(r, l);
  }, qa = (r, c) => _r(r, c).match({
    ltr: (f, p, k, C) => {
      const z = r.document.createRange();
      return z.setStart(f.dom, p), z.setEnd(k.dom, C), z;
    },
    rtl: (f, p, k, C) => {
      const z = r.document.createRange();
      return z.setStart(k.dom, C), z.setEnd(f.dom, p), z;
    }
  });
  xu.ltr, xu.rtl;
  const ua = { create: (r, c, l, f) => ({
    start: r,
    soffset: c,
    finish: l,
    foffset: f
  }) }, kb = { create: (r, c, l, f) => ({
    start: wr.on(r, c),
    finish: wr.on(l, f)
  }) }, wb = (r, c) => {
    const l = qa(r, c);
    return ua.create(O.fromDom(l.startContainer), l.startOffset, O.fromDom(l.endContainer), l.endOffset);
  }, _m = kb.create, _b = (r, c, l, f, p, k, C) => Et(l, p) && f === k ? L.none() : Zn(l, "td,th", c).bind((z) => Zn(p, "td,th", c).bind((I) => vg(r, c, z, I, C))), vg = (r, c, l, f, p) => Et(l, f) ? L.none() : Md(l, f, c).bind((k) => {
    const C = k.boxes.getOr([]);
    return C.length > 1 ? (p(r, C, k.start, k.finish), L.some(jr.create(L.some(_m(l, 0, l, uo(l))), !0))) : L.none();
  }), vm = (r, c, l, f, p) => {
    const k = (C) => (p.clearBeforeUpdate(l), p.selectRange(l, C.boxes, C.start, C.finish), C.boxes);
    return zi(f, r, c, p.firstSelectedSelector, p.lastSelectedSelector).map(k);
  }, Cm = (r, c) => ({
    item: r,
    mode: c
  }), vb = (r, c, l, f = Tu) => r.property().parent(c).map((p) => Cm(p, f)), Tu = (r, c, l, f = jf) => l.sibling(r, c).map((p) => Cm(p, f)), jf = (r, c, l, f = jf) => {
    const p = r.property().children(c);
    return l.first(p).map((C) => Cm(C, f));
  }, X_ = [
    {
      current: vb,
      next: Tu,
      fallback: L.none()
    },
    {
      current: Tu,
      next: jf,
      fallback: L.some(vb)
    },
    {
      current: jf,
      next: jf,
      fallback: L.some(Tu)
    }
  ], Cg = (r, c, l, f, p = X_) => wn(p, (C) => C.current === l).bind((C) => C.current(r, c, f, C.next).orThunk(() => C.fallback.bind((z) => Cg(r, c, z, f)))), Sg = {
    left: () => ({
      sibling: (l, f) => l.query().prevSibling(f),
      first: (l) => l.length > 0 ? L.some(l[l.length - 1]) : L.none()
    }),
    right: () => ({
      sibling: (l, f) => l.query().nextSibling(f),
      first: (l) => l.length > 0 ? L.some(l[0]) : L.none()
    })
  }, xg = (r, c, l, f, p, k) => Cg(r, c, f, p).bind((z) => k(z.item) ? L.none() : l(z.item) ? L.some(z.item) : xg(r, z.item, l, z.mode, p, k)), Q_ = (r, c, l, f) => xg(r, c, l, Tu, Sg.left(), f), J_ = (r, c, l, f) => xg(r, c, l, Tu, Sg.right(), f), Sb = (r) => (c) => r.property().children(c).length === 0, e0 = (r, c, l) => fa(r, c, Sb(r), l), t0 = (r, c, l) => n0(r, c, Sb(r), l), fa = Q_, n0 = J_, Nl = iu(), zu = (r, c) => e0(Nl, r, c), Sm = (r, c) => t0(Nl, r, c), o0 = (r, c, l) => fa(Nl, r, c, l), Eg = (r, c, l) => n0(Nl, r, c, l), s0 = (r, c, l) => Qr(r, c, l).isSome(), xm = kr.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]), r0 = (r, c, l) => {
    const f = r.getRect(c), p = r.getRect(l);
    return p.right > f.left && p.left < f.right;
  }, xb = (r) => Zn(r, "tr"), Gc = {
    ...xm,
    verify: (r, c, l, f, p, k, C) => Zn(f, "td,th", C).bind((z) => Zn(c, "td,th", C).map((I) => Et(z, I) ? Et(f, z) && uo(z) === p ? k(I) : xm.none("in same cell") : Id(xb, [
      z,
      I
    ]).fold(() => r0(r, I, z) ? xm.success() : k(I), (Y) => k(I)))).getOr(xm.none("default")),
    cata: (r, c, l, f, p) => r.fold(c, l, f, p)
  }, Em = (r, c, l, f) => ({
    parent: r,
    children: c,
    element: l,
    index: f
  }), c0 = (r) => q(r).bind((c) => {
    const l = wt(c);
    return Eb(l, r).map((f) => Em(c, l, r, f));
  }), Eb = (r, c) => w(r, ot(Et, c)), Tm = To("br"), Uf = (r, c, l) => c(r, l).bind((f) => Ao(f) && vn(f).trim().length === 0 ? Uf(f, c, l) : L.some(f)), Au = (r, c, l) => l.traverse(c).orThunk(() => Uf(c, l.gather, r)).map(l.relative), Tg = (r, c) => It(r, c).filter(Tm).orThunk(() => It(r, c - 1).filter(Tm)), i0 = (r, c, l, f) => Tg(c, l).bind((p) => f.traverse(p).fold(() => Uf(p, f.gather, r).map(f.relative), (k) => c0(k).map((C) => wr.on(C.parent, C.index)))), Kc = (r, c, l, f) => (Tm(c) ? Au(r, c, f) : i0(r, c, l, f)).map((k) => ({
    start: k,
    finish: k
  })), zg = (r) => Gc.cata(r, (c) => L.none(), () => L.none(), (c) => L.some(Ja(c, 0)), (c) => L.some(Ja(c, uo(c)))), Nu = (r, c) => ({
    left: r.left,
    top: r.top + c,
    right: r.right,
    bottom: r.bottom + c
  }), Rl = (r, c) => ({
    left: r.left,
    top: r.top - c,
    right: r.right,
    bottom: r.bottom - c
  }), Ag = (r, c, l) => ({
    left: r.left + c,
    top: r.top + l,
    right: r.right + c,
    bottom: r.bottom + l
  }), zm = (r) => r.top, l0 = (r) => r.bottom, u0 = (r, c, l) => l >= 0 && l < uo(c) ? r.getRangedRect(c, l, c, l + 1) : l > 0 ? r.getRangedRect(c, l - 1, c, l) : L.none(), Ca = (r) => ({
    left: r.left,
    top: r.top,
    right: r.right,
    bottom: r.bottom
  }), Ur = (r, c) => L.some(r.getRect(c)), Fs = (r, c, l) => hn(c) ? Ur(r, c).map(Ca) : Ao(c) ? u0(r, c, l).map(Ca) : L.none(), Tb = (r, c) => hn(c) ? Ur(r, c).map(Ca) : Ao(c) ? r.getRangedRect(c, 0, c, uo(c)).map(Ca) : L.none(), Yc = 5, Ru = 100, tc = kr.generate([
    { none: [] },
    { retry: ["caret"] }
  ]), zb = (r, c) => r.left < c.left || Math.abs(c.right - r.left) < 1 || r.left > c.right, Ab = (r, c, l) => x(c, Sy).fold(Le, (f) => Tb(r, f).exists((p) => zb(l, p))), f0 = (r, c, l, f, p) => {
    const k = Nu(p, Yc);
    return Math.abs(l.bottom - f.bottom) < 1 || l.top > p.bottom ? tc.retry(k) : l.top === p.bottom ? tc.retry(Nu(p, 1)) : Ab(r, c, p) ? tc.retry(Ag(k, Yc, 0)) : tc.none();
  }, Nb = {
    point: zm,
    adjuster: (r, c, l, f, p) => {
      const k = Rl(p, Yc);
      return Math.abs(l.top - f.top) < 1 || l.bottom < p.top ? tc.retry(k) : l.bottom === p.top ? tc.retry(Rl(p, 1)) : Ab(r, c, p) ? tc.retry(Ag(k, Yc, 0)) : tc.none();
    },
    move: Rl,
    gather: zu
  }, m0 = {
    point: l0,
    adjuster: f0,
    move: Nu,
    gather: Sm
  }, p0 = (r, c, l) => r.elementFromPoint(c, l).filter((f) => ue(f) === "table").isSome(), Rb = (r, c, l, f, p) => Am(r, c, l, c.move(f, Yc), p), Am = (r, c, l, f, p) => p === 0 ? L.some(f) : p0(r, f.left, c.point(f)) ? Rb(r, c, l, f, p - 1) : r.situsFromPoint(f.left, c.point(f)).bind((k) => k.start.fold(L.none, (C) => Tb(r, C).bind((z) => c.adjuster(r, C, z, l, f).fold(L.none, (I) => Am(r, c, l, I, p - 1))).orThunk(() => L.some(f)), L.none)), Db = (r, c, l) => r.point(c) > l.getInnerHeight() ? L.some(r.point(c) - l.getInnerHeight()) : r.point(c) < 0 ? L.some(-r.point(c)) : L.none(), Ng = (r, c, l) => {
    const f = r.move(l, Yc), p = Am(c, r, l, f, Ru).getOr(f);
    return Db(r, p, c).fold(() => c.situsFromPoint(p.left, r.point(p)), (k) => (c.scrollBy(0, k), c.situsFromPoint(p.left, r.point(p) - k)));
  }, Du = {
    tryUp: ot(Ng, Nb),
    tryDown: ot(Ng, m0),
    getJumpSize: ke(Yc)
  }, Ob = 20, Ou = (r, c, l) => r.getSelection().bind((f) => Kc(c, f.finish, f.foffset, l).fold(() => L.some(Ja(f.finish, f.foffset)), (p) => {
    const k = r.fromSitus(p), C = Gc.verify(r, f.finish, f.foffset, k.finish, k.foffset, l.failure, c);
    return zg(C);
  })), Dl = (r, c, l, f, p, k) => k === 0 ? L.none() : g0(r, c, l, f, p).bind((C) => {
    const z = r.fromSitus(C), I = Gc.verify(r, l, f, z.finish, z.foffset, p.failure, c);
    return Gc.cata(I, () => L.none(), () => L.some(C), (Y) => Et(l, Y) && f === 0 ? Nm(r, l, f, Rl, p) : Dl(r, c, Y, 0, p, k - 1), (Y) => Et(l, Y) && f === uo(Y) ? Nm(r, l, f, Nu, p) : Dl(r, c, Y, uo(Y), p, k - 1));
  }), Nm = (r, c, l, f, p) => Fs(r, c, l).bind((k) => Pb(r, p, f(k, Du.getJumpSize()))), Pb = (r, c, l) => {
    const f = On().browser;
    return f.isChromium() || f.isSafari() || f.isFirefox() ? c.retry(r, l) : L.none();
  }, g0 = (r, c, l, f, p) => Fs(r, l, f).bind((k) => Pb(r, p, k)), h0 = (r, c, l) => Ou(r, c, l).bind((f) => Dl(r, c, f.element, f.offset, l, Ob).map(r.fromSitus)), y0 = (r, c) => s0(r, (l) => q(l).exists((f) => Et(f, c))), Rg = (r, c, l, f, p) => Zn(f, "td,th", c).bind((k) => Zn(k, "table", c).bind((C) => y0(p, C) ? h0(r, c, l).bind((z) => Zn(z.finish, "td,th", c).map((I) => ({
    start: k,
    finish: I,
    range: z
  }))) : L.none())), Ol = (r, c, l, f, p, k) => k(f, c).orThunk(() => Rg(r, c, l, f, p).map((C) => {
    const z = C.range;
    return jr.create(L.some(_m(z.start, z.soffset, z.finish, z.foffset)), !0);
  })), Hf = (r, c) => Zn(r, "tr", c).bind((l) => Zn(l, "table", c).bind((f) => {
    const p = Ds(f, "tr");
    return Et(l, p[0]) ? o0(f, (k) => ja(k).isSome(), c).map((k) => {
      const C = uo(k);
      return jr.create(L.some(_m(k, C, k, C)), !0);
    }) : L.none();
  })), b0 = (r, c) => Zn(r, "tr", c).bind((l) => Zn(l, "table", c).bind((f) => {
    const p = Ds(f, "tr");
    return Et(l, p[p.length - 1]) ? Eg(f, (k) => Qa(k).isSome(), c).map((k) => jr.create(L.some(_m(k, 0, k, 0)), !0)) : L.none();
  })), Bb = (r, c, l, f, p, k, C) => Rg(r, l, f, p, k).bind((z) => vg(c, l, z.start, z.finish, C)), Rm = (r) => {
    let c = r;
    return {
      get: () => c,
      set: (p) => {
        c = p;
      }
    };
  }, Dg = (r) => {
    const c = Rm(L.none()), l = () => c.get().each(r);
    return {
      clear: () => {
        l(), c.set(L.none());
      },
      isSet: () => c.get().isSome(),
      get: () => c.get(),
      set: (z) => {
        l(), c.set(L.some(z));
      }
    };
  }, Pu = () => {
    const r = Dg(xe);
    return {
      ...r,
      on: (l) => r.get().each(l)
    };
  }, Dm = (r, c) => Zn(r, "td,th", c), Om = (r, c, l, f) => {
    const p = Pu(), k = p.clear, C = (he) => {
      p.on((ct) => {
        f.clearBeforeUpdate(c), Dm(he.target, l).each((Tt) => {
          Md(ct, Tt, l).each((Ct) => {
            const Ye = Ct.boxes.getOr([]);
            if (Ye.length === 1) {
              const Rt = Ye[0], Xe = jc(Rt) === "false", Kt = nt(fr(he.target), Rt, Et);
              Xe && Kt && (f.selectRange(c, Ye, Rt, Rt), r.selectContents(Rt));
            } else
              Ye.length > 1 && (f.selectRange(c, Ye, Ct.start, Ct.finish), r.selectContents(Tt));
          });
        });
      });
    };
    return {
      clearstate: k,
      mousedown: (he) => {
        f.clear(c), Dm(he.target, l).each(p.set);
      },
      mouseover: (he) => {
        C(he);
      },
      mouseup: (he) => {
        C(he), k();
      }
    };
  }, Pm = {
    traverse: vt,
    gather: Sm,
    relative: wr.before,
    retry: Du.tryDown,
    failure: Gc.failedDown
  }, Bm = {
    traverse: St,
    gather: zu,
    relative: wr.before,
    retry: Du.tryUp,
    failure: Gc.failedUp
  }, Bu = (r) => (c) => c === r, Og = Bu(38), $m = Bu(40), Fm = (r) => r >= 37 && r <= 40, $b = {
    isBackward: Bu(37),
    isForward: Bu(39)
  }, k0 = {
    isBackward: Bu(39),
    isForward: Bu(37)
  }, Fb = (r) => {
    const c = r !== void 0 ? r.dom : document, l = c.body.scrollLeft || c.documentElement.scrollLeft, f = c.body.scrollTop || c.documentElement.scrollTop;
    return Za(l, f);
  }, w0 = (r, c, l) => {
    const p = (l !== void 0 ? l.dom : document).defaultView;
    p && p.scrollBy(r, c);
  }, Im = kr.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Ib = (r) => Im.exact(r.start, r.soffset, r.finish, r.foffset), Wf = (r) => r.match({
    domRange: (c) => O.fromDom(c.startContainer),
    relative: (c, l) => wr.getStart(c),
    exact: (c, l, f, p) => c
  }), Lb = Im.domRange, _0 = Im.relative, v0 = Im.exact, C0 = (r) => {
    const c = Wf(r);
    return No(c);
  }, S0 = ua.create, $u = {
    domRange: Lb,
    relative: _0,
    exact: v0,
    exactFromRange: Ib,
    getWin: C0,
    range: S0
  }, x0 = (r, c, l) => {
    var f, p;
    return L.from((p = (f = r.dom).caretPositionFromPoint) === null || p === void 0 ? void 0 : p.call(f, c, l)).bind((k) => {
      if (k.offsetNode === null)
        return L.none();
      const C = r.dom.createRange();
      return C.setStart(k.offsetNode, k.offset), C.collapse(), L.some(C);
    });
  }, E0 = (r, c, l) => {
    var f, p;
    return L.from((p = (f = r.dom).caretRangeFromPoint) === null || p === void 0 ? void 0 : p.call(f, c, l));
  }, T0 = (() => document.caretPositionFromPoint ? x0 : document.caretRangeFromPoint ? E0 : L.none)(), z0 = (r, c, l) => {
    const f = O.fromDom(r.document);
    return T0(f, c, l).map((p) => ua.create(O.fromDom(p.startContainer), p.startOffset, O.fromDom(p.endContainer), p.endOffset));
  }, Lm = (r, c) => {
    const l = ue(r);
    return l === "input" ? wr.after(r) : Ze([
      "br",
      "img"
    ], l) ? c === 0 ? wr.before(r) : wr.after(r) : wr.on(r, c);
  }, A0 = (r, c) => {
    const l = r.fold(wr.before, Lm, wr.after), f = c.fold(wr.before, Lm, wr.after);
    return $u.relative(l, f);
  }, Mb = (r, c, l, f) => {
    const p = Lm(r, c), k = Lm(l, f);
    return $u.relative(p, k);
  }, jb = (r, c, l, f) => {
    const k = ln(r).dom.createRange();
    return k.setStart(r.dom, c), k.setEnd(l.dom, f), k;
  }, Pg = (r, c, l, f) => {
    const p = jb(r, c, l, f), k = Et(r, l) && c === f;
    return p.collapsed && !k;
  }, Mm = (r) => L.from(r.getSelection()), Bg = (r, c) => {
    Mm(r).each((l) => {
      l.removeAllRanges(), l.addRange(c);
    });
  }, $g = (r, c, l, f, p) => {
    const k = _g(r, c, l, f, p);
    Bg(r, k);
  }, Ub = (r, c, l, f, p, k) => {
    c.collapse(l.dom, f), c.extend(p.dom, k);
  }, Hb = (r, c) => _r(r, c).match({
    ltr: (l, f, p, k) => {
      $g(r, l, f, p, k);
    },
    rtl: (l, f, p, k) => {
      Mm(r).each((C) => {
        if (C.setBaseAndExtent)
          C.setBaseAndExtent(l.dom, f, p.dom, k);
        else if (C.extend)
          try {
            Ub(r, C, l, f, p, k);
          } catch {
            $g(r, p, k, l, f);
          }
        else
          $g(r, p, k, l, f);
      });
    }
  }), Wb = (r, c, l, f, p) => {
    const k = Mb(c, l, f, p);
    Hb(r, k);
  }, qb = (r, c, l) => {
    const f = A0(c, l);
    Hb(r, f);
  }, Vb = (r) => {
    if (r.rangeCount > 0) {
      const c = r.getRangeAt(0), l = r.getRangeAt(r.rangeCount - 1);
      return L.some(ua.create(O.fromDom(c.startContainer), c.startOffset, O.fromDom(l.endContainer), l.endOffset));
    } else
      return L.none();
  }, N0 = (r) => {
    if (r.anchorNode === null || r.focusNode === null)
      return Vb(r);
    {
      const c = O.fromDom(r.anchorNode), l = O.fromDom(r.focusNode);
      return Pg(c, r.anchorOffset, l, r.focusOffset) ? L.some(ua.create(c, r.anchorOffset, l, r.focusOffset)) : Vb(r);
    }
  }, Fg = (r, c, l = !0) => {
    const p = (l ? K_ : G_)(r, c);
    Bg(r, p);
  }, sn = (r) => Mm(r).filter((c) => c.rangeCount > 0).bind(N0), $i = (r) => sn(r).map((c) => $u.exact(c.start, c.soffset, c.finish, c.foffset)), R0 = (r, c) => {
    const l = qa(r, c);
    return wm(l);
  }, Gb = (r, c, l) => z0(r, c, l), jm = (r) => {
    Mm(r).each((c) => c.removeAllRanges());
  }, qf = (r) => ({
    elementFromPoint: (Xe, Kt) => O.fromPoint(O.fromDom(r.document), Xe, Kt),
    getRect: (Xe) => Xe.dom.getBoundingClientRect(),
    getRangedRect: (Xe, Kt, Cn, Fn) => {
      const Zo = $u.exact(Xe, Kt, Cn, Fn);
      return R0(r, Zo);
    },
    getSelection: () => $i(r).map((Xe) => wb(r, Xe)),
    fromSitus: (Xe) => {
      const Kt = $u.relative(Xe.start, Xe.finish);
      return wb(r, Kt);
    },
    situsFromPoint: (Xe, Kt) => Gb(r, Xe, Kt).map((Cn) => kb.create(Cn.start, Cn.soffset, Cn.finish, Cn.foffset)),
    clearSelection: () => {
      jm(r);
    },
    collapseSelection: (Xe = !1) => {
      $i(r).each((Kt) => Kt.fold((Cn) => Cn.collapse(Xe), (Cn, Fn) => {
        const Zo = Xe ? Cn : Fn;
        qb(r, Zo, Zo);
      }, (Cn, Fn, Zo, Is) => {
        const Yo = Xe ? Cn : Zo, Hr = Xe ? Fn : Is;
        Wb(r, Yo, Hr, Yo, Hr);
      }));
    },
    setSelection: (Xe) => {
      Wb(r, Xe.start, Xe.soffset, Xe.finish, Xe.foffset);
    },
    setRelativeSelection: (Xe, Kt) => {
      qb(r, Xe, Kt);
    },
    selectNode: (Xe) => {
      Fg(r, Xe, !1);
    },
    selectContents: (Xe) => {
      Fg(r, Xe);
    },
    getInnerHeight: () => r.innerHeight,
    getScrollY: () => Fb(O.fromDom(r.document)).top,
    scrollBy: (Xe, Kt) => {
      w0(Xe, Kt, O.fromDom(r.document));
    }
  }), Fu = (r, c) => ({
    rows: r,
    cols: c
  }), Kb = (r, c, l, f) => {
    const p = qf(r), k = Om(p, c, l, f);
    return {
      clearstate: k.clearstate,
      mousedown: k.mousedown,
      mouseover: k.mouseover,
      mouseup: k.mouseup
    };
  }, D0 = (r, c, l, f) => {
    const p = qf(r), k = () => (f.clear(c), L.none());
    return {
      keydown: (I, Y, he, ct, Tt, Ct) => {
        const Ye = I.raw, Rt = Ye.which, Xe = Ye.shiftKey === !0;
        return jd(c, f.selectedSelector).fold(() => (Fm(Rt) && !Xe && f.clearBeforeUpdate(c), $m(Rt) && Xe ? ot(Bb, p, c, l, Pm, ct, Y, f.selectRange) : Og(Rt) && Xe ? ot(Bb, p, c, l, Bm, ct, Y, f.selectRange) : $m(Rt) ? ot(Ol, p, l, Pm, ct, Y, b0) : Og(Rt) ? ot(Ol, p, l, Bm, ct, Y, Hf) : L.none), (Cn) => {
          const Fn = (Zo) => () => Ue(Zo, (Yo) => vm(Yo.rows, Yo.cols, c, Cn, f)).fold(() => rw(c, f.firstSelectedSelector, f.lastSelectedSelector).map((Yo) => {
            const Hr = $m(Rt) || Ct.isForward(Rt) ? wr.after : wr.before;
            return p.setRelativeSelection(wr.on(Yo.first, 0), Hr(Yo.table)), f.clear(c), jr.create(L.none(), !0);
          }), (Yo) => L.some(jr.create(L.none(), !0)));
          return $m(Rt) && Xe ? Fn([Fu(1, 0)]) : Og(Rt) && Xe ? Fn([Fu(-1, 0)]) : Ct.isBackward(Rt) && Xe ? Fn([
            Fu(0, -1),
            Fu(-1, 0)
          ]) : Ct.isForward(Rt) && Xe ? Fn([
            Fu(0, 1),
            Fu(1, 0)
          ]) : Fm(Rt) && !Xe ? k : L.none;
        })();
      },
      keyup: (I, Y, he, ct, Tt) => jd(c, f.selectedSelector).fold(() => {
        const Ct = I.raw, Ye = Ct.which;
        return Ct.shiftKey === !0 && Fm(Ye) ? _b(c, l, Y, he, ct, Tt, f.selectRange) : L.none();
      }, L.none)
    };
  }, O0 = (r, c, l, f) => {
    const p = qf(r);
    return (k, C) => {
      f.clearBeforeUpdate(c), Md(k, C, l).each((z) => {
        const I = z.boxes.getOr([]);
        f.selectRange(c, I, z.start, z.finish), p.selectContents(C), p.collapseSelection();
      });
    };
  }, Um = (r, c) => {
    const l = gn(r, c);
    return l === void 0 || l === "" ? [] : l.split(" ");
  }, Ig = (r, c, l) => {
    const p = Um(r, c).concat([l]);
    return wo(r, c, p.join(" ")), !0;
  }, Vf = (r, c, l) => {
    const f = Rn(Um(r, c), (p) => p !== l);
    return f.length > 0 ? wo(r, c, f.join(" ")) : lo(r, c), !1;
  }, Gf = (r) => r.dom.classList !== void 0, P0 = (r) => Um(r, "class"), B0 = (r, c) => Ig(r, "class", c), $0 = (r, c) => Vf(r, "class", c), Fi = (r, c) => {
    Gf(r) ? r.dom.classList.add(c) : B0(r, c);
  }, Yb = (r) => {
    (Gf(r) ? r.dom.classList : P0(r)).length === 0 && lo(r, "class");
  }, F0 = (r, c) => {
    Gf(r) ? r.dom.classList.remove(c) : $0(r, c), Yb(r);
  }, Lg = (r, c) => Gf(r) && r.dom.classList.contains(c), I0 = (r, c) => {
    yt(c, (l) => {
      F0(r, l);
    });
  }, L0 = (r) => (c) => {
    Fi(c, r);
  }, Mg = (r) => (c) => {
    I0(c, r);
  }, M0 = {
    byClass: (r) => {
      const c = L0(r.selected), l = Mg([
        r.selected,
        r.lastSelected,
        r.firstSelected
      ]), f = (k) => {
        const C = Ds(k, r.selectedSelector);
        yt(C, l);
      };
      return {
        clearBeforeUpdate: f,
        clear: f,
        selectRange: (k, C, z, I) => {
          f(k), yt(C, c), Fi(z, r.firstSelected), Fi(I, r.lastSelected);
        },
        selectedSelector: r.selectedSelector,
        firstSelectedSelector: r.firstSelectedSelector,
        lastSelectedSelector: r.lastSelectedSelector
      };
    },
    byAttr: (r, c, l) => {
      const f = (I) => {
        lo(I, r.selected), lo(I, r.firstSelected), lo(I, r.lastSelected);
      }, p = (I) => {
        wo(I, r.selected, "1");
      }, k = (I) => {
        C(I), l();
      }, C = (I) => {
        const Y = Ds(I, `${r.selectedSelector},${r.firstSelectedSelector},${r.lastSelectedSelector}`);
        yt(Y, f);
      };
      return {
        clearBeforeUpdate: C,
        clear: k,
        selectRange: (I, Y, he, ct) => {
          k(I), yt(Y, p), wo(he, r.firstSelected, "1"), wo(ct, r.lastSelected, "1"), c(Y, he, ct);
        },
        selectedSelector: r.selectedSelector,
        firstSelectedSelector: r.firstSelectedSelector,
        lastSelectedSelector: r.lastSelectedSelector
      };
    }
  }, j0 = (r, c, l, f) => {
    switch (r.tag) {
      case "none":
        return c();
      case "single":
        return f(r.element);
      case "multiple":
        return l(r.elements);
    }
  }, U0 = () => ({ tag: "none" }), Xc = (r) => ({
    tag: "multiple",
    elements: r
  }), Hm = (r) => ({
    tag: "single",
    element: r
  }), H0 = (r, c, l) => ({ get: () => Lc(r(), l).fold(() => c().fold(U0, Hm), Xc) }), W0 = (r, c) => {
    const l = r.slice(0, c[c.length - 1].row + 1), f = Tf(l);
    return re(f, (p) => {
      const k = p.cells.slice(0, c[c.length - 1].column + 1);
      return Pe(k, (C) => C.element);
    });
  }, q0 = (r, c) => {
    const l = r.slice(c[0].row + c[0].rowspan - 1, r.length), f = Tf(l);
    return re(f, (p) => {
      const k = p.cells.slice(c[0].column + c[0].colspan - 1, p.cells.length);
      return Pe(k, (C) => C.element);
    });
  }, V0 = (r, c, l) => {
    const f = In.fromTable(r);
    return Uc(f, c).map((k) => {
      const C = Ef(f, l, !1), { rows: z } = _s(C), I = W0(z, k), Y = q0(z, k);
      return {
        upOrLeftCells: I,
        downOrRightCells: Y
      };
    });
  }, G0 = (r, c, l, f, p, k, C) => ({
    target: r,
    x: c,
    y: l,
    stop: f,
    prevent: p,
    kill: k,
    raw: C
  }), Xb = (r) => {
    const c = O.fromDom(ks(r).getOr(r.target)), l = () => r.stopPropagation(), f = () => r.preventDefault(), p = rt(f, l);
    return G0(c, r.clientX, r.clientY, l, f, p, r);
  }, K0 = (r, c) => (l) => {
    r(l) && c(Xb(l));
  }, Iu = (r, c, l, f, p) => {
    const k = K0(l, f);
    return r.dom.addEventListener(c, k, p), { unbind: ot(Y0, r, c, k, p) };
  }, Wm = (r, c, l, f) => Iu(r, c, l, f, !1), Y0 = (r, c, l, f) => {
    r.dom.removeEventListener(c, l, f);
  }, Zb = Ve, Lu = (r, c, l) => Wm(r, c, Zb, l), Pl = Xb, jg = (r) => Lg(O.fromDom(r.target), "ephox-snooker-resizer-bar") === !1, X0 = (r, c) => {
    const l = H0(() => O.fromDom(r.getBody()), () => jp(gc(r), Ua(r)), Mc.selectedSelector), f = (I, Y, he) => {
      Us(Y).each((Tt) => {
        const Ct = Wy(r), Ye = Ko(xe, O.fromDom(r.getDoc()), Ct), Rt = hc(r), Xe = V0(Tt, { selection: Rt }, Ye);
        y_(r, I, Y, he, Xe);
      });
    }, p = () => b_(r), k = M0.byAttr(Mc, f, p);
    return r.on("init", (I) => {
      const Y = r.getWin(), he = cu(r), ct = Ua(r), Tt = () => {
        const Oo = r.selection, dr = O.fromDom(Oo.getStart()), mr = O.fromDom(Oo.getEnd());
        Id(Us, [
          dr,
          mr
        ]).fold(() => k.clear(he), xe);
      }, Ct = Kb(Y, he, ct, k), Ye = D0(Y, he, ct, k), Rt = O0(Y, he, ct, k), Xe = (Oo) => Oo.raw.shiftKey === !0;
      r.on("TableSelectorChange", (Oo) => Rt(Oo.start, Oo.finish));
      const Kt = (Oo, dr) => {
        !Xe(Oo) || (dr.kill && Oo.kill(), dr.selection.each((mr) => {
          const Va = $u.relative(mr.start, mr.finish), Ea = qa(Y, Va);
          r.selection.setRng(Ea);
        }));
      }, Cn = (Oo) => {
        const dr = Pl(Oo);
        if (dr.raw.shiftKey && Fm(dr.raw.which)) {
          const mr = r.selection.getRng(), Va = O.fromDom(mr.startContainer), Ea = O.fromDom(mr.endContainer);
          Ye.keyup(dr, Va, mr.startOffset, Ea, mr.endOffset).each((Wu) => {
            Kt(dr, Wu);
          });
        }
      }, Fn = (Oo) => {
        const dr = Pl(Oo);
        c.hide();
        const mr = r.selection.getRng(), Va = O.fromDom(mr.startContainer), Ea = O.fromDom(mr.endContainer), Wu = lf($b, k0)(O.fromDom(r.selection.getStart()));
        Ye.keydown(dr, Va, mr.startOffset, Ea, mr.endOffset, Wu).each((or) => {
          Kt(dr, or);
        }), c.show();
      }, Zo = (Oo) => Oo.button === 0, Is = (Oo) => Oo.buttons === void 0 ? !0 : (Oo.buttons & 1) !== 0, Yo = (Oo) => {
        Ct.clearstate();
      }, Hr = (Oo) => {
        Zo(Oo) && jg(Oo) && Ct.mousedown(Pl(Oo));
      }, Hu = (Oo) => {
        Is(Oo) && jg(Oo) && Ct.mouseover(Pl(Oo));
      }, Yf = (Oo) => {
        Zo(Oo) && jg(Oo) && Ct.mouseup(Pl(Oo));
      }, Qm = (() => {
        const Oo = Rm(O.fromDom(he)), dr = Rm(0);
        return { touchEnd: (Va) => {
          const Ea = O.fromDom(Va.target);
          if (To("td")(Ea) || To("th")(Ea)) {
            const Wu = Oo.get(), or = dr.get();
            Et(Wu, Ea) && Va.timeStamp - or < 300 && (Va.preventDefault(), Rt(Ea, Ea));
          }
          Oo.set(Ea), dr.set(Va.timeStamp);
        } };
      })();
      r.on("dragstart", Yo), r.on("mousedown", Hr), r.on("mouseover", Hu), r.on("mouseup", Yf), r.on("touchend", Qm.touchEnd), r.on("keyup", Cn), r.on("keydown", Fn), r.on("NodeChange", Tt);
    }), r.on("PreInit", () => {
      r.serializer.addTempAttr(Mc.firstSelected), r.serializer.addTempAttr(Mc.lastSelected);
    }), {
      getSelectedCells: () => j0(l.get(), ke([]), (I) => Pe(I, (Y) => Y.dom), (I) => [I.dom]),
      clearSelectedCells: (I) => k.clear(O.fromDom(I))
    };
  }, Sa = (r) => {
    let c = [];
    return {
      bind: (k) => {
        if (k === void 0)
          throw new Error("Event bind error: undefined handler");
        c.push(k);
      },
      unbind: (k) => {
        c = Rn(c, (C) => C !== k);
      },
      trigger: (...k) => {
        const C = {};
        yt(r, (z, I) => {
          C[z] = k[I];
        }), yt(c, (z) => {
          z(C);
        });
      }
    };
  }, Zc = (r) => {
    const c = En(r, (f) => ({
      bind: f.bind,
      unbind: f.unbind
    })), l = En(r, (f) => f.trigger);
    return {
      registry: c,
      trigger: l
    };
  }, Z0 = (r, c) => {
    let l = null;
    const f = () => {
      Ie(l) || (clearTimeout(l), l = null);
    };
    return {
      cancel: f,
      throttle: (...k) => {
        f(), l = setTimeout(() => {
          l = null, r.apply(null, k);
        }, c);
      }
    };
  }, Mu = (r) => r.slice(0).sort(), Q0 = (r, c) => {
    throw new Error("All required keys (" + Mu(r).join(", ") + ") were not specified. Specified keys were: " + Mu(c).join(", ") + ".");
  }, Ug = (r) => {
    throw new Error("Unsupported keys for object: " + Mu(r).join(", "));
  }, J0 = (r, c) => {
    if (!Ee(c))
      throw new Error("The " + r + " fields must be an array. Was: " + c + ".");
    yt(c, (l) => {
      if (!We(l))
        throw new Error("The value " + l + " in the " + r + " fields was not a string.");
    });
  }, ev = (r, c) => {
    throw new Error("All values need to be of type: " + c + ". Keys (" + Mu(r).join(", ") + ") were not.");
  }, Qb = (r) => {
    const c = Mu(r);
    wn(c, (f, p) => p < c.length - 1 && f === c[p + 1]).each((f) => {
      throw new Error("The field: " + f + " occurs more than once in the combined fields: [" + c.join(", ") + "].");
    });
  }, tv = (r, c) => nv(r, c, {
    validate: Ne,
    label: "function"
  }), nv = (r, c, l) => {
    if (c.length === 0)
      throw new Error("You must specify at least one required field.");
    return J0("required", c), Qb(c), (f) => {
      const p = kt(f);
      we(c, (z) => Ze(p, z)) || Q0(c, p), r(c, p);
      const C = Rn(c, (z) => !l.validate(f[z], z));
      return C.length > 0 && ev(C, l.label), f;
    };
  }, Hg = (r, c) => {
    const l = Rn(c, (f) => !Ze(r, f));
    l.length > 0 && Ug(l);
  }, qm = (r) => tv(Hg, r), Vm = qm([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]), Gm = qm([
    "element",
    "start",
    "stop",
    "destroy"
  ]), Km = qm([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]), ju = () => {
    let r = L.none();
    const c = () => {
      r = L.none();
    }, l = (k, C) => {
      const z = r.map((I) => k.compare(I, C));
      return r = L.some(C), z;
    }, f = (k, C) => {
      C.extract(k).each((I) => {
        l(C, I).each((he) => {
          p.trigger.move(he);
        });
      });
    }, p = Zc({ move: Sa(["info"]) });
    return {
      onEvent: f,
      reset: c,
      events: p.registry
    };
  }, xx = () => {
    const r = Zc({ move: Sa(["info"]) });
    return {
      onEvent: xe,
      reset: xe,
      events: r.registry
    };
  }, ov = () => {
    const r = xx(), c = ju();
    let l = r;
    return {
      on: () => {
        l.reset(), l = c;
      },
      off: () => {
        l.reset(), l = r;
      },
      isOn: () => l === c,
      onEvent: (z, I) => {
        l.onEvent(z, I);
      },
      events: c.events
    };
  }, sv = (r, c, l) => {
    let f = !1;
    const p = Zc({
      start: Sa([]),
      stop: Sa([])
    }), k = ov(), C = () => {
      Ct.stop(), k.isOn() && (k.off(), p.trigger.stop());
    }, z = Z0(C, 200), I = (Rt) => {
      Ct.start(Rt), k.on(), p.trigger.start();
    }, Y = (Rt) => {
      z.cancel(), k.onEvent(Rt, c);
    };
    k.events.move.bind((Rt) => {
      c.mutate(r, Rt.info);
    });
    const he = () => {
      f = !0;
    }, ct = () => {
      f = !1;
    }, Tt = (Rt) => (...Xe) => {
      f && Rt.apply(null, Xe);
    }, Ct = c.sink(Km({
      forceDrop: C,
      drop: Tt(C),
      move: Tt(Y),
      delayDrop: Tt(z.throttle)
    }), l), Ye = () => {
      Ct.destroy();
    };
    return {
      element: Ct.element,
      go: I,
      on: he,
      off: ct,
      destroy: Ye,
      events: p.registry
    };
  }, Wg = (r) => {
    const c = r.replace(/\./g, "-");
    return { resolve: (f) => c + "-" + f };
  }, Jb = Wg("ephox-dragster").resolve, Ex = (r) => {
    const c = {
      layerClass: Jb("blocker"),
      ...r
    }, l = O.fromTag("div");
    return wo(l, "role", "presentation"), ko(l, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    }), Fi(l, Jb("blocker")), Fi(l, c.layerClass), {
      element: ke(l),
      destroy: () => {
        Jo(l);
      }
    };
  };
  var av = Vm({
    compare: (r, c) => Za(c.left - r.left, c.top - r.top),
    extract: (r) => L.some(Za(r.x, r.y)),
    sink: (r, c) => {
      const l = Ex(c), f = Lu(l.element(), "mousedown", r.forceDrop), p = Lu(l.element(), "mouseup", r.drop), k = Lu(l.element(), "mousemove", r.move), C = Lu(l.element(), "mouseout", r.delayDrop), z = () => {
        l.destroy(), p.unbind(), k.unbind(), C.unbind(), f.unbind();
      }, I = (he) => {
        Dn(he, l.element());
      }, Y = () => {
        Jo(l.element());
      };
      return Gm({
        element: l.element,
        start: I,
        stop: Y,
        destroy: z
      });
    },
    mutate: (r, c) => {
      r.mutate(c.left, c.top);
    }
  });
  const cv = (r, c = {}) => {
    var l;
    const f = (l = c.mode) !== null && l !== void 0 ? l : av;
    return sv(r, f, c);
  }, Kf = Wg("ephox-snooker").resolve, iv = () => {
    const r = Zc({
      drag: Sa([
        "xDelta",
        "yDelta"
      ])
    });
    return {
      mutate: (l, f) => {
        r.trigger.drag(l, f);
      },
      events: r.registry
    };
  }, lv = () => {
    const r = Zc({
      drag: Sa([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let c = L.none();
    const l = iv();
    return l.events.drag.bind((k) => {
      c.each((C) => {
        r.trigger.drag(k.xDelta, k.yDelta, C);
      });
    }), {
      assign: (k) => {
        c = L.some(k);
      },
      get: () => c,
      mutate: l.mutate,
      events: r.registry
    };
  }, t1 = (r, c, l, f, p) => {
    const k = O.fromTag("div");
    return ko(k, {
      position: "absolute",
      left: c - f / 2 + "px",
      top: l + "px",
      height: p + "px",
      width: f + "px"
    }), os(k, {
      "data-column": r,
      role: "presentation"
    }), k;
  }, n1 = (r, c, l, f, p) => {
    const k = O.fromTag("div");
    return ko(k, {
      position: "absolute",
      left: c + "px",
      top: l - p / 2 + "px",
      height: p + "px",
      width: f + "px"
    }), os(k, {
      "data-row": r,
      role: "presentation"
    }), k;
  }, qg = Kf("resizer-bar"), Vg = Kf("resizer-rows"), o1 = Kf("resizer-cols"), Ym = 7, s1 = (r, c) => re(r.all, (l, f) => c(l.element) ? [f] : []), r1 = (r, c) => {
    const l = [];
    return Z(r.grid.columns, (f) => {
      In.getColumnAt(r, f).map((k) => k.element).forall(c) && l.push(f);
    }), Rn(l, (f) => {
      const p = In.filterItems(r, (k) => k.column === f);
      return we(p, (k) => c(k.element));
    });
  }, Xm = (r) => {
    const c = Ds(r.parent(), "." + qg);
    yt(c, Jo);
  }, a1 = (r, c, l) => {
    const f = r.origin();
    yt(c, (p) => {
      p.each((k) => {
        const C = l(f, k);
        Fi(C, qg), Dn(r.parent(), C);
      });
    });
  }, uv = (r, c, l, f) => {
    a1(r, c, (p, k) => {
      const C = t1(k.col, k.x - p.left, l.top - p.top, Ym, f);
      return Fi(C, o1), C;
    });
  }, fv = (r, c, l, f) => {
    a1(r, c, (p, k) => {
      const C = n1(k.row, l.left - p.left, k.y - p.top, f, Ym);
      return Fi(C, Vg), C;
    });
  }, dv = (r, c, l, f, p) => {
    const k = La(l), C = c.isResizable, z = f.length > 0 ? fl.positions(f, l) : [], I = z.length > 0 ? s1(r, C) : [], Y = Rn(z, (Ct, Ye) => qt(I, (Rt) => Ye === Rt));
    fv(c, Y, k, yr(l));
    const he = p.length > 0 ? vi.positions(p, l) : [], ct = he.length > 0 ? r1(r, C) : [], Tt = Rn(he, (Ct, Ye) => qt(ct, (Rt) => Ye === Rt));
    uv(c, Tt, k, aa(l));
  }, Gg = (r, c) => {
    if (Xm(r), r.isResizable(c)) {
      const l = In.fromTable(c), f = af(l), p = fc(l);
      dv(l, r, c, f, p);
    }
  }, Uu = (r, c) => {
    const l = Ds(r.parent(), "." + qg);
    yt(l, c);
  }, c1 = (r) => {
    Uu(r, (c) => {
      qn(c, "display", "none");
    });
  }, i1 = (r) => {
    Uu(r, (c) => {
      qn(c, "display", "block");
    });
  }, Kg = (r) => Lg(r, Vg), mv = (r) => Lg(r, o1), l1 = Kf("resizer-bar-dragging"), pv = (r) => {
    const c = lv(), l = cv(c, {});
    let f = L.none();
    const p = (Ye, Rt) => L.from(gn(Ye, Rt));
    c.events.drag.bind((Ye) => {
      p(Ye.target, "data-row").each((Rt) => {
        const Xe = as(Ye.target, "top");
        qn(Ye.target, "top", Xe + Ye.yDelta + "px");
      }), p(Ye.target, "data-column").each((Rt) => {
        const Xe = as(Ye.target, "left");
        qn(Ye.target, "left", Xe + Ye.xDelta + "px");
      });
    });
    const k = (Ye, Rt) => {
      const Xe = as(Ye, Rt), Kt = es(Ye, "data-initial-" + Rt, 0);
      return Xe - Kt;
    };
    l.events.stop.bind(() => {
      c.get().each((Ye) => {
        f.each((Rt) => {
          p(Ye, "data-row").each((Xe) => {
            const Kt = k(Ye, "top");
            lo(Ye, "data-initial-top"), Ct.trigger.adjustHeight(Rt, Kt, parseInt(Xe, 10));
          }), p(Ye, "data-column").each((Xe) => {
            const Kt = k(Ye, "left");
            lo(Ye, "data-initial-left"), Ct.trigger.adjustWidth(Rt, Kt, parseInt(Xe, 10));
          }), Gg(r, Rt);
        });
      });
    });
    const C = (Ye, Rt) => {
      Ct.trigger.startAdjust(), c.assign(Ye), wo(Ye, "data-initial-" + Rt, as(Ye, Rt)), Fi(Ye, l1), qn(Ye, "opacity", "0.2"), l.go(r.parent());
    }, z = Lu(r.parent(), "mousedown", (Ye) => {
      Kg(Ye.target) && C(Ye.target, "top"), mv(Ye.target) && C(Ye.target, "left");
    }), I = (Ye) => Et(Ye, r.view()), Y = (Ye) => Zn(Ye, "table", I).filter(Vh), he = Lu(r.view(), "mouseover", (Ye) => {
      Y(Ye.target).fold(() => {
        Ro(Ye.target) && Xm(r);
      }, (Rt) => {
        f = L.some(Rt), Gg(r, Rt);
      });
    }), ct = () => {
      z.unbind(), he.unbind(), l.destroy(), Xm(r);
    }, Tt = (Ye) => {
      Gg(r, Ye);
    }, Ct = Zc({
      adjustHeight: Sa([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: Sa([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: Sa([])
    });
    return {
      destroy: ct,
      refresh: Tt,
      on: l.on,
      off: l.off,
      hideBars: ot(c1, r),
      showBars: ot(i1, r),
      events: Ct.registry
    };
  }, u1 = { create: (r, c, l) => {
    const f = fl, p = vi, k = pv(r), C = Zc({
      beforeResize: Sa([
        "table",
        "type"
      ]),
      afterResize: Sa([
        "table",
        "type"
      ]),
      startDrag: Sa([])
    });
    return k.events.adjustHeight.bind((z) => {
      const I = z.table;
      C.trigger.beforeResize(I, "row");
      const Y = f.delta(z.delta, I);
      om(I, Y, z.row, f), C.trigger.afterResize(I, "row");
    }), k.events.startAdjust.bind((z) => {
      C.trigger.startDrag();
    }), k.events.adjustWidth.bind((z) => {
      const I = z.table;
      C.trigger.beforeResize(I, "col");
      const Y = p.delta(z.delta, I), he = l(I);
      ng(I, Y, z.column, c, he), C.trigger.afterResize(I, "col");
    }), {
      on: k.on,
      off: k.off,
      refreshBars: k.refresh,
      hideBars: k.hideBars,
      showBars: k.showBars,
      destroy: k.destroy,
      events: C.registry
    };
  } }, f1 = {
    only: (r, c) => {
      const l = xs(r) ? Mo(r) : r;
      return {
        parent: ke(l),
        view: ke(r),
        origin: ke(Za(0, 0)),
        isResizable: c
      };
    },
    detached: (r, c, l) => {
      const f = () => La(c);
      return {
        parent: ke(c),
        view: ke(r),
        origin: f,
        isResizable: l
      };
    },
    body: (r, c, l) => ({
      parent: ke(c),
      view: ke(r),
      origin: ke(Za(0, 0)),
      isResizable: l
    })
  }, hv = () => {
    const r = O.fromTag("div");
    return ko(r, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    }), Dn(Oa(), r), r;
  }, yv = (r, c) => r.inline ? f1.body(O.fromDom(r.getBody()), hv(), c) : f1.only(O.fromDom(r.getDoc()), c), Yg = (r, c) => {
    r.inline && Jo(c.parent());
  }, Zm = (r) => $e(r) && r.tagName === "TABLE", Xg = "bar-", Ox = (r) => gn(r, "data-mce-resize") !== "false", d1 = (r) => {
    const c = In.fromTable(r);
    In.hasColumns(c) || yt(Xa(r), (l) => {
      const f = Qs(l, "width");
      qn(l, "width", f), lo(l, "width");
    });
  }, bv = (r) => {
    const c = Pu(), l = Pu(), f = Pu();
    let p, k;
    const C = (Ye) => Yy(r, Ye), z = () => Vy(r) ? fu() : jh(), I = (Ye) => Yd(Ye).columns, Y = (Ye, Rt, Xe) => {
      const Kt = V(Rt, "e");
      if (k === "" && wu(Ye), Xe !== p && k !== "") {
        qn(Ye, "width", k);
        const Cn = z(), Fn = C(Ye), Zo = Vy(r) || Kt ? I(Ye) - 1 : 0;
        ng(Ye, Xe - p, Zo, Cn, Fn);
      } else if (Ph(k)) {
        const Cn = parseFloat(k.replace("%", "")), Fn = Xe * Cn / p;
        qn(Ye, "width", Fn + "%");
      }
      qk(k) && d1(Ye);
    }, he = () => {
      l.on((Ye) => {
        Ye.destroy();
      }), f.on((Ye) => {
        Yg(r, Ye);
      });
    };
    return r.on("init", () => {
      const Ye = yv(r, Ox);
      if (f.set(Ye), S_(r) && x_(r)) {
        const Rt = z(), Xe = u1.create(Ye, Rt, C);
        Xe.on(), Xe.events.startDrag.bind((Kt) => {
          c.set(r.selection.getRng());
        }), Xe.events.beforeResize.bind((Kt) => {
          const Cn = Kt.table.dom;
          k_(r, Cn, Oh(Cn), Op(Cn), Xg + Kt.type);
        }), Xe.events.afterResize.bind((Kt) => {
          const Cn = Kt.table, Fn = Cn.dom;
          Ha(Cn), c.on((Zo) => {
            r.selection.setRng(Zo), r.focus();
          }), w_(r, Fn, Oh(Fn), Op(Fn), Xg + Kt.type), r.undoManager.add();
        }), l.set(Xe);
      }
    }), r.on("ObjectResizeStart", (Ye) => {
      const Rt = Ye.target;
      if (Zm(Rt)) {
        const Xe = O.fromDom(Rt);
        yt(r.dom.select(".mce-clonedresizable"), (Kt) => {
          r.dom.addClass(Kt, "mce-" + ug(r) + "-columns");
        }), !pg(Xe) && Vc(r) ? El(Xe) : !sb(Xe) && mm(r) && wu(Xe), rb(Xe) && $(Ye.origin, Xg) && wu(Xe), p = Ye.width, k = Pf(r) ? "" : Wk(r, Rt).getOr("");
      }
    }), r.on("ObjectResized", (Ye) => {
      const Rt = Ye.target;
      if (Zm(Rt)) {
        const Xe = O.fromDom(Rt), Kt = Ye.origin;
        $(Kt, "corner-") && Y(Xe, Kt, Ye.width), Ha(Xe), Cl(r, Xe.dom, dm);
      }
    }), r.on("SwitchMode", () => {
      l.on((Ye) => {
        r.mode.isReadOnly() ? Ye.hideBars() : Ye.showBars();
      });
    }), r.on("remove", () => {
      he();
    }), {
      refresh: (Ye) => {
        l.on((Rt) => Rt.refreshBars(O.fromDom(Ye)));
      },
      hide: () => {
        l.on((Ye) => Ye.hideBars());
      },
      show: () => {
        l.on((Ye) => Ye.showBars());
      }
    };
  }, kv = (r) => {
    Hy(r);
    const c = bv(r), l = X0(r, c), f = A_(r, c, l);
    return ub(r, f), wg(r, f), dw(r, f), {
      getSelectedCells: l.getSelectedCells,
      clearSelectedCells: l.clearSelectedCells
    };
  }, xa = (r) => ({ table: kv(r) });
  var wv = () => {
    g.add("dom", xa);
  };
  wv();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (O, G, de) => {
    var dt;
    return de(O, G.prototype) ? !0 : ((dt = O.constructor) === null || dt === void 0 ? void 0 : dt.name) === G.name;
  }, D = (O) => {
    const G = typeof O;
    return O === null ? "null" : G === "object" && Array.isArray(O) ? "array" : G === "object" && _(O, String, (de, dt) => dt.isPrototypeOf(de)) ? "string" : G;
  }, X = (O) => (G) => D(G) === O, _e = X("string"), Ae = X("object"), We = X("array"), Ke = (O) => O == null, Ee = (O) => !Ke(O);
  class Ie {
    constructor(G, de) {
      this.tag = G, this.value = de;
    }
    static some(G) {
      return new Ie(!0, G);
    }
    static none() {
      return Ie.singletonNone;
    }
    fold(G, de) {
      return this.tag ? de(this.value) : G();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(G) {
      return this.tag ? Ie.some(G(this.value)) : Ie.none();
    }
    bind(G) {
      return this.tag ? G(this.value) : Ie.none();
    }
    exists(G) {
      return this.tag && G(this.value);
    }
    forall(G) {
      return !this.tag || G(this.value);
    }
    filter(G) {
      return !this.tag || G(this.value) ? this : Ie.none();
    }
    getOr(G) {
      return this.tag ? this.value : G;
    }
    or(G) {
      return this.tag ? this : G;
    }
    getOrThunk(G) {
      return this.tag ? this.value : G();
    }
    orThunk(G) {
      return this.tag ? this : G();
    }
    getOrDie(G) {
      if (this.tag)
        return this.value;
      throw new Error(G != null ? G : "Called getOrDie on None");
    }
    static from(G) {
      return Ee(G) ? Ie.some(G) : Ie.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(G) {
      this.tag && G(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ie.singletonNone = new Ie(!1);
  const pt = Array.prototype.push, _t = (O, G) => {
    for (let de = 0, dt = O.length; de < dt; de++) {
      const rn = O[de];
      G(rn, de);
    }
  }, $e = (O) => {
    const G = [];
    for (let de = 0, dt = O.length; de < dt; ++de) {
      if (!We(O[de]))
        throw new Error("Arr.flatten item " + de + " was not an array, input: " + O);
      pt.apply(G, O[de]);
    }
    return G;
  }, Ne = (O) => {
    let G = O;
    return {
      get: () => G,
      set: (rn) => {
        G = rn;
      }
    };
  }, tt = Object.keys, xe = Object.hasOwnProperty, rt = (O, G) => {
    const de = tt(O);
    for (let dt = 0, rn = de.length; dt < rn; dt++) {
      const Et = de[dt], An = O[Et];
      G(An, Et);
    }
  }, ae = (O, G) => ke(O, G) ? Ie.from(O[G]) : Ie.none(), ke = (O, G) => xe.call(O, G), ge = (O) => (G) => G.options.get(O), zt = (O) => {
    const G = O.options.register;
    G("audio_template_callback", { processor: "function" }), G("video_template_callback", { processor: "function" }), G("iframe_template_callback", { processor: "function" }), G("media_live_embeds", {
      processor: "boolean",
      default: !0
    }), G("media_filter_html", {
      processor: "boolean",
      default: !0
    }), G("media_url_resolver", { processor: "function" }), G("media_alt_source", {
      processor: "boolean",
      default: !0
    }), G("media_poster", {
      processor: "boolean",
      default: !0
    }), G("media_dimensions", {
      processor: "boolean",
      default: !0
    });
  }, ot = ge("audio_template_callback"), le = ge("video_template_callback"), it = ge("iframe_template_callback"), ft = ge("media_live_embeds"), Le = ge("media_filter_html"), Ve = ge("media_url_resolver"), L = ge("media_alt_source"), Wt = ge("media_poster"), Je = ge("media_dimensions");
  var jt = tinymce.util.Tools.resolve("tinymce.util.Tools"), ye = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Ze = tinymce.util.Tools.resolve("tinymce.html.DomParser");
  const qt = ye.DOM, Z = (O) => O.replace(/px$/, ""), Pe = (O) => {
    const G = O.attr("style"), de = G ? qt.parseStyle(G) : {};
    return {
      type: "ephox-embed-iri",
      source: O.attr("data-ephox-embed-iri"),
      altsource: "",
      poster: "",
      width: ae(de, "max-width").map(Z).getOr(""),
      height: ae(de, "max-height").map(Z).getOr("")
    };
  }, yt = (O, G) => {
    let de = {};
    const rn = Ze({
      validate: !1,
      forced_root_block: !1
    }, G).parse(O);
    for (let Et = rn; Et; Et = Et.walk())
      if (Et.type === 1) {
        const An = Et.name;
        if (Et.attr("data-ephox-embed-iri")) {
          de = Pe(Et);
          break;
        } else
          !de.source && An === "param" && (de.source = Et.attr("movie")), (An === "iframe" || An === "object" || An === "embed" || An === "video" || An === "audio") && (de.type || (de.type = An), de = jt.extend(Et.attributes.map, de)), An === "script" && (de = {
            type: "script",
            source: Et.attr("src")
          }), An === "source" && (de.source ? de.altsource || (de.altsource = Et.attr("src")) : de.source = Et.attr("src")), An === "img" && !de.poster && (de.poster = Et.attr("src"));
      }
    return de.source = de.source || de.src || de.data, de.altsource = de.altsource || "", de.poster = de.poster || "", de;
  }, et = (O) => {
    const G = {
      mp3: "audio/mpeg",
      m4a: "audio/x-m4a",
      wav: "audio/wav",
      mp4: "video/mp4",
      webm: "video/webm",
      ogg: "video/ogg",
      swf: "application/x-shockwave-flash"
    }, de = O.toLowerCase().split(".").pop(), dt = G[de];
    return dt || "";
  };
  var kn = tinymce.util.Tools.resolve("tinymce.html.Node"), Rn = tinymce.util.Tools.resolve("tinymce.html.Serializer");
  const an = (O, G = {}) => Ze({
    forced_root_block: !1,
    validate: !1,
    allow_conditional_comments: !0,
    ...G
  }, O), en = ye.DOM, cn = (O) => /^[0-9.]+$/.test(O) ? O + "px" : O, wn = (O, G) => {
    const de = G.attr("style"), dt = de ? en.parseStyle(de) : {};
    dt["max-width"] = cn(O.width), dt["max-height"] = cn(O.height), G.attr("style", en.serializeStyle(dt));
  }, w = [
    "source",
    "altsource"
  ], ie = (O, G, de, dt) => {
    let rn = 0, Et = 0;
    const An = an(dt);
    An.addNodeFilter("source", (ln) => rn = ln.length);
    const Po = An.parse(O);
    for (let ln = Po; ln; ln = ln.walk())
      if (ln.type === 1) {
        const jn = ln.name;
        if (ln.attr("data-ephox-embed-iri")) {
          wn(G, ln);
          break;
        } else {
          switch (jn) {
            case "video":
            case "object":
            case "embed":
            case "img":
            case "iframe":
              G.height !== void 0 && G.width !== void 0 && (ln.attr("width", G.width), ln.attr("height", G.height));
              break;
          }
          if (de)
            switch (jn) {
              case "video":
                ln.attr("poster", G.poster), ln.attr("src", null);
                for (let No = rn; No < 2; No++)
                  if (G[w[No]]) {
                    const q = new kn("source", 1);
                    q.attr("src", G[w[No]]), q.attr("type", G[w[No] + "mime"] || null), ln.append(q);
                  }
                break;
              case "iframe":
                ln.attr("src", G.source);
                break;
              case "object":
                const Mo = ln.getAll("img").length > 0;
                if (G.poster && !Mo) {
                  ln.attr("src", G.poster);
                  const No = new kn("img", 1);
                  No.attr("src", G.poster), No.attr("width", G.width), No.attr("height", G.height), ln.append(No);
                }
                break;
              case "source":
                if (Et < 2 && (ln.attr("src", G[w[Et]]), ln.attr("type", G[w[Et] + "mime"] || null), !G[w[Et]])) {
                  ln.remove();
                  continue;
                }
                Et++;
                break;
              case "img":
                G.poster || ln.remove();
                break;
            }
        }
      }
    return Rn({}, dt).serialize(Po);
  }, re = [
    {
      regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$2?$4",
      allowFullscreen: !0
    },
    {
      regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
      allowFullscreen: !1
    },
    {
      regex: /dailymotion\.com\/video\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    },
    {
      regex: /dai\.ly\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    }
  ], we = (O) => {
    const G = O.match(/^(https?:\/\/|www\.)(.+)$/i);
    return G && G.length > 1 ? G[1] === "www." ? "https://" : G[1] : "https://";
  }, J = (O, G) => {
    const de = we(G), dt = O.regex.exec(G);
    let rn = de + O.url;
    for (let Et = 0; Et < dt.length; Et++)
      rn = rn.replace("$" + Et, () => dt[Et] ? dt[Et] : "");
    return rn.replace(/\?$/, "");
  }, me = (O) => {
    const G = re.filter((de) => de.regex.test(O));
    return G.length > 0 ? jt.extend({}, G[0], { url: J(G[0], O) }) : null;
  }, ce = (O, G) => {
    if (G)
      return G(O);
    {
      const de = O.allowfullscreen ? ' allowFullscreen="1"' : "";
      return '<iframe src="' + O.source + '" width="' + O.width + '" height="' + O.height + '"' + de + "></iframe>";
    }
  }, Ce = (O) => {
    let G = '<object data="' + O.source + '" width="' + O.width + '" height="' + O.height + '" type="application/x-shockwave-flash">';
    return O.poster && (G += '<img src="' + O.poster + '" width="' + O.width + '" height="' + O.height + '" />'), G += "</object>", G;
  }, W = (O, G) => G ? G(O) : '<audio controls="controls" src="' + O.source + '">' + (O.altsource ? `
<source src="` + O.altsource + '"' + (O.altsourcemime ? ' type="' + O.altsourcemime + '"' : "") + ` />
` : "") + "</audio>", M = (O, G) => G ? G(O) : '<video width="' + O.width + '" height="' + O.height + '"' + (O.poster ? ' poster="' + O.poster + '"' : "") + ` controls="controls">
<source src="` + O.source + '"' + (O.sourcemime ? ' type="' + O.sourcemime + '"' : "") + ` />
` + (O.altsource ? '<source src="' + O.altsource + '"' + (O.altsourcemime ? ' type="' + O.altsourcemime + '"' : "") + ` />
` : "") + "</video>", Ue = (O) => '<script src="' + O.source + '"><\/script>', kt = (O, G) => {
    const de = jt.extend({}, G);
    if (!de.source && (jt.extend(de, yt(de.embed, O.schema)), !de.source))
      return "";
    de.altsource || (de.altsource = ""), de.poster || (de.poster = ""), de.source = O.convertURL(de.source, "source"), de.altsource = O.convertURL(de.altsource, "source"), de.sourcemime = et(de.source), de.altsourcemime = et(de.altsource), de.poster = O.convertURL(de.poster, "poster");
    const dt = me(de.source);
    if (dt && (de.source = dt.url, de.type = dt.type, de.allowfullscreen = dt.allowFullscreen, de.width = de.width || String(dt.w), de.height = de.height || String(dt.h)), de.embed)
      return ie(de.embed, de, !0, O.schema);
    {
      const rn = ot(O), Et = le(O), An = it(O);
      return de.width = de.width || "300", de.height = de.height || "150", jt.each(de, (Po, ln) => {
        de[ln] = O.dom.encode("" + Po);
      }), de.type === "iframe" ? ce(de, An) : de.sourcemime === "application/x-shockwave-flash" ? Ce(de) : de.sourcemime.indexOf("audio") !== -1 ? W(de, rn) : de.type === "script" ? Ue(de) : M(de, Et);
    }
  }, Qe = (O) => O.hasAttribute("data-mce-object") || O.hasAttribute("data-ephox-embed-iri"), pn = (O) => {
    O.on("click keyup touchend", () => {
      const G = O.selection.getNode();
      G && O.dom.hasClass(G, "mce-preview-object") && O.dom.getAttrib(G, "data-mce-selected") && G.setAttribute("data-mce-selected", "2");
    }), O.on("ObjectSelected", (G) => {
      G.target.getAttribute("data-mce-object") === "script" && G.preventDefault();
    }), O.on("ObjectResized", (G) => {
      const de = G.target;
      if (de.getAttribute("data-mce-object")) {
        let dt = de.getAttribute("data-mce-html");
        dt && (dt = unescape(dt), de.setAttribute("data-mce-html", escape(ie(dt, {
          width: String(G.width),
          height: String(G.height)
        }, !1, O.schema))));
      }
    });
  }, En = {}, Eo = (O, G, de) => new Promise((dt, rn) => {
    const Et = (An) => (An.html && (En[O.source] = An), dt({
      url: O.source,
      html: An.html ? An.html : G(O)
    }));
    En[O.source] ? Et(En[O.source]) : de({ url: O.source }, Et, rn);
  }), oo = (O, G) => Promise.resolve({
    html: G(O),
    url: O.source
  }), Yn = (O) => (G) => kt(O, G), eo = (O, G) => {
    const de = Ve(O);
    return de ? Eo(G, Yn(O), de) : oo(G, Yn(O));
  }, Xt = (O) => ke(En, O), ro = (O, G) => ae(G, O).bind((de) => ae(de, "meta")), io = (O, G, de) => (dt) => {
    const rn = () => ae(O, dt), Et = () => ae(G, dt), An = (jn) => ae(jn, "value").bind((Mo) => Mo.length > 0 ? Ie.some(Mo) : Ie.none()), Po = () => rn().bind((jn) => Ae(jn) ? An(jn).orThunk(Et) : Et().orThunk(() => Ie.from(jn))), ln = () => Et().orThunk(() => rn().bind((jn) => Ae(jn) ? An(jn) : Ie.from(jn)));
    return { [dt]: (dt === de ? Po() : ln()).getOr("") };
  }, Fe = (O, G) => {
    const de = {};
    return ae(O, "dimensions").each((dt) => {
      _t([
        "width",
        "height"
      ], (rn) => {
        ae(G, rn).orThunk(() => ae(dt, rn)).each((Et) => de[rn] = Et);
      });
    }), de;
  }, st = (O, G) => {
    const de = G ? ro(G, O).getOr({}) : {}, dt = io(O, de, G);
    return {
      ...dt("source"),
      ...dt("altsource"),
      ...dt("poster"),
      ...dt("embed"),
      ...Fe(O, de)
    };
  }, Qt = (O) => {
    const G = {
      ...O,
      source: { value: ae(O, "source").getOr("") },
      altsource: { value: ae(O, "altsource").getOr("") },
      poster: { value: ae(O, "poster").getOr("") }
    };
    return _t([
      "width",
      "height"
    ], (de) => {
      ae(O, de).each((dt) => {
        const rn = G.dimensions || {};
        rn[de] = dt, G.dimensions = rn;
      });
    }), G;
  }, Ut = (O) => (G) => {
    const de = G && G.msg ? "Media embed handler error: " + G.msg : "Media embed handler threw unknown error.";
    O.notificationManager.open({
      type: "error",
      text: de
    });
  }, Tn = (O) => {
    const G = O.selection.getNode(), de = Qe(G) ? O.serializer.serialize(G, { selection: !0 }) : "";
    return {
      embed: de,
      ...yt(de, O.schema)
    };
  }, Pn = (O, G) => (de) => {
    if (_e(de.url) && de.url.trim().length > 0) {
      const dt = de.html, Et = {
        ...yt(dt, G.schema),
        source: de.url,
        embed: dt
      };
      O.setData(Qt(Et));
    }
  }, ho = (O, G) => {
    const de = O.dom.select("*[data-mce-object]");
    for (let dt = 0; dt < G.length; dt++)
      for (let rn = de.length - 1; rn >= 0; rn--)
        G[dt] === de[rn] && de.splice(rn, 1);
    O.selection.select(de[0]);
  }, Bo = (O, G) => {
    const de = O.dom.select("*[data-mce-object]");
    O.insertContent(G), ho(O, de), O.nodeChanged();
  }, ue = (O, G, de) => {
    G.embed = ie(G.embed, G, !1, de.schema), G.embed && (O.source === G.source || Xt(G.source)) ? Bo(de, G.embed) : eo(de, G).then((dt) => {
      Bo(de, dt.html);
    }).catch(Ut(de));
  }, ze = (O) => {
    const G = Tn(O), de = Ne(G), dt = Qt(G), rn = (wt, It) => {
      const Lt = st(It.getData(), "source");
      wt.source !== Lt.source && (Pn(vt, O)({
        url: Lt.source,
        html: ""
      }), eo(O, Lt).then(Pn(vt, O)).catch(Ut(O)));
    }, Et = (wt) => {
      const It = st(wt.getData()), Lt = yt(It.embed, O.schema);
      wt.setData(Qt(Lt));
    }, An = (wt, It) => {
      const Lt = st(wt.getData(), It), un = kt(O, Lt);
      wt.setData(Qt({
        ...Lt,
        embed: un
      }));
    }, Po = [{
      name: "source",
      type: "urlinput",
      filetype: "media",
      label: "Source"
    }], ln = Je(O) ? [{
      type: "sizeinput",
      name: "dimensions",
      label: "Constrain proportions",
      constrain: !0
    }] : [], jn = {
      title: "General",
      name: "general",
      items: $e([
        Po,
        ln
      ])
    }, No = {
      title: "Embed",
      items: [{
        type: "textarea",
        name: "embed",
        label: "Paste your embed code below:"
      }]
    }, q = [];
    L(O) && q.push({
      name: "altsource",
      type: "urlinput",
      filetype: "media",
      label: "Alternative source URL"
    }), Wt(O) && q.push({
      name: "poster",
      type: "urlinput",
      filetype: "image",
      label: "Media poster (Image URL)"
    });
    const ee = {
      title: "Advanced",
      name: "advanced",
      items: q
    }, Ge = [
      jn,
      No
    ];
    q.length > 0 && Ge.push(ee);
    const St = {
      type: "tabpanel",
      tabs: Ge
    }, vt = O.windowManager.open({
      title: "Insert/Edit Media",
      size: "normal",
      body: St,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (wt) => {
        const It = st(wt.getData());
        ue(de.get(), It, O), wt.close();
      },
      onChange: (wt, It) => {
        switch (It.name) {
          case "source":
            rn(de.get(), wt);
            break;
          case "embed":
            Et(wt);
            break;
          case "dimensions":
          case "altsource":
          case "poster":
            An(wt, It.name);
            break;
        }
        de.set(st(wt.getData()));
      },
      initialData: dt
    });
  }, At = (O) => ({ showDialog: () => {
    ze(O);
  } }), Ot = (O) => {
    const G = () => {
      ze(O);
    };
    O.addCommand("mceMedia", G);
  }, hn = (O, G, de) => G === "" || O.length >= G.length && O.substr(de, de + G.length) === G, Ao = (O, G) => hn(O, G, 0);
  var xs = tinymce.util.Tools.resolve("tinymce.Env");
  const zs = (O) => {
    const G = O.name;
    return G === "iframe" || G === "video" || G === "audio";
  }, To = (O, G, de, dt = null) => {
    const rn = O.attr(de);
    return Ee(rn) ? rn : ke(G, de) ? null : dt;
  }, rs = (O, G, de) => {
    const dt = G.name === "img" || O.name === "video", rn = dt ? "300" : null, Et = O.name === "audio" ? "30" : "150", An = dt ? Et : null;
    G.attr({
      width: To(O, de, "width", rn),
      height: To(O, de, "height", An)
    });
  }, wo = (O, G, de, dt) => {
    const rn = an(O.schema).parse(dt, { context: G });
    for (; rn.firstChild; )
      de.append(rn.firstChild);
  }, os = (O, G) => {
    const de = G.name, dt = new kn("img", 1);
    return gn(O, G, dt), rs(G, dt, {}), dt.attr({
      style: G.attr("style"),
      src: xs.transparentSrc,
      "data-mce-object": de,
      class: "mce-object mce-object-" + de
    }), dt;
  }, Vn = (O, G) => {
    const de = G.name, dt = new kn("span", 1);
    dt.attr({
      contentEditable: "false",
      style: G.attr("style"),
      "data-mce-object": de,
      class: "mce-preview-object mce-object-" + de
    }), gn(O, G, dt);
    const rn = O.dom.parseStyle(G.attr("style")), Et = new kn(de, 1);
    if (rs(G, Et, rn), Et.attr({
      src: G.attr("src"),
      style: G.attr("style"),
      class: G.attr("class")
    }), de === "iframe")
      Et.attr({
        allowfullscreen: G.attr("allowfullscreen"),
        frameborder: "0"
      });
    else {
      _t([
        "controls",
        "crossorigin",
        "currentTime",
        "loop",
        "muted",
        "poster",
        "preload"
      ], (jn) => {
        Et.attr(jn, G.attr(jn));
      });
      const ln = dt.attr("data-mce-html");
      Ee(ln) && wo(O, de, Et, unescape(ln));
    }
    const An = new kn("span", 1);
    return An.attr("class", "mce-shim"), dt.append(Et), dt.append(An), dt;
  }, gn = (O, G, de) => {
    const dt = G.attributes;
    let rn = dt.length;
    for (; rn--; ) {
      const ln = dt[rn].name;
      let jn = dt[rn].value;
      ln !== "width" && ln !== "height" && ln !== "style" && !Ao(ln, "data-mce-") && ((ln === "data" || ln === "src") && (jn = O.convertURL(jn, ln)), de.attr("data-mce-p-" + ln, jn));
    }
    const Et = Rn({ inner: !0 }, O.schema), An = new kn("div", 1);
    _t(G.children(), (ln) => An.append(ln));
    const Po = Et.serialize(An);
    Po && (de.attr("data-mce-html", escape(Po)), de.empty());
  }, qo = (O) => {
    const G = O.attr("class");
    return G && /\btiny-pageembed\b/.test(G);
  }, lo = (O) => {
    for (; O = O.parent; )
      if (O.attr("data-ephox-embed-iri") || qo(O))
        return !0;
    return !1;
  }, Io = (O) => (G) => {
    let de = G.length, dt;
    for (; de--; )
      dt = G[de], dt.parent && (dt.parent.attr("data-mce-object") || (zs(dt) && ft(O) ? lo(dt) || dt.replace(Vn(O, dt)) : lo(dt) || dt.replace(os(O, dt))));
  }, Ks = (O, G, de) => {
    const dt = Le(O);
    return an(O.schema, { validate: dt }).parse(de, { context: G });
  }, As = (O) => {
    O.on("PreInit", () => {
      const { schema: G, serializer: de, parser: dt } = O, rn = G.getBoolAttrs();
      _t("webkitallowfullscreen mozallowfullscreen".split(" "), (Et) => {
        rn[Et] = {};
      }), rt({ embed: ["wmode"] }, (Et, An) => {
        const Po = G.getElementRule(An);
        _t(Et, (ln) => {
          Po.attributes[ln] = {}, Po.attributesOrder.push(ln);
        });
      }), dt.addNodeFilter("iframe,video,audio,object,embed,script", Io(O)), de.addAttributeFilter("data-mce-object", (Et, An) => {
        let Po = Et.length;
        for (; Po--; ) {
          const ln = Et[Po];
          if (!ln.parent)
            continue;
          const jn = ln.attr(An), Mo = new kn(jn, 1);
          if (jn !== "audio" && jn !== "script") {
            const Ge = ln.attr("class");
            Ge && Ge.indexOf("mce-preview-object") !== -1 ? Mo.attr({
              width: ln.firstChild.attr("width"),
              height: ln.firstChild.attr("height")
            }) : Mo.attr({
              width: ln.attr("width"),
              height: ln.attr("height")
            });
          }
          Mo.attr({ style: ln.attr("style") });
          const No = ln.attributes;
          let q = No.length;
          for (; q--; ) {
            const Ge = No[q].name;
            Ge.indexOf("data-mce-p-") === 0 && Mo.attr(Ge.substr(11), No[q].value);
          }
          jn === "script" && Mo.attr("type", "text/javascript");
          const ee = ln.attr("data-mce-html");
          if (ee) {
            const Ge = Ks(O, jn, unescape(ee));
            _t(Ge.children(), (St) => Mo.append(St));
          }
          ln.replace(Mo);
        }
      });
    }), O.on("SetContent", () => {
      const G = O.dom;
      _t(G.select("span.mce-preview-object"), (de) => {
        G.select("span.mce-shim", de).length === 0 && G.add(de, "span", { class: "mce-shim" });
      });
    });
  }, cs = (O) => {
    O.on("ResolveName", (G) => {
      let de;
      G.target.nodeType === 1 && (de = G.target.getAttribute("data-mce-object")) && (G.name = de);
    });
  }, Lo = (O) => {
    const G = () => O.execCommand("mceMedia");
    O.ui.registry.addToggleButton("media", {
      tooltip: "Insert/edit media",
      icon: "embed",
      onAction: G,
      onSetup: (de) => {
        const dt = O.selection;
        return de.setActive(Qe(dt.getNode())), dt.selectorChangedWithUnbind("img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]", de.setActive).unbind;
      }
    }), O.ui.registry.addMenuItem("media", {
      icon: "embed",
      text: "Media...",
      onAction: G
    });
  };
  var Ys = () => {
    g.add("media", (O) => (zt(O), Ot(O), Lo(O), cs(O), As(O), pn(O), At(O)));
  };
  Ys();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager"), _ = tinymce.util.Tools.resolve("tinymce.Env"), D = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const X = (Ne) => (tt) => tt.options.get(Ne), _e = X("content_style"), Ae = X("content_css_cors"), We = X("body_class"), Ke = X("body_id"), Ee = (Ne) => {
    var tt;
    let xe = "";
    const rt = Ne.dom.encode, ae = (tt = _e(Ne)) !== null && tt !== void 0 ? tt : "";
    xe += '<base href="' + rt(Ne.documentBaseURI.getURI()) + '">';
    const ke = Ae(Ne) ? ' crossorigin="anonymous"' : "";
    D.each(Ne.contentCSS, (Ve) => {
      xe += '<link type="text/css" rel="stylesheet" href="' + rt(Ne.documentBaseURI.toAbsolute(Ve)) + '"' + ke + ">";
    }), ae && (xe += '<style type="text/css">' + ae + "</style>");
    const ge = Ke(Ne), zt = We(Ne), ot = _.os.isMacOS() || _.os.isiOS() ? "e.metaKey" : "e.ctrlKey && !e.altKey", le = '<script>document.addEventListener && document.addEventListener("click", function(e) {for (var elm = e.target; elm; elm = elm.parentNode) {if (elm.nodeName === "A" && !(' + ot + ")) {e.preventDefault();}}}, false);<\/script> ", it = Ne.getBody().dir, ft = it ? ' dir="' + rt(it) + '"' : "";
    return "<!DOCTYPE html><html><head>" + xe + '</head><body id="' + rt(ge) + '" class="mce-content-body ' + rt(zt) + '"' + ft + ">" + Ne.getContent() + le + "</body></html>";
  }, Ie = (Ne) => {
    const tt = Ee(Ne);
    Ne.windowManager.open({
      title: "Preview",
      size: "large",
      body: {
        type: "panel",
        items: [{
          name: "preview",
          type: "iframe",
          sandboxed: !0,
          transparent: !1
        }]
      },
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: { preview: tt }
    }).focus("close");
  }, pt = (Ne) => {
    Ne.addCommand("mcePreview", () => {
      Ie(Ne);
    });
  }, _t = (Ne) => {
    const tt = () => Ne.execCommand("mcePreview");
    Ne.ui.registry.addButton("preview", {
      icon: "preview",
      tooltip: "Preview",
      onAction: tt
    }), Ne.ui.registry.addMenuItem("preview", {
      icon: "preview",
      text: "Preview",
      onAction: tt
    });
  };
  var $e = () => {
    g.add("preview", (Ne) => {
      pt(Ne), _t(Ne);
    });
  };
  $e();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (re, we, J) => {
    var me;
    return J(re, we.prototype) ? !0 : ((me = re.constructor) === null || me === void 0 ? void 0 : me.name) === we.name;
  }, D = (re) => {
    const we = typeof re;
    return re === null ? "null" : we === "object" && Array.isArray(re) ? "array" : we === "object" && _(re, String, (J, me) => me.isPrototypeOf(J)) ? "string" : we;
  }, X = (re) => (we) => D(we) === re, _e = (re) => (we) => typeof we === re, Ae = X("string"), We = X("object"), Ke = X("array"), Ee = _e("function");
  var Ie = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), pt = tinymce.util.Tools.resolve("tinymce.EditorManager"), _t = tinymce.util.Tools.resolve("tinymce.Env"), $e = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ne = (re) => (we) => we.options.get(re), tt = (re) => {
    const we = re.options.register, J = (me) => Ae(me) || Ee(me) || We(me);
    we("importcss_merge_classes", {
      processor: "boolean",
      default: !0
    }), we("importcss_exclusive", {
      processor: "boolean",
      default: !0
    }), we("importcss_selector_converter", { processor: "function" }), we("importcss_selector_filter", { processor: J }), we("importcss_file_filter", { processor: J }), we("importcss_groups", { processor: "object[]" }), we("importcss_append", {
      processor: "boolean",
      default: !1
    });
  }, xe = Ne("importcss_merge_classes"), rt = Ne("importcss_exclusive"), ae = Ne("importcss_selector_converter"), ke = Ne("importcss_selector_filter"), ge = Ne("importcss_groups"), zt = Ne("importcss_append"), ot = Ne("importcss_file_filter"), le = Ne("skin"), it = Ne("skin_url"), ft = Array.prototype.push, Le = (re, we) => {
    const J = re.length, me = new Array(J);
    for (let ce = 0; ce < J; ce++) {
      const Ce = re[ce];
      me[ce] = we(Ce, ce);
    }
    return me;
  }, Ve = (re) => {
    const we = [];
    for (let J = 0, me = re.length; J < me; ++J) {
      if (!Ke(re[J]))
        throw new Error("Arr.flatten item " + J + " was not an array, input: " + re);
      ft.apply(we, re[J]);
    }
    return we;
  }, L = (re, we) => Ve(Le(re, we)), Wt = () => {
    const re = [], we = [], J = {};
    return {
      addItemToGroup: (W, M) => {
        J[W] ? J[W].push(M) : (we.push(W), J[W] = [M]);
      },
      addItem: (W) => {
        re.push(W);
      },
      toFormats: () => L(we, (M) => {
        const Ue = J[M];
        return Ue.length === 0 ? [] : [{
          title: M,
          items: Ue
        }];
      }).concat(re)
    };
  }, Je = /^\.(?:ephox|tiny-pageembed|mce)(?:[.-]+\w+)+$/, jt = (re) => {
    const we = _t.cacheSuffix;
    return Ae(re) && (re = re.replace("?" + we, "").replace("&" + we, "")), re;
  }, ye = (re, we) => {
    const J = le(re);
    if (J) {
      const me = it(re), ce = me ? re.documentBaseURI.toAbsolute(me) : pt.baseURL + "/skins/ui/" + J, Ce = pt.baseURL + "/skins/content/";
      return we === ce + "/content" + (re.inline ? ".inline" : "") + ".min.css" || we.indexOf(Ce) !== -1;
    }
    return !1;
  }, Ze = (re) => Ae(re) ? (we) => we.indexOf(re) !== -1 : re instanceof RegExp ? (we) => re.test(we) : re, qt = (re) => re.styleSheet, Z = (re) => re.selectorText, Pe = (re, we, J) => {
    const me = [], ce = {}, Ce = (W, M) => {
      let Ue = W.href, kt;
      if (Ue = jt(Ue), !(!Ue || !J(Ue, M) || ye(re, Ue))) {
        $e.each(W.imports, (Qe) => {
          Ce(Qe, !0);
        });
        try {
          kt = W.cssRules || W.rules;
        } catch {
        }
        $e.each(kt, (Qe) => {
          qt(Qe) ? Ce(Qe.styleSheet, !0) : Z(Qe) && $e.each(Qe.selectorText.split(","), (pn) => {
            me.push($e.trim(pn));
          });
        });
      }
    };
    $e.each(re.contentCSS, (W) => {
      ce[W] = !0;
    }), J || (J = (W, M) => M || ce[W]);
    try {
      $e.each(we.styleSheets, (W) => {
        Ce(W);
      });
    } catch {
    }
    return me;
  }, yt = (re, we) => {
    let J;
    const me = /^(?:([a-z0-9\-_]+))?(\.[a-z0-9_\-\.]+)$/i.exec(we);
    if (!me)
      return;
    const ce = me[1], Ce = me[2].substr(1).split(".").join(" "), W = $e.makeMap("a,img");
    return me[1] ? (J = { title: we }, re.schema.getTextBlockElements()[ce] ? J.block = ce : re.schema.getBlockElements()[ce] || W[ce.toLowerCase()] ? J.selector = ce : J.inline = ce) : me[2] && (J = {
      inline: "span",
      title: we.substr(1),
      classes: Ce
    }), xe(re) ? J.classes = Ce : J.attributes = { class: Ce }, J;
  }, et = (re, we) => $e.grep(re, (J) => !J.filter || J.filter(we)), kn = (re) => $e.map(re, (we) => $e.extend({}, we, {
    original: we,
    selectors: {},
    filter: Ze(we.filter)
  })), Rn = (re, we) => we === null || rt(re), an = (re, we, J, me) => !(Rn(re, J) ? we in me : we in J.selectors), en = (re, we, J, me) => {
    Rn(re, J) ? me[we] = !0 : J.selectors[we] = !0;
  }, cn = (re, we, J, me) => {
    let ce;
    return me && me.selector_converter ? ce = me.selector_converter : ae(re) ? ce = ae(re) : ce = () => yt(re, J), ce.call(we, J, me);
  }, wn = (re) => {
    re.on("init", () => {
      const we = Wt(), J = {}, me = Ze(ke(re)), ce = kn(ge(re)), Ce = (M, Ue) => {
        if (an(re, M, Ue, J)) {
          en(re, M, Ue, J);
          const kt = cn(re, re.plugins.importcss, M, Ue);
          if (kt) {
            const Qe = kt.name || Ie.DOM.uniqueId();
            return re.formatter.register(Qe, kt), {
              title: kt.title,
              format: Qe
            };
          }
        }
        return null;
      };
      $e.each(Pe(re, re.getDoc(), Ze(ot(re))), (M) => {
        if (!Je.test(M) && (!me || me(M))) {
          const Ue = et(ce, M);
          if (Ue.length > 0)
            $e.each(Ue, (kt) => {
              const Qe = Ce(M, kt);
              Qe && we.addItemToGroup(kt.title, Qe);
            });
          else {
            const kt = Ce(M, null);
            kt && we.addItem(kt);
          }
        }
      });
      const W = we.toFormats();
      re.dispatch("addStyleModifications", {
        items: W,
        replace: !zt(re)
      });
    });
  }, w = (re) => ({ convertSelectorToFormat: (J) => yt(re, J) });
  var ie = () => {
    g.add("importcss", (re) => (tt(re), wn(re), w(re)));
  };
  ie();
})();
(function() {
  const g = (q) => {
    let ee = q;
    return {
      get: () => ee,
      set: (vt) => {
        ee = vt;
      }
    };
  };
  var _ = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = (q, ee, Ge) => {
    var St;
    return Ge(q, ee.prototype) ? !0 : ((St = q.constructor) === null || St === void 0 ? void 0 : St.name) === ee.name;
  }, X = (q) => {
    const ee = typeof q;
    return q === null ? "null" : ee === "object" && Array.isArray(q) ? "array" : ee === "object" && D(q, String, (Ge, St) => St.isPrototypeOf(Ge)) ? "string" : ee;
  }, _e = (q) => (ee) => X(ee) === q, Ae = (q) => (ee) => typeof ee === q, We = _e("string"), Ke = _e("array"), Ee = Ae("boolean"), Ie = (q) => q == null, pt = (q) => !Ie(q), _t = Ae("number"), $e = () => {
  }, Ne = (q) => () => q, tt = Ne(!0), rt = Ne("[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]");
  class ae {
    constructor(ee, Ge) {
      this.tag = ee, this.value = Ge;
    }
    static some(ee) {
      return new ae(!0, ee);
    }
    static none() {
      return ae.singletonNone;
    }
    fold(ee, Ge) {
      return this.tag ? Ge(this.value) : ee();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ee) {
      return this.tag ? ae.some(ee(this.value)) : ae.none();
    }
    bind(ee) {
      return this.tag ? ee(this.value) : ae.none();
    }
    exists(ee) {
      return this.tag && ee(this.value);
    }
    forall(ee) {
      return !this.tag || ee(this.value);
    }
    filter(ee) {
      return !this.tag || ee(this.value) ? this : ae.none();
    }
    getOr(ee) {
      return this.tag ? this.value : ee;
    }
    or(ee) {
      return this.tag ? this : ee;
    }
    getOrThunk(ee) {
      return this.tag ? this.value : ee();
    }
    orThunk(ee) {
      return this.tag ? this : ee();
    }
    getOrDie(ee) {
      if (this.tag)
        return this.value;
      throw new Error(ee != null ? ee : "Called getOrDie on None");
    }
    static from(ee) {
      return pt(ee) ? ae.some(ee) : ae.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ee) {
      this.tag && ee(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ae.singletonNone = new ae(!1);
  const ke = rt;
  var ge = tinymce.util.Tools.resolve("tinymce.Env"), zt = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const ot = Array.prototype.slice, le = Array.prototype.push, it = (q, ee) => {
    const Ge = q.length, St = new Array(Ge);
    for (let vt = 0; vt < Ge; vt++) {
      const wt = q[vt];
      St[vt] = ee(wt, vt);
    }
    return St;
  }, ft = (q, ee) => {
    for (let Ge = 0, St = q.length; Ge < St; Ge++) {
      const vt = q[Ge];
      ee(vt, Ge);
    }
  }, Le = (q, ee) => {
    for (let Ge = q.length - 1; Ge >= 0; Ge--) {
      const St = q[Ge];
      ee(St, Ge);
    }
  }, Ve = (q, ee) => {
    if (q.length === 0)
      return [];
    {
      let Ge = ee(q[0]);
      const St = [];
      let vt = [];
      for (let wt = 0, It = q.length; wt < It; wt++) {
        const Lt = q[wt], un = ee(Lt);
        un !== Ge && (St.push(vt), vt = []), Ge = un, vt.push(Lt);
      }
      return vt.length !== 0 && St.push(vt), St;
    }
  }, L = (q, ee, Ge) => (ft(q, (St, vt) => {
    Ge = ee(Ge, St, vt);
  }), Ge), Wt = (q) => {
    const ee = [];
    for (let Ge = 0, St = q.length; Ge < St; ++Ge) {
      if (!Ke(q[Ge]))
        throw new Error("Arr.flatten item " + Ge + " was not an array, input: " + q);
      le.apply(ee, q[Ge]);
    }
    return ee;
  }, Je = (q, ee) => Wt(it(q, ee)), jt = (q, ee) => {
    const Ge = ot.call(q, 0);
    return Ge.sort(ee), Ge;
  }, ye = Object.hasOwnProperty, Ze = (q, ee) => ye.call(q, ee);
  typeof window < "u" || Function("return this;")();
  const qt = 9, Z = 11, Pe = 1, yt = 3, et = (q) => q.dom.nodeType, Rn = ((q) => (ee) => et(ee) === q)(yt), an = (q, ee, Ge) => {
    if (We(Ge) || Ee(Ge) || _t(Ge))
      q.setAttribute(ee, Ge + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", ee, ":: Value ", Ge, ":: Element ", q), new Error("Attribute value was not simple");
  }, en = (q, ee, Ge) => {
    an(q.dom, ee, Ge);
  }, cn = (q, ee) => {
    const St = (ee || document).createElement("div");
    if (St.innerHTML = q, !St.hasChildNodes() || St.childNodes.length > 1) {
      const vt = "HTML does not have a single root node";
      throw console.error(vt, q), new Error(vt);
    }
    return ie(St.childNodes[0]);
  }, wn = (q, ee) => {
    const St = (ee || document).createElement(q);
    return ie(St);
  }, w = (q, ee) => {
    const St = (ee || document).createTextNode(q);
    return ie(St);
  }, ie = (q) => {
    if (q == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: q };
  }, we = {
    fromHtml: cn,
    fromTag: wn,
    fromText: w,
    fromDom: ie,
    fromPoint: (q, ee, Ge) => ae.from(q.dom.elementFromPoint(ee, Ge)).map(ie)
  }, J = (q) => q.nodeType !== Pe && q.nodeType !== qt && q.nodeType !== Z || q.childElementCount === 0, me = (q, ee) => {
    const Ge = ee === void 0 ? document : ee.dom;
    return J(Ge) ? [] : it(Ge.querySelectorAll(q), we.fromDom);
  }, ce = (q) => ae.from(q.dom.parentNode).map(we.fromDom), Ce = (q) => it(q.dom.childNodes, we.fromDom), W = (q, ee) => ({
    element: q,
    offset: ee
  }), M = (q, ee) => {
    const Ge = Ce(q);
    return Ge.length > 0 && ee < Ge.length ? W(Ge[ee], 0) : W(q, ee);
  }, Ue = (q, ee) => {
    ce(q).each((St) => {
      St.dom.insertBefore(ee.dom, q.dom);
    });
  }, kt = (q, ee) => {
    q.dom.appendChild(ee.dom);
  }, Qe = (q, ee) => {
    Ue(q, ee), kt(ee, q);
  }, En = ((q, ee) => {
    const Ge = (wt) => {
      if (!q(wt))
        throw new Error("Can only get " + ee + " value of a " + ee + " node");
      return St(wt).getOr("");
    }, St = (wt) => q(wt) ? ae.from(wt.dom.nodeValue) : ae.none();
    return {
      get: Ge,
      getOption: St,
      set: (wt, It) => {
        if (!q(wt))
          throw new Error("Can only set raw " + ee + " value of a " + ee + " node");
        wt.dom.nodeValue = It;
      }
    };
  })(Rn, "text"), Eo = (q) => En.get(q), oo = (q, ee, Ge) => (q.compareDocumentPosition(ee) & Ge) !== 0, Yn = (q, ee) => oo(q, ee, Node.DOCUMENT_POSITION_PRECEDING), eo = (q, ee) => me(ee, q);
  var Xt = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const ro = (q, ee) => q.isBlock(ee) || Ze(q.schema.getVoidElements(), ee.nodeName), io = (q, ee) => q.getContentEditable(ee) === "false", Fe = (q, ee) => q.getContentEditable(ee) === "true" && q.getContentEditableParent(ee.parentNode) === "false", st = (q, ee) => !q.isBlock(ee) && Ze(q.schema.getWhitespaceElements(), ee.nodeName), Qt = (q, ee) => ro(q, ee) || io(q, ee) || st(q, ee) || Fe(q, ee), Ut = (q) => q.nodeType === 3, Tn = () => ({
    sOffset: 0,
    fOffset: 0,
    elements: []
  }), Pn = (q, ee) => M(we.fromDom(q), ee), ho = (q, ee, Ge, St, vt, wt = !0) => {
    let It = wt ? ee(!1) : Ge;
    for (; It; ) {
      const Lt = io(q, It);
      if (Lt || st(q, It)) {
        if (Lt ? St.cef(It) : St.boundary(It))
          break;
        It = ee(!0);
        continue;
      } else if (ro(q, It)) {
        if (St.boundary(It))
          break;
      } else
        Ut(It) && St.text(It);
      if (It === vt)
        break;
      It = ee(!1);
    }
  }, Bo = (q, ee, Ge, St, vt) => {
    if (Qt(q, Ge))
      return;
    const wt = q.getParent(St, q.isBlock), It = new Xt(Ge, wt), Lt = vt ? It.next.bind(It) : It.prev.bind(It);
    ho(q, Lt, Ge, {
      boundary: tt,
      cef: tt,
      text: (un) => {
        vt ? ee.fOffset += un.length : ee.sOffset += un.length, ee.elements.push(we.fromDom(un));
      }
    });
  }, ue = (q, ee, Ge, St, vt, wt = !0) => {
    const It = new Xt(Ge, ee), Lt = [];
    let un = Tn();
    Bo(q, un, Ge, ee, !1);
    const Xn = () => (un.elements.length > 0 && (Lt.push(un), un = Tn()), !1);
    return ho(q, It.next.bind(It), Ge, {
      boundary: Xn,
      cef: (yo) => (Xn(), vt && Lt.push(...vt.cef(yo)), !1),
      text: (yo) => {
        un.elements.push(we.fromDom(yo)), vt && vt.text(yo, un);
      }
    }, St, wt), St && Bo(q, un, St, ee, !0), Xn(), Lt;
  }, ze = (q, ee) => {
    const Ge = Pn(ee.startContainer, ee.startOffset), St = Ge.element.dom, vt = Pn(ee.endContainer, ee.endOffset), wt = vt.element.dom;
    return ue(q, ee.commonAncestorContainer, St, wt, {
      text: (It, Lt) => {
        It === wt ? Lt.fOffset += It.length - vt.offset : It === St && (Lt.sOffset += Ge.offset);
      },
      cef: (It) => {
        const Lt = Je(eo(we.fromDom(It), "*[contenteditable=true]"), (un) => {
          const Xn = un.dom;
          return ue(q, Xn, Xn);
        });
        return jt(Lt, (un, Xn) => Yn(un.elements[0].dom, Xn.elements[0].dom) ? 1 : -1);
      }
    }, !1);
  }, At = (q, ee) => ee.collapsed ? [] : ze(q, ee), Ot = (q, ee) => {
    const Ge = q.createRng();
    return Ge.selectNode(ee), At(q, Ge);
  }, hn = (q, ee) => Je(ee, (Ge) => Ot(q, Ge)), Ao = (q, ee, Ge = 0, St = q.length) => {
    const vt = ee.regex;
    vt.lastIndex = Ge;
    const wt = [];
    let It;
    for (; It = vt.exec(q); ) {
      const Lt = It[ee.matchIndex], un = It.index + It[0].indexOf(Lt), Xn = un + Lt.length;
      if (Xn > St)
        break;
      wt.push({
        start: un,
        finish: Xn
      }), vt.lastIndex = Xn;
    }
    return wt;
  }, xs = (q, ee) => {
    const Ge = L(q, (St, vt) => {
      const wt = Eo(vt), It = St.last, Lt = It + wt.length, un = Je(ee, (Xn, yo) => Xn.start < Lt && Xn.finish > It ? [{
        element: vt,
        start: Math.max(It, Xn.start) - It,
        finish: Math.min(Lt, Xn.finish) - It,
        matchId: yo
      }] : []);
      return {
        results: St.results.concat(un),
        last: Lt
      };
    }, {
      results: [],
      last: 0
    }).results;
    return Ve(Ge, (St) => St.matchId);
  }, zs = (q, ee) => Je(ee, (Ge) => {
    const St = Ge.elements, vt = it(St, Eo).join(""), wt = Ao(vt, q, Ge.sOffset, vt.length - Ge.fOffset);
    return xs(St, wt);
  }), To = (q, ee) => {
    Le(q, (Ge, St) => {
      Le(Ge, (vt) => {
        const wt = we.fromDom(ee.cloneNode(!1));
        en(wt, "data-mce-index", St);
        const It = vt.element.dom;
        if (It.length === vt.finish && vt.start === 0)
          Qe(vt.element, wt);
        else {
          It.length !== vt.finish && It.splitText(vt.finish);
          const Lt = It.splitText(vt.start);
          Qe(we.fromDom(Lt), wt);
        }
      });
    });
  }, rs = (q, ee, Ge, St) => {
    const vt = Ot(q, Ge), wt = zs(ee, vt);
    return To(wt, St), wt.length;
  }, wo = (q, ee, Ge, St) => {
    const vt = Ge.getBookmark(), wt = q.select("td[data-mce-selected],th[data-mce-selected]"), It = wt.length > 0 ? hn(q, wt) : At(q, Ge.getRng()), Lt = zs(ee, It);
    return To(Lt, St), Ge.moveToBookmark(vt), Lt.length;
  }, os = (q) => {
    const ee = q.getAttribute("data-mce-index");
    return typeof ee == "number" ? "" + ee : ee;
  }, Vn = (q, ee, Ge, St) => {
    const vt = q.dom.create("span", { "data-mce-bogus": 1 });
    vt.className = "mce-match-marker";
    const wt = q.getBody();
    return G(q, ee, !1), St ? wo(q.dom, Ge, q.selection, vt) : rs(q.dom, Ge, wt, vt);
  }, gn = (q) => {
    const ee = q.parentNode;
    q.firstChild && ee.insertBefore(q.firstChild, q), q.parentNode.removeChild(q);
  }, qo = (q, ee) => {
    const Ge = [], St = zt.toArray(q.getBody().getElementsByTagName("span"));
    if (St.length)
      for (let vt = 0; vt < St.length; vt++) {
        const wt = os(St[vt]);
        wt === null || !wt.length || wt === ee.toString() && Ge.push(St[vt]);
      }
    return Ge;
  }, lo = (q, ee, Ge) => {
    const St = ee.get();
    let vt = St.index;
    const wt = q.dom;
    Ge = Ge !== !1, Ge ? vt + 1 === St.count ? vt = 0 : vt++ : vt - 1 === -1 ? vt = St.count - 1 : vt--, wt.removeClass(qo(q, St.index), "mce-match-marker-selected");
    const It = qo(q, vt);
    return It.length ? (wt.addClass(qo(q, vt), "mce-match-marker-selected"), q.selection.scrollIntoView(It[0]), vt) : -1;
  }, Io = (q, ee) => {
    const Ge = ee.parentNode;
    q.remove(ee), q.isEmpty(Ge) && q.remove(Ge);
  }, Ks = (q, ee) => {
    const Ge = q.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&").replace(/\s/g, "[^\\S\\r\\n\\uFEFF]"), St = "(" + Ge + ")";
    return ee ? `(?:^|\\s|${ke()})` + St + `(?=$|\\s|${ke()})` : St;
  }, As = (q, ee, Ge, St, vt, wt) => {
    const It = q.selection, Lt = Ks(Ge, vt), un = It.isForward(), Xn = {
      regex: new RegExp(Lt, St ? "g" : "gi"),
      matchIndex: 1
    }, yo = Vn(q, ee, Xn, wt);
    if (ge.browser.isSafari() && It.setRng(It.getRng(), un), yo) {
      const Dn = lo(q, ee, !0);
      ee.set({
        index: Dn,
        count: yo,
        text: Ge,
        matchCase: St,
        wholeWord: vt,
        inSelection: wt
      });
    }
    return yo;
  }, cs = (q, ee) => {
    const Ge = lo(q, ee, !0);
    ee.set({
      ...ee.get(),
      index: Ge
    });
  }, Lo = (q, ee) => {
    const Ge = lo(q, ee, !1);
    ee.set({
      ...ee.get(),
      index: Ge
    });
  }, Ys = (q) => {
    const ee = os(q);
    return ee !== null && ee.length > 0;
  }, O = (q, ee, Ge, St, vt) => {
    const wt = ee.get(), It = wt.index;
    let Lt, un = It;
    St = St !== !1;
    const Xn = q.getBody(), yo = zt.grep(zt.toArray(Xn.getElementsByTagName("span")), Ys);
    for (let Dn = 0; Dn < yo.length; Dn++) {
      const sr = os(yo[Dn]);
      let bs = Lt = parseInt(sr, 10);
      if (vt || bs === wt.index) {
        for (Ge.length ? (yo[Dn].firstChild.nodeValue = Ge, gn(yo[Dn])) : Io(q.dom, yo[Dn]); yo[++Dn]; )
          if (bs = parseInt(os(yo[Dn]), 10), bs === Lt)
            Io(q.dom, yo[Dn]);
          else {
            Dn--;
            break;
          }
        St && un--;
      } else
        Lt > It && yo[Dn].setAttribute("data-mce-index", String(Lt - 1));
    }
    return ee.set({
      ...wt,
      count: vt ? 0 : wt.count - 1,
      index: un
    }), St ? cs(q, ee) : Lo(q, ee), !vt && ee.get().count > 0;
  }, G = (q, ee, Ge) => {
    let St, vt;
    const wt = ee.get(), It = zt.toArray(q.getBody().getElementsByTagName("span"));
    for (let Lt = 0; Lt < It.length; Lt++) {
      const un = os(It[Lt]);
      un !== null && un.length && (un === wt.index.toString() && (St || (St = It[Lt].firstChild), vt = It[Lt].firstChild), gn(It[Lt]));
    }
    if (ee.set({
      ...wt,
      index: -1,
      count: 0,
      text: ""
    }), St && vt) {
      const Lt = q.dom.createRng();
      return Lt.setStart(St, 0), Lt.setEnd(vt, vt.data.length), Ge !== !1 && q.selection.setRng(Lt), Lt;
    }
  }, de = (q, ee) => ee.get().count > 1, dt = (q, ee) => ee.get().count > 1, rn = (q, ee) => ({
    done: (Lt) => G(q, ee, Lt),
    find: (Lt, un, Xn, yo = !1) => As(q, ee, Lt, un, Xn, yo),
    next: () => cs(q, ee),
    prev: () => Lo(q, ee),
    replace: (Lt, un, Xn) => O(q, ee, Lt, un, Xn)
  }), Et = (q) => {
    const ee = g(ae.none()), Ge = () => ee.get().each(q);
    return {
      clear: () => {
        Ge(), ee.set(ae.none());
      },
      isSet: () => ee.get().isSome(),
      get: () => ee.get(),
      set: (Lt) => {
        Ge(), ee.set(ae.some(Lt));
      }
    };
  }, An = () => {
    const q = Et($e);
    return {
      ...q,
      on: (Ge) => q.get().each(Ge)
    };
  }, Po = (q, ee) => {
    const Ge = An();
    q.undoManager.add();
    const St = zt.trim(q.selection.getContent({ format: "text" })), vt = (Bn) => {
      Bn.setEnabled("next", de(q, ee)), Bn.setEnabled("prev", dt(q, ee));
    }, wt = (Bn) => {
      const to = Bn.getData(), Qo = ee.get();
      ee.set({
        ...Qo,
        matchCase: to.matchcase,
        wholeWord: to.wholewords,
        inSelection: to.inselection
      });
    }, It = (Bn, to) => {
      ft([
        "replace",
        "replaceall",
        "prev",
        "next"
      ], (Ns) => Bn.setEnabled(Ns, !to));
    }, Lt = (Bn) => {
      q.windowManager.alert("Could not find the specified string.", () => {
        Bn.focus("findtext");
      });
    }, un = (Bn, to) => {
      ge.browser.isSafari() && ge.deviceType.isTouch() && (to === "find" || to === "replace" || to === "replaceall") && Bn.focus(to);
    }, Xn = (Bn) => {
      G(q, ee, !1), It(Bn, !0), vt(Bn);
    }, yo = (Bn) => {
      const to = Bn.getData(), Qo = ee.get();
      if (!to.findtext.length) {
        Xn(Bn);
        return;
      }
      if (Qo.text === to.findtext && Qo.matchCase === to.matchcase && Qo.wholeWord === to.wholewords)
        cs(q, ee);
      else {
        const Jo = As(q, ee, to.findtext, to.matchcase, to.wholewords, to.inselection);
        Jo <= 0 && Lt(Bn), It(Bn, Jo === 0);
      }
      vt(Bn);
    }, Dn = ee.get(), sr = {
      findtext: St,
      replacetext: "",
      wholewords: Dn.wholeWord,
      matchcase: Dn.matchCase,
      inselection: Dn.inSelection
    }, bs = {
      title: "Find and Replace",
      size: "normal",
      body: {
        type: "panel",
        items: [
          {
            type: "bar",
            items: [
              {
                type: "input",
                name: "findtext",
                placeholder: "Find",
                maximized: !0,
                inputMode: "search"
              },
              {
                type: "button",
                name: "prev",
                text: "Previous",
                icon: "action-prev",
                enabled: !1,
                borderless: !0
              },
              {
                type: "button",
                name: "next",
                text: "Next",
                icon: "action-next",
                enabled: !1,
                borderless: !0
              }
            ]
          },
          {
            type: "input",
            name: "replacetext",
            placeholder: "Replace with",
            inputMode: "search"
          }
        ]
      },
      buttons: [
        {
          type: "menu",
          name: "options",
          icon: "preferences",
          tooltip: "Preferences",
          align: "start",
          items: [
            {
              type: "togglemenuitem",
              name: "matchcase",
              text: "Match case"
            },
            {
              type: "togglemenuitem",
              name: "wholewords",
              text: "Find whole words only"
            },
            {
              type: "togglemenuitem",
              name: "inselection",
              text: "Find in selection"
            }
          ]
        },
        {
          type: "custom",
          name: "find",
          text: "Find",
          primary: !0
        },
        {
          type: "custom",
          name: "replace",
          text: "Replace",
          enabled: !1
        },
        {
          type: "custom",
          name: "replaceall",
          text: "Replace all",
          enabled: !1
        }
      ],
      initialData: sr,
      onChange: (Bn, to) => {
        to.name === "findtext" && ee.get().count > 0 && Xn(Bn);
      },
      onAction: (Bn, to) => {
        const Qo = Bn.getData();
        switch (to.name) {
          case "find":
            yo(Bn);
            break;
          case "replace":
            O(q, ee, Qo.replacetext) ? vt(Bn) : Xn(Bn);
            break;
          case "replaceall":
            O(q, ee, Qo.replacetext, !0, !0), Xn(Bn);
            break;
          case "prev":
            Lo(q, ee), vt(Bn);
            break;
          case "next":
            cs(q, ee), vt(Bn);
            break;
          case "matchcase":
          case "wholewords":
          case "inselection":
            wt(Bn), Xn(Bn);
            break;
        }
        un(Bn, to.name);
      },
      onSubmit: (Bn) => {
        yo(Bn), un(Bn, "find");
      },
      onClose: () => {
        q.focus(), G(q, ee), q.undoManager.add();
      }
    };
    Ge.set(q.windowManager.open(bs, { inline: "toolbar" }));
  }, ln = (q, ee) => {
    q.addCommand("SearchReplace", () => {
      Po(q, ee);
    });
  }, jn = (q, ee) => () => {
    Po(q, ee);
  }, Mo = (q, ee) => {
    q.ui.registry.addMenuItem("searchreplace", {
      text: "Find and replace...",
      shortcut: "Meta+F",
      onAction: jn(q, ee),
      icon: "search"
    }), q.ui.registry.addButton("searchreplace", {
      tooltip: "Find and replace",
      onAction: jn(q, ee),
      icon: "search"
    }), q.shortcuts.add("Meta+F", "", jn(q, ee));
  };
  var No = () => {
    _.add("searchreplace", (q) => {
      const ee = g({
        index: -1,
        count: 0,
        text: "",
        matchCase: !1,
        wholeWord: !1,
        inSelection: !1
      });
      return ln(q, ee), Mo(q, ee), rn(q, ee);
    });
  };
  No();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = () => /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g, D = (ye) => (Ze) => Ze.options.get(ye), X = (ye) => {
    const Ze = ye.options.register;
    Ze("autolink_pattern", {
      processor: "regexp",
      default: new RegExp("^" + _().source + "$", "i")
    }), Ze("link_default_target", { processor: "string" }), Ze("link_default_protocol", {
      processor: "string",
      default: "https"
    });
  }, _e = D("autolink_pattern"), Ae = D("link_default_target"), We = D("link_default_protocol"), Ke = (ye, Ze, qt) => {
    var Z;
    return qt(ye, Ze.prototype) ? !0 : ((Z = ye.constructor) === null || Z === void 0 ? void 0 : Z.name) === Ze.name;
  }, Ee = (ye) => {
    const Ze = typeof ye;
    return ye === null ? "null" : Ze === "object" && Array.isArray(ye) ? "array" : Ze === "object" && Ke(ye, String, (qt, Z) => Z.isPrototypeOf(qt)) ? "string" : Ze;
  }, pt = ((ye) => (Ze) => Ee(Ze) === ye)("string"), _t = (ye) => ye == null, $e = (ye) => !_t(ye), Ne = (ye, Ze, qt) => Ze === "" || ye.length >= Ze.length && ye.substr(qt, qt + Ze.length) === Ze, tt = (ye, Ze) => ye.indexOf(Ze) !== -1, xe = (ye, Ze) => Ne(ye, Ze, 0), rt = (ye) => /^[(\[{ \u00a0]$/.test(ye), ae = (ye) => ye.nodeType === 3, ke = (ye) => ye.nodeType === 1, ge = (ye, Ze) => {
    if (Ze < 0 && (Ze = 0), ae(ye)) {
      const qt = ye.data.length;
      Ze > qt && (Ze = qt);
    }
    return Ze;
  }, zt = (ye, Ze, qt) => {
    !ke(Ze) || Ze.hasChildNodes() ? ye.setStart(Ze, ge(Ze, qt)) : ye.setStartBefore(Ze);
  }, ot = (ye, Ze, qt) => {
    !ke(Ze) || Ze.hasChildNodes() ? ye.setEnd(Ze, ge(Ze, qt)) : ye.setEndAfter(Ze);
  }, le = (ye) => /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(ye), it = (ye) => /[?!,.;:]/.test(ye), ft = (ye, Ze) => {
    let qt, Z, Pe, yt, et, kn;
    const Rn = _e(ye);
    if (ye.dom.getParent(ye.selection.getNode(), "a[href]") !== null)
      return;
    const an = ye.selection.getRng().cloneRange();
    if (an.startOffset < 5) {
      if (yt = an.endContainer.previousSibling, !yt) {
        if (!an.endContainer.firstChild || !an.endContainer.firstChild.nextSibling)
          return;
        yt = an.endContainer.firstChild.nextSibling;
      }
      if (et = yt.length, zt(an, yt, et), ot(an, yt, et), an.endOffset < 5)
        return;
      qt = an.endOffset, Z = yt;
    } else {
      if (Z = an.endContainer, !ae(Z) && Z.firstChild) {
        for (; !ae(Z) && Z.firstChild; )
          Z = Z.firstChild;
        ae(Z) && (zt(an, Z, 0), ot(an, Z, Z.nodeValue.length));
      }
      an.endOffset === 1 ? qt = 2 : qt = an.endOffset - 1 - Ze;
    }
    const en = qt;
    do
      zt(an, Z, qt >= 2 ? qt - 2 : 0), ot(an, Z, qt >= 1 ? qt - 1 : 0), qt -= 1, kn = an.toString();
    while (!rt(kn) && qt - 2 >= 0);
    rt(an.toString()) ? (zt(an, Z, qt), ot(an, Z, en), qt += 1) : an.startOffset === 0 ? (zt(an, Z, 0), ot(an, Z, en)) : (zt(an, Z, qt), ot(an, Z, en)), Pe = an.toString(), it(Pe.charAt(Pe.length - 1)) && ot(an, Z, en - 1), Pe = an.toString().trim();
    const cn = Pe.match(Rn), wn = We(ye);
    if (cn) {
      let w = cn[0];
      return xe(w, "www.") ? w = wn + "://" + w : tt(w, "@") && !le(w) && (w = "mailto:" + w), {
        rng: an,
        url: w
      };
    } else
      return null;
  }, Le = (ye, Ze) => {
    const qt = Ae(ye), { rng: Z, url: Pe } = Ze, yt = ye.selection.getBookmark();
    ye.selection.setRng(Z);
    const et = "createlink", kn = {
      command: et,
      ui: !1,
      value: Pe
    };
    ye.dispatch("BeforeExecCommand", kn).isDefaultPrevented() || (ye.getDoc().execCommand(et, !1, Pe), ye.dispatch("ExecCommand", kn), pt(qt) && ye.dom.setAttrib(ye.selection.getNode(), "target", qt)), ye.selection.moveToBookmark(yt), ye.nodeChanged();
  }, Ve = (ye) => {
    const Ze = ft(ye, 0);
    $e(Ze) && Le(ye, Ze);
  }, L = Ve, Wt = (ye) => {
    const Ze = ft(ye, -1);
    $e(Ze) && Le(ye, Ze);
  }, Je = (ye) => {
    ye.on("keydown", (Ze) => {
      Ze.keyCode === 13 && !Ze.isDefaultPrevented() && Wt(ye);
    }), ye.on("keyup", (Ze) => {
      Ze.keyCode === 32 ? Ve(ye) : (Ze.keyCode === 48 && Ze.shiftKey || Ze.keyCode === 221) && L(ye);
    });
  };
  var jt = () => {
    g.add("autolink", (ye) => {
      X(ye), Je(ye);
    });
  };
  jt();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (Z, Pe, yt) => {
    var et;
    return yt(Z, Pe.prototype) ? !0 : ((et = Z.constructor) === null || et === void 0 ? void 0 : et.name) === Pe.name;
  }, D = (Z) => {
    const Pe = typeof Z;
    return Z === null ? "null" : Pe === "object" && Array.isArray(Z) ? "array" : Pe === "object" && _(Z, String, (yt, et) => et.isPrototypeOf(yt)) ? "string" : Pe;
  }, X = (Z) => (Pe) => D(Pe) === Z, _e = (Z) => (Pe) => Z === Pe, Ae = X("string"), We = _e(void 0);
  var Ke = tinymce.util.Tools.resolve("tinymce.util.Delay"), Ee = tinymce.util.Tools.resolve("tinymce.util.LocalStorage"), Ie = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const pt = (Z) => Z.dispatch("RestoreDraft"), _t = (Z) => Z.dispatch("StoreDraft"), $e = (Z) => Z.dispatch("RemoveDraft"), Ne = (Z) => {
    const Pe = {
      s: 1e3,
      m: 6e4
    }, yt = /^(\d+)([ms]?)$/.exec(Z);
    return (yt[2] ? Pe[yt[2]] : 1) * parseInt(Z, 10);
  }, tt = (Z) => (Pe) => Pe.options.get(Z), xe = (Z) => {
    const Pe = Z.options.register, yt = (et) => {
      const kn = Ae(et);
      return kn ? {
        value: Ne(et),
        valid: kn
      } : {
        valid: !1,
        message: "Must be a string."
      };
    };
    Pe("autosave_ask_before_unload", {
      processor: "boolean",
      default: !0
    }), Pe("autosave_prefix", {
      processor: "string",
      default: "tinymce-autosave-{path}{query}{hash}-{id}-"
    }), Pe("autosave_restore_when_empty", {
      processor: "boolean",
      default: !1
    }), Pe("autosave_interval", {
      processor: yt,
      default: "30s"
    }), Pe("autosave_retention", {
      processor: yt,
      default: "20m"
    });
  }, rt = tt("autosave_ask_before_unload"), ae = tt("autosave_restore_when_empty"), ke = tt("autosave_interval"), ge = tt("autosave_retention"), zt = (Z) => {
    const Pe = document.location;
    return Z.options.get("autosave_prefix").replace(/{path}/g, Pe.pathname).replace(/{query}/g, Pe.search).replace(/{hash}/g, Pe.hash).replace(/{id}/g, Z.id);
  }, ot = (Z, Pe) => {
    if (We(Pe))
      return Z.dom.isEmpty(Z.getBody());
    {
      const yt = Ie.trim(Pe);
      if (yt === "")
        return !0;
      {
        const et = new DOMParser().parseFromString(yt, "text/html");
        return Z.dom.isEmpty(et);
      }
    }
  }, le = (Z) => {
    const Pe = parseInt(Ee.getItem(zt(Z) + "time"), 10) || 0;
    return new Date().getTime() - Pe > ge(Z) ? (it(Z, !1), !1) : !0;
  }, it = (Z, Pe) => {
    const yt = zt(Z);
    Ee.removeItem(yt + "draft"), Ee.removeItem(yt + "time"), Pe !== !1 && $e(Z);
  }, ft = (Z) => {
    const Pe = zt(Z);
    !ot(Z) && Z.isDirty() && (Ee.setItem(Pe + "draft", Z.getContent({
      format: "raw",
      no_events: !0
    })), Ee.setItem(Pe + "time", new Date().getTime().toString()), _t(Z));
  }, Le = (Z) => {
    const Pe = zt(Z);
    le(Z) && (Z.setContent(Ee.getItem(Pe + "draft"), { format: "raw" }), pt(Z));
  }, Ve = (Z) => {
    const Pe = ke(Z);
    Ke.setEditorInterval(Z, () => {
      ft(Z);
    }, Pe);
  }, L = (Z) => {
    Z.undoManager.transact(() => {
      Le(Z), it(Z);
    }), Z.focus();
  }, Wt = (Z) => ({
    hasDraft: () => le(Z),
    storeDraft: () => ft(Z),
    restoreDraft: () => Le(Z),
    removeDraft: (Pe) => it(Z, Pe),
    isEmpty: (Pe) => ot(Z, Pe)
  });
  var Je = tinymce.util.Tools.resolve("tinymce.EditorManager");
  const jt = (Z) => {
    Z.editorManager.on("BeforeUnload", (Pe) => {
      let yt;
      Ie.each(Je.get(), (et) => {
        et.plugins.autosave && et.plugins.autosave.storeDraft(), !yt && et.isDirty() && rt(et) && (yt = et.translate("You have unsaved changes are you sure you want to navigate away?"));
      }), yt && (Pe.preventDefault(), Pe.returnValue = yt);
    });
  }, ye = (Z) => (Pe) => {
    Pe.setEnabled(le(Z));
    const yt = () => Pe.setEnabled(le(Z));
    return Z.on("StoreDraft RestoreDraft RemoveDraft", yt), () => Z.off("StoreDraft RestoreDraft RemoveDraft", yt);
  }, Ze = (Z) => {
    Ve(Z), Z.ui.registry.addButton("restoredraft", {
      tooltip: "Restore last draft",
      icon: "restore-draft",
      onAction: () => {
        L(Z);
      },
      onSetup: ye(Z)
    }), Z.ui.registry.addMenuItem("restoredraft", {
      text: "Restore last draft",
      icon: "restore-draft",
      onAction: () => {
        L(Z);
      },
      onSetup: ye(Z)
    });
  };
  var qt = () => {
    g.add("autosave", (Z) => (xe(Z), jt(Z), Ze(Z), Z.on("init", () => {
      ae(Z) && Z.dom.isEmpty(Z.getBody()) && Le(Z);
    }), Wt(Z)));
  };
  qt();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (Fe, st, Qt) => {
    var Ut;
    return Qt(Fe, st.prototype) ? !0 : ((Ut = Fe.constructor) === null || Ut === void 0 ? void 0 : Ut.name) === st.name;
  }, D = (Fe) => {
    const st = typeof Fe;
    return Fe === null ? "null" : st === "object" && Array.isArray(Fe) ? "array" : st === "object" && _(Fe, String, (Qt, Ut) => Ut.isPrototypeOf(Qt)) ? "string" : st;
  }, X = (Fe) => (st) => D(st) === Fe, _e = (Fe) => (st) => typeof st === Fe, Ae = X("string"), We = _e("boolean"), Ke = (Fe) => Fe == null, Ee = (Fe) => !Ke(Fe), Ie = _e("function"), pt = _e("number"), _t = (Fe, st) => (Qt) => Fe(st(Qt)), Ne = ((Fe) => () => Fe)(!1);
  class tt {
    constructor(st, Qt) {
      this.tag = st, this.value = Qt;
    }
    static some(st) {
      return new tt(!0, st);
    }
    static none() {
      return tt.singletonNone;
    }
    fold(st, Qt) {
      return this.tag ? Qt(this.value) : st();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(st) {
      return this.tag ? tt.some(st(this.value)) : tt.none();
    }
    bind(st) {
      return this.tag ? st(this.value) : tt.none();
    }
    exists(st) {
      return this.tag && st(this.value);
    }
    forall(st) {
      return !this.tag || st(this.value);
    }
    filter(st) {
      return !this.tag || st(this.value) ? this : tt.none();
    }
    getOr(st) {
      return this.tag ? this.value : st;
    }
    or(st) {
      return this.tag ? this : st;
    }
    getOrThunk(st) {
      return this.tag ? this.value : st();
    }
    orThunk(st) {
      return this.tag ? this : st();
    }
    getOrDie(st) {
      if (this.tag)
        return this.value;
      throw new Error(st != null ? st : "Called getOrDie on None");
    }
    static from(st) {
      return Ee(st) ? tt.some(st) : tt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(st) {
      this.tag && st(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  tt.singletonNone = new tt(!1);
  const xe = (Fe, st) => {
    const Qt = Fe.length, Ut = new Array(Qt);
    for (let Tn = 0; Tn < Qt; Tn++) {
      const Pn = Fe[Tn];
      Ut[Tn] = st(Pn, Tn);
    }
    return Ut;
  }, rt = (Fe, st) => {
    for (let Qt = 0, Ut = Fe.length; Qt < Ut; Qt++) {
      const Tn = Fe[Qt];
      st(Tn, Qt);
    }
  }, ae = (Fe, st) => {
    const Qt = [];
    for (let Ut = 0, Tn = Fe.length; Ut < Tn; Ut++) {
      const Pn = Fe[Ut];
      st(Pn, Ut) && Qt.push(Pn);
    }
    return Qt;
  }, ke = 9, ge = 11, zt = 1, ot = 3, le = (Fe, st) => {
    const Ut = (st || document).createElement("div");
    if (Ut.innerHTML = Fe, !Ut.hasChildNodes() || Ut.childNodes.length > 1) {
      const Tn = "HTML does not have a single root node";
      throw console.error(Tn, Fe), new Error(Tn);
    }
    return Le(Ut.childNodes[0]);
  }, it = (Fe, st) => {
    const Ut = (st || document).createElement(Fe);
    return Le(Ut);
  }, ft = (Fe, st) => {
    const Ut = (st || document).createTextNode(Fe);
    return Le(Ut);
  }, Le = (Fe) => {
    if (Fe == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Fe };
  }, L = {
    fromHtml: le,
    fromTag: it,
    fromText: ft,
    fromDom: Le,
    fromPoint: (Fe, st, Qt) => tt.from(Fe.dom.elementFromPoint(st, Qt)).map(Le)
  }, Wt = (Fe, st) => {
    const Qt = Fe.dom;
    if (Qt.nodeType !== zt)
      return !1;
    {
      const Ut = Qt;
      if (Ut.matches !== void 0)
        return Ut.matches(st);
      if (Ut.msMatchesSelector !== void 0)
        return Ut.msMatchesSelector(st);
      if (Ut.webkitMatchesSelector !== void 0)
        return Ut.webkitMatchesSelector(st);
      if (Ut.mozMatchesSelector !== void 0)
        return Ut.mozMatchesSelector(st);
      throw new Error("Browser lacks native selectors");
    }
  };
  typeof window < "u" || Function("return this;")();
  const Je = (Fe) => Fe.dom.nodeName.toLowerCase(), jt = (Fe) => Fe.dom.nodeType, ye = (Fe) => (st) => jt(st) === Fe, Ze = ye(zt), qt = ye(ot), Z = ye(ke), Pe = ye(ge), yt = (Fe) => (st) => Ze(st) && Je(st) === Fe, et = (Fe) => L.fromDom(Fe.dom.ownerDocument), kn = (Fe) => Z(Fe) ? Fe : et(Fe), Rn = (Fe) => tt.from(Fe.dom.parentNode).map(L.fromDom), an = (Fe) => xe(Fe.dom.childNodes, L.fromDom), en = (Fe, st, Qt) => {
    if (Ae(Qt) || We(Qt) || pt(Qt))
      Fe.setAttribute(st, Qt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", st, ":: Value ", Qt, ":: Element ", Fe), new Error("Attribute value was not simple");
  }, cn = (Fe, st, Qt) => {
    en(Fe.dom, st, Qt);
  }, wn = (Fe, st) => {
    Fe.dom.removeAttribute(st);
  }, w = (Fe) => Pe(Fe) && Ee(Fe.dom.host), re = Ie(Element.prototype.attachShadow) && Ie(Node.prototype.getRootNode) ? (Fe) => L.fromDom(Fe.dom.getRootNode()) : kn, we = (Fe) => {
    const st = re(Fe);
    return w(st) ? tt.some(st) : tt.none();
  }, J = (Fe) => L.fromDom(Fe.dom.host), me = (Fe) => {
    const st = qt(Fe) ? Fe.dom.parentNode : Fe.dom;
    if (st == null || st.ownerDocument === null)
      return !1;
    const Qt = st.ownerDocument;
    return we(L.fromDom(st)).fold(() => Qt.body.contains(st), _t(me, J));
  }, ce = (Fe, st, Qt) => {
    let Ut = Fe.dom;
    const Tn = Ie(Qt) ? Qt : Ne;
    for (; Ut.parentNode; ) {
      Ut = Ut.parentNode;
      const Pn = L.fromDom(Ut);
      if (st(Pn))
        return tt.some(Pn);
      if (Tn(Pn))
        break;
    }
    return tt.none();
  }, Ce = (Fe, st, Qt) => ce(Fe, (Ut) => Wt(Ut, st), Qt), W = (Fe) => Fe.style !== void 0 && Ie(Fe.style.getPropertyValue), M = (Fe, st) => {
    const Qt = Fe.dom, Tn = window.getComputedStyle(Qt).getPropertyValue(st);
    return Tn === "" && !me(Fe) ? Ue(Qt, st) : Tn;
  }, Ue = (Fe, st) => W(Fe) ? Fe.style.getPropertyValue(st) : "", kt = (Fe) => M(Fe, "direction") === "rtl" ? "rtl" : "ltr", Qe = (Fe, st) => ae(an(Fe), st), pn = (Fe, st) => Qe(Fe, (Qt) => Wt(Qt, st)), En = (Fe) => Rn(Fe).filter(Ze), Eo = (Fe, st) => (st ? Ce(Fe, "ol,ul") : tt.some(Fe)).getOr(Fe), oo = yt("li"), Yn = (Fe, st) => {
    const Qt = Fe.selection.getSelectedBlocks();
    Qt.length > 0 && (rt(Qt, (Ut) => {
      const Tn = L.fromDom(Ut), Pn = oo(Tn), ho = Eo(Tn, Pn);
      En(ho).each((ue) => {
        if (kt(ue) !== st ? cn(ho, "dir", st) : kt(ho) !== st && wn(ho, "dir"), Pn) {
          const At = pn(ho, "li[dir]");
          rt(At, (Ot) => wn(Ot, "dir"));
        }
      });
    }), Fe.nodeChanged());
  }, eo = (Fe) => {
    Fe.addCommand("mceDirectionLTR", () => {
      Yn(Fe, "ltr");
    }), Fe.addCommand("mceDirectionRTL", () => {
      Yn(Fe, "rtl");
    });
  }, Xt = (Fe, st) => (Qt) => {
    const Ut = (Tn) => {
      const Pn = L.fromDom(Tn.element);
      Qt.setActive(kt(Pn) === st);
    };
    return Fe.on("NodeChange", Ut), () => Fe.off("NodeChange", Ut);
  }, ro = (Fe) => {
    Fe.ui.registry.addToggleButton("ltr", {
      tooltip: "Left to right",
      icon: "ltr",
      onAction: () => Fe.execCommand("mceDirectionLTR"),
      onSetup: Xt(Fe, "ltr")
    }), Fe.ui.registry.addToggleButton("rtl", {
      tooltip: "Right to left",
      icon: "rtl",
      onAction: () => Fe.execCommand("mceDirectionRTL"),
      onSetup: Xt(Fe, "rtl")
    });
  };
  var io = () => {
    g.add("directionality", (Fe) => {
      eo(Fe), ro(Fe);
    });
  };
  io();
})();
(function() {
  const g = ($e) => {
    let Ne = $e;
    return {
      get: () => Ne,
      set: (rt) => {
        Ne = rt;
      }
    };
  };
  var _ = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = ($e, Ne) => {
    $e.dispatch("VisualBlocks", { state: Ne });
  }, X = ($e, Ne, tt) => {
    $e.dom.toggleClass($e.getBody(), "mce-visualblocks"), tt.set(!tt.get()), D($e, tt.get());
  }, _e = ($e, Ne, tt) => {
    $e.addCommand("mceVisualBlocks", () => {
      X($e, Ne, tt);
    });
  }, Ae = ($e) => (Ne) => Ne.options.get($e), We = ($e) => {
    const Ne = $e.options.register;
    Ne("visualblocks_default_state", {
      processor: "boolean",
      default: !1
    });
  }, Ke = Ae("visualblocks_default_state"), Ee = ($e, Ne, tt) => {
    $e.on("PreviewFormats AfterPreviewFormats", (xe) => {
      tt.get() && $e.dom.toggleClass($e.getBody(), "mce-visualblocks", xe.type === "afterpreviewformats");
    }), $e.on("init", () => {
      Ke($e) && X($e, Ne, tt);
    });
  }, Ie = ($e, Ne) => (tt) => {
    tt.setActive(Ne.get());
    const xe = (rt) => tt.setActive(rt.state);
    return $e.on("VisualBlocks", xe), () => $e.off("VisualBlocks", xe);
  }, pt = ($e, Ne) => {
    const tt = () => $e.execCommand("mceVisualBlocks");
    $e.ui.registry.addToggleButton("visualblocks", {
      icon: "visualblocks",
      tooltip: "Show blocks",
      onAction: tt,
      onSetup: Ie($e, Ne)
    }), $e.ui.registry.addToggleMenuItem("visualblocks", {
      text: "Show blocks",
      icon: "visualblocks",
      onAction: tt,
      onSetup: Ie($e, Ne)
    });
  };
  var _t = () => {
    _.add("visualblocks", ($e, Ne) => {
      We($e);
      const tt = g(!1);
      _e($e, Ne, tt), pt($e, tt), Ee($e, Ne, tt);
    });
  };
  _t();
})();
(function() {
  const g = (ue) => {
    let ze = ue;
    return {
      get: () => ze,
      set: (hn) => {
        ze = hn;
      }
    };
  };
  var _ = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = (ue) => ({ isEnabled: () => ue.get() }), X = (ue, ze) => ue.dispatch("VisualChars", { state: ze }), _e = (ue, ze, At) => {
    var Ot;
    return At(ue, ze.prototype) ? !0 : ((Ot = ue.constructor) === null || Ot === void 0 ? void 0 : Ot.name) === ze.name;
  }, Ae = (ue) => {
    const ze = typeof ue;
    return ue === null ? "null" : ze === "object" && Array.isArray(ue) ? "array" : ze === "object" && _e(ue, String, (At, Ot) => Ot.isPrototypeOf(At)) ? "string" : ze;
  }, We = (ue) => (ze) => Ae(ze) === ue, Ke = (ue) => (ze) => typeof ze === ue, Ee = (ue) => (ze) => ue === ze, Ie = We("string"), pt = Ee(null), _t = Ke("boolean"), $e = (ue) => ue == null, Ne = (ue) => !$e(ue), tt = Ke("number");
  class xe {
    constructor(ze, At) {
      this.tag = ze, this.value = At;
    }
    static some(ze) {
      return new xe(!0, ze);
    }
    static none() {
      return xe.singletonNone;
    }
    fold(ze, At) {
      return this.tag ? At(this.value) : ze();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ze) {
      return this.tag ? xe.some(ze(this.value)) : xe.none();
    }
    bind(ze) {
      return this.tag ? ze(this.value) : xe.none();
    }
    exists(ze) {
      return this.tag && ze(this.value);
    }
    forall(ze) {
      return !this.tag || ze(this.value);
    }
    filter(ze) {
      return !this.tag || ze(this.value) ? this : xe.none();
    }
    getOr(ze) {
      return this.tag ? this.value : ze;
    }
    or(ze) {
      return this.tag ? this : ze;
    }
    getOrThunk(ze) {
      return this.tag ? this.value : ze();
    }
    orThunk(ze) {
      return this.tag ? this : ze();
    }
    getOrDie(ze) {
      if (this.tag)
        return this.value;
      throw new Error(ze != null ? ze : "Called getOrDie on None");
    }
    static from(ze) {
      return Ne(ze) ? xe.some(ze) : xe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ze) {
      this.tag && ze(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  xe.singletonNone = new xe(!1);
  const rt = (ue, ze) => {
    const At = ue.length, Ot = new Array(At);
    for (let hn = 0; hn < At; hn++) {
      const Ao = ue[hn];
      Ot[hn] = ze(Ao, hn);
    }
    return Ot;
  }, ae = (ue, ze) => {
    for (let At = 0, Ot = ue.length; At < Ot; At++) {
      const hn = ue[At];
      ze(hn, At);
    }
  }, ke = (ue, ze) => {
    const At = [];
    for (let Ot = 0, hn = ue.length; Ot < hn; Ot++) {
      const Ao = ue[Ot];
      ze(Ao, Ot) && At.push(Ao);
    }
    return At;
  }, ge = Object.keys, zt = (ue, ze) => {
    const At = ge(ue);
    for (let Ot = 0, hn = At.length; Ot < hn; Ot++) {
      const Ao = At[Ot], xs = ue[Ao];
      ze(xs, Ao);
    }
  };
  typeof window < "u" || Function("return this;")();
  const ot = 3, le = (ue) => ue.dom.nodeType, it = (ue) => ue.dom.nodeValue, Le = ((ue) => (ze) => le(ze) === ue)(ot), Ve = (ue, ze, At) => {
    if (Ie(At) || _t(At) || tt(At))
      ue.setAttribute(ze, At + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", ze, ":: Value ", At, ":: Element ", ue), new Error("Attribute value was not simple");
  }, L = (ue, ze, At) => {
    Ve(ue.dom, ze, At);
  }, Wt = (ue, ze) => {
    const At = ue.dom.getAttribute(ze);
    return At === null ? void 0 : At;
  }, Je = (ue, ze) => {
    ue.dom.removeAttribute(ze);
  }, jt = (ue, ze) => {
    const At = Wt(ue, ze);
    return At === void 0 || At === "" ? [] : At.split(" ");
  }, ye = (ue, ze, At) => {
    const hn = jt(ue, ze).concat([At]);
    return L(ue, ze, hn.join(" ")), !0;
  }, Ze = (ue, ze, At) => {
    const Ot = ke(jt(ue, ze), (hn) => hn !== At);
    return Ot.length > 0 ? L(ue, ze, Ot.join(" ")) : Je(ue, ze), !1;
  }, qt = (ue) => ue.dom.classList !== void 0, Z = (ue) => jt(ue, "class"), Pe = (ue, ze) => ye(ue, "class", ze), yt = (ue, ze) => Ze(ue, "class", ze), et = (ue, ze) => {
    qt(ue) ? ue.dom.classList.add(ze) : Pe(ue, ze);
  }, kn = (ue) => {
    (qt(ue) ? ue.dom.classList : Z(ue)).length === 0 && Je(ue, "class");
  }, Rn = (ue, ze) => {
    qt(ue) ? ue.dom.classList.remove(ze) : yt(ue, ze), kn(ue);
  }, an = (ue, ze) => {
    const Ot = (ze || document).createElement("div");
    if (Ot.innerHTML = ue, !Ot.hasChildNodes() || Ot.childNodes.length > 1) {
      const hn = "HTML does not have a single root node";
      throw console.error(hn, ue), new Error(hn);
    }
    return wn(Ot.childNodes[0]);
  }, en = (ue, ze) => {
    const Ot = (ze || document).createElement(ue);
    return wn(Ot);
  }, cn = (ue, ze) => {
    const Ot = (ze || document).createTextNode(ue);
    return wn(Ot);
  }, wn = (ue) => {
    if (ue == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: ue };
  }, ie = {
    fromHtml: an,
    fromTag: en,
    fromText: cn,
    fromDom: wn,
    fromPoint: (ue, ze, At) => xe.from(ue.dom.elementFromPoint(ze, At)).map(wn)
  }, re = {
    "\xA0": "nbsp",
    "\xAD": "shy"
  }, we = (ue, ze) => {
    let At = "";
    return zt(ue, (Ot, hn) => {
      At += hn;
    }), new RegExp("[" + At + "]", ze ? "g" : "");
  }, J = (ue) => {
    let ze = "";
    return zt(ue, (At) => {
      ze && (ze += ","), ze += "span.mce-" + At;
    }), ze;
  }, me = we(re), ce = we(re, !0), Ce = J(re), W = "mce-nbsp", M = (ue) => '<span data-mce-bogus="1" class="mce-' + re[ue] + '">' + ue + "</span>", Ue = (ue) => {
    const ze = it(ue);
    return Le(ue) && ze !== void 0 && me.test(ze);
  }, kt = (ue, ze) => {
    let At = [];
    const Ot = ue.dom, hn = rt(Ot.childNodes, ie.fromDom);
    return ae(hn, (Ao) => {
      ze(Ao) && (At = At.concat([Ao])), At = At.concat(kt(Ao, ze));
    }), At;
  }, Qe = (ue, ze) => {
    for (; ue.parentNode; ) {
      if (ue.parentNode === ze)
        return ue;
      ue = ue.parentNode;
    }
  }, pn = (ue) => ue.replace(ce, M), En = (ue) => ue.nodeName.toLowerCase() === "span" && ue.classList.contains("mce-nbsp-wrap"), Eo = (ue, ze) => {
    const At = kt(ie.fromDom(ze), Ue);
    ae(At, (Ot) => {
      const hn = Ot.dom.parentNode;
      if (En(hn))
        et(ie.fromDom(hn), W);
      else {
        const Ao = pn(ue.dom.encode(it(Ot))), xs = ue.dom.create("div", null, Ao);
        let zs;
        for (; zs = xs.lastChild; )
          ue.dom.insertAfter(zs, Ot.dom);
        ue.dom.remove(Ot.dom);
      }
    });
  }, oo = (ue, ze) => {
    const At = ue.dom.select(Ce, ze);
    ae(At, (Ot) => {
      En(Ot) ? Rn(ie.fromDom(Ot), W) : ue.dom.remove(Ot, !0);
    });
  }, Yn = (ue) => {
    const ze = ue.getBody(), At = ue.selection.getBookmark();
    let Ot = Qe(ue.selection.getNode(), ze);
    Ot = Ot !== void 0 ? Ot : ze, oo(ue, Ot), Eo(ue, Ot), ue.selection.moveToBookmark(At);
  }, eo = (ue, ze) => {
    X(ue, ze.get());
    const At = ue.getBody();
    ze.get() === !0 ? Eo(ue, At) : oo(ue, At);
  }, Xt = (ue, ze) => {
    ze.set(!ze.get());
    const At = ue.selection.getBookmark();
    eo(ue, ze), ue.selection.moveToBookmark(At);
  }, ro = (ue, ze) => {
    ue.addCommand("mceVisualChars", () => {
      Xt(ue, ze);
    });
  }, io = (ue) => (ze) => ze.options.get(ue), Fe = (ue) => {
    const ze = ue.options.register;
    ze("visualchars_default_state", {
      processor: "boolean",
      default: !1
    });
  }, st = io("visualchars_default_state"), Qt = (ue, ze) => {
    ue.on("init", () => {
      eo(ue, ze);
    });
  }, Ut = (ue, ze) => {
    let At = null;
    return {
      cancel: () => {
        pt(At) || (clearTimeout(At), At = null);
      },
      throttle: (...Ao) => {
        pt(At) && (At = setTimeout(() => {
          At = null, ue.apply(null, Ao);
        }, ze));
      }
    };
  }, Tn = (ue, ze) => {
    const At = Ut(() => {
      Yn(ue);
    }, 300);
    ue.on("keydown", (Ot) => {
      ze.get() === !0 && (Ot.keyCode === 13 ? Yn(ue) : At.throttle());
    }), ue.on("remove", At.cancel);
  }, Pn = (ue, ze) => (At) => {
    At.setActive(ze.get());
    const Ot = (hn) => At.setActive(hn.state);
    return ue.on("VisualChars", Ot), () => ue.off("VisualChars", Ot);
  }, ho = (ue, ze) => {
    const At = () => ue.execCommand("mceVisualChars");
    ue.ui.registry.addToggleButton("visualchars", {
      tooltip: "Show invisible characters",
      icon: "visualchars",
      onAction: At,
      onSetup: Pn(ue, ze)
    }), ue.ui.registry.addToggleMenuItem("visualchars", {
      text: "Show invisible characters",
      icon: "visualchars",
      onAction: At,
      onSetup: Pn(ue, ze)
    });
  };
  var Bo = () => {
    _.add("visualchars", (ue) => {
      Fe(ue);
      const ze = g(st(ue));
      return ro(ue, ze), ho(ue, ze), Tn(ue, ze), Qt(ue, ze), D(ze);
    });
  };
  Bo();
})();
(function() {
  const g = ($) => {
    let V = $;
    return {
      get: () => V,
      set: (Zt) => {
        V = Zt;
      }
    };
  };
  var _ = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = ($) => ({ isFullscreen: () => $.get() !== null }), X = ($, V, Te) => {
    var He;
    return Te($, V.prototype) ? !0 : ((He = $.constructor) === null || He === void 0 ? void 0 : He.name) === V.name;
  }, _e = ($) => {
    const V = typeof $;
    return $ === null ? "null" : V === "object" && Array.isArray($) ? "array" : V === "object" && X($, String, (Te, He) => He.isPrototypeOf(Te)) ? "string" : V;
  }, Ae = ($) => (V) => _e(V) === $, We = ($) => (V) => typeof V === $, Ke = ($) => (V) => $ === V, Ee = Ae("string"), Ie = Ae("array"), pt = Ke(null), _t = We("boolean"), $e = ($) => $ == null, Ne = ($) => !$e($), tt = We("function"), xe = We("number"), rt = () => {
  }, ae = ($, V) => (...Te) => $(V.apply(null, Te)), ke = ($, V) => (Te) => $(V(Te)), ge = ($) => () => $;
  function zt($, ...V) {
    return (...Te) => {
      const He = V.concat(Te);
      return $.apply(null, He);
    };
  }
  const ot = ge(!1), le = ge(!0);
  class it {
    constructor(V, Te) {
      this.tag = V, this.value = Te;
    }
    static some(V) {
      return new it(!0, V);
    }
    static none() {
      return it.singletonNone;
    }
    fold(V, Te) {
      return this.tag ? Te(this.value) : V();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(V) {
      return this.tag ? it.some(V(this.value)) : it.none();
    }
    bind(V) {
      return this.tag ? V(this.value) : it.none();
    }
    exists(V) {
      return this.tag && V(this.value);
    }
    forall(V) {
      return !this.tag || V(this.value);
    }
    filter(V) {
      return !this.tag || V(this.value) ? this : it.none();
    }
    getOr(V) {
      return this.tag ? this.value : V;
    }
    or(V) {
      return this.tag ? this : V;
    }
    getOrThunk(V) {
      return this.tag ? this.value : V();
    }
    orThunk(V) {
      return this.tag ? this : V();
    }
    getOrDie(V) {
      if (this.tag)
        return this.value;
      throw new Error(V != null ? V : "Called getOrDie on None");
    }
    static from(V) {
      return Ne(V) ? it.some(V) : it.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(V) {
      this.tag && V(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  it.singletonNone = new it(!1);
  const ft = ($) => {
    const V = g(it.none()), Te = () => V.get().each($);
    return {
      clear: () => {
        Te(), V.set(it.none());
      },
      isSet: () => V.get().isSome(),
      get: () => V.get(),
      set: (jo) => {
        Te(), V.set(it.some(jo));
      }
    };
  }, Le = () => ft(($) => $.unbind()), Ve = () => {
    const $ = ft(rt);
    return {
      ...$,
      on: (Te) => $.get().each(Te)
    };
  }, L = ($, V) => {
    let Te = null;
    return {
      cancel: () => {
        pt(Te) || (clearTimeout(Te), Te = null);
      },
      throttle: (...tn) => {
        pt(Te) && (Te = setTimeout(() => {
          Te = null, $.apply(null, tn);
        }, V));
      }
    };
  }, Wt = Array.prototype.push, Je = ($, V) => {
    const Te = $.length, He = new Array(Te);
    for (let Zt = 0; Zt < Te; Zt++) {
      const tn = $[Zt];
      He[Zt] = V(tn, Zt);
    }
    return He;
  }, jt = ($, V) => {
    for (let Te = 0, He = $.length; Te < He; Te++) {
      const Zt = $[Te];
      V(Zt, Te);
    }
  }, ye = ($, V) => {
    const Te = [];
    for (let He = 0, Zt = $.length; He < Zt; He++) {
      const tn = $[He];
      V(tn, He) && Te.push(tn);
    }
    return Te;
  }, Ze = ($, V, Te) => {
    for (let He = 0, Zt = $.length; He < Zt; He++) {
      const tn = $[He];
      if (V(tn, He))
        return it.some(tn);
      if (Te(tn, He))
        break;
    }
    return it.none();
  }, qt = ($, V) => Ze($, V, ot), Z = ($) => {
    const V = [];
    for (let Te = 0, He = $.length; Te < He; ++Te) {
      if (!Ie($[Te]))
        throw new Error("Arr.flatten item " + Te + " was not an array, input: " + $);
      Wt.apply(V, $[Te]);
    }
    return V;
  }, Pe = ($, V) => Z(Je($, V)), yt = ($, V) => V >= 0 && V < $.length ? it.some($[V]) : it.none(), et = ($) => yt($, 0), kn = ($, V) => {
    for (let Te = 0; Te < $.length; Te++) {
      const He = V($[Te], Te);
      if (He.isSome())
        return He;
    }
    return it.none();
  }, Rn = Object.keys, an = ($, V) => {
    const Te = Rn($);
    for (let He = 0, Zt = Te.length; He < Zt; He++) {
      const tn = Te[He], vo = $[tn];
      V(vo, tn);
    }
  }, en = ($, V) => $.indexOf(V) !== -1, cn = ($) => $.style !== void 0 && tt($.style.getPropertyValue), wn = ($, V) => {
    const He = (V || document).createElement("div");
    if (He.innerHTML = $, !He.hasChildNodes() || He.childNodes.length > 1) {
      const Zt = "HTML does not have a single root node";
      throw console.error(Zt, $), new Error(Zt);
    }
    return re(He.childNodes[0]);
  }, w = ($, V) => {
    const He = (V || document).createElement($);
    return re(He);
  }, ie = ($, V) => {
    const He = (V || document).createTextNode($);
    return re(He);
  }, re = ($) => {
    if ($ == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: $ };
  }, J = {
    fromHtml: wn,
    fromTag: w,
    fromText: ie,
    fromDom: re,
    fromPoint: ($, V, Te) => it.from($.dom.elementFromPoint(V, Te)).map(re)
  };
  typeof window < "u" || Function("return this;")();
  const me = 9, ce = 11, Ce = 1, W = 3, M = ($) => $.dom.nodeType, Ue = ($) => (V) => M(V) === $, kt = Ue(Ce), Qe = Ue(W), pn = Ue(me), En = Ue(ce), Eo = ($, V) => {
    const Te = $.dom;
    if (Te.nodeType !== Ce)
      return !1;
    {
      const He = Te;
      if (He.matches !== void 0)
        return He.matches(V);
      if (He.msMatchesSelector !== void 0)
        return He.msMatchesSelector(V);
      if (He.webkitMatchesSelector !== void 0)
        return He.webkitMatchesSelector(V);
      if (He.mozMatchesSelector !== void 0)
        return He.mozMatchesSelector(V);
      throw new Error("Browser lacks native selectors");
    }
  }, oo = ($) => $.nodeType !== Ce && $.nodeType !== me && $.nodeType !== ce || $.childElementCount === 0, Yn = ($, V) => {
    const Te = V === void 0 ? document : V.dom;
    return oo(Te) ? [] : Je(Te.querySelectorAll($), J.fromDom);
  }, eo = ($, V) => $.dom === V.dom, Xt = ($) => J.fromDom($.dom.ownerDocument), ro = ($) => pn($) ? $ : Xt($), io = ($) => it.from($.dom.parentNode).map(J.fromDom), Fe = ($, V) => {
    const Te = tt(V) ? V : ot;
    let He = $.dom;
    const Zt = [];
    for (; He.parentNode !== null && He.parentNode !== void 0; ) {
      const tn = He.parentNode, vo = J.fromDom(tn);
      if (Zt.push(vo), Te(vo) === !0)
        break;
      He = tn;
    }
    return Zt;
  }, st = ($) => {
    const V = (Te) => ye(Te, (He) => !eo($, He));
    return io($).map(Qt).map(V).getOr([]);
  }, Qt = ($) => Je($.dom.childNodes, J.fromDom), Ut = ($) => En($) && Ne($.dom.host), Tn = tt(Element.prototype.attachShadow) && tt(Node.prototype.getRootNode), Pn = ge(Tn), ho = Tn ? ($) => J.fromDom($.dom.getRootNode()) : ro, Bo = ($) => {
    const V = ho($);
    return Ut(V) ? it.some(V) : it.none();
  }, ue = ($) => J.fromDom($.dom.host), ze = ($) => {
    if (Pn() && Ne($.target)) {
      const V = J.fromDom($.target);
      if (kt(V) && At(V) && $.composed && $.composedPath) {
        const Te = $.composedPath();
        if (Te)
          return et(Te);
      }
    }
    return it.from($.target);
  }, At = ($) => Ne($.dom.shadowRoot), Ot = ($) => {
    const V = Qe($) ? $.dom.parentNode : $.dom;
    if (V == null || V.ownerDocument === null)
      return !1;
    const Te = V.ownerDocument;
    return Bo(J.fromDom(V)).fold(() => Te.body.contains(V), ke(Ot, ue));
  }, hn = ($) => {
    const V = $.dom.body;
    if (V == null)
      throw new Error("Body is not available yet");
    return J.fromDom(V);
  }, Ao = ($, V, Te) => {
    if (Ee(Te) || _t(Te) || xe(Te))
      $.setAttribute(V, Te + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", V, ":: Value ", Te, ":: Element ", $), new Error("Attribute value was not simple");
  }, xs = ($, V, Te) => {
    Ao($.dom, V, Te);
  }, zs = ($, V) => {
    const Te = $.dom.getAttribute(V);
    return Te === null ? void 0 : Te;
  }, To = ($, V) => {
    $.dom.removeAttribute(V);
  }, rs = ($, V, Te) => {
    if (!Ee(Te))
      throw console.error("Invalid call to CSS.set. Property ", V, ":: Value ", Te, ":: Element ", $), new Error("CSS value must be a string: " + Te);
    cn($) && $.style.setProperty(V, Te);
  }, wo = ($, V) => {
    const Te = $.dom;
    an(V, (He, Zt) => {
      rs(Te, Zt, He);
    });
  }, os = ($, V) => {
    const Te = $.dom, Zt = window.getComputedStyle(Te).getPropertyValue(V);
    return Zt === "" && !Ot($) ? Vn(Te, V) : Zt;
  }, Vn = ($, V) => cn($) ? $.style.getPropertyValue(V) : "", gn = ($, V, Te, He, Zt, tn, vo) => ({
    target: $,
    x: V,
    y: Te,
    stop: He,
    prevent: Zt,
    kill: tn,
    raw: vo
  }), qo = ($) => {
    const V = J.fromDom(ze($).getOr($.target)), Te = () => $.stopPropagation(), He = () => $.preventDefault(), Zt = ae(He, Te);
    return gn(V, $.clientX, $.clientY, Te, He, Zt, $);
  }, lo = ($, V) => (Te) => {
    $(Te) && V(qo(Te));
  }, Io = ($, V, Te, He, Zt) => {
    const tn = lo(Te, He);
    return $.dom.addEventListener(V, tn, Zt), { unbind: zt(As, $, V, tn, Zt) };
  }, Ks = ($, V, Te, He) => Io($, V, Te, He, !1), As = ($, V, Te, He) => {
    $.dom.removeEventListener(V, Te, He);
  }, cs = le, Lo = ($, V, Te) => Ks($, V, cs, Te), Ys = ($) => {
    let V = !1, Te;
    return (...He) => (V || (V = !0, Te = $.apply(null, He)), Te);
  }, O = ($, V, Te, He) => {
    const Zt = $.isiOS() && /ipad/i.test(Te) === !0, tn = $.isiOS() && !Zt, vo = $.isiOS() || $.isAndroid(), jo = vo || He("(pointer:coarse)"), Zs = Zt || !tn && vo && He("(min-device-width:768px)"), qn = tn || vo && !Zs, ko = V.isSafari() && $.isiOS() && /safari/i.test(Te) === !1, Qs = !qn && !Zs && !ko;
    return {
      isiPad: ge(Zt),
      isiPhone: ge(tn),
      isTablet: ge(Zs),
      isPhone: ge(qn),
      isTouch: ge(jo),
      isAndroid: $.isAndroid,
      isiOS: $.isiOS,
      isWebView: ge(ko),
      isDesktop: ge(Qs)
    };
  }, G = ($, V) => {
    for (let Te = 0; Te < $.length; Te++) {
      const He = $[Te];
      if (He.test(V))
        return He;
    }
  }, de = ($, V) => {
    const Te = G($, V);
    if (!Te)
      return {
        major: 0,
        minor: 0
      };
    const He = (Zt) => Number(V.replace(Te, "$" + Zt));
    return Et(He(1), He(2));
  }, dt = ($, V) => {
    const Te = String(V).toLowerCase();
    return $.length === 0 ? rn() : de($, Te);
  }, rn = () => Et(0, 0), Et = ($, V) => ({
    major: $,
    minor: V
  }), An = {
    nu: Et,
    detect: dt,
    unknown: rn
  }, Po = ($, V) => kn(V.brands, (Te) => {
    const He = Te.brand.toLowerCase();
    return qt($, (Zt) => {
      var tn;
      return He === ((tn = Zt.brand) === null || tn === void 0 ? void 0 : tn.toLowerCase());
    }).map((Zt) => ({
      current: Zt.name,
      version: An.nu(parseInt(Te.version, 10), 0)
    }));
  }), ln = ($, V) => {
    const Te = String(V).toLowerCase();
    return qt($, (He) => He.search(Te));
  }, jn = ($, V) => ln($, V).map((Te) => {
    const He = An.detect(Te.versionRegexes, V);
    return {
      current: Te.name,
      version: He
    };
  }), Mo = ($, V) => ln($, V).map((Te) => {
    const He = An.detect(Te.versionRegexes, V);
    return {
      current: Te.name,
      version: He
    };
  }), No = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, q = ($) => (V) => en(V, $), ee = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: ($) => en($, "edge/") && en($, "chrome") && en($, "safari") && en($, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        No
      ],
      search: ($) => en($, "chrome") && !en($, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: ($) => en($, "msie") || en($, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        No,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: q("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: q("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        No,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: ($) => (en($, "safari") || en($, "mobile/")) && en($, "applewebkit")
    }
  ], Ge = [
    {
      name: "Windows",
      search: q("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: ($) => en($, "iphone") || en($, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: q("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: q("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: q("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: q("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: q("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: q("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], St = {
    browsers: ge(ee),
    oses: ge(Ge)
  }, vt = "Edge", wt = "Chromium", It = "IE", Lt = "Opera", un = "Firefox", Xn = "Safari", yo = () => Dn({
    current: void 0,
    version: An.unknown()
  }), Dn = ($) => {
    const V = $.current, Te = $.version, He = (Zt) => () => V === Zt;
    return {
      current: V,
      version: Te,
      isEdge: He(vt),
      isChromium: He(wt),
      isIE: He(It),
      isOpera: He(Lt),
      isFirefox: He(un),
      isSafari: He(Xn)
    };
  }, sr = {
    unknown: yo,
    nu: Dn,
    edge: ge(vt),
    chromium: ge(wt),
    ie: ge(It),
    opera: ge(Lt),
    firefox: ge(un),
    safari: ge(Xn)
  }, bs = "Windows", Bn = "iOS", to = "Android", Qo = "Linux", Jo = "macOS", Ns = "Solaris", Rs = "FreeBSD", Yr = "ChromeOS", js = () => vr({
    current: void 0,
    version: An.unknown()
  }), vr = ($) => {
    const V = $.current, Te = $.version, He = (Zt) => () => V === Zt;
    return {
      current: V,
      version: Te,
      isWindows: He(bs),
      isiOS: He(Bn),
      isAndroid: He(to),
      isMacOS: He(Jo),
      isLinux: He(Qo),
      isSolaris: He(Ns),
      isFreeBSD: He(Rs),
      isChromeOS: He(Yr)
    };
  }, rr = {
    unknown: js,
    nu: vr,
    windows: ge(bs),
    ios: ge(Bn),
    android: ge(to),
    linux: ge(Qo),
    macos: ge(Jo),
    solaris: ge(Ns),
    freebsd: ge(Rs),
    chromeos: ge(Yr)
  }, Cr = { detect: ($, V, Te) => {
    const He = St.browsers(), Zt = St.oses(), tn = V.bind((Zs) => Po(He, Zs)).orThunk(() => jn(He, $)).fold(sr.unknown, sr.nu), vo = Mo(Zt, $).fold(rr.unknown, rr.nu), jo = O(vo, tn, $, Te);
    return {
      browser: tn,
      os: vo,
      deviceType: jo
    };
  } }, $r = ($) => window.matchMedia($).matches;
  let Xr = Ys(() => Cr.detect(navigator.userAgent, it.from(navigator.userAgentData), $r));
  const Fr = () => Xr(), Xs = ($, V) => ({
    left: $,
    top: V,
    translate: (He, Zt) => Xs($ + He, V + Zt)
  }), Da = Xs, ar = ($) => {
    const V = $ !== void 0 ? $.dom : document, Te = V.body.scrollLeft || V.documentElement.scrollLeft, He = V.body.scrollTop || V.documentElement.scrollTop;
    return Da(Te, He);
  }, Sr = ($) => {
    const V = $ === void 0 ? window : $;
    return Fr().browser.isFirefox() ? it.none() : it.from(V.visualViewport);
  }, Zr = ($, V, Te, He) => ({
    x: $,
    y: V,
    width: Te,
    height: He,
    right: $ + Te,
    bottom: V + He
  }), is = ($) => {
    const V = $ === void 0 ? window : $, Te = V.document, He = ar(J.fromDom(Te));
    return Sr(V).fold(() => {
      const Zt = V.document.documentElement, tn = Zt.clientWidth, vo = Zt.clientHeight;
      return Zr(He.left, He.top, tn, vo);
    }, (Zt) => Zr(Math.max(Zt.pageLeft, He.left), Math.max(Zt.pageTop, He.top), Zt.width, Zt.height));
  }, R = ($, V, Te) => Sr(Te).map((He) => {
    const Zt = (tn) => V(qo(tn));
    return He.addEventListener($, Zt), { unbind: () => He.removeEventListener($, Zt) };
  }).getOrThunk(() => ({ unbind: rt }));
  var Q = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), fe = tinymce.util.Tools.resolve("tinymce.Env");
  const qe = ($, V) => {
    $.dispatch("FullscreenStateChanged", { state: V }), $.dispatch("ResizeEditor");
  }, bt = ($) => (V) => V.options.get($), Nn = ($) => {
    const V = $.options.register;
    V("fullscreen_native", {
      processor: "boolean",
      default: !1
    });
  }, bo = bt("fullscreen_native"), Vo = ($) => {
    const V = J.fromDom($.getElement());
    return Bo(V).map(ue).getOrThunk(() => hn(Xt(V)));
  }, po = ($) => $.fullscreenElement !== void 0 ? $.fullscreenElement : $.msFullscreenElement !== void 0 ? $.msFullscreenElement : $.webkitFullscreenElement !== void 0 ? $.webkitFullscreenElement : null, ms = () => document.fullscreenElement !== void 0 ? "fullscreenchange" : document.msFullscreenElement !== void 0 ? "MSFullscreenChange" : document.webkitFullscreenElement !== void 0 ? "webkitfullscreenchange" : "fullscreenchange", ks = ($) => {
    const V = $.dom;
    V.requestFullscreen ? V.requestFullscreen() : V.msRequestFullscreen ? V.msRequestFullscreen() : V.webkitRequestFullScreen && V.webkitRequestFullScreen();
  }, xr = ($) => {
    const V = $.dom;
    V.exitFullscreen ? V.exitFullscreen() : V.msExitFullscreen ? V.msExitFullscreen() : V.webkitCancelFullScreen && V.webkitCancelFullScreen();
  }, Ro = ($) => $.dom === po(Xt($).dom), Oa = ($, V, Te) => ye(Fe($, Te), V), ya = ($, V) => ye(st($), V), cr = ($) => Yn($), ps = ($, V, Te) => Oa($, (He) => Eo(He, V), Te), hr = ($, V) => ya($, (Te) => Eo(Te, V)), Er = "data-ephox-mobile-fullscreen-style", Gn = "display:none!important;", Ds = "position:absolute!important;", Pa = "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;", Qr = "background-color:rgb(255,255,255)!important;", x = fe.os.isAndroid(), B = ($) => {
    const V = os($, "background-color");
    return V !== void 0 && V !== "" ? "background-color:" + V + "!important" : Qr;
  }, K = ($, V, Te) => {
    const He = (qn) => hr(qn, "*:not(.tox-silver-sink)"), Zt = (qn) => (ko) => {
      const Qs = zs(ko, "style"), Js = Qs === void 0 ? "no-styles" : Qs.trim();
      Js !== qn && (xs(ko, Er, Js), wo(ko, $.parseStyle(qn)));
    }, tn = ps(V, "*"), vo = Pe(tn, He), jo = B(Te);
    jt(vo, Zt(Gn)), jt(tn, Zt(Ds + Pa + jo)), Zt((x === !0 ? "" : Ds) + Pa + jo)(V);
  }, Re = ($) => {
    const V = cr("[" + Er + "]");
    jt(V, (Te) => {
      const He = zs(Te, Er);
      He !== "no-styles" ? wo(Te, $.parseStyle(He)) : To(Te, "style"), To(Te, Er);
    });
  }, Gt = Q.DOM, Un = () => is(window), Zn = ($) => window.scrollTo($.x, $.y), nt = Sr().fold(() => ({
    bind: rt,
    unbind: rt
  }), ($) => {
    const V = Ve(), Te = Le(), He = Le(), Zt = () => {
      document.body.scrollTop = 0, document.documentElement.scrollTop = 0;
    }, tn = () => {
      window.requestAnimationFrame(() => {
        V.on((qn) => wo(qn, {
          top: $.offsetTop + "px",
          left: $.offsetLeft + "px",
          height: $.height + "px",
          width: $.width + "px"
        }));
      });
    }, vo = L(() => {
      Zt(), tn();
    }, 50);
    return {
      bind: (qn) => {
        V.set(qn), vo.throttle(), Te.set(R("resize", vo.throttle)), He.set(R("scroll", vo.throttle));
      },
      unbind: () => {
        V.on(() => {
          Te.clear(), He.clear();
        }), V.clear();
      }
    };
  }), Xo = ($, V) => {
    const Te = document.body, He = document.documentElement, Zt = $.getContainer(), tn = J.fromDom(Zt), vo = Vo($), jo = V.get(), Zs = J.fromDom($.getBody()), qn = fe.deviceType.isTouch(), ko = Zt.style, Js = $.iframeElement.style, Ya = (ao) => {
      ao(Te, "tox-fullscreen"), ao(He, "tox-fullscreen"), ao(Zt, "tox-fullscreen"), Bo(tn).map((es) => ue(es).dom).each((es) => {
        ao(es, "tox-fullscreen"), ao(es, "tox-shadowhost");
      });
    }, ir = () => {
      qn && Re($.dom), Ya(Gt.removeClass), nt.unbind(), it.from(V.get()).each((ao) => ao.fullscreenChangeHandler.unbind());
    };
    if (jo)
      jo.fullscreenChangeHandler.unbind(), bo($) && Ro(vo) && xr(Xt(vo)), Js.width = jo.iframeWidth, Js.height = jo.iframeHeight, ko.width = jo.containerWidth, ko.height = jo.containerHeight, ko.top = jo.containerTop, ko.left = jo.containerLeft, ir(), Zn(jo.scrollPos), V.set(null), qe($, !1), $.off("remove", ir);
    else {
      const ao = Lo(Xt(vo), ms(), (Os) => {
        bo($) && !Ro(vo) && V.get() !== null && Xo($, V);
      }), es = {
        scrollPos: Un(),
        containerWidth: ko.width,
        containerHeight: ko.height,
        containerTop: ko.top,
        containerLeft: ko.left,
        iframeWidth: Js.width,
        iframeHeight: Js.height,
        fullscreenChangeHandler: ao
      };
      qn && K($.dom, tn, Zs), Js.width = Js.height = "100%", ko.width = ko.height = "", Ya(Gt.addClass), nt.bind(tn), $.on("remove", ir), V.set(es), bo($) && ks(vo), qe($, !0);
    }
  }, Tr = ($, V) => {
    $.addCommand("mceFullScreen", () => {
      Xo($, V);
    });
  }, zo = ($, V) => (Te) => {
    Te.setActive(V.get() !== null);
    const He = (Zt) => Te.setActive(Zt.state);
    return $.on("FullscreenStateChanged", He), () => $.off("FullscreenStateChanged", He);
  }, zr = ($, V) => {
    const Te = () => $.execCommand("mceFullScreen");
    $.ui.registry.addToggleMenuItem("fullscreen", {
      text: "Fullscreen",
      icon: "fullscreen",
      shortcut: "Meta+Shift+F",
      onAction: Te,
      onSetup: zo($, V)
    }), $.ui.registry.addToggleButton("fullscreen", {
      tooltip: "Fullscreen",
      icon: "fullscreen",
      onAction: Te,
      onSetup: zo($, V)
    });
  };
  var gs = () => {
    _.add("fullscreen", ($) => {
      const V = g(null);
      return $.inline || (Nn($), Tr($, V), zr($, V), $.addShortcut("Meta+Shift+F", "", "mceFullScreen")), D(V);
    });
  };
  gs();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = Object.getPrototypeOf, D = (x, B, K) => {
    var Re;
    return K(x, B.prototype) ? !0 : ((Re = x.constructor) === null || Re === void 0 ? void 0 : Re.name) === B.name;
  }, X = (x) => {
    const B = typeof x;
    return x === null ? "null" : B === "object" && Array.isArray(x) ? "array" : B === "object" && D(x, String, (K, Re) => Re.isPrototypeOf(K)) ? "string" : B;
  }, _e = (x) => (B) => X(B) === x, Ae = (x) => (B) => typeof B === x, We = (x) => (B) => x === B, Ke = (x, B) => Ie(x) && D(x, B, (K, Re) => _(K) === Re), Ee = _e("string"), Ie = _e("object"), pt = (x) => Ke(x, Object), _t = _e("array"), $e = We(null), Ne = Ae("boolean"), tt = (x) => x == null, xe = (x) => !tt(x), rt = Ae("function"), ae = Ae("number"), ke = (x, B) => {
    if (_t(x)) {
      for (let K = 0, Re = x.length; K < Re; ++K)
        if (!B(x[K]))
          return !1;
      return !0;
    }
    return !1;
  }, ge = () => {
  };
  class zt {
    constructor(B, K) {
      this.tag = B, this.value = K;
    }
    static some(B) {
      return new zt(!0, B);
    }
    static none() {
      return zt.singletonNone;
    }
    fold(B, K) {
      return this.tag ? K(this.value) : B();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(B) {
      return this.tag ? zt.some(B(this.value)) : zt.none();
    }
    bind(B) {
      return this.tag ? B(this.value) : zt.none();
    }
    exists(B) {
      return this.tag && B(this.value);
    }
    forall(B) {
      return !this.tag || B(this.value);
    }
    filter(B) {
      return !this.tag || B(this.value) ? this : zt.none();
    }
    getOr(B) {
      return this.tag ? this.value : B;
    }
    or(B) {
      return this.tag ? this : B;
    }
    getOrThunk(B) {
      return this.tag ? this.value : B();
    }
    orThunk(B) {
      return this.tag ? this : B();
    }
    getOrDie(B) {
      if (this.tag)
        return this.value;
      throw new Error(B != null ? B : "Called getOrDie on None");
    }
    static from(B) {
      return xe(B) ? zt.some(B) : zt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(B) {
      this.tag && B(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  zt.singletonNone = new zt(!1);
  const ot = Object.keys, le = Object.hasOwnProperty, it = (x, B) => {
    const K = ot(x);
    for (let Re = 0, Gt = K.length; Re < Gt; Re++) {
      const Un = K[Re], Zn = x[Un];
      B(Zn, Un);
    }
  }, ft = (x) => (B, K) => {
    x[K] = B;
  }, Le = (x, B, K, Re) => {
    const Gt = {};
    return it(x, (Un, Zn) => {
      (B(Un, Zn) ? K : Re)(Un, Zn);
    }), Gt;
  }, Ve = (x, B) => {
    const K = {};
    return Le(x, B, ft(K), ge), K;
  }, L = (x, B) => le.call(x, B), Wt = (x, B) => L(x, B) && x[B] !== void 0 && x[B] !== null, Je = Array.prototype.push, jt = (x) => {
    const B = [];
    for (let K = 0, Re = x.length; K < Re; ++K) {
      if (!_t(x[K]))
        throw new Error("Arr.flatten item " + K + " was not an array, input: " + x);
      Je.apply(B, x[K]);
    }
    return B;
  }, ye = (x, B) => B >= 0 && B < x.length ? zt.some(x[B]) : zt.none(), Ze = (x) => ye(x, 0), qt = (x, B) => {
    for (let K = 0; K < x.length; K++) {
      const Re = B(x[K], K);
      if (Re.isSome())
        return Re;
    }
    return zt.none();
  };
  typeof window < "u" || Function("return this;")();
  const Z = (x, B, K) => {
    if (Ee(K) || Ne(K) || ae(K))
      x.setAttribute(B, K + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", B, ":: Value ", K, ":: Element ", x), new Error("Attribute value was not simple");
  }, Pe = (x, B, K) => {
    Z(x.dom, B, K);
  }, yt = (x, B) => {
    x.dom.removeAttribute(B);
  }, et = (x, B) => {
    const Re = (B || document).createElement("div");
    if (Re.innerHTML = x, !Re.hasChildNodes() || Re.childNodes.length > 1) {
      const Gt = "HTML does not have a single root node";
      throw console.error(Gt, x), new Error(Gt);
    }
    return an(Re.childNodes[0]);
  }, kn = (x, B) => {
    const Re = (B || document).createElement(x);
    return an(Re);
  }, Rn = (x, B) => {
    const Re = (B || document).createTextNode(x);
    return an(Re);
  }, an = (x) => {
    if (x == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: x };
  }, cn = {
    fromHtml: et,
    fromTag: kn,
    fromText: Rn,
    fromDom: an,
    fromPoint: (x, B, K) => zt.from(x.dom.elementFromPoint(B, K)).map(an)
  };
  var wn = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), w = tinymce.util.Tools.resolve("tinymce.util.URI");
  const ie = (x) => x.length > 0, re = (x) => (B) => B.options.get(x), we = (x) => {
    const B = x.options.register;
    B("image_dimensions", {
      processor: "boolean",
      default: !0
    }), B("image_advtab", {
      processor: "boolean",
      default: !1
    }), B("image_uploadtab", {
      processor: "boolean",
      default: !0
    }), B("image_prepend_url", {
      processor: "string",
      default: ""
    }), B("image_class_list", { processor: "object[]" }), B("image_description", {
      processor: "boolean",
      default: !0
    }), B("image_title", {
      processor: "boolean",
      default: !1
    }), B("image_caption", {
      processor: "boolean",
      default: !1
    }), B("image_list", {
      processor: (K) => {
        const Re = K === !1 || Ee(K) || ke(K, Ie) || rt(K);
        return Re ? {
          value: K,
          valid: Re
        } : {
          valid: !1,
          message: "Must be false, a string, an array or a function."
        };
      },
      default: !1
    });
  }, J = re("image_dimensions"), me = re("image_advtab"), ce = re("image_uploadtab"), Ce = re("image_prepend_url"), W = re("image_class_list"), M = re("image_description"), Ue = re("image_title"), kt = re("image_caption"), Qe = re("image_list"), pn = re("a11y_advanced_options"), En = re("automatic_uploads"), Eo = (x) => ie(x.options.get("images_upload_url")), oo = (x) => xe(x.options.get("images_upload_handler")), Yn = (x, B) => Math.max(parseInt(x, 10), parseInt(B, 10)), eo = (x) => new Promise((B) => {
    const K = document.createElement("img"), Re = (Un) => {
      K.onload = K.onerror = null, K.parentNode && K.parentNode.removeChild(K), B(Un);
    };
    K.onload = () => {
      const Un = Yn(K.width, K.clientWidth), Zn = Yn(K.height, K.clientHeight), nt = {
        width: Un,
        height: Zn
      };
      Re(Promise.resolve(nt));
    }, K.onerror = () => {
      Re(Promise.reject(`Failed to get image dimensions for: ${x}`));
    };
    const Gt = K.style;
    Gt.visibility = "hidden", Gt.position = "fixed", Gt.bottom = Gt.left = "0px", Gt.width = Gt.height = "auto", document.body.appendChild(K), K.src = x;
  }), Xt = (x) => (x && (x = x.replace(/px$/, "")), x), ro = (x) => (x.length > 0 && /^[0-9]+$/.test(x) && (x += "px"), x), io = (x) => {
    if (x.margin) {
      const B = String(x.margin).split(" ");
      switch (B.length) {
        case 1:
          x["margin-top"] = x["margin-top"] || B[0], x["margin-right"] = x["margin-right"] || B[0], x["margin-bottom"] = x["margin-bottom"] || B[0], x["margin-left"] = x["margin-left"] || B[0];
          break;
        case 2:
          x["margin-top"] = x["margin-top"] || B[0], x["margin-right"] = x["margin-right"] || B[1], x["margin-bottom"] = x["margin-bottom"] || B[0], x["margin-left"] = x["margin-left"] || B[1];
          break;
        case 3:
          x["margin-top"] = x["margin-top"] || B[0], x["margin-right"] = x["margin-right"] || B[1], x["margin-bottom"] = x["margin-bottom"] || B[2], x["margin-left"] = x["margin-left"] || B[1];
          break;
        case 4:
          x["margin-top"] = x["margin-top"] || B[0], x["margin-right"] = x["margin-right"] || B[1], x["margin-bottom"] = x["margin-bottom"] || B[2], x["margin-left"] = x["margin-left"] || B[3];
      }
      delete x.margin;
    }
    return x;
  }, Fe = (x, B) => {
    const K = Qe(x);
    Ee(K) ? fetch(K).then((Re) => {
      Re.ok && Re.json().then(B);
    }) : rt(K) ? K(B) : B(K);
  }, st = (x, B, K) => {
    const Re = () => {
      K.onload = K.onerror = null, x.selection && (x.selection.select(K), x.nodeChanged());
    };
    K.onload = () => {
      !B.width && !B.height && J(x) && x.dom.setAttribs(K, {
        width: String(K.clientWidth),
        height: String(K.clientHeight)
      }), Re();
    }, K.onerror = Re;
  }, Qt = (x) => new Promise((B, K) => {
    const Re = new FileReader();
    Re.onload = () => {
      B(Re.result);
    }, Re.onerror = () => {
      K(Re.error.message);
    }, Re.readAsDataURL(x);
  }), Ut = (x) => x.nodeName === "IMG" && (x.hasAttribute("data-mce-object") || x.hasAttribute("data-mce-placeholder")), Tn = (x, B) => {
    const K = x.options.get;
    return w.isDomSafe(B, "img", {
      allow_html_data_urls: K("allow_html_data_urls"),
      allow_script_urls: K("allow_script_urls"),
      allow_svg_data_urls: K("allow_svg_data_urls")
    });
  }, Pn = wn.DOM, ho = (x) => x.style.marginLeft && x.style.marginRight && x.style.marginLeft === x.style.marginRight ? Xt(x.style.marginLeft) : "", Bo = (x) => x.style.marginTop && x.style.marginBottom && x.style.marginTop === x.style.marginBottom ? Xt(x.style.marginTop) : "", ue = (x) => x.style.borderWidth ? Xt(x.style.borderWidth) : "", ze = (x, B) => x.hasAttribute(B) ? x.getAttribute(B) : "", At = (x, B) => x.style[B] ? x.style[B] : "", Ot = (x) => x.parentNode !== null && x.parentNode.nodeName === "FIGURE", hn = (x, B, K) => {
    K === "" ? x.removeAttribute(B) : x.setAttribute(B, K);
  }, Ao = (x) => {
    const B = Pn.create("figure", { class: "image" });
    Pn.insertAfter(B, x), B.appendChild(x), B.appendChild(Pn.create("figcaption", { contentEditable: "true" }, "Caption")), B.contentEditable = "false";
  }, xs = (x) => {
    const B = x.parentNode;
    Pn.insertAfter(x, B), Pn.remove(B);
  }, zs = (x) => {
    Ot(x) ? xs(x) : Ao(x);
  }, To = (x, B) => {
    const K = x.getAttribute("style"), Re = B(K !== null ? K : "");
    Re.length > 0 ? (x.setAttribute("style", Re), x.setAttribute("data-mce-style", Re)) : x.removeAttribute("style");
  }, rs = (x, B) => (K, Re, Gt) => {
    K.style[Re] ? (K.style[Re] = ro(Gt), To(K, B)) : hn(K, Re, Gt);
  }, wo = (x, B) => x.style[B] ? Xt(x.style[B]) : ze(x, B), os = (x, B) => {
    const K = ro(B);
    x.style.marginLeft = K, x.style.marginRight = K;
  }, Vn = (x, B) => {
    const K = ro(B);
    x.style.marginTop = K, x.style.marginBottom = K;
  }, gn = (x, B) => {
    const K = ro(B);
    x.style.borderWidth = K;
  }, qo = (x, B) => {
    x.style.borderStyle = B;
  }, lo = (x) => At(x, "borderStyle"), Io = (x) => x.nodeName === "FIGURE", Ks = (x) => x.nodeName === "IMG", As = (x) => Pn.getAttrib(x, "alt").length === 0 && Pn.getAttrib(x, "role") === "presentation", cs = (x) => As(x) ? "" : ze(x, "alt"), Lo = () => ({
    src: "",
    alt: "",
    title: "",
    width: "",
    height: "",
    class: "",
    style: "",
    caption: !1,
    hspace: "",
    vspace: "",
    border: "",
    borderStyle: "",
    isDecorative: !1
  }), Ys = (x, B) => {
    const K = document.createElement("img");
    return hn(K, "style", B.style), (ho(K) || B.hspace !== "") && os(K, B.hspace), (Bo(K) || B.vspace !== "") && Vn(K, B.vspace), (ue(K) || B.border !== "") && gn(K, B.border), (lo(K) || B.borderStyle !== "") && qo(K, B.borderStyle), x(K.getAttribute("style"));
  }, O = (x, B) => {
    const K = document.createElement("img");
    if (An(x, {
      ...B,
      caption: !1
    }, K), dt(K, B.alt, B.isDecorative), B.caption) {
      const Re = Pn.create("figure", { class: "image" });
      return Re.appendChild(K), Re.appendChild(Pn.create("figcaption", { contentEditable: "true" }, "Caption")), Re.contentEditable = "false", Re;
    } else
      return K;
  }, G = (x, B) => ({
    src: ze(B, "src"),
    alt: cs(B),
    title: ze(B, "title"),
    width: wo(B, "width"),
    height: wo(B, "height"),
    class: ze(B, "class"),
    style: x(ze(B, "style")),
    caption: Ot(B),
    hspace: ho(B),
    vspace: Bo(B),
    border: ue(B),
    borderStyle: At(B, "borderStyle"),
    isDecorative: As(B)
  }), de = (x, B, K, Re, Gt) => {
    K[Re] !== B[Re] && Gt(x, Re, K[Re]);
  }, dt = (x, B, K) => {
    if (K) {
      Pn.setAttrib(x, "role", "presentation");
      const Re = cn.fromDom(x);
      Pe(Re, "alt", "");
    } else {
      if ($e(B)) {
        const Re = cn.fromDom(x);
        yt(Re, "alt");
      } else {
        const Re = cn.fromDom(x);
        Pe(Re, "alt", B);
      }
      Pn.getAttrib(x, "role") === "presentation" && Pn.setAttrib(x, "role", "");
    }
  }, rn = (x, B, K) => {
    (K.alt !== B.alt || K.isDecorative !== B.isDecorative) && dt(x, K.alt, K.isDecorative);
  }, Et = (x, B) => (K, Re, Gt) => {
    x(K, Gt), To(K, B);
  }, An = (x, B, K) => {
    const Re = G(x, K);
    de(K, Re, B, "caption", (Gt, Un, Zn) => zs(Gt)), de(K, Re, B, "src", hn), de(K, Re, B, "title", hn), de(K, Re, B, "width", rs("width", x)), de(K, Re, B, "height", rs("height", x)), de(K, Re, B, "class", hn), de(K, Re, B, "style", Et((Gt, Un) => hn(Gt, "style", Un), x)), de(K, Re, B, "hspace", Et(os, x)), de(K, Re, B, "vspace", Et(Vn, x)), de(K, Re, B, "border", Et(gn, x)), de(K, Re, B, "borderStyle", Et(qo, x)), rn(K, Re, B);
  }, Po = (x, B) => {
    const K = x.dom.styles.parse(B), Re = io(K), Gt = x.dom.styles.parse(x.dom.styles.serialize(Re));
    return x.dom.styles.serialize(Gt);
  }, ln = (x) => {
    const B = x.selection.getNode(), K = x.dom.getParent(B, "figure.image");
    return K ? x.dom.select("img", K)[0] : B && (B.nodeName !== "IMG" || Ut(B)) ? null : B;
  }, jn = (x, B) => {
    const K = x.dom, Re = Ve(x.schema.getTextBlockElements(), (Un, Zn) => !x.schema.isValidChild(Zn, "figure")), Gt = K.getParent(B.parentNode, (Un) => Wt(Re, Un.nodeName), x.getBody());
    return Gt ? K.split(Gt, B) : B;
  }, Mo = (x) => {
    const B = ln(x);
    return B ? G((K) => Po(x, K), B) : Lo();
  }, No = (x, B) => {
    const K = O((Gt) => Po(x, Gt), B);
    x.dom.setAttrib(K, "data-mce-id", "__mcenew"), x.focus(), x.selection.setContent(K.outerHTML);
    const Re = x.dom.select('*[data-mce-id="__mcenew"]')[0];
    if (x.dom.setAttrib(Re, "data-mce-id", null), Io(Re)) {
      const Gt = jn(x, Re);
      x.selection.select(Gt);
    } else
      x.selection.select(Re);
  }, q = (x, B) => {
    x.dom.setAttrib(B, "src", B.getAttribute("src"));
  }, ee = (x, B) => {
    if (B) {
      const K = x.dom.is(B.parentNode, "figure.image") ? B.parentNode : B;
      x.dom.remove(K), x.focus(), x.nodeChanged(), x.dom.isEmpty(x.getBody()) && (x.setContent(""), x.selection.setCursorLocation());
    }
  }, Ge = (x, B) => {
    const K = ln(x);
    if (An((Re) => Po(x, Re), B, K), q(x, K), Io(K.parentNode)) {
      const Re = K.parentNode;
      jn(x, Re), x.selection.select(K.parentNode);
    } else
      x.selection.select(K), st(x, B, K);
  }, St = (x, B) => {
    const K = B.src;
    return {
      ...B,
      src: Tn(x, K) ? K : ""
    };
  }, vt = (x, B) => {
    const K = ln(x);
    if (K) {
      const Gt = {
        ...G((Zn) => Po(x, Zn), K),
        ...B
      }, Un = St(x, Gt);
      Gt.src ? Ge(x, Un) : ee(x, K);
    } else
      B.src && No(x, {
        ...Lo(),
        ...B
      });
  }, Lt = ((x) => (...B) => {
    if (B.length === 0)
      throw new Error("Can't merge zero objects");
    const K = {};
    for (let Re = 0; Re < B.length; Re++) {
      const Gt = B[Re];
      for (const Un in Gt)
        L(Gt, Un) && (K[Un] = x(K[Un], Gt[Un]));
    }
    return K;
  })((x, B) => pt(x) && pt(B) ? Lt(x, B) : B);
  var un = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), Xn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const yo = (x) => Ee(x.value) ? x.value : "", Dn = (x) => Ee(x.text) ? x.text : Ee(x.title) ? x.title : "", sr = (x, B) => {
    const K = [];
    return Xn.each(x, (Re) => {
      const Gt = Dn(Re);
      if (Re.menu !== void 0) {
        const Un = sr(Re.menu, B);
        K.push({
          text: Gt,
          items: Un
        });
      } else {
        const Un = B(Re);
        K.push({
          text: Gt,
          value: Un
        });
      }
    }), K;
  }, bs = (x = yo) => (B) => B ? zt.from(B).map((K) => sr(K, x)) : zt.none(), Bn = (x) => bs(yo)(x), to = (x) => L(x, "items"), Qo = (x, B) => qt(x, (K) => to(K) ? Qo(K.items, B) : K.value === B ? zt.some(K) : zt.none()), Ns = {
    sanitizer: bs,
    sanitize: Bn,
    findEntry: (x, B) => x.bind((K) => Qo(K, B))
  }, Yr = { makeTab: (x) => ({
    title: "Advanced",
    name: "advanced",
    items: [{
      type: "grid",
      columns: 2,
      items: [
        {
          type: "input",
          label: "Vertical space",
          name: "vspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Horizontal space",
          name: "hspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Border width",
          name: "border",
          inputMode: "numeric"
        },
        {
          type: "listbox",
          name: "borderstyle",
          label: "Border style",
          items: [
            {
              text: "Select...",
              value: ""
            },
            {
              text: "Solid",
              value: "solid"
            },
            {
              text: "Dotted",
              value: "dotted"
            },
            {
              text: "Dashed",
              value: "dashed"
            },
            {
              text: "Double",
              value: "double"
            },
            {
              text: "Groove",
              value: "groove"
            },
            {
              text: "Ridge",
              value: "ridge"
            },
            {
              text: "Inset",
              value: "inset"
            },
            {
              text: "Outset",
              value: "outset"
            },
            {
              text: "None",
              value: "none"
            },
            {
              text: "Hidden",
              value: "hidden"
            }
          ]
        }
      ]
    }]
  }) }, js = (x) => {
    const B = Ns.sanitizer((He) => x.convertURL(He.value || He.url, "src")), K = new Promise((He) => {
      Fe(x, (Zt) => {
        He(B(Zt).map((tn) => jt([
          [{
            text: "None",
            value: ""
          }],
          tn
        ])));
      });
    }), Re = Ns.sanitize(W(x)), Gt = me(x), Un = ce(x), Zn = Eo(x), nt = oo(x), Xo = Mo(x), Tr = M(x), zo = Ue(x), zr = J(x), gs = kt(x), $ = pn(x), V = En(x), Te = zt.some(Ce(x)).filter((He) => Ee(He) && He.length > 0);
    return K.then((He) => ({
      image: Xo,
      imageList: He,
      classList: Re,
      hasAdvTab: Gt,
      hasUploadTab: Un,
      hasUploadUrl: Zn,
      hasUploadHandler: nt,
      hasDescription: Tr,
      hasImageTitle: zo,
      hasDimensions: zr,
      hasImageCaption: gs,
      prependURL: Te,
      hasAccessibilityOptions: $,
      automaticUploads: V
    }));
  }, vr = (x) => {
    const B = {
      name: "src",
      type: "urlinput",
      filetype: "image",
      label: "Source"
    }, K = x.imageList.map((zo) => ({
      name: "images",
      type: "listbox",
      label: "Image list",
      items: zo
    })), Re = {
      name: "alt",
      type: "input",
      label: "Alternative description",
      enabled: !(x.hasAccessibilityOptions && x.image.isDecorative)
    }, Gt = {
      name: "title",
      type: "input",
      label: "Image title"
    }, Un = {
      name: "dimensions",
      type: "sizeinput"
    }, Zn = {
      type: "label",
      label: "Accessibility",
      items: [{
        name: "isDecorative",
        type: "checkbox",
        label: "Image is decorative"
      }]
    }, nt = x.classList.map((zo) => ({
      name: "classes",
      type: "listbox",
      label: "Class",
      items: zo
    })), Xo = {
      type: "label",
      label: "Caption",
      items: [{
        type: "checkbox",
        name: "caption",
        label: "Show caption"
      }]
    }, Tr = (zo) => zo ? {
      type: "grid",
      columns: 2
    } : { type: "panel" };
    return jt([
      [B],
      K.toArray(),
      x.hasAccessibilityOptions && x.hasDescription ? [Zn] : [],
      x.hasDescription ? [Re] : [],
      x.hasImageTitle ? [Gt] : [],
      x.hasDimensions ? [Un] : [],
      [{
        ...Tr(x.classList.isSome() && x.hasImageCaption),
        items: jt([
          nt.toArray(),
          x.hasImageCaption ? [Xo] : []
        ])
      }]
    ]);
  }, Ra = {
    makeTab: (x) => ({
      title: "General",
      name: "general",
      items: vr(x)
    }),
    makeItems: vr
  }, $r = { makeTab: (x) => ({
    title: "Upload",
    name: "upload",
    items: [{
      type: "dropzone",
      name: "fileinput"
    }]
  }) }, Xr = (x) => ({
    prevImage: Ns.findEntry(x.imageList, x.image.src),
    prevAlt: x.image.alt,
    open: !0
  }), Fr = (x) => ({
    src: {
      value: x.src,
      meta: {}
    },
    images: x.src,
    alt: x.alt,
    title: x.title,
    dimensions: {
      width: x.width,
      height: x.height
    },
    classes: x.class,
    caption: x.caption,
    style: x.style,
    vspace: x.vspace,
    border: x.border,
    hspace: x.hspace,
    borderstyle: x.borderStyle,
    fileinput: [],
    isDecorative: x.isDecorative
  }), Xs = (x, B) => ({
    src: x.src.value,
    alt: x.alt.length === 0 && B ? null : x.alt,
    title: x.title,
    width: x.dimensions.width,
    height: x.dimensions.height,
    class: x.classes,
    style: x.style,
    caption: x.caption,
    hspace: x.hspace,
    vspace: x.vspace,
    border: x.border,
    borderStyle: x.borderstyle,
    isDecorative: x.isDecorative
  }), Da = (x, B) => /^(?:[a-zA-Z]+:)?\/\//.test(B) ? zt.none() : x.prependURL.bind((K) => B.substring(0, K.length) !== K ? zt.some(K + B) : zt.none()), ar = (x, B) => {
    const K = B.getData();
    Da(x, K.src.value).each((Re) => {
      B.setData({
        src: {
          value: Re,
          meta: K.src.meta
        }
      });
    });
  }, Sr = (x, B, K) => {
    x.hasDescription && Ee(K.alt) && (B.alt = K.alt), x.hasAccessibilityOptions && (B.isDecorative = K.isDecorative || B.isDecorative || !1), x.hasImageTitle && Ee(K.title) && (B.title = K.title), x.hasDimensions && (Ee(K.width) && (B.dimensions.width = K.width), Ee(K.height) && (B.dimensions.height = K.height)), Ee(K.class) && Ns.findEntry(x.classList, K.class).each((Re) => {
      B.classes = Re.value;
    }), x.hasImageCaption && Ne(K.caption) && (B.caption = K.caption), x.hasAdvTab && (Ee(K.style) && (B.style = K.style), Ee(K.vspace) && (B.vspace = K.vspace), Ee(K.border) && (B.border = K.border), Ee(K.hspace) && (B.hspace = K.hspace), Ee(K.borderstyle) && (B.borderstyle = K.borderstyle));
  }, Zr = (x, B) => {
    const K = B.getData(), Re = K.src.meta;
    if (Re !== void 0) {
      const Gt = Lt({}, K);
      Sr(x, Gt, Re), B.setData(Gt);
    }
  }, is = (x, B, K, Re) => {
    const Gt = Re.getData(), Un = Gt.src.value, Zn = Gt.src.meta || {};
    !Zn.width && !Zn.height && B.hasDimensions && (ie(Un) ? x.imageSize(Un).then((nt) => {
      K.open && Re.setData({ dimensions: nt });
    }).catch((nt) => console.error(nt)) : Re.setData({
      dimensions: {
        width: "",
        height: ""
      }
    }));
  }, R = (x, B, K) => {
    const Re = K.getData(), Gt = Ns.findEntry(x.imageList, Re.src.value);
    B.prevImage = Gt, K.setData({ images: Gt.map((Un) => Un.value).getOr("") });
  }, Q = (x, B, K, Re) => {
    ar(B, Re), Zr(B, Re), is(x, B, K, Re), R(B, K, Re);
  }, fe = (x, B, K, Re) => {
    const Gt = Re.getData(), Un = Ns.findEntry(B.imageList, Gt.images);
    Un.each((Zn) => {
      Gt.alt === "" || K.prevImage.map((Xo) => Xo.text === Gt.alt).getOr(!1) ? Zn.value === "" ? Re.setData({
        src: Zn,
        alt: K.prevAlt
      }) : Re.setData({
        src: Zn,
        alt: Zn.text
      }) : Re.setData({ src: Zn });
    }), K.prevImage = Un, Q(x, B, K, Re);
  }, qe = (x, B, K, Re) => {
    const Gt = Re.getData();
    Re.block("Uploading image"), Ze(Gt.fileinput).fold(() => {
      Re.unblock();
    }, (Un) => {
      const Zn = URL.createObjectURL(Un), nt = () => {
        Re.unblock(), URL.revokeObjectURL(Zn);
      }, Xo = (Tr) => {
        Re.setData({
          src: {
            value: Tr,
            meta: {}
          }
        }), Re.showTab("general"), Q(x, B, K, Re);
      };
      Qt(Un).then((Tr) => {
        const zo = x.createBlobCache(Un, Zn, Tr);
        B.automaticUploads ? x.uploadImage(zo).then((zr) => {
          Xo(zr.url), nt();
        }).catch((zr) => {
          nt(), x.alertErr(zr);
        }) : (x.addToBlobCache(zo), Xo(zo.blobUri()), Re.unblock());
      });
    });
  }, bt = (x, B, K) => (Re, Gt) => {
    Gt.name === "src" ? Q(x, B, K, Re) : Gt.name === "images" ? fe(x, B, K, Re) : Gt.name === "alt" ? K.prevAlt = Re.getData().alt : Gt.name === "fileinput" ? qe(x, B, K, Re) : Gt.name === "isDecorative" && Re.setEnabled("alt", !Re.getData().isDecorative);
  }, Nn = (x) => () => {
    x.open = !1;
  }, bo = (x) => x.hasAdvTab || x.hasUploadUrl || x.hasUploadHandler ? {
    type: "tabpanel",
    tabs: jt([
      [Ra.makeTab(x)],
      x.hasAdvTab ? [Yr.makeTab(x)] : [],
      x.hasUploadTab && (x.hasUploadUrl || x.hasUploadHandler) ? [$r.makeTab(x)] : []
    ])
  } : {
    type: "panel",
    items: Ra.makeItems(x)
  }, Vo = (x, B, K) => (Re) => {
    const Gt = Lt(Fr(B.image), Re.getData()), Un = {
      ...Gt,
      style: Ys(K.normalizeCss, Xs(Gt, !1))
    };
    x.execCommand("mceUpdateImage", !1, Xs(Un, B.hasAccessibilityOptions)), x.editorUpload.uploadImagesAuto(), Re.close();
  }, po = (x) => (B) => Tn(x, B) ? eo(x.documentBaseURI.toAbsolute(B)).then((K) => ({
    width: String(K.width),
    height: String(K.height)
  })) : Promise.resolve({
    width: "",
    height: ""
  }), ms = (x) => (B, K, Re) => x.editorUpload.blobCache.create({
    blob: B,
    blobUri: K,
    name: B.name ? B.name.replace(/\.[^\.]+$/, "") : null,
    filename: B.name,
    base64: Re.split(",")[1]
  }), ks = (x) => (B) => {
    x.editorUpload.blobCache.add(B);
  }, xr = (x) => (B) => {
    x.windowManager.alert(B);
  }, Ro = (x) => (B) => Po(x, B), Oa = (x) => (B) => x.dom.parseStyle(B), ya = (x) => (B, K) => x.dom.serializeStyle(B, K), cr = (x) => (B) => un(x).upload([B], !1).then((K) => K.length === 0 ? Promise.reject("Failed to upload image") : K[0].status === !1 ? Promise.reject(K[0].error.message) : K[0]), ps = (x) => {
    const B = {
      imageSize: po(x),
      addToBlobCache: ks(x),
      createBlobCache: ms(x),
      alertErr: xr(x),
      normalizeCss: Ro(x),
      parseStyle: Oa(x),
      serializeStyle: ya(x),
      uploadImage: cr(x)
    };
    return { open: () => {
      js(x).then((Re) => {
        const Gt = Xr(Re);
        return {
          title: "Insert/Edit Image",
          size: "normal",
          body: bo(Re),
          buttons: [
            {
              type: "cancel",
              name: "cancel",
              text: "Cancel"
            },
            {
              type: "submit",
              name: "save",
              text: "Save",
              primary: !0
            }
          ],
          initialData: Fr(Re.image),
          onSubmit: Vo(x, Re, B),
          onChange: bt(B, Re, Gt),
          onClose: Nn(Gt)
        };
      }).then(x.windowManager.open);
    } };
  }, hr = (x) => {
    x.addCommand("mceImage", ps(x).open), x.addCommand("mceUpdateImage", (B, K) => {
      x.undoManager.transact(() => vt(x, K));
    });
  }, Er = (x) => {
    const B = x.attr("class");
    return B && /\bimage\b/.test(B);
  }, Gn = (x) => (B) => {
    let K = B.length;
    const Re = (Gt) => {
      Gt.attr("contenteditable", x ? "true" : null);
    };
    for (; K--; ) {
      const Gt = B[K];
      Er(Gt) && (Gt.attr("contenteditable", x ? "false" : null), Xn.each(Gt.getAll("figcaption"), Re));
    }
  }, Ds = (x) => {
    x.on("PreInit", () => {
      x.parser.addNodeFilter("figure", Gn(!0)), x.serializer.addNodeFilter("figure", Gn(!1));
    });
  }, Pa = (x) => {
    x.ui.registry.addToggleButton("image", {
      icon: "image",
      tooltip: "Insert/edit image",
      onAction: ps(x).open,
      onSetup: (B) => (B.setActive(xe(ln(x))), x.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", B.setActive).unbind)
    }), x.ui.registry.addMenuItem("image", {
      icon: "image",
      text: "Image...",
      onAction: ps(x).open
    }), x.ui.registry.addContextMenu("image", { update: (B) => Io(B) || Ks(B) && !Ut(B) ? ["image"] : [] });
  };
  var Qr = () => {
    g.add("image", (x) => {
      we(x), Ds(x), Pa(x), hr(x);
    });
  };
  Qr();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (R, Q, fe) => {
    var qe;
    return fe(R, Q.prototype) ? !0 : ((qe = R.constructor) === null || qe === void 0 ? void 0 : qe.name) === Q.name;
  }, D = (R) => {
    const Q = typeof R;
    return R === null ? "null" : Q === "object" && Array.isArray(R) ? "array" : Q === "object" && _(R, String, (fe, qe) => qe.isPrototypeOf(fe)) ? "string" : Q;
  }, X = (R) => (Q) => D(Q) === R, _e = (R) => (Q) => typeof Q === R, Ae = (R) => (Q) => R === Q, We = X("string"), Ke = X("object"), Ee = X("array"), Ie = Ae(null), pt = _e("boolean"), _t = (R) => R == null, $e = (R) => !_t(R), Ne = _e("function"), tt = (R, Q) => {
    if (Ee(R)) {
      for (let fe = 0, qe = R.length; fe < qe; ++fe)
        if (!Q(R[fe]))
          return !1;
      return !0;
    }
    return !1;
  }, xe = () => {
  }, rt = (R, Q) => R === Q;
  class ae {
    constructor(Q, fe) {
      this.tag = Q, this.value = fe;
    }
    static some(Q) {
      return new ae(!0, Q);
    }
    static none() {
      return ae.singletonNone;
    }
    fold(Q, fe) {
      return this.tag ? fe(this.value) : Q();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Q) {
      return this.tag ? ae.some(Q(this.value)) : ae.none();
    }
    bind(Q) {
      return this.tag ? Q(this.value) : ae.none();
    }
    exists(Q) {
      return this.tag && Q(this.value);
    }
    forall(Q) {
      return !this.tag || Q(this.value);
    }
    filter(Q) {
      return !this.tag || Q(this.value) ? this : ae.none();
    }
    getOr(Q) {
      return this.tag ? this.value : Q;
    }
    or(Q) {
      return this.tag ? this : Q;
    }
    getOrThunk(Q) {
      return this.tag ? this.value : Q();
    }
    orThunk(Q) {
      return this.tag ? this : Q();
    }
    getOrDie(Q) {
      if (this.tag)
        return this.value;
      throw new Error(Q != null ? Q : "Called getOrDie on None");
    }
    static from(Q) {
      return $e(Q) ? ae.some(Q) : ae.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Q) {
      this.tag && Q(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ae.singletonNone = new ae(!1);
  const ke = Array.prototype.indexOf, ge = Array.prototype.push, zt = (R, Q) => ke.call(R, Q), ot = (R, Q) => zt(R, Q) > -1, le = (R, Q) => {
    const fe = R.length, qe = new Array(fe);
    for (let bt = 0; bt < fe; bt++) {
      const Nn = R[bt];
      qe[bt] = Q(Nn, bt);
    }
    return qe;
  }, it = (R, Q) => {
    for (let fe = 0, qe = R.length; fe < qe; fe++) {
      const bt = R[fe];
      Q(bt, fe);
    }
  }, ft = (R, Q, fe) => (it(R, (qe, bt) => {
    fe = Q(fe, qe, bt);
  }), fe), Le = (R) => {
    const Q = [];
    for (let fe = 0, qe = R.length; fe < qe; ++fe) {
      if (!Ee(R[fe]))
        throw new Error("Arr.flatten item " + fe + " was not an array, input: " + R);
      ge.apply(Q, R[fe]);
    }
    return Q;
  }, Ve = (R, Q) => Le(le(R, Q)), L = (R, Q) => {
    for (let fe = 0; fe < R.length; fe++) {
      const qe = Q(R[fe], fe);
      if (qe.isSome())
        return qe;
    }
    return ae.none();
  }, Wt = (R, Q, fe = rt) => R.exists((qe) => fe(qe, Q)), Je = (R) => {
    const Q = [], fe = (qe) => {
      Q.push(qe);
    };
    for (let qe = 0; qe < R.length; qe++)
      R[qe].each(fe);
    return Q;
  }, jt = (R, Q) => R ? ae.some(Q) : ae.none(), ye = (R) => (Q) => Q.options.get(R), Ze = (R) => {
    const Q = R.options.register;
    Q("link_assume_external_targets", {
      processor: (fe) => {
        const qe = We(fe) || pt(fe);
        return qe ? fe === !0 ? {
          value: 1,
          valid: qe
        } : fe === "http" || fe === "https" ? {
          value: fe,
          valid: qe
        } : {
          value: 0,
          valid: qe
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), Q("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), Q("link_list", { processor: (fe) => We(fe) || Ne(fe) || tt(fe, Ke) }), Q("link_default_target", { processor: "string" }), Q("link_default_protocol", {
      processor: "string",
      default: "https"
    }), Q("link_target_list", {
      processor: (fe) => pt(fe) || tt(fe, Ke),
      default: !0
    }), Q("link_rel_list", {
      processor: "object[]",
      default: []
    }), Q("link_class_list", {
      processor: "object[]",
      default: []
    }), Q("link_title", {
      processor: "boolean",
      default: !0
    }), Q("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), Q("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, qt = ye("link_assume_external_targets"), Z = ye("link_context_toolbar"), Pe = ye("link_list"), yt = ye("link_default_target"), et = ye("link_default_protocol"), kn = ye("link_target_list"), Rn = ye("link_rel_list"), an = ye("link_class_list"), en = ye("link_title"), cn = ye("allow_unsafe_link_target"), wn = ye("link_quicklink");
  var w = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const ie = (R) => We(R.value) ? R.value : "", re = (R) => We(R.text) ? R.text : We(R.title) ? R.title : "", we = (R, Q) => {
    const fe = [];
    return w.each(R, (qe) => {
      const bt = re(qe);
      if (qe.menu !== void 0) {
        const Nn = we(qe.menu, Q);
        fe.push({
          text: bt,
          items: Nn
        });
      } else {
        const Nn = Q(qe);
        fe.push({
          text: bt,
          value: Nn
        });
      }
    }), fe;
  }, J = (R = ie) => (Q) => ae.from(Q).map((fe) => we(fe, R)), Ce = {
    sanitize: (R) => J(ie)(R),
    sanitizeWith: J,
    createUi: (R, Q) => (fe) => ({
      name: R,
      type: "listbox",
      label: Q,
      items: fe
    }),
    getValue: ie
  }, W = Object.keys, M = Object.hasOwnProperty, Ue = (R, Q) => {
    const fe = W(R);
    for (let qe = 0, bt = fe.length; qe < bt; qe++) {
      const Nn = fe[qe], bo = R[Nn];
      Q(bo, Nn);
    }
  }, kt = (R) => (Q, fe) => {
    R[fe] = Q;
  }, Qe = (R, Q, fe, qe) => {
    const bt = {};
    return Ue(R, (Nn, bo) => {
      (Q(Nn, bo) ? fe : qe)(Nn, bo);
    }), bt;
  }, pn = (R, Q) => {
    const fe = {};
    return Qe(R, Q, kt(fe), xe), fe;
  }, En = (R, Q) => M.call(R, Q), Eo = (R, Q) => En(R, Q) && R[Q] !== void 0 && R[Q] !== null;
  var oo = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Yn = tinymce.util.Tools.resolve("tinymce.util.URI");
  const eo = (R) => R && R.nodeName.toLowerCase() === "a", Xt = (R) => eo(R) && !!Fe(R), ro = (R, Q) => {
    if (R.collapsed)
      return [];
    {
      const fe = R.cloneContents(), qe = new oo(fe.firstChild, fe), bt = [];
      let Nn = fe.firstChild;
      do
        Q(Nn) && bt.push(Nn);
      while (Nn = qe.next());
      return bt;
    }
  }, io = (R) => /^\w+:/i.test(R), Fe = (R) => {
    const Q = R.getAttribute("data-mce-href");
    return Q || R.getAttribute("href");
  }, st = (R, Q) => {
    const fe = ["noopener"], qe = R ? R.split(/\s+/) : [], bt = (po) => w.trim(po.sort().join(" ")), Nn = (po) => (po = bo(po), po.length > 0 ? po.concat(fe) : fe), bo = (po) => po.filter((ms) => w.inArray(fe, ms) === -1), Vo = Q ? Nn(qe) : bo(qe);
    return Vo.length > 0 ? bt(Vo) : "";
  }, Qt = (R) => R.replace(/\uFEFF/g, ""), Ut = (R, Q) => (Q = Q || R.selection.getNode(), ue(Q) ? R.dom.select("a[href]", Q)[0] : R.dom.getParent(Q, "a[href]")), Tn = (R, Q) => {
    const fe = Q ? Q.innerText || Q.textContent : R.getContent({ format: "text" });
    return Qt(fe);
  }, Pn = (R) => w.grep(R, Xt).length > 0, ho = (R) => ro(R, Xt).length > 0, Bo = (R) => {
    const Q = R.schema.getTextInlineElements(), fe = (bt) => bt.nodeType === 1 && !eo(bt) && !En(Q, bt.nodeName.toLowerCase());
    return ro(R.selection.getRng(), fe).length === 0;
  }, ue = (R) => R && R.nodeName === "FIGURE" && /\bimage\b/i.test(R.className), ze = (R) => ft([
    "title",
    "rel",
    "class",
    "target"
  ], (fe, qe) => (R[qe].each((bt) => {
    fe[qe] = bt.length > 0 ? bt : null;
  }), fe), { href: R.href }), At = (R, Q) => (Q === "http" || Q === "https") && !io(R) ? Q + "://" + R : R, Ot = (R, Q) => {
    const fe = { ...Q };
    if (Rn(R).length === 0 && !cn(R)) {
      const qe = st(fe.rel, fe.target === "_blank");
      fe.rel = qe || null;
    }
    return ae.from(fe.target).isNone() && kn(R) === !1 && (fe.target = yt(R)), fe.href = At(fe.href, qt(R)), fe;
  }, hn = (R, Q, fe, qe) => {
    fe.each((bt) => {
      En(Q, "innerText") ? Q.innerText = bt : Q.textContent = bt;
    }), R.dom.setAttribs(Q, qe), R.selection.select(Q);
  }, Ao = (R, Q, fe, qe) => {
    ue(Q) ? qo(R, Q, qe) : fe.fold(() => {
      R.execCommand("mceInsertLink", !1, qe);
    }, (bt) => {
      R.insertContent(R.dom.createHTML("a", qe, R.dom.encode(bt)));
    });
  }, xs = (R, Q, fe) => {
    const qe = R.selection.getNode(), bt = Ut(R, qe), Nn = Ot(R, ze(fe));
    R.undoManager.transact(() => {
      fe.href === Q.href && Q.attach(), bt ? (R.focus(), hn(R, bt, fe.text, Nn)) : Ao(R, qe, fe.text, Nn);
    });
  }, zs = (R) => {
    const Q = R.dom, fe = R.selection, qe = fe.getBookmark(), bt = fe.getRng().cloneRange(), Nn = Q.getParent(bt.startContainer, "a[href]", R.getBody()), bo = Q.getParent(bt.endContainer, "a[href]", R.getBody());
    Nn && bt.setStartBefore(Nn), bo && bt.setEndAfter(bo), fe.setRng(bt), R.execCommand("unlink"), fe.moveToBookmark(qe);
  }, To = (R) => {
    R.undoManager.transact(() => {
      const Q = R.selection.getNode();
      ue(Q) ? gn(R, Q) : zs(R), R.focus();
    });
  }, rs = (R) => {
    const {
      class: Q,
      href: fe,
      rel: qe,
      target: bt,
      text: Nn,
      title: bo
    } = R;
    return pn({
      class: Q.getOrNull(),
      href: fe,
      rel: qe.getOrNull(),
      target: bt.getOrNull(),
      text: Nn.getOrNull(),
      title: bo.getOrNull()
    }, (Vo, po) => Ie(Vo) === !1);
  }, wo = (R, Q) => {
    const fe = R.options.get, qe = {
      allow_html_data_urls: fe("allow_html_data_urls"),
      allow_script_urls: fe("allow_script_urls"),
      allow_svg_data_urls: fe("allow_svg_data_urls")
    }, bt = Q.href;
    return {
      ...Q,
      href: Yn.isDomSafe(bt, "a", qe) ? bt : ""
    };
  }, os = (R, Q, fe) => {
    const qe = wo(R, fe);
    R.hasPlugin("rtc", !0) ? R.execCommand("createlink", !1, rs(qe)) : xs(R, Q, qe);
  }, Vn = (R) => {
    R.hasPlugin("rtc", !0) ? R.execCommand("unlink") : To(R);
  }, gn = (R, Q) => {
    const fe = R.dom.select("img", Q)[0];
    if (fe) {
      const qe = R.dom.getParents(fe, "a[href]", Q)[0];
      qe && (qe.parentNode.insertBefore(fe, qe), R.dom.remove(qe));
    }
  }, qo = (R, Q, fe) => {
    const qe = R.dom.select("img", Q)[0];
    if (qe) {
      const bt = R.dom.create("a", fe);
      qe.parentNode.insertBefore(bt, qe), bt.appendChild(qe);
    }
  }, lo = (R) => Eo(R, "items"), Io = (R, Q) => L(Q, (fe) => lo(fe) ? Io(R, fe.items) : jt(fe.value === R, fe)), Ks = (R, Q, fe, qe) => {
    const bt = qe[Q], Nn = R.length > 0;
    return bt !== void 0 ? Io(bt, fe).map((bo) => ({
      url: {
        value: bo.value,
        meta: {
          text: Nn ? R : bo.text,
          attach: xe
        }
      },
      text: Nn ? R : bo.text
    })) : ae.none();
  }, As = (R, Q) => Q === "link" ? R.link : Q === "anchor" ? R.anchor : ae.none(), Lo = {
    init: (R, Q) => {
      const fe = {
        text: R.text,
        title: R.title
      }, qe = (po) => jt(fe.title.length <= 0, ae.from(po.meta.title).getOr("")), bt = (po) => jt(fe.text.length <= 0, ae.from(po.meta.text).getOr(po.value)), Nn = (po) => {
        const ms = bt(po.url), ks = qe(po.url);
        return ms.isSome() || ks.isSome() ? ae.some({
          ...ms.map((xr) => ({ text: xr })).getOr({}),
          ...ks.map((xr) => ({ title: xr })).getOr({})
        }) : ae.none();
      }, bo = (po, ms) => {
        const ks = As(Q, ms.name).getOr([]);
        return Ks(fe.text, ms.name, ks, po);
      };
      return { onChange: (po, ms) => {
        const ks = ms.name;
        return ks === "url" ? Nn(po()) : ot([
          "anchor",
          "link"
        ], ks) ? bo(po(), ms) : ((ks === "text" || ks === "title") && (fe[ks] = po()[ks]), ae.none());
      } };
    },
    getDelta: Ks
  };
  var Ys = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const O = (R, Q, fe) => {
    const qe = R.selection.getRng();
    Ys.setEditorTimeout(R, () => {
      R.windowManager.confirm(Q, (bt) => {
        R.selection.setRng(qe), fe(bt);
      });
    });
  }, G = (R) => {
    const Q = R.href;
    return Q.indexOf("@") > 0 && Q.indexOf("/") === -1 && Q.indexOf("mailto:") === -1 ? ae.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (qe) => ({
        ...qe,
        href: "mailto:" + Q
      })
    }) : ae.none();
  }, de = (R, Q) => (fe) => {
    const qe = fe.href;
    return R === 1 && !io(qe) || R === 0 && /^\s*www(\.|\d\.)/i.test(qe) ? ae.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${Q}:// prefix?`,
      preprocess: (Nn) => ({
        ...Nn,
        href: Q + "://" + qe
      })
    }) : ae.none();
  }, rn = { preprocess: (R, Q) => L([
    G,
    de(qt(R), et(R))
  ], (fe) => fe(Q)).fold(() => Promise.resolve(Q), (fe) => new Promise((qe) => {
    O(R, fe.message, (bt) => {
      qe(bt ? fe.preprocess(Q) : Q);
    });
  })) }, An = { getAnchors: (R) => {
    const Q = R.dom.select("a:not([href])"), fe = Ve(Q, (qe) => {
      const bt = qe.name || qe.id;
      return bt ? [{
        text: bt,
        value: "#" + bt
      }] : [];
    });
    return fe.length > 0 ? ae.some([{
      text: "None",
      value: ""
    }].concat(fe)) : ae.none();
  } }, ln = { getClasses: (R) => {
    const Q = an(R);
    return Q.length > 0 ? Ce.sanitize(Q) : ae.none();
  } }, jn = (R) => {
    try {
      return ae.some(JSON.parse(R));
    } catch {
      return ae.none();
    }
  }, No = { getLinks: (R) => {
    const Q = (qe) => R.convertURL(qe.value || qe.url, "href"), fe = Pe(R);
    return new Promise((qe) => {
      We(fe) ? fetch(fe).then((bt) => bt.ok ? bt.text().then(jn) : Promise.reject()).then(qe, () => qe(ae.none())) : Ne(fe) ? fe((bt) => qe(ae.some(bt))) : qe(ae.from(fe));
    }).then((qe) => qe.bind(Ce.sanitizeWith(Q)).map((bt) => bt.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(bt) : bt));
  } }, ee = { getRels: (R, Q) => {
    const fe = Rn(R);
    if (fe.length > 0) {
      const qe = Wt(Q, "_blank"), bt = cn(R) === !1, Nn = (Vo) => st(Ce.getValue(Vo), qe);
      return (bt ? Ce.sanitizeWith(Nn) : Ce.sanitize)(fe);
    }
    return ae.none();
  } }, Ge = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], vt = { getTargets: (R) => {
    const Q = kn(R);
    return Ee(Q) ? Ce.sanitize(Q).orThunk(() => ae.some(Ge)) : Q === !1 ? ae.none() : ae.some(Ge);
  } }, wt = (R, Q, fe) => {
    const qe = R.getAttrib(Q, fe);
    return qe !== null && qe.length > 0 ? ae.some(qe) : ae.none();
  }, It = (R, Q) => {
    const fe = R.dom, bt = Bo(R) ? ae.some(Tn(R.selection, Q)) : ae.none(), Nn = Q ? ae.some(fe.getAttrib(Q, "href")) : ae.none(), bo = Q ? ae.from(fe.getAttrib(Q, "target")) : ae.none(), Vo = wt(fe, Q, "rel"), po = wt(fe, Q, "class"), ms = wt(fe, Q, "title");
    return {
      url: Nn,
      text: bt,
      title: ms,
      target: bo,
      rel: Vo,
      linkClass: po
    };
  }, un = { collect: (R, Q) => No.getLinks(R).then((fe) => {
    const qe = It(R, Q);
    return {
      anchor: qe,
      catalogs: {
        targets: vt.getTargets(R),
        rels: ee.getRels(R, qe.target),
        classes: ln.getClasses(R),
        anchor: An.getAnchors(R),
        link: fe
      },
      optNode: ae.from(Q),
      flags: { titleEnabled: en(R) }
    };
  }) }, Xn = (R, Q) => (fe) => {
    const qe = fe.getData();
    if (!qe.url.value) {
      Vn(R), fe.close();
      return;
    }
    const bt = (Vo) => ae.from(qe[Vo]).filter((po) => !Wt(Q.anchor[Vo], po)), Nn = {
      href: qe.url.value,
      text: bt("text"),
      target: bt("target"),
      rel: bt("rel"),
      class: bt("linkClass"),
      title: bt("title")
    }, bo = {
      href: qe.url.value,
      attach: qe.url.meta !== void 0 && qe.url.meta.attach ? qe.url.meta.attach : xe
    };
    rn.preprocess(R, Nn).then((Vo) => {
      os(R, bo, Vo);
    }), fe.close();
  }, yo = (R) => {
    const Q = Ut(R);
    return un.collect(R, Q);
  }, Dn = (R, Q) => {
    const fe = R.anchor, qe = fe.url.getOr("");
    return {
      url: {
        value: qe,
        meta: { original: { value: qe } }
      },
      text: fe.text.getOr(""),
      title: fe.title.getOr(""),
      anchor: qe,
      link: qe,
      rel: fe.rel.getOr(""),
      target: fe.target.or(Q).getOr(""),
      linkClass: fe.linkClass.getOr("")
    };
  }, sr = (R, Q, fe) => {
    const qe = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL"
    }], bt = R.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), Nn = R.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], bo = ae.from(yt(fe)), Vo = Dn(R, bo), po = R.catalogs, ms = Lo.init(Vo, po), ks = {
      type: "panel",
      items: Le([
        qe,
        bt,
        Nn,
        Je([
          po.anchor.map(Ce.createUi("anchor", "Anchors")),
          po.rels.map(Ce.createUi("rel", "Rel")),
          po.targets.map(Ce.createUi("target", "Open link in...")),
          po.link.map(Ce.createUi("link", "Link list")),
          po.classes.map(Ce.createUi("linkClass", "Class"))
        ])
      ])
    };
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: ks,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Vo,
      onChange: (xr, { name: Ro }) => {
        ms.onChange(xr.getData, { name: Ro }).each((Oa) => {
          xr.setData(Oa);
        });
      },
      onSubmit: Q
    };
  }, bs = (R) => {
    yo(R).then((fe) => {
      const qe = Xn(R, fe);
      return sr(fe, qe, R);
    }).then((fe) => {
      R.windowManager.open(fe);
    });
  }, Bn = (R) => {
    R.addCommand("mceLink", (Q, fe) => {
      (fe == null ? void 0 : fe.dialog) === !0 || !wn(R) ? bs(R) : R.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  };
  var to = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Qo = (R, Q) => {
    document.body.appendChild(R), R.dispatchEvent(Q), document.body.removeChild(R);
  }, Jo = (R) => {
    const Q = document.createElement("a");
    Q.target = "_blank", Q.href = R, Q.rel = "noreferrer noopener";
    const fe = document.createEvent("MouseEvents");
    fe.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), Qo(Q, fe);
  }, Ns = (R, Q) => R.dom.getParent(Q, "a[href]"), Rs = (R) => Ns(R, R.selection.getStart()), Yr = (R) => R.altKey === !0 && R.shiftKey === !1 && R.ctrlKey === !1 && R.metaKey === !1, js = (R, Q) => {
    if (Q) {
      const fe = Fe(Q);
      if (/^#/.test(fe)) {
        const qe = R.dom.select(fe);
        qe.length && R.selection.scrollIntoView(qe[0], !0);
      } else
        Jo(Q.href);
    }
  }, vr = (R) => () => {
    R.execCommand("mceLink", !1, { dialog: !0 });
  }, rr = (R) => () => {
    js(R, Rs(R));
  }, Ra = (R) => {
    R.on("click", (Q) => {
      const fe = Ns(R, Q.target);
      fe && to.metaKeyPressed(Q) && (Q.preventDefault(), js(R, fe));
    }), R.on("keydown", (Q) => {
      if (!Q.isDefaultPrevented() && Q.keyCode === 13 && Yr(Q)) {
        const fe = Rs(R);
        fe && (Q.preventDefault(), js(R, fe));
      }
    });
  }, Cr = (R, Q) => (R.on("NodeChange", Q), () => R.off("NodeChange", Q)), $r = (R) => (Q) => {
    const fe = () => Q.setActive(!R.mode.isReadOnly() && Ut(R, R.selection.getNode()) !== null);
    return fe(), Cr(R, fe);
  }, Xr = (R) => (Q) => {
    const fe = () => Q.setEnabled(Ut(R, R.selection.getNode()) !== null);
    return fe(), Cr(R, fe);
  }, Fr = (R) => (Q) => {
    const fe = (bt) => Pn(bt) || ho(R.selection.getRng()), qe = R.dom.getParents(R.selection.getStart());
    return Q.setEnabled(fe(qe)), Cr(R, (bt) => Q.setEnabled(fe(bt.parents)));
  }, Xs = (R) => {
    R.addShortcut("Meta+K", "", () => {
      R.execCommand("mceLink");
    });
  }, Da = (R) => {
    R.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      onAction: vr(R),
      onSetup: $r(R)
    }), R.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: rr(R),
      onSetup: Xr(R)
    }), R.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => Vn(R),
      onSetup: Fr(R)
    });
  }, ar = (R) => {
    R.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: rr(R),
      onSetup: Xr(R)
    }), R.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onAction: vr(R)
    }), R.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => Vn(R),
      onSetup: Fr(R)
    });
  }, Sr = (R) => {
    const Q = "link unlink openlink", fe = "link";
    R.ui.registry.addContextMenu("link", { update: (qe) => Pn(R.dom.getParents(qe, "a")) ? Q : fe });
  }, Zr = (R) => {
    const Q = (bt) => {
      bt.selection.collapse(!1);
    }, fe = (bt) => {
      const Nn = R.selection.getNode();
      return bt.setEnabled(Ut(R, Nn) !== null), xe;
    }, qe = (bt) => {
      const Nn = Ut(R), bo = Bo(R);
      if (!Nn && bo) {
        const Vo = Tn(R.selection, Nn);
        return ae.some(Vo.length > 0 ? Vo : bt);
      } else
        return ae.none();
    };
    R.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: $r(R)
      },
      label: "Link",
      predicate: (bt) => !!Ut(R, bt) && Z(R),
      initValue: () => {
        const bt = Ut(R);
        return bt ? Fe(bt) : "";
      },
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (bt) => {
            const Nn = R.selection.getNode();
            return bt.setActive(!!Ut(R, Nn)), $r(R)(bt);
          },
          onAction: (bt) => {
            const Nn = bt.getValue(), bo = qe(Nn);
            os(R, {
              href: Nn,
              attach: xe
            }, {
              href: Nn,
              text: bo,
              title: ae.none(),
              rel: ae.none(),
              target: ae.none(),
              class: ae.none()
            }), Q(R), bt.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: fe,
          onAction: (bt) => {
            Vn(R), bt.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: fe,
          onAction: (bt) => {
            rr(R)(), bt.hide();
          }
        }
      ]
    });
  };
  var is = () => {
    g.add("link", (R) => {
      Ze(R), Da(R), ar(R), Sr(R), Zr(R), Ra(R), Bn(R), Xs(R);
    });
  };
  is();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (m, h, E) => {
    var P;
    return E(m, h.prototype) ? !0 : ((P = m.constructor) === null || P === void 0 ? void 0 : P.name) === h.name;
  }, D = (m) => {
    const h = typeof m;
    return m === null ? "null" : h === "object" && Array.isArray(m) ? "array" : h === "object" && _(m, String, (E, P) => P.isPrototypeOf(E)) ? "string" : h;
  }, X = (m) => (h) => D(h) === m, _e = (m) => (h) => typeof h === m, Ae = (m) => (h) => m === h, We = X("string"), Ke = X("array"), Ee = _e("boolean"), Ie = Ae(void 0), pt = (m) => m == null, _t = (m) => !pt(m), $e = _e("function"), Ne = _e("number"), tt = () => {
  }, xe = (m, h) => (E) => m(h(E)), rt = (m) => () => m, ae = (m) => m, ke = (m, h) => m === h;
  function ge(m, ...h) {
    return (...E) => {
      const P = h.concat(E);
      return m.apply(null, P);
    };
  }
  const zt = rt(!1), ot = rt(!0);
  class le {
    constructor(h, E) {
      this.tag = h, this.value = E;
    }
    static some(h) {
      return new le(!0, h);
    }
    static none() {
      return le.singletonNone;
    }
    fold(h, E) {
      return this.tag ? E(this.value) : h();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(h) {
      return this.tag ? le.some(h(this.value)) : le.none();
    }
    bind(h) {
      return this.tag ? h(this.value) : le.none();
    }
    exists(h) {
      return this.tag && h(this.value);
    }
    forall(h) {
      return !this.tag || h(this.value);
    }
    filter(h) {
      return !this.tag || h(this.value) ? this : le.none();
    }
    getOr(h) {
      return this.tag ? this.value : h;
    }
    or(h) {
      return this.tag ? this : h;
    }
    getOrThunk(h) {
      return this.tag ? this.value : h();
    }
    orThunk(h) {
      return this.tag ? this : h();
    }
    getOrDie(h) {
      if (this.tag)
        return this.value;
      throw new Error(h != null ? h : "Called getOrDie on None");
    }
    static from(h) {
      return _t(h) ? le.some(h) : le.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(h) {
      this.tag && h(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  le.singletonNone = new le(!1);
  const it = Object.keys, ft = Object.hasOwnProperty, Le = (m, h) => {
    const E = it(m);
    for (let P = 0, oe = E.length; P < oe; P++) {
      const Me = E[P], mt = m[Me];
      h(mt, Me);
    }
  }, Ve = (m) => (h, E) => {
    m[E] = h;
  }, L = (m, h, E, P) => {
    const oe = {};
    return Le(m, (Me, mt) => {
      (h(Me, mt) ? E : P)(Me, mt);
    }), oe;
  }, Wt = (m, h) => {
    const E = {};
    return L(m, h, Ve(E), tt), E;
  }, Je = (m, h) => {
    const E = [];
    return Le(m, (P, oe) => {
      E.push(h(P, oe));
    }), E;
  }, jt = (m) => Je(m, ae), ye = (m) => it(m).length, Ze = (m, h) => qt(m, h) ? le.from(m[h]) : le.none(), qt = (m, h) => ft.call(m, h), Z = (m, h) => qt(m, h) && m[h] !== void 0 && m[h] !== null, Pe = Array.prototype.indexOf, yt = Array.prototype.push, et = (m, h) => Pe.call(m, h), kn = (m, h) => et(m, h) > -1, Rn = (m, h) => {
    for (let E = 0, P = m.length; E < P; E++) {
      const oe = m[E];
      if (h(oe, E))
        return !0;
    }
    return !1;
  }, an = (m, h) => {
    const E = [];
    for (let P = 0; P < m; P++)
      E.push(h(P));
    return E;
  }, en = (m, h) => {
    const E = m.length, P = new Array(E);
    for (let oe = 0; oe < E; oe++) {
      const Me = m[oe];
      P[oe] = h(Me, oe);
    }
    return P;
  }, cn = (m, h) => {
    for (let E = 0, P = m.length; E < P; E++) {
      const oe = m[E];
      h(oe, E);
    }
  }, wn = (m, h) => {
    for (let E = m.length - 1; E >= 0; E--) {
      const P = m[E];
      h(P, E);
    }
  }, w = (m, h) => {
    const E = [], P = [];
    for (let oe = 0, Me = m.length; oe < Me; oe++) {
      const mt = m[oe];
      (h(mt, oe) ? E : P).push(mt);
    }
    return {
      pass: E,
      fail: P
    };
  }, ie = (m, h) => {
    const E = [];
    for (let P = 0, oe = m.length; P < oe; P++) {
      const Me = m[P];
      h(Me, P) && E.push(Me);
    }
    return E;
  }, re = (m, h, E) => (wn(m, (P, oe) => {
    E = h(E, P, oe);
  }), E), we = (m, h, E) => (cn(m, (P, oe) => {
    E = h(E, P, oe);
  }), E), J = (m, h, E) => {
    for (let P = 0, oe = m.length; P < oe; P++) {
      const Me = m[P];
      if (h(Me, P))
        return le.some(Me);
      if (E(Me, P))
        break;
    }
    return le.none();
  }, me = (m, h) => J(m, h, zt), ce = (m) => {
    const h = [];
    for (let E = 0, P = m.length; E < P; ++E) {
      if (!Ke(m[E]))
        throw new Error("Arr.flatten item " + E + " was not an array, input: " + m);
      yt.apply(h, m[E]);
    }
    return h;
  }, Ce = (m, h) => ce(en(m, h)), W = (m, h) => {
    for (let E = 0, P = m.length; E < P; ++E) {
      const oe = m[E];
      if (h(oe, E) !== !0)
        return !1;
    }
    return !0;
  }, M = (m, h) => {
    const E = {};
    for (let P = 0, oe = m.length; P < oe; P++) {
      const Me = m[P];
      E[String(Me)] = h(Me, P);
    }
    return E;
  }, Ue = (m, h) => h >= 0 && h < m.length ? le.some(m[h]) : le.none(), kt = (m) => Ue(m, 0), Qe = (m) => Ue(m, m.length - 1), pn = (m, h) => {
    for (let E = 0; E < m.length; E++) {
      const P = h(m[E], E);
      if (P.isSome())
        return P;
    }
    return le.none();
  }, En = (m, h) => {
    const P = (h || document).createElement("div");
    if (P.innerHTML = m, !P.hasChildNodes() || P.childNodes.length > 1) {
      const oe = "HTML does not have a single root node";
      throw console.error(oe, m), new Error(oe);
    }
    return Yn(P.childNodes[0]);
  }, Eo = (m, h) => {
    const P = (h || document).createElement(m);
    return Yn(P);
  }, oo = (m, h) => {
    const P = (h || document).createTextNode(m);
    return Yn(P);
  }, Yn = (m) => {
    if (m == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: m };
  }, Xt = {
    fromHtml: En,
    fromTag: Eo,
    fromText: oo,
    fromDom: Yn,
    fromPoint: (m, h, E) => le.from(m.dom.elementFromPoint(h, E)).map(Yn)
  };
  typeof window < "u" || Function("return this;")();
  const ro = 8, io = 9, Fe = 11, st = 1, Qt = 3, Ut = (m) => m.dom.nodeName.toLowerCase(), Tn = (m) => m.dom.nodeType, Pn = (m) => (h) => Tn(h) === m, ho = (m) => Tn(m) === ro || Ut(m) === "#comment", Bo = Pn(st), ue = Pn(Qt), ze = Pn(io), At = Pn(Fe), Ot = (m) => (h) => Bo(h) && Ut(h) === m, hn = (m, h) => {
    const E = m.dom;
    if (E.nodeType !== st)
      return !1;
    {
      const P = E;
      if (P.matches !== void 0)
        return P.matches(h);
      if (P.msMatchesSelector !== void 0)
        return P.msMatchesSelector(h);
      if (P.webkitMatchesSelector !== void 0)
        return P.webkitMatchesSelector(h);
      if (P.mozMatchesSelector !== void 0)
        return P.mozMatchesSelector(h);
      throw new Error("Browser lacks native selectors");
    }
  }, Ao = (m) => m.nodeType !== st && m.nodeType !== io && m.nodeType !== Fe || m.childElementCount === 0, xs = (m, h) => {
    const E = h === void 0 ? document : h.dom;
    return Ao(E) ? [] : en(E.querySelectorAll(m), Xt.fromDom);
  }, zs = (m, h) => {
    const E = h === void 0 ? document : h.dom;
    return Ao(E) ? le.none() : le.from(E.querySelector(m)).map(Xt.fromDom);
  }, To = (m, h) => m.dom === h.dom, rs = hn, wo = (m) => Xt.fromDom(m.dom.ownerDocument), os = (m) => ze(m) ? m : wo(m), Vn = (m) => le.from(m.dom.parentNode).map(Xt.fromDom), gn = (m, h) => {
    const E = $e(h) ? h : zt;
    let P = m.dom;
    const oe = [];
    for (; P.parentNode !== null && P.parentNode !== void 0; ) {
      const Me = P.parentNode, mt = Xt.fromDom(Me);
      if (oe.push(mt), E(mt) === !0)
        break;
      P = Me;
    }
    return oe;
  }, qo = (m) => le.from(m.dom.previousSibling).map(Xt.fromDom), lo = (m) => le.from(m.dom.nextSibling).map(Xt.fromDom), Io = (m) => en(m.dom.childNodes, Xt.fromDom), Ks = (m, h) => {
    const E = m.dom.childNodes;
    return le.from(E[h]).map(Xt.fromDom);
  }, As = (m) => Ks(m, 0), cs = (m) => At(m) && _t(m.dom.host), Ys = $e(Element.prototype.attachShadow) && $e(Node.prototype.getRootNode) ? (m) => Xt.fromDom(m.dom.getRootNode()) : os, O = (m) => {
    const h = Ys(m);
    return cs(h) ? le.some(h) : le.none();
  }, G = (m) => Xt.fromDom(m.dom.host), de = (m) => {
    const h = ue(m) ? m.dom.parentNode : m.dom;
    if (h == null || h.ownerDocument === null)
      return !1;
    const E = h.ownerDocument;
    return O(Xt.fromDom(h)).fold(() => E.body.contains(h), xe(de, G));
  }, dt = (m, h) => ie(Io(m), h), rn = (m, h) => {
    let E = [];
    return cn(Io(m), (P) => {
      h(P) && (E = E.concat([P])), E = E.concat(rn(P, h));
    }), E;
  }, Et = (m, h) => dt(m, (E) => hn(E, h)), An = (m, h) => xs(h, m);
  var Po = (m, h, E, P, oe) => m(E, P) ? le.some(E) : $e(oe) && oe(E) ? le.none() : h(E, P, oe);
  const ln = (m, h, E) => {
    let P = m.dom;
    const oe = $e(E) ? E : zt;
    for (; P.parentNode; ) {
      P = P.parentNode;
      const Me = Xt.fromDom(P);
      if (h(Me))
        return le.some(Me);
      if (oe(Me))
        break;
    }
    return le.none();
  }, jn = (m, h) => {
    const E = (oe) => h(Xt.fromDom(oe));
    return me(m.dom.childNodes, E).map(Xt.fromDom);
  }, Mo = (m, h, E) => ln(m, (P) => hn(P, h), E), No = (m, h) => jn(m, (E) => hn(E, h)), q = (m, h) => zs(h, m), ee = (m, h, E) => Po((oe, Me) => hn(oe, Me), Mo, m, h, E), Ge = (m, h, E) => {
    if (We(E) || Ee(E) || Ne(E))
      m.setAttribute(h, E + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", h, ":: Value ", E, ":: Element ", m), new Error("Attribute value was not simple");
  }, St = (m, h, E) => {
    Ge(m.dom, h, E);
  }, vt = (m, h) => {
    const E = m.dom;
    Le(h, (P, oe) => {
      Ge(E, oe, P);
    });
  }, wt = (m, h) => {
    const E = m.dom.getAttribute(h);
    return E === null ? void 0 : E;
  }, It = (m, h) => le.from(wt(m, h)), Lt = (m, h) => {
    m.dom.removeAttribute(h);
  }, un = (m) => we(m.dom.attributes, (h, E) => (h[E.name] = E.value, h), {}), Xn = (m, h, E = ke) => m.exists((P) => E(P, h)), yo = (m) => {
    const h = [], E = (P) => {
      h.push(P);
    };
    for (let P = 0; P < m.length; P++)
      m[P].each(E);
    return h;
  }, Dn = (m, h, E) => m.isSome() && h.isSome() ? le.some(E(m.getOrDie(), h.getOrDie())) : le.none(), sr = (m) => m.bind(ae), bs = (m, h) => m ? le.some(h) : le.none(), Bn = (m, h) => m.substring(h), to = (m, h, E) => h === "" || m.length >= h.length && m.substr(E, E + h.length) === h, Qo = (m, h) => Jo(m, h) ? Bn(m, h.length) : m, Jo = (m, h) => to(m, h, 0), Rs = ((m) => (h) => h.replace(m, ""))(/^\s+|\s+$/g), Yr = (m) => m.length > 0, js = (m) => !Yr(m), vr = (m) => {
    const h = parseFloat(m);
    return isNaN(h) ? le.none() : le.some(h);
  }, rr = (m) => m.style !== void 0 && $e(m.style.getPropertyValue), Ra = (m, h, E) => {
    if (!We(E))
      throw console.error("Invalid call to CSS.set. Property ", h, ":: Value ", E, ":: Element ", m), new Error("CSS value must be a string: " + E);
    rr(m) && m.style.setProperty(h, E);
  }, Cr = (m, h) => {
    rr(m) && m.style.removeProperty(h);
  }, $r = (m, h, E) => {
    const P = m.dom;
    Ra(P, h, E);
  }, Xr = (m, h) => {
    const E = m.dom, oe = window.getComputedStyle(E).getPropertyValue(h);
    return oe === "" && !de(m) ? Fr(E, h) : oe;
  }, Fr = (m, h) => rr(m) ? m.style.getPropertyValue(h) : "", Xs = (m, h) => {
    const E = m.dom, P = Fr(E, h);
    return le.from(P).filter((oe) => oe.length > 0);
  }, Da = (m, h) => {
    const E = m.dom;
    Cr(E, h), Xn(It(m, "style").map(Rs), "") && Lt(m, "style");
  }, ar = (m, h, E = 0) => It(m, h).map((P) => parseInt(P, 10)).getOr(E), Sr = (m, h) => Zr(m, h, ot), Zr = (m, h, E) => Ce(Io(m), (P) => hn(P, h) ? E(P) ? [P] : [] : Zr(P, h, E)), is = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], R = (m) => kn(is, m), Q = (m, h) => ({
    rows: m,
    columns: h
  }), fe = (m, h, E) => ({
    element: m,
    rowspan: h,
    colspan: E
  }), qe = (m, h, E, P, oe, Me) => ({
    element: m,
    rowspan: h,
    colspan: E,
    row: P,
    column: oe,
    isLocked: Me
  }), bt = (m, h, E) => ({
    element: m,
    cells: h,
    section: E
  }), Nn = (m, h, E, P) => ({
    startRow: m,
    startCol: h,
    finishRow: E,
    finishCol: P
  }), bo = (m, h, E) => ({
    element: m,
    colspan: h,
    column: E
  }), Vo = (m, h) => ({
    element: m,
    columns: h
  }), po = (m, h, E = zt) => {
    if (E(h))
      return le.none();
    if (kn(m, Ut(h)))
      return le.some(h);
    const P = (oe) => hn(oe, "table") || E(oe);
    return Mo(h, m.join(","), P);
  }, ms = (m, h) => po([
    "td",
    "th"
  ], m, h), ks = (m) => Sr(m, "th,td"), xr = (m) => hn(m, "colgroup") ? Et(m, "col") : Ce(ya(m), (h) => Et(h, "col")), Ro = (m, h) => ee(m, "table", h), Oa = (m) => Sr(m, "tr"), ya = (m) => Ro(m).fold(rt([]), (h) => Et(h, "colgroup")), cr = (m, h) => en(m, (E) => {
    if (Ut(E) === "colgroup") {
      const P = en(xr(E), (oe) => {
        const Me = ar(oe, "span", 1);
        return fe(oe, 1, Me);
      });
      return bt(E, P, "colgroup");
    } else {
      const P = en(ks(E), (oe) => {
        const Me = ar(oe, "rowspan", 1), mt = ar(oe, "colspan", 1);
        return fe(oe, Me, mt);
      });
      return bt(E, P, h(E));
    }
  }), ps = (m) => Vn(m).map((h) => {
    const E = Ut(h);
    return R(E) ? E : "tbody";
  }).getOr("tbody"), hr = (m) => {
    const h = Oa(m), P = [
      ...ya(m),
      ...h
    ];
    return cr(P, ps);
  }, Er = "data-snooker-locked-cols", Gn = (m) => It(m, Er).bind((h) => le.from(h.match(/\d+/g))).map((h) => M(h, ot)), Ds = (m, h) => m + "," + h, Pa = (m, h, E) => le.from(m.access[Ds(h, E)]), Qr = (m, h, E) => {
    const P = x(m, (oe) => E(h, oe.element));
    return P.length > 0 ? le.some(P[0]) : le.none();
  }, x = (m, h) => {
    const E = Ce(m.all, (P) => P.cells);
    return ie(E, h);
  }, B = (m) => {
    const h = {};
    let E = 0;
    return cn(m.cells, (P) => {
      const oe = P.colspan;
      an(oe, (Me) => {
        const mt = E + Me;
        h[mt] = bo(P.element, oe, mt);
      }), E += oe;
    }), h;
  }, K = (m) => {
    const h = {}, E = [], oe = kt(m).map((tr) => tr.element).bind(Ro).bind(Gn).getOr({});
    let Me = 0, mt = 0, xt = 0;
    const {
      pass: vn,
      fail: Ln
    } = w(m, (tr) => tr.section === "colgroup");
    cn(Ln, (tr) => {
      const Nr = [];
      cn(tr.cells, (Qa) => {
        let ja = 0;
        for (; h[Ds(xt, ja)] !== void 0; )
          ja++;
        const ru = Z(oe, ja.toString()), pl = qe(Qa.element, Qa.rowspan, Qa.colspan, xt, ja, ru);
        for (let Fc = 0; Fc < Qa.colspan; Fc++)
          for (let Ic = 0; Ic < Qa.rowspan; Ic++) {
            const au = xt + Ic, gl = ja + Fc, hl = Ds(au, gl);
            h[hl] = pl, mt = Math.max(mt, gl + 1);
          }
        Nr.push(pl);
      }), Me++, E.push(bt(tr.element, Nr, tr.section)), xt++;
    });
    const { columns: ss, colgroups: uo } = Qe(vn).map((tr) => {
      const Nr = B(tr);
      return {
        colgroups: [Vo(tr.element, jt(Nr))],
        columns: Nr
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Q(Me, mt),
      access: h,
      all: E,
      columns: ss,
      colgroups: uo
    };
  }, Xo = {
    fromTable: (m) => {
      const h = hr(m);
      return K(h);
    },
    generate: K,
    getAt: Pa,
    findItem: Qr,
    filterItems: x,
    justCells: (m) => Ce(m.all, (h) => h.cells),
    justColumns: (m) => jt(m.columns),
    hasColumns: (m) => it(m.columns).length > 0,
    getColumnAt: (m, h) => le.from(m.columns[h])
  };
  var Tr = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const zo = (m, h, E) => {
    const P = m.select("td,th", h);
    let oe;
    return ((mt, xt) => {
      for (let vn = 0; vn < xt.length; vn++) {
        const Ln = m.getStyle(xt[vn], E);
        if (typeof mt > "u" && (mt = Ln), mt !== Ln)
          return "";
      }
      return mt;
    })(oe, P);
  }, zr = (m, h, E) => {
    Tr.each("left center right".split(" "), (P) => {
      P !== E && m.formatter.remove("align" + P, {}, h);
    }), E && m.formatter.apply("align" + E, {}, h);
  }, gs = (m, h, E) => {
    Tr.each("top middle bottom".split(" "), (P) => {
      P !== E && m.formatter.remove("valign" + P, {}, h);
    }), E && m.formatter.apply("valign" + E, {}, h);
  }, $ = (m, h, E) => {
    m.dispatch("TableModified", {
      ...E,
      table: h
    });
  }, V = (m, h) => vr(m).getOr(h), Te = (m, h, E) => V(Xr(m, h), E), He = (m, h, E, P) => {
    const oe = Te(m, `padding-${E}`, 0), Me = Te(m, `padding-${P}`, 0), mt = Te(m, `border-${E}-width`, 0), xt = Te(m, `border-${P}-width`, 0);
    return h - oe - Me - mt - xt;
  }, Zt = (m, h) => {
    const E = m.dom, P = E.getBoundingClientRect().width || E.offsetWidth;
    return h === "border-box" ? P : He(m, P, "left", "right");
  }, vo = (m) => Zt(m, "content-box");
  var jo = tinymce.util.Tools.resolve("tinymce.Env");
  const Zs = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", qn = an(5, (m) => {
    const h = `${m + 1}px`;
    return {
      title: h,
      value: h
    };
  }), ko = en([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (m) => ({
    title: m,
    value: m.toLowerCase()
  })), Qs = "100%", Js = (m) => {
    var h;
    const E = m.dom, P = (h = E.getParent(m.selection.getStart(), E.isBlock)) !== null && h !== void 0 ? h : m.getBody();
    return vo(Xt.fromDom(P)) + "px";
  }, Ya = (m, h) => xc(m) || !ta(m) ? h : Sc(m) ? {
    ...h,
    width: Js(m)
  } : {
    ...h,
    width: Qs
  }, ir = (m, h) => xc(m) || ta(m) ? h : Sc(m) ? {
    ...h,
    width: Js(m)
  } : {
    ...h,
    width: Qs
  }, ao = (m) => (h) => h.options.get(m), es = (m) => {
    const h = m.options.register;
    h("table_border_widths", {
      processor: "object[]",
      default: qn
    }), h("table_border_styles", {
      processor: "object[]",
      default: ko
    }), h("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), h("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), h("table_advtab", {
      processor: "boolean",
      default: !0
    }), h("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), h("table_grid", {
      processor: "boolean",
      default: !jo.deviceType.isTouch()
    }), h("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), h("table_row_class_list", {
      processor: "object[]",
      default: []
    }), h("table_class_list", {
      processor: "object[]",
      default: []
    }), h("table_toolbar", {
      processor: "string",
      default: Zs
    }), h("table_background_color_map", {
      processor: "object[]",
      default: []
    }), h("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, Os = ao("table_sizing_mode"), Jr = ao("table_border_widths"), Ba = ao("table_border_styles"), as = ao("table_cell_advtab"), ba = ao("table_row_advtab"), ea = ao("table_advtab"), rc = ao("table_appearance_options"), Ki = ao("table_grid"), ta = ao("table_style_by_css"), na = ao("table_cell_class_list"), Xa = ao("table_row_class_list"), ac = ao("table_class_list"), Us = ao("table_toolbar"), Yi = ao("table_background_color_map"), ka = ao("table_border_color_map"), Sc = (m) => Os(m) === "fixed", xc = (m) => Os(m) === "responsive", ui = (m) => {
    const h = m.options, E = h.get("table_default_styles");
    return h.isSet("table_default_styles") ? E : Ya(m, E);
  }, Ec = (m) => {
    const h = m.options, E = h.get("table_default_attributes");
    return h.isSet("table_default_attributes") ? E : ir(m, E);
  }, oa = (m) => m.nodeName.toLowerCase(), tf = (m) => Xt.fromDom(m.getBody()), Tc = (m) => (h) => To(h, tf(m)), Xi = (m) => m ? m.replace(/px$/, "") : "", lr = (m) => /^\d+(\.\d+)?$/.test(m) ? m + "px" : m, Zi = (m) => Xt.fromDom(m.selection.getStart()), ne = (m) => Xt.fromDom(m.selection.getEnd()), cc = (m, h) => h.column >= m.startCol && h.column + h.colspan - 1 <= m.finishCol && h.row >= m.startRow && h.row + h.rowspan - 1 <= m.finishRow, sa = (m, h) => {
    let E = !0;
    const P = ge(cc, h);
    for (let oe = h.startRow; oe <= h.finishRow; oe++)
      for (let Me = h.startCol; Me <= h.finishCol; Me++)
        E = E && Xo.getAt(m, oe, Me).exists(P);
    return E ? le.some(h) : le.none();
  }, Qi = (m, h) => Nn(Math.min(m.row, h.row), Math.min(m.column, h.column), Math.max(m.row + m.rowspan - 1, h.row + h.rowspan - 1), Math.max(m.column + m.colspan - 1, h.column + h.colspan - 1)), nf = (m, h, E) => {
    const P = Xo.findItem(m, h, To), oe = Xo.findItem(m, E, To);
    return P.bind((Me) => oe.map((mt) => Qi(Me, mt)));
  }, ql = (m, h, E) => nf(m, h, E).bind((P) => sa(m, P)), _o = (m, h, E) => {
    const P = ws(m);
    return ql(P, h, E);
  }, ws = Xo.fromTable, fi = (m, h) => {
    Vn(m).each((P) => {
      P.dom.insertBefore(h.dom, m.dom);
    });
  }, wa = (m, h) => {
    lo(m).fold(() => {
      Vn(m).each((oe) => {
        $a(oe, h);
      });
    }, (P) => {
      fi(P, h);
    });
  }, Vl = (m, h) => {
    As(m).fold(() => {
      $a(m, h);
    }, (P) => {
      m.dom.insertBefore(h.dom, P.dom);
    });
  }, $a = (m, h) => {
    m.dom.appendChild(h.dom);
  }, er = (m, h) => {
    fi(m, h), $a(h, m);
  }, Ji = (m, h) => {
    cn(h, (E, P) => {
      const oe = P === 0 ? m : h[P - 1];
      wa(oe, E);
    });
  }, Gl = (m, h) => {
    cn(h, (E) => {
      $a(m, E);
    });
  }, el = (m) => {
    const h = m.dom;
    h.parentNode !== null && h.parentNode.removeChild(h);
  }, Fa = (m) => {
    const h = Io(m);
    h.length > 0 && Ji(m, h), el(m);
  }, mi = ((m, h) => {
    const E = (Me) => {
      if (!m(Me))
        throw new Error("Can only get " + h + " value of a " + h + " node");
      return P(Me).getOr("");
    }, P = (Me) => m(Me) ? le.from(Me.dom.nodeValue) : le.none();
    return {
      get: E,
      getOption: P,
      set: (Me, mt) => {
        if (!m(Me))
          throw new Error("Can only set raw " + h + " value of a " + h + " node");
        Me.dom.nodeValue = mt;
      }
    };
  })(ue, "text"), tl = (m) => mi.get(m), fs = (m, h) => mi.set(m, h);
  var ic = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], nl = () => {
    const m = (Ln) => Xt.fromDom(Ln.dom.cloneNode(!1)), h = (Ln) => os(Ln).dom, E = (Ln) => Bo(Ln) ? Ut(Ln) === "body" ? !0 : kn(ic, Ut(Ln)) : !1, P = (Ln) => Bo(Ln) ? kn([
      "br",
      "img",
      "hr",
      "input"
    ], Ut(Ln)) : !1, oe = (Ln) => Bo(Ln) && wt(Ln, "contenteditable") === "false", Me = (Ln, ss) => Ln.dom.compareDocumentPosition(ss.dom), mt = (Ln, ss) => {
      const uo = un(Ln);
      vt(ss, uo);
    }, xt = (Ln) => {
      const ss = Ut(Ln);
      return kn([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], ss);
    }, vn = (Ln) => Bo(Ln) ? It(Ln, "lang") : le.none();
    return {
      up: rt({
        selector: Mo,
        closest: ee,
        predicate: ln,
        all: gn
      }),
      down: rt({
        selector: An,
        predicate: rn
      }),
      styles: rt({
        get: Xr,
        getRaw: Xs,
        set: $r,
        remove: Da
      }),
      attrs: rt({
        get: wt,
        set: St,
        remove: Lt,
        copyTo: mt
      }),
      insert: rt({
        before: fi,
        after: wa,
        afterAll: Ji,
        append: $a,
        appendAll: Gl,
        prepend: Vl,
        wrap: er
      }),
      remove: rt({
        unwrap: Fa,
        remove: el
      }),
      create: rt({
        nu: Xt.fromTag,
        clone: m,
        text: Xt.fromText
      }),
      query: rt({
        comparePosition: Me,
        prevSibling: qo,
        nextSibling: lo
      }),
      property: rt({
        children: Io,
        name: Ut,
        parent: Vn,
        document: h,
        isText: ue,
        isComment: ho,
        isElement: Bo,
        isSpecial: xt,
        getLanguage: vn,
        getText: tl,
        setText: fs,
        isBoundary: E,
        isEmptyTag: P,
        isNonEditable: oe
      }),
      eq: To,
      is: rs
    };
  };
  const pi = (m, h, E, P) => {
    const oe = E[0], Me = E.slice(1);
    return P(m, h, oe, Me);
  }, ol = (m, h, E) => E.length > 0 ? pi(m, h, E, Kl) : le.none(), Kl = (m, h, E, P) => {
    const oe = h(m, E);
    return re(P, (Me, mt) => {
      const xt = h(m, mt);
      return sl(m, Me, xt);
    }, oe);
  }, sl = (m, h, E) => h.bind((P) => E.filter(ge(m.eq, P))), rl = ol, b = nl(), S = (m, h) => rl(b, (E, P) => m(P), h), A = (m) => Mo(m, "table"), te = (m, h) => {
    const E = An(m, h);
    return E.length > 0 ? le.some(E) : le.none();
  }, be = (m, h, E) => q(m, h).bind((P) => q(m, E).bind((oe) => S(A, [
    P,
    oe
  ]).map((Me) => ({
    first: P,
    last: oe,
    table: Me
  })))), $t = (m, h) => te(m, h), yn = (m, h, E) => be(m, h, E).bind((P) => {
    const oe = (vn) => To(m, vn), Me = "thead,tfoot,tbody,table", mt = Mo(P.first, Me, oe), xt = Mo(P.last, Me, oe);
    return mt.bind((vn) => xt.bind((Ln) => To(vn, Ln) ? _o(P.table, P.first, P.last) : le.none()));
  }), On = (m) => en(m, Xt.fromDom), Hn = "data-mce-selected", Mn = "td[" + Hn + "],th[" + Hn + "]", ts = "data-mce-first-selected", Ir = "td[" + ts + "],th[" + ts + "]", Hs = "data-mce-last-selected", gd = "td[" + Hs + "],th[" + Hs + "]", gi = {
    selected: Hn,
    selectedSelector: Mn,
    firstSelected: ts,
    firstSelectedSelector: Ir,
    lastSelected: Hs,
    lastSelectedSelector: gd
  }, hd = (m) => Ro(m).bind((h) => $t(h, gi.firstSelectedSelector)).fold(rt(m), (h) => h[0]), Yl = (m) => (h, E) => {
    const P = Ut(h), oe = P === "col" || P === "colgroup" ? hd(h) : h;
    return ee(oe, m, E);
  }, Ia = Yl("th,td,caption"), yr = Yl("th,td"), ra = (m) => On(m.model.table.getSelectedCells()), yd = (m, h) => {
    const E = yr(m), P = E.bind((oe) => Ro(oe)).map((oe) => Oa(oe));
    return Dn(E, P, (oe, Me) => ie(Me, (mt) => Rn(On(mt.dom.cells), (xt) => wt(xt, h) === "1" || To(xt, oe)))).getOr([]);
  }, ls = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], bd = (m) => ({ value: m }), al = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, lc = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, cl = (m) => al.test(m) || lc.test(m), Do = (m) => Qo(m, "#").toUpperCase(), Es = (m) => cl(m) ? le.some({ value: Do(m) }) : le.none(), Ar = (m) => {
    const h = m.toString(16);
    return (h.length === 1 ? "0" + h : h).toUpperCase();
  }, _s = (m) => {
    const h = Ar(m.red) + Ar(m.green) + Ar(m.blue);
    return bd(h);
  }, of = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, hi = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, sf = (m, h, E, P) => ({
    red: m,
    green: h,
    blue: E,
    alpha: P
  }), uc = (m, h, E, P) => {
    const oe = parseInt(m, 10), Me = parseInt(h, 10), mt = parseInt(E, 10), xt = parseFloat(P);
    return sf(oe, Me, mt, xt);
  }, Xl = (m) => {
    if (m === "transparent")
      return le.some(sf(0, 0, 0, 0));
    const h = of.exec(m);
    if (h !== null)
      return le.some(uc(h[1], h[2], h[3], "1"));
    const E = hi.exec(m);
    return E !== null ? le.some(uc(E[1], E[2], E[3], E[4])) : le.none();
  }, bp = (m) => Es(m).orThunk(() => Xl(m).map(_s)).getOrThunk(() => {
    const h = document.createElement("canvas");
    h.height = 1, h.width = 1;
    const E = h.getContext("2d");
    E.clearRect(0, 0, h.width, h.height), E.fillStyle = "#FFFFFF", E.fillStyle = m, E.fillRect(0, 0, 1, 1);
    const P = E.getImageData(0, 0, 1, 1).data, oe = P[0], Me = P[1], mt = P[2], xt = P[3];
    return _s(sf(oe, Me, mt, xt));
  }), kp = (m) => Xl(m).map(_s).map((h) => "#" + h.value).getOr(m), Zl = (m) => {
    let h = m;
    return {
      get: () => h,
      set: (oe) => {
        h = oe;
      }
    };
  }, wp = (m) => {
    const h = Zl(le.none()), E = () => h.get().each(m);
    return {
      clear: () => {
        E(), h.set(le.none());
      },
      isSet: () => h.get().isSome(),
      get: () => h.get(),
      set: (xt) => {
        E(), h.set(le.some(xt));
      }
    };
  }, rf = () => wp((m) => m.unbind()), il = (m, h, E) => (P) => {
    const oe = rf(), Me = js(E), mt = () => {
      const xt = ra(m), vn = (Ln) => m.formatter.match(h, { value: E }, Ln.dom, Me);
      Me ? (P.setActive(!Rn(xt, vn)), oe.set(m.formatter.formatChanged(h, (Ln) => P.setActive(!Ln), !0))) : (P.setActive(W(xt, vn)), oe.set(m.formatter.formatChanged(h, P.setActive, !1, { value: E })));
    };
    return m.initialized ? mt() : m.on("init", mt), oe.clear;
  }, kd = (m) => Z(m, "menu"), zc = (m) => en(m, (h) => {
    const E = h.text || h.title;
    return kd(h) ? {
      text: E,
      items: zc(h.menu)
    } : {
      text: E,
      value: h.value
    };
  }), yi = (m, h, E, P) => en(h, (oe) => {
    const Me = oe.text || oe.title;
    return kd(oe) ? {
      type: "nestedmenuitem",
      text: Me,
      getSubmenuItems: () => yi(m, oe.menu, E, P)
    } : {
      text: Me,
      type: "togglemenuitem",
      onAction: () => P(oe.value),
      onSetup: il(m, E, oe.value)
    };
  }), Ac = (m, h) => (E) => {
    m.execCommand("mceTableApplyCellStyle", !1, { [h]: E });
  }, In = (m) => Ce(m, (h) => kd(h) ? [{
    ...h,
    menu: In(h.menu)
  }] : Yr(h.value) ? [h] : []), fc = (m, h, E, P) => (oe) => oe(yi(m, h, E, P)), bi = (m, h, E) => {
    const P = en(h, (oe) => ({
      text: oe.title,
      value: "#" + bp(oe.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: P.length > 0 ? P : void 0,
        allowCustomColors: !1
      },
      onAction: (oe) => {
        const Me = oe.value === "remove" ? "" : oe.value;
        m.execCommand("mceTableApplyCellStyle", !1, { [E]: Me });
      }
    }];
  }, af = (m) => () => {
    const E = m.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    m.execCommand("mceTableRowType", !1, { type: E });
  }, cf = (m) => () => {
    const E = m.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    m.execCommand("mceTableColType", !1, { type: E });
  }, lf = (m) => {
    const h = zc(na(m));
    return h.length > 0 ? le.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: h
    }) : le.none();
  }, Nc = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "height",
      type: "input",
      label: "Height"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: ls
    }
  ], ki = (m) => Nc.concat(lf(m).toArray()), dn = (m, h) => {
    const P = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat(zc(Ba(m)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ], Me = h === "cell" ? [{
      name: "borderwidth",
      type: "input",
      label: "Border width"
    }].concat(P) : P;
    return {
      title: "Advanced",
      name: "advanced",
      items: Me
    };
  }, wi = { normal: (m, h) => {
    const E = m.dom;
    return {
      setAttrib: (mt, xt) => {
        E.setAttrib(h, mt, xt);
      },
      setStyle: (mt, xt) => {
        E.setStyle(h, mt, xt);
      },
      setFormat: (mt, xt) => {
        xt === "" ? m.formatter.remove(mt, { value: null }, h, !0) : m.formatter.apply(mt, { value: xt }, h);
      }
    };
  } }, uf = Ot("th"), Za = (m, h) => m && h ? "sectionCells" : m ? "section" : "cells", Rc = (m) => {
    const h = m.section === "thead", E = Xn(Ql(m.cells), "th");
    return m.section === "tfoot" ? { type: "footer" } : h || E ? {
      type: "header",
      subType: Za(h, E)
    } : { type: "body" };
  }, Ql = (m) => {
    const h = ie(m, (E) => uf(E.element));
    return h.length === 0 ? le.some("td") : h.length === m.length ? le.some("th") : le.none();
  }, La = (m) => {
    const h = en(m, (oe) => Rc(oe).type), E = kn(h, "header"), P = kn(h, "footer");
    if (!E && !P)
      return le.some("body");
    {
      const oe = kn(h, "body");
      return E && !oe && !P ? le.some("header") : !E && !oe && P ? le.some("footer") : le.none();
    }
  }, wd = (m) => {
    let h = !1, E;
    return (...P) => (h || (h = !0, E = m.apply(null, P)), E);
  }, ll = (m, h) => pn(m.all, (E) => me(E.cells, (P) => To(h, P.element))), Ft = (m, h, E) => {
    const P = en(h.selection, (Me) => ms(Me).bind((mt) => ll(m, mt)).filter(E)), oe = yo(P);
    return bs(oe.length > 0, oe);
  }, _d = (m, h) => h.mergable, vd = (m, h) => h.unmergable, ul = (m, h) => Ft(m, h, ot), Jl = (m, h) => ll(m, h).exists((E) => !E.isLocked), _i = (m, h) => W(h, (E) => Jl(m, E)), ds = (m, h) => _d(m, h).filter((E) => _i(m, E.cells)), Cd = (m, h) => vd(m, h).filter((E) => _i(m, E));
  ({ ...{ generate: (m) => {
    if (!Ke(m))
      throw new Error("cases must be an array");
    if (m.length === 0)
      throw new Error("there must be at least one case");
    const h = [], E = {};
    return cn(m, (P, oe) => {
      const Me = it(P);
      if (Me.length !== 1)
        throw new Error("one and only one name per case");
      const mt = Me[0], xt = P[mt];
      if (E[mt] !== void 0)
        throw new Error("duplicate key detected:" + mt);
      if (mt === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Ke(xt))
        throw new Error("case arguments must be an array");
      h.push(mt), E[mt] = (...vn) => {
        const Ln = vn.length;
        if (Ln !== xt.length)
          throw new Error("Wrong number of arguments to case " + mt + ". Expected " + xt.length + " (" + xt + "), got " + Ln);
        return {
          fold: (...uo) => {
            if (uo.length !== m.length)
              throw new Error("Wrong number of arguments to fold. Expected " + m.length + ", got " + uo.length);
            return uo[oe].apply(null, vn);
          },
          match: (uo) => {
            const Go = it(uo);
            if (h.length !== Go.length)
              throw new Error("Wrong number of arguments to match. Expected: " + h.join(",") + `
Actual: ` + Go.join(","));
            if (!W(h, (Nr) => kn(Go, Nr)))
              throw new Error("Not all branches were specified when using match. Specified: " + Go.join(", ") + `
Required: ` + h.join(", "));
            return uo[mt].apply(null, vn);
          },
          log: (uo) => {
            console.log(uo, {
              constructors: h,
              constructor: mt,
              params: vn
            });
          }
        };
      };
    }), E;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const Nh = (m, h) => {
    const E = Xo.fromTable(m);
    return ul(E, h).bind((oe) => {
      const Me = oe[oe.length - 1], mt = oe[0].row, xt = Me.row + Me.rowspan, vn = E.all.slice(mt, xt);
      return La(vn);
    }).getOr("");
  }, Dc = (m) => Jo(m, "rgb") ? kp(m) : m, vi = (m) => {
    const h = Xt.fromDom(m);
    return {
      borderwidth: Xs(h, "border-width").getOr(""),
      borderstyle: Xs(h, "border-style").getOr(""),
      bordercolor: Xs(h, "border-color").map(Dc).getOr(""),
      backgroundcolor: Xs(h, "background-color").map(Dc).getOr("")
    };
  }, ff = (m) => {
    const h = m[0], E = m.slice(1);
    return cn(E, (P) => {
      cn(it(h), (oe) => {
        Le(P, (Me, mt) => {
          const xt = h[oe];
          xt !== "" && oe === mt && xt !== Me && (h[oe] = "");
        });
      });
    }), h;
  }, Sd = (m, h, E, P) => me(m, (oe) => !Ie(E.formatter.matchNode(P, h + oe))).getOr(""), eu = ge(Sd, [
    "left",
    "center",
    "right"
  ], "align"), Ci = ge(Sd, [
    "top",
    "middle",
    "bottom"
  ], "valign"), Oc = (m, h) => {
    const E = ui(m), P = Ec(m), oe = () => ({
      borderstyle: Ze(E, "border-style").getOr(""),
      bordercolor: Dc(Ze(E, "border-color").getOr("")),
      backgroundcolor: Dc(Ze(E, "background-color").getOr(""))
    }), Me = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, mt = () => {
      const ss = E["border-width"];
      return ta(m) && ss ? { border: ss } : Ze(P, "border").fold(() => ({}), (uo) => ({ border: uo }));
    }, xt = h ? oe() : {}, vn = () => {
      const ss = Ze(E, "border-spacing").or(Ze(P, "cellspacing")).fold(() => ({}), (Go) => ({ cellspacing: Go })), uo = Ze(E, "border-padding").or(Ze(P, "cellpadding")).fold(() => ({}), (Go) => ({ cellpadding: Go }));
      return {
        ...ss,
        ...uo
      };
    };
    return {
      ...Me,
      ...E,
      ...P,
      ...xt,
      ...mt(),
      ...vn()
    };
  }, _p = (m) => Ro(Xt.fromDom(m)).map((h) => {
    const E = { selection: On(m.cells) };
    return Nh(h, E);
  }).getOr(""), vp = (m, h, E) => {
    const P = (xt, vn) => {
      const Ln = Xs(Xt.fromDom(vn), "border-width");
      return ta(m) && Ln.isSome() ? Ln.getOr("") : xt.getAttrib(vn, "border") || zo(m.dom, vn, "border-width") || zo(m.dom, vn, "border");
    }, oe = m.dom, Me = ta(m) ? oe.getStyle(h, "border-spacing") || oe.getAttrib(h, "cellspacing") : oe.getAttrib(h, "cellspacing") || oe.getStyle(h, "border-spacing"), mt = ta(m) ? zo(oe, h, "padding") || oe.getAttrib(h, "cellpadding") : oe.getAttrib(h, "cellpadding") || zo(oe, h, "padding");
    return {
      width: oe.getStyle(h, "width") || oe.getAttrib(h, "width"),
      height: oe.getStyle(h, "height") || oe.getAttrib(h, "height"),
      cellspacing: Me,
      cellpadding: mt,
      border: P(oe, h),
      caption: !!oe.select("caption", h)[0],
      class: oe.getAttrib(h, "class", ""),
      align: eu(m, h),
      ...E ? vi(h) : {}
    };
  }, xd = (m, h, E) => {
    const P = m.dom;
    return {
      height: P.getStyle(h, "height") || P.getAttrib(h, "height"),
      class: P.getAttrib(h, "class", ""),
      type: _p(h),
      align: eu(m, h),
      ...E ? vi(h) : {}
    };
  }, Si = (m, h, E, P) => {
    const oe = m.dom, Me = P.getOr(h), mt = (xt, vn) => oe.getStyle(xt, vn) || oe.getAttrib(xt, vn);
    return {
      width: mt(Me, "width"),
      height: mt(h, "height"),
      scope: oe.getAttrib(h, "scope"),
      celltype: oa(h),
      class: oe.getAttrib(h, "class", ""),
      halign: eu(m, h),
      valign: Ci(m, h),
      ...E ? vi(h) : {}
    };
  }, Pc = (m, h) => {
    const E = Xo.fromTable(m), P = Xo.justCells(E), oe = ie(P, (Me) => Rn(h, (mt) => To(Me.element, mt)));
    return en(oe, (Me) => ({
      element: Me.element.dom,
      column: Xo.getColumnAt(E, Me.column).map((mt) => mt.element.dom)
    }));
  }, Ma = (m, h, E, P) => {
    P("scope") && m.setAttrib("scope", E.scope), P("class") && m.setAttrib("class", E.class), P("height") && m.setStyle("height", lr(E.height)), P("width") && h.setStyle("width", lr(E.width));
  }, Ed = (m, h, E) => {
    E("backgroundcolor") && m.setFormat("tablecellbackgroundcolor", h.backgroundcolor), E("bordercolor") && m.setFormat("tablecellbordercolor", h.bordercolor), E("borderstyle") && m.setFormat("tablecellborderstyle", h.borderstyle), E("borderwidth") && m.setFormat("tablecellborderwidth", lr(h.borderwidth));
  }, Rh = (m, h, E, P) => {
    const oe = h.length === 1;
    cn(h, (Me) => {
      const mt = Me.element, xt = oe ? ot : P, vn = wi.normal(m, mt), Ln = Me.column.map((ss) => wi.normal(m, ss)).getOr(vn);
      Ma(vn, Ln, E, xt), as(m) && Ed(vn, E, xt), P("halign") && zr(m, mt, E.halign), P("valign") && gs(m, mt, E.valign);
    });
  }, Td = (m, h) => {
    m.execCommand("mceTableCellType", !1, {
      type: h.celltype,
      no_events: !0
    });
  }, hs = (m, h, E, P) => {
    const oe = Wt(P, (Me, mt) => E[mt] !== Me);
    ye(oe) > 0 && h.length >= 1 && Ro(h[0]).each((Me) => {
      const mt = Pc(Me, h), xt = ye(Wt(oe, (Ln, ss) => ss !== "scope" && ss !== "celltype")) > 0, vn = qt(oe, "celltype");
      (xt || qt(oe, "scope")) && Rh(m, mt, P, ge(qt, oe)), vn && Td(m, P), $(m, Me.dom, {
        structure: vn,
        style: xt
      });
    });
  }, Cp = (m, h, E, P) => {
    const oe = P.getData();
    P.close(), m.undoManager.transact(() => {
      hs(m, h, E, oe), m.focus();
    });
  }, zd = (m, h) => {
    const E = Ro(h[0]).map((P) => en(Pc(P, h), (oe) => Si(m, oe.element, as(m), oe.column)));
    return ff(E.getOrDie());
  }, xi = (m) => {
    const h = ra(m);
    if (h.length === 0)
      return;
    const E = zd(m, h), P = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: ki(m)
        },
        dn(m, "cell")
      ]
    }, oe = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: ki(m)
      }]
    };
    m.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: as(m) ? P : oe,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: E,
      onSubmit: ge(Cp, m, h, E)
    });
  }, Sp = (m) => {
    const h = zc(Xa(m));
    return h.length > 0 ? le.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: h
    }) : le.none();
  }, xp = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], df = (m) => xp.concat(Sp(m).toArray()), Ad = (m, h, E) => {
    E("class") && m.setAttrib("class", h.class), E("height") && m.setStyle("height", lr(h.height));
  }, Ep = (m, h, E) => {
    E("backgroundcolor") && m.setStyle("background-color", h.backgroundcolor), E("bordercolor") && m.setStyle("border-color", h.bordercolor), E("borderstyle") && m.setStyle("border-style", h.borderstyle);
  }, Nd = (m, h, E, P) => {
    const Me = h.length === 1 ? ot : P;
    cn(h, (mt) => {
      const xt = wi.normal(m, mt);
      Ad(xt, E, Me), ba(m) && Ep(xt, E, Me), P("align") && zr(m, mt, E.align);
    });
  }, mc = (m, h) => {
    m.execCommand("mceTableRowType", !1, {
      type: h.type,
      no_events: !0
    });
  }, ia = (m, h, E, P) => {
    const oe = Wt(P, (Me, mt) => E[mt] !== Me);
    if (ye(oe) > 0) {
      const Me = qt(oe, "type"), mt = Me ? ye(oe) > 1 : !0;
      mt && Nd(m, h, P, ge(qt, oe)), Me && mc(m, P), Ro(Xt.fromDom(h[0])).each((xt) => $(m, xt.dom, {
        structure: Me,
        style: mt
      }));
    }
  }, Tp = (m, h, E, P) => {
    const oe = P.getData();
    P.close(), m.undoManager.transact(() => {
      ia(m, h, E, oe), m.focus();
    });
  }, mf = (m) => {
    const h = yd(Zi(m), gi.selected);
    if (h.length === 0)
      return;
    const E = en(h, (mt) => xd(m, mt.dom, ba(m))), P = ff(E), oe = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: df(m)
        },
        dn(m, "row")
      ]
    }, Me = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: df(m)
      }]
    };
    m.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: ba(m) ? oe : Me,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: P,
      onSubmit: ge(Tp, m, en(h, (mt) => mt.dom), P)
    });
  }, Ei = (m, h, E) => {
    const P = E ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], oe = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], Me = rc(m) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], mt = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], xt = h.length > 0 ? [{
      type: "listbox",
      name: "class",
      label: "Class",
      items: h
    }] : [];
    return P.concat(oe).concat(Me).concat(mt).concat(xt);
  }, pf = (m, h, E, P) => {
    if (h.tagName === "TD" || h.tagName === "TH")
      We(E) ? m.setStyle(h, E, P) : m.setStyles(h, E);
    else if (h.children)
      for (let oe = 0; oe < h.children.length; oe++)
        pf(m, h.children[oe], E, P);
  }, gf = (m, h, E) => {
    const P = m.dom, oe = {}, Me = {};
    if (oe.class = E.class, Me.height = lr(E.height), ta(m) ? Me.width = lr(E.width) : P.getAttrib(h, "width") && (oe.width = Xi(E.width)), ta(m) ? (Me["border-width"] = lr(E.border), Me["border-spacing"] = lr(E.cellspacing)) : (oe.border = E.border, oe.cellpadding = E.cellpadding, oe.cellspacing = E.cellspacing), ta(m) && h.children)
      for (let mt = 0; mt < h.children.length; mt++)
        pf(P, h.children[mt], {
          "border-width": lr(E.border),
          padding: lr(E.cellpadding)
        }), ea(m) && pf(P, h.children[mt], { "border-color": E.bordercolor });
    ea(m) && (Me["background-color"] = E.backgroundcolor, Me["border-color"] = E.bordercolor, Me["border-style"] = E.borderstyle), oe.style = P.serializeStyle({
      ...ui(m),
      ...Me
    }), P.setAttribs(h, {
      ...Ec(m),
      ...oe
    });
  }, dl = (m, h, E, P) => {
    const oe = m.dom, Me = P.getData(), mt = Wt(Me, (xt, vn) => E[vn] !== xt);
    P.close(), Me.class === "" && delete Me.class, m.undoManager.transact(() => {
      if (!h) {
        const xt = parseInt(Me.cols, 10) || 1, vn = parseInt(Me.rows, 10) || 1;
        m.execCommand("mceInsertTable", !1, {
          rows: vn,
          columns: xt
        }), h = yr(Zi(m), Tc(m)).bind((Ln) => Ro(Ln, Tc(m))).map((Ln) => Ln.dom).getOrUndefined();
      }
      if (ye(mt) > 0) {
        gf(m, h, Me);
        const xt = oe.select("caption", h)[0];
        (xt && !Me.caption || !xt && Me.caption) && m.execCommand("mceTableToggleCaption"), zr(m, h, Me.align);
      }
      if (m.focus(), m.addVisual(), ye(mt) > 0) {
        const xt = qt(mt, "caption"), vn = xt ? ye(mt) > 1 : !0;
        $(m, h, {
          structure: xt,
          style: vn
        });
      }
    });
  }, Rd = (m, h) => {
    const E = m.dom;
    let P, oe = Oc(m, ea(m));
    h === !1 ? (P = E.getParent(m.selection.getStart(), "table", m.getBody()), P ? oe = vp(m, P, ea(m)) : ea(m) && (oe.borderstyle = "", oe.bordercolor = "", oe.backgroundcolor = "")) : (oe.cols = "1", oe.rows = "1", ea(m) && (oe.borderstyle = "", oe.bordercolor = "", oe.backgroundcolor = ""));
    const Me = zc(ac(m));
    Me.length > 0 && oe.class && (oe.class = oe.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const mt = {
      type: "grid",
      columns: 2,
      items: Ei(m, Me, h)
    }, xt = () => ({
      type: "panel",
      items: [mt]
    }), vn = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [mt]
        },
        dn(m, "table")
      ]
    }), Ln = ea(m) ? vn() : xt();
    m.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: Ln,
      onSubmit: ge(dl, m, P, oe),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: oe
    });
  }, tu = (m) => {
    Le({
      mceTableProps: ge(Rd, m, !1),
      mceTableRowProps: ge(mf, m),
      mceTableCellProps: ge(xi, m)
    }, (h, E) => m.addCommand(E, () => h())), m.addCommand("mceInsertTableDialog", (h) => {
      Rd(m, !0);
    });
  }, nu = (m, h) => No(m, h).isSome(), hf = ae, yf = (m) => {
    const h = (P, oe) => It(P, oe).exists((Me) => parseInt(Me, 10) > 1), E = (P) => h(P, "rowspan") || h(P, "colspan");
    return m.length > 0 && W(m, E) ? le.some(m) : le.none();
  }, bf = (m, h, E) => h.length <= 1 ? le.none() : yn(m, E.firstSelectedSelector, E.lastSelectedSelector).map((P) => ({
    bounds: P,
    cells: h
  })), ml = (m) => ({
    element: m,
    mergable: le.none(),
    unmergable: le.none(),
    selection: [m]
  }), Ws = (m, h, E) => ({
    element: E,
    mergable: bf(h, m, gi),
    unmergable: yf(m),
    selection: hf(m)
  }), ou = (m) => {
    const h = Zl(le.none()), E = Zl([]);
    let P = le.none();
    const oe = Ot("caption"), Me = ($n) => P.forall((Ko) => !Ko[$n]), mt = () => Ia(Zi(m), Tc(m)), xt = () => Ia(ne(m), Tc(m)), vn = () => mt().bind(($n) => sr(Dn(Ro($n), xt().bind(Ro), (Ko, Ps) => To(Ko, Ps) ? oe($n) ? le.some(ml($n)) : le.some(Ws(ra(m), Ko, $n)) : le.none()))), Ln = ($n) => Ro($n.element).map((Ps) => {
      const Lr = Xo.fromTable(Ps), Dp = ul(Lr, $n).getOr([]), cu = we(Dp, (Ua, Ha) => (Ha.isLocked && (Ua.onAny = !0, Ha.column === 0 ? Ua.onFirst = !0 : Ha.column + Ha.colspan >= Lr.grid.columns && (Ua.onLast = !0)), Ua), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: ds(Lr, $n).isSome(),
        unmergeable: Cd(Lr, $n).isSome(),
        locked: cu
      };
    }), ss = () => {
      h.set(wd(vn)()), P = h.get().bind(Ln), cn(E.get(), ($n) => $n());
    }, uo = ($n) => ($n(), E.set(E.get().concat([$n])), () => {
      E.set(ie(E.get(), (Ko) => Ko !== $n));
    }), Go = ($n, Ko) => uo(() => h.get().fold(() => {
      $n.setEnabled(!1);
    }, (Ps) => {
      $n.setEnabled(!Ko(Ps));
    })), tr = ($n, Ko, Ps) => uo(() => h.get().fold(() => {
      $n.setEnabled(!1), $n.setActive(!1);
    }, (Lr) => {
      $n.setEnabled(!Ko(Lr)), $n.setActive(Ps(Lr));
    })), Nr = ($n) => P.exists((Ko) => Ko.locked[$n]), Qa = ($n) => Go($n, (Ko) => !1), ja = ($n) => Go($n, (Ko) => oe(Ko.element)), ru = ($n) => (Ko) => Go(Ko, (Ps) => oe(Ps.element) || Nr($n)), pl = ($n) => (Ko) => Go(Ko, (Ps) => oe(Ps.element) || $n().isNone()), Fc = ($n, Ko) => (Ps) => Go(Ps, (Lr) => oe(Lr.element) || $n().isNone() || Nr(Ko)), Ic = ($n) => Go($n, (Ko) => Me("mergeable")), au = ($n) => Go($n, (Ko) => Me("unmergeable")), gl = ($n) => tr($n, zt, (Ko) => Ro(Ko.element, Tc(m)).exists((Lr) => nu(Lr, "caption"))), hl = ($n, Ko) => (Ps) => tr(Ps, (Lr) => oe(Lr.element), () => m.queryCommandValue($n) === Ko), Np = hl("mceTableRowType", "header"), Rp = hl("mceTableColType", "th");
    return m.on("NodeChange ExecCommand TableSelectorChange", ss), {
      onSetupTable: Qa,
      onSetupCellOrRow: ja,
      onSetupColumn: ru,
      onSetupPasteable: pl,
      onSetupPasteableColumn: Fc,
      onSetupMergeable: Ic,
      onSetupUnmergeable: au,
      resetTargets: ss,
      onSetupTableWithCaption: gl,
      onSetupTableRowHeaders: Np,
      onSetupTableColumnHeaders: Rp,
      targets: h.get
    };
  };
  var Dd = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const kf = "x-tinymce/dom-table-", br = kf + "rows", wf = kf + "columns", su = (m) => {
    var h;
    const E = (h = Dd.read()) !== null && h !== void 0 ? h : [];
    return pn(E, (P) => le.from(P.getType(m)));
  }, Bc = () => su(br), Ti = () => su(wf), zp = (m, h) => {
    m.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      fetch: (xt) => xt("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const E = (xt) => () => m.execCommand(xt), P = (xt, vn) => {
      m.queryCommandSupported(vn.command) && m.ui.registry.addButton(xt, {
        ...vn,
        onAction: $e(vn.onAction) ? vn.onAction : E(vn.command)
      });
    }, oe = (xt, vn) => {
      m.queryCommandSupported(vn.command) && m.ui.registry.addToggleButton(xt, {
        ...vn,
        onAction: $e(vn.onAction) ? vn.onAction : E(vn.command)
      });
    };
    P("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: h.onSetupTable
    }), P("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: h.onSetupTable
    }), P("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: h.onSetupCellOrRow
    }), P("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: h.onSetupMergeable
    }), P("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: h.onSetupUnmergeable
    }), P("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: h.onSetupCellOrRow
    }), P("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: h.onSetupCellOrRow
    }), P("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: h.onSetupCellOrRow
    }), P("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: h.onSetupCellOrRow
    }), P("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: h.onSetupColumn("onFirst")
    }), P("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: h.onSetupColumn("onLast")
    }), P("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: h.onSetupColumn("onAny")
    }), P("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: h.onSetupCellOrRow
    }), P("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: h.onSetupCellOrRow
    }), P("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: h.onSetupPasteable(Bc)
    }), P("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: h.onSetupPasteable(Bc)
    }), P("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: h.onSetupColumn("onAny")
    }), P("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: h.onSetupColumn("onAny")
    }), P("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: h.onSetupPasteableColumn(Ti, "onFirst")
    }), P("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: h.onSetupPasteableColumn(Ti, "onLast")
    }), P("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table"
    });
    const Me = In(ac(m));
    Me.length !== 0 && m.queryCommandSupported("mceTableToggleClass") && m.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: fc(m, Me, "tableclass", (xt) => m.execCommand("mceTableToggleClass", !1, xt)),
      onSetup: h.onSetupTable
    });
    const mt = In(na(m));
    mt.length !== 0 && m.queryCommandSupported("mceTableCellToggleClass") && m.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: fc(m, mt, "tablecellclass", (xt) => m.execCommand("mceTableCellToggleClass", !1, xt)),
      onSetup: h.onSetupCellOrRow
    }), m.queryCommandSupported("mceTableApplyCellStyle") && (m.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: fc(m, ls, "tablecellverticalalign", Ac(m, "vertical-align")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: fc(m, Jr(m), "tablecellborderwidth", Ac(m, "border-width")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: fc(m, Ba(m), "tablecellborderstyle", Ac(m, "border-style")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: (xt) => xt(bi(m, Yi(m), "background-color")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: (xt) => xt(bi(m, ka(m), "border-color")),
      onSetup: h.onSetupCellOrRow
    })), oe("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: h.onSetupTableWithCaption
    }), oe("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: af(m),
      onSetup: h.onSetupTableRowHeaders
    }), oe("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: cf(m),
      onSetup: h.onSetupTableColumnHeaders
    });
  }, Dh = (m) => {
    const h = (P) => m.dom.is(P, "table") && m.getBody().contains(P), E = Us(m);
    E.length > 0 && m.ui.registry.addContextToolbar("table", {
      predicate: h,
      items: E,
      scope: "node",
      position: "node"
    });
  }, pc = (m, h) => {
    const E = (uo) => () => m.execCommand(uo), P = (uo, Go) => m.queryCommandSupported(Go.command) ? (m.ui.registry.addMenuItem(uo, {
      ...Go,
      onAction: $e(Go.onAction) ? Go.onAction : E(Go.command)
    }), !0) : !1, oe = (uo, Go) => {
      m.queryCommandSupported(Go.command) && m.ui.registry.addToggleMenuItem(uo, {
        ...Go,
        onAction: $e(Go.onAction) ? Go.onAction : E(Go.command)
      });
    }, Me = (uo) => {
      m.execCommand("mceInsertTable", !1, {
        rows: uo.numRows,
        columns: uo.numColumns
      });
    }, mt = [
      P("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: h.onSetupCellOrRow
      }),
      P("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: h.onSetupCellOrRow
      }),
      P("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: h.onSetupCellOrRow
      }),
      P("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: h.onSetupCellOrRow
      }),
      P("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: h.onSetupCellOrRow
      }),
      P("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: h.onSetupCellOrRow
      }),
      P("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: h.onSetupPasteable(Bc)
      }),
      P("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: h.onSetupPasteable(Bc)
      })
    ], xt = [
      P("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: h.onSetupColumn("onFirst")
      }),
      P("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: h.onSetupColumn("onLast")
      }),
      P("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: h.onSetupColumn("onAny")
      }),
      P("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: h.onSetupColumn("onAny")
      }),
      P("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: h.onSetupColumn("onAny")
      }),
      P("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: h.onSetupPasteableColumn(Ti, "onFirst")
      }),
      P("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: h.onSetupPasteableColumn(Ti, "onLast")
      })
    ], vn = [
      P("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: h.onSetupCellOrRow
      }),
      P("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: h.onSetupMergeable
      }),
      P("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: h.onSetupUnmergeable
      })
    ];
    Ki(m) ? m.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: Me
      }]
    }) : m.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: E("mceInsertTableDialog")
    }), m.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: E("mceInsertTableDialog")
    }), P("tableprops", {
      text: "Table properties",
      onSetup: h.onSetupTable,
      command: "mceTableProps"
    }), P("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: h.onSetupTable,
      command: "mceTableDelete"
    }), kn(mt, !0) && m.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: rt("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), kn(xt, !0) && m.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: rt("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), kn(vn, !0) && m.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: rt("tablecellprops tablemergecells tablesplitcells")
    }), m.ui.registry.addContextMenu("table", {
      update: () => (h.resetTargets(), h.targets().fold(rt(""), (uo) => Ut(uo.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const Ln = In(ac(m));
    Ln.length !== 0 && m.queryCommandSupported("mceTableToggleClass") && m.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => yi(m, Ln, "tableclass", (uo) => m.execCommand("mceTableToggleClass", !1, uo)),
      onSetup: h.onSetupTable
    });
    const ss = In(na(m));
    ss.length !== 0 && m.queryCommandSupported("mceTableCellToggleClass") && m.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => yi(m, ss, "tablecellclass", (uo) => m.execCommand("mceTableCellToggleClass", !1, uo)),
      onSetup: h.onSetupCellOrRow
    }), m.queryCommandSupported("mceTableApplyCellStyle") && (m.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => yi(m, ls, "tablecellverticalalign", Ac(m, "vertical-align")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => yi(m, Jr(m), "tablecellborderwidth", Ac(m, "border-width")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => yi(m, Ba(m), "tablecellborderstyle", Ac(m, "border-style")),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => bi(m, Yi(m), "background-color"),
      onSetup: h.onSetupCellOrRow
    }), m.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => bi(m, ka(m), "border-color"),
      onSetup: h.onSetupCellOrRow
    })), oe("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: h.onSetupTableWithCaption
    }), oe("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: af(m),
      onSetup: h.onSetupTableRowHeaders
    }), oe("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: cf(m),
      onSetup: h.onSetupTableRowHeaders
    });
  }, $c = (m) => {
    const h = ou(m);
    es(m), tu(m), pc(m, h), zp(m, h), Dh(m);
  };
  var Ap = () => {
    g.add("table", $c);
  };
  Ap();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (J, me) => J.dispatch("insertCustomChar", { chr: me }), D = (J, me) => {
    const ce = _(J, me).chr;
    J.execCommand("mceInsertContent", !1, ce);
  }, X = (J, me, ce) => {
    var Ce;
    return ce(J, me.prototype) ? !0 : ((Ce = J.constructor) === null || Ce === void 0 ? void 0 : Ce.name) === me.name;
  }, _e = (J) => {
    const me = typeof J;
    return J === null ? "null" : me === "object" && Array.isArray(J) ? "array" : me === "object" && X(J, String, (ce, Ce) => Ce.isPrototypeOf(ce)) ? "string" : me;
  }, Ae = (J) => (me) => _e(me) === J, We = (J) => (me) => typeof me === J, Ke = (J) => (me) => J === me, Ee = Ae("array"), Ie = Ke(null), pt = (J) => J == null, _t = (J) => !pt(J), $e = We("function"), tt = ((J) => () => J)(!1);
  class xe {
    constructor(me, ce) {
      this.tag = me, this.value = ce;
    }
    static some(me) {
      return new xe(!0, me);
    }
    static none() {
      return xe.singletonNone;
    }
    fold(me, ce) {
      return this.tag ? ce(this.value) : me();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(me) {
      return this.tag ? xe.some(me(this.value)) : xe.none();
    }
    bind(me) {
      return this.tag ? me(this.value) : xe.none();
    }
    exists(me) {
      return this.tag && me(this.value);
    }
    forall(me) {
      return !this.tag || me(this.value);
    }
    filter(me) {
      return !this.tag || me(this.value) ? this : xe.none();
    }
    getOr(me) {
      return this.tag ? this.value : me;
    }
    or(me) {
      return this.tag ? this : me;
    }
    getOrThunk(me) {
      return this.tag ? this.value : me();
    }
    orThunk(me) {
      return this.tag ? this : me();
    }
    getOrDie(me) {
      if (this.tag)
        return this.value;
      throw new Error(me != null ? me : "Called getOrDie on None");
    }
    static from(me) {
      return _t(me) ? xe.some(me) : xe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(me) {
      this.tag && me(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  xe.singletonNone = new xe(!1);
  const rt = Array.prototype.push, ae = (J, me) => {
    const ce = J.length, Ce = new Array(ce);
    for (let W = 0; W < ce; W++) {
      const M = J[W];
      Ce[W] = me(M, W);
    }
    return Ce;
  }, ke = (J, me) => {
    for (let ce = 0, Ce = J.length; ce < Ce; ce++) {
      const W = J[ce];
      me(W, ce);
    }
  }, ge = (J, me, ce) => {
    for (let Ce = 0, W = J.length; Ce < W; Ce++) {
      const M = J[Ce];
      if (me(M, Ce))
        return xe.some(M);
      if (ce(M, Ce))
        break;
    }
    return xe.none();
  }, zt = (J, me) => ge(J, me, tt), ot = (J) => {
    const me = [];
    for (let ce = 0, Ce = J.length; ce < Ce; ++ce) {
      if (!Ee(J[ce]))
        throw new Error("Arr.flatten item " + ce + " was not an array, input: " + J);
      rt.apply(me, J[ce]);
    }
    return me;
  }, le = (J, me) => ot(ae(J, me));
  var it = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const ft = (J) => (me) => me.options.get(J), Le = (J) => {
    const me = J.options.register, ce = (Ce) => $e(Ce) || Ee(Ce);
    me("charmap", { processor: ce }), me("charmap_append", { processor: ce });
  }, Ve = ft("charmap"), L = ft("charmap_append"), Wt = it.isArray, Je = "User Defined", jt = () => [
    {
      name: "Currency",
      characters: [
        [
          36,
          "dollar sign"
        ],
        [
          162,
          "cent sign"
        ],
        [
          8364,
          "euro sign"
        ],
        [
          163,
          "pound sign"
        ],
        [
          165,
          "yen sign"
        ],
        [
          164,
          "currency sign"
        ],
        [
          8352,
          "euro-currency sign"
        ],
        [
          8353,
          "colon sign"
        ],
        [
          8354,
          "cruzeiro sign"
        ],
        [
          8355,
          "french franc sign"
        ],
        [
          8356,
          "lira sign"
        ],
        [
          8357,
          "mill sign"
        ],
        [
          8358,
          "naira sign"
        ],
        [
          8359,
          "peseta sign"
        ],
        [
          8360,
          "rupee sign"
        ],
        [
          8361,
          "won sign"
        ],
        [
          8362,
          "new sheqel sign"
        ],
        [
          8363,
          "dong sign"
        ],
        [
          8365,
          "kip sign"
        ],
        [
          8366,
          "tugrik sign"
        ],
        [
          8367,
          "drachma sign"
        ],
        [
          8368,
          "german penny symbol"
        ],
        [
          8369,
          "peso sign"
        ],
        [
          8370,
          "guarani sign"
        ],
        [
          8371,
          "austral sign"
        ],
        [
          8372,
          "hryvnia sign"
        ],
        [
          8373,
          "cedi sign"
        ],
        [
          8374,
          "livre tournois sign"
        ],
        [
          8375,
          "spesmilo sign"
        ],
        [
          8376,
          "tenge sign"
        ],
        [
          8377,
          "indian rupee sign"
        ],
        [
          8378,
          "turkish lira sign"
        ],
        [
          8379,
          "nordic mark sign"
        ],
        [
          8380,
          "manat sign"
        ],
        [
          8381,
          "ruble sign"
        ],
        [
          20870,
          "yen character"
        ],
        [
          20803,
          "yuan character"
        ],
        [
          22291,
          "yuan character, in hong kong and taiwan"
        ],
        [
          22278,
          "yen/yuan character variant one"
        ]
      ]
    },
    {
      name: "Text",
      characters: [
        [
          169,
          "copyright sign"
        ],
        [
          174,
          "registered sign"
        ],
        [
          8482,
          "trade mark sign"
        ],
        [
          8240,
          "per mille sign"
        ],
        [
          181,
          "micro sign"
        ],
        [
          183,
          "middle dot"
        ],
        [
          8226,
          "bullet"
        ],
        [
          8230,
          "three dot leader"
        ],
        [
          8242,
          "minutes / feet"
        ],
        [
          8243,
          "seconds / inches"
        ],
        [
          167,
          "section sign"
        ],
        [
          182,
          "paragraph sign"
        ],
        [
          223,
          "sharp s / ess-zed"
        ]
      ]
    },
    {
      name: "Quotations",
      characters: [
        [
          8249,
          "single left-pointing angle quotation mark"
        ],
        [
          8250,
          "single right-pointing angle quotation mark"
        ],
        [
          171,
          "left pointing guillemet"
        ],
        [
          187,
          "right pointing guillemet"
        ],
        [
          8216,
          "left single quotation mark"
        ],
        [
          8217,
          "right single quotation mark"
        ],
        [
          8220,
          "left double quotation mark"
        ],
        [
          8221,
          "right double quotation mark"
        ],
        [
          8218,
          "single low-9 quotation mark"
        ],
        [
          8222,
          "double low-9 quotation mark"
        ],
        [
          60,
          "less-than sign"
        ],
        [
          62,
          "greater-than sign"
        ],
        [
          8804,
          "less-than or equal to"
        ],
        [
          8805,
          "greater-than or equal to"
        ],
        [
          8211,
          "en dash"
        ],
        [
          8212,
          "em dash"
        ],
        [
          175,
          "macron"
        ],
        [
          8254,
          "overline"
        ],
        [
          164,
          "currency sign"
        ],
        [
          166,
          "broken bar"
        ],
        [
          168,
          "diaeresis"
        ],
        [
          161,
          "inverted exclamation mark"
        ],
        [
          191,
          "turned question mark"
        ],
        [
          710,
          "circumflex accent"
        ],
        [
          732,
          "small tilde"
        ],
        [
          176,
          "degree sign"
        ],
        [
          8722,
          "minus sign"
        ],
        [
          177,
          "plus-minus sign"
        ],
        [
          247,
          "division sign"
        ],
        [
          8260,
          "fraction slash"
        ],
        [
          215,
          "multiplication sign"
        ],
        [
          185,
          "superscript one"
        ],
        [
          178,
          "superscript two"
        ],
        [
          179,
          "superscript three"
        ],
        [
          188,
          "fraction one quarter"
        ],
        [
          189,
          "fraction one half"
        ],
        [
          190,
          "fraction three quarters"
        ]
      ]
    },
    {
      name: "Mathematical",
      characters: [
        [
          402,
          "function / florin"
        ],
        [
          8747,
          "integral"
        ],
        [
          8721,
          "n-ary sumation"
        ],
        [
          8734,
          "infinity"
        ],
        [
          8730,
          "square root"
        ],
        [
          8764,
          "similar to"
        ],
        [
          8773,
          "approximately equal to"
        ],
        [
          8776,
          "almost equal to"
        ],
        [
          8800,
          "not equal to"
        ],
        [
          8801,
          "identical to"
        ],
        [
          8712,
          "element of"
        ],
        [
          8713,
          "not an element of"
        ],
        [
          8715,
          "contains as member"
        ],
        [
          8719,
          "n-ary product"
        ],
        [
          8743,
          "logical and"
        ],
        [
          8744,
          "logical or"
        ],
        [
          172,
          "not sign"
        ],
        [
          8745,
          "intersection"
        ],
        [
          8746,
          "union"
        ],
        [
          8706,
          "partial differential"
        ],
        [
          8704,
          "for all"
        ],
        [
          8707,
          "there exists"
        ],
        [
          8709,
          "diameter"
        ],
        [
          8711,
          "backward difference"
        ],
        [
          8727,
          "asterisk operator"
        ],
        [
          8733,
          "proportional to"
        ],
        [
          8736,
          "angle"
        ]
      ]
    },
    {
      name: "Extended Latin",
      characters: [
        [
          192,
          "A - grave"
        ],
        [
          193,
          "A - acute"
        ],
        [
          194,
          "A - circumflex"
        ],
        [
          195,
          "A - tilde"
        ],
        [
          196,
          "A - diaeresis"
        ],
        [
          197,
          "A - ring above"
        ],
        [
          256,
          "A - macron"
        ],
        [
          198,
          "ligature AE"
        ],
        [
          199,
          "C - cedilla"
        ],
        [
          200,
          "E - grave"
        ],
        [
          201,
          "E - acute"
        ],
        [
          202,
          "E - circumflex"
        ],
        [
          203,
          "E - diaeresis"
        ],
        [
          274,
          "E - macron"
        ],
        [
          204,
          "I - grave"
        ],
        [
          205,
          "I - acute"
        ],
        [
          206,
          "I - circumflex"
        ],
        [
          207,
          "I - diaeresis"
        ],
        [
          298,
          "I - macron"
        ],
        [
          208,
          "ETH"
        ],
        [
          209,
          "N - tilde"
        ],
        [
          210,
          "O - grave"
        ],
        [
          211,
          "O - acute"
        ],
        [
          212,
          "O - circumflex"
        ],
        [
          213,
          "O - tilde"
        ],
        [
          214,
          "O - diaeresis"
        ],
        [
          216,
          "O - slash"
        ],
        [
          332,
          "O - macron"
        ],
        [
          338,
          "ligature OE"
        ],
        [
          352,
          "S - caron"
        ],
        [
          217,
          "U - grave"
        ],
        [
          218,
          "U - acute"
        ],
        [
          219,
          "U - circumflex"
        ],
        [
          220,
          "U - diaeresis"
        ],
        [
          362,
          "U - macron"
        ],
        [
          221,
          "Y - acute"
        ],
        [
          376,
          "Y - diaeresis"
        ],
        [
          562,
          "Y - macron"
        ],
        [
          222,
          "THORN"
        ],
        [
          224,
          "a - grave"
        ],
        [
          225,
          "a - acute"
        ],
        [
          226,
          "a - circumflex"
        ],
        [
          227,
          "a - tilde"
        ],
        [
          228,
          "a - diaeresis"
        ],
        [
          229,
          "a - ring above"
        ],
        [
          257,
          "a - macron"
        ],
        [
          230,
          "ligature ae"
        ],
        [
          231,
          "c - cedilla"
        ],
        [
          232,
          "e - grave"
        ],
        [
          233,
          "e - acute"
        ],
        [
          234,
          "e - circumflex"
        ],
        [
          235,
          "e - diaeresis"
        ],
        [
          275,
          "e - macron"
        ],
        [
          236,
          "i - grave"
        ],
        [
          237,
          "i - acute"
        ],
        [
          238,
          "i - circumflex"
        ],
        [
          239,
          "i - diaeresis"
        ],
        [
          299,
          "i - macron"
        ],
        [
          240,
          "eth"
        ],
        [
          241,
          "n - tilde"
        ],
        [
          242,
          "o - grave"
        ],
        [
          243,
          "o - acute"
        ],
        [
          244,
          "o - circumflex"
        ],
        [
          245,
          "o - tilde"
        ],
        [
          246,
          "o - diaeresis"
        ],
        [
          248,
          "o slash"
        ],
        [
          333,
          "o macron"
        ],
        [
          339,
          "ligature oe"
        ],
        [
          353,
          "s - caron"
        ],
        [
          249,
          "u - grave"
        ],
        [
          250,
          "u - acute"
        ],
        [
          251,
          "u - circumflex"
        ],
        [
          252,
          "u - diaeresis"
        ],
        [
          363,
          "u - macron"
        ],
        [
          253,
          "y - acute"
        ],
        [
          254,
          "thorn"
        ],
        [
          255,
          "y - diaeresis"
        ],
        [
          563,
          "y - macron"
        ],
        [
          913,
          "Alpha"
        ],
        [
          914,
          "Beta"
        ],
        [
          915,
          "Gamma"
        ],
        [
          916,
          "Delta"
        ],
        [
          917,
          "Epsilon"
        ],
        [
          918,
          "Zeta"
        ],
        [
          919,
          "Eta"
        ],
        [
          920,
          "Theta"
        ],
        [
          921,
          "Iota"
        ],
        [
          922,
          "Kappa"
        ],
        [
          923,
          "Lambda"
        ],
        [
          924,
          "Mu"
        ],
        [
          925,
          "Nu"
        ],
        [
          926,
          "Xi"
        ],
        [
          927,
          "Omicron"
        ],
        [
          928,
          "Pi"
        ],
        [
          929,
          "Rho"
        ],
        [
          931,
          "Sigma"
        ],
        [
          932,
          "Tau"
        ],
        [
          933,
          "Upsilon"
        ],
        [
          934,
          "Phi"
        ],
        [
          935,
          "Chi"
        ],
        [
          936,
          "Psi"
        ],
        [
          937,
          "Omega"
        ],
        [
          945,
          "alpha"
        ],
        [
          946,
          "beta"
        ],
        [
          947,
          "gamma"
        ],
        [
          948,
          "delta"
        ],
        [
          949,
          "epsilon"
        ],
        [
          950,
          "zeta"
        ],
        [
          951,
          "eta"
        ],
        [
          952,
          "theta"
        ],
        [
          953,
          "iota"
        ],
        [
          954,
          "kappa"
        ],
        [
          955,
          "lambda"
        ],
        [
          956,
          "mu"
        ],
        [
          957,
          "nu"
        ],
        [
          958,
          "xi"
        ],
        [
          959,
          "omicron"
        ],
        [
          960,
          "pi"
        ],
        [
          961,
          "rho"
        ],
        [
          962,
          "final sigma"
        ],
        [
          963,
          "sigma"
        ],
        [
          964,
          "tau"
        ],
        [
          965,
          "upsilon"
        ],
        [
          966,
          "phi"
        ],
        [
          967,
          "chi"
        ],
        [
          968,
          "psi"
        ],
        [
          969,
          "omega"
        ]
      ]
    },
    {
      name: "Symbols",
      characters: [
        [
          8501,
          "alef symbol"
        ],
        [
          982,
          "pi symbol"
        ],
        [
          8476,
          "real part symbol"
        ],
        [
          978,
          "upsilon - hook symbol"
        ],
        [
          8472,
          "Weierstrass p"
        ],
        [
          8465,
          "imaginary part"
        ]
      ]
    },
    {
      name: "Arrows",
      characters: [
        [
          8592,
          "leftwards arrow"
        ],
        [
          8593,
          "upwards arrow"
        ],
        [
          8594,
          "rightwards arrow"
        ],
        [
          8595,
          "downwards arrow"
        ],
        [
          8596,
          "left right arrow"
        ],
        [
          8629,
          "carriage return"
        ],
        [
          8656,
          "leftwards double arrow"
        ],
        [
          8657,
          "upwards double arrow"
        ],
        [
          8658,
          "rightwards double arrow"
        ],
        [
          8659,
          "downwards double arrow"
        ],
        [
          8660,
          "left right double arrow"
        ],
        [
          8756,
          "therefore"
        ],
        [
          8834,
          "subset of"
        ],
        [
          8835,
          "superset of"
        ],
        [
          8836,
          "not a subset of"
        ],
        [
          8838,
          "subset of or equal to"
        ],
        [
          8839,
          "superset of or equal to"
        ],
        [
          8853,
          "circled plus"
        ],
        [
          8855,
          "circled times"
        ],
        [
          8869,
          "perpendicular"
        ],
        [
          8901,
          "dot operator"
        ],
        [
          8968,
          "left ceiling"
        ],
        [
          8969,
          "right ceiling"
        ],
        [
          8970,
          "left floor"
        ],
        [
          8971,
          "right floor"
        ],
        [
          9001,
          "left-pointing angle bracket"
        ],
        [
          9002,
          "right-pointing angle bracket"
        ],
        [
          9674,
          "lozenge"
        ],
        [
          9824,
          "black spade suit"
        ],
        [
          9827,
          "black club suit"
        ],
        [
          9829,
          "black heart suit"
        ],
        [
          9830,
          "black diamond suit"
        ],
        [
          8194,
          "en space"
        ],
        [
          8195,
          "em space"
        ],
        [
          8201,
          "thin space"
        ],
        [
          8204,
          "zero width non-joiner"
        ],
        [
          8205,
          "zero width joiner"
        ],
        [
          8206,
          "left-to-right mark"
        ],
        [
          8207,
          "right-to-left mark"
        ]
      ]
    }
  ], ye = (J) => it.grep(J, (me) => Wt(me) && me.length === 2), Ze = (J) => Wt(J) ? ye(J) : typeof J == "function" ? J() : [], qt = (J, me) => {
    const ce = Ve(J);
    ce && (me = [{
      name: Je,
      characters: Ze(ce)
    }]);
    const Ce = L(J);
    if (Ce) {
      const W = it.grep(me, (M) => M.name === Je);
      return W.length ? (W[0].characters = [].concat(W[0].characters).concat(Ze(Ce)), me) : me.concat({
        name: Je,
        characters: Ze(Ce)
      });
    }
    return me;
  }, Z = (J) => {
    const me = qt(J, jt());
    return me.length > 1 ? [{
      name: "All",
      characters: le(me, (ce) => ce.characters)
    }].concat(me) : me;
  }, Pe = (J) => ({
    getCharMap: () => Z(J),
    insertChar: (Ce) => {
      D(J, Ce);
    }
  }), yt = (J) => {
    let me = J;
    return {
      get: () => me,
      set: (W) => {
        me = W;
      }
    };
  }, et = (J, me) => {
    let ce = null;
    const Ce = () => {
      Ie(ce) || (clearTimeout(ce), ce = null);
    };
    return {
      cancel: Ce,
      throttle: (...M) => {
        Ce(), ce = setTimeout(() => {
          ce = null, J.apply(null, M);
        }, me);
      }
    };
  }, kn = (J, me) => J.indexOf(me) !== -1, Rn = String.fromCodePoint, an = (J, me, ce) => kn(Rn(J).toLowerCase(), ce) ? !0 : kn(me.toLowerCase(), ce) || kn(me.toLowerCase().replace(/\s+/g, ""), ce), en = (J, me) => {
    const ce = [], Ce = me.toLowerCase();
    return ke(J.characters, (W) => {
      an(W[0], W[1], Ce) && ce.push(W);
    }), ae(ce, (W) => ({
      text: W[1],
      value: Rn(W[0]),
      icon: Rn(W[0])
    }));
  }, cn = "pattern", wn = (J, me) => {
    const ce = () => [
      {
        label: "Search",
        type: "input",
        name: cn
      },
      {
        type: "collection",
        name: "results"
      }
    ], Ce = () => ae(me, (eo) => ({
      title: eo.name,
      name: eo.name,
      items: ce()
    })), W = () => ({
      type: "panel",
      items: ce()
    }), M = () => ({
      type: "tabpanel",
      tabs: Ce()
    }), Ue = me.length === 1 ? yt(Je) : yt("All"), kt = (eo, Xt) => {
      zt(me, (ro) => ro.name === Ue.get()).each((ro) => {
        const io = en(ro, Xt);
        eo.setData({ results: io });
      });
    }, pn = et((eo) => {
      const Xt = eo.getData().pattern;
      kt(eo, Xt);
    }, 40), En = me.length === 1 ? W() : M(), Eo = {
      pattern: "",
      results: en(me[0], "")
    }, oo = {
      title: "Special Character",
      size: "normal",
      body: En,
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: Eo,
      onAction: (eo, Xt) => {
        Xt.name === "results" && (D(J, Xt.value), eo.close());
      },
      onTabChange: (eo, Xt) => {
        Ue.set(Xt.newTabName), pn.throttle(eo);
      },
      onChange: (eo, Xt) => {
        Xt.name === cn && pn.throttle(eo);
      }
    };
    J.windowManager.open(oo).focus(cn);
  }, w = (J, me) => {
    J.addCommand("mceShowCharmap", () => {
      wn(J, me);
    });
  }, ie = (J, me) => {
    J.ui.registry.addAutocompleter("charmap", {
      ch: ":",
      columns: "auto",
      minChars: 2,
      fetch: (ce, Ce) => new Promise((W, M) => {
        W(en(me, ce));
      }),
      onAction: (ce, Ce, W) => {
        J.selection.setRng(Ce), J.insertContent(W), ce.hide();
      }
    });
  }, re = (J) => {
    J.ui.registry.addButton("charmap", {
      icon: "insert-character",
      tooltip: "Special character",
      onAction: () => J.execCommand("mceShowCharmap")
    }), J.ui.registry.addMenuItem("charmap", {
      icon: "insert-character",
      text: "Special character...",
      onAction: () => J.execCommand("mceShowCharmap")
    });
  };
  var we = () => {
    g.add("charmap", (J) => {
      Le(J);
      const me = Z(J);
      return w(J, me), re(J), ie(J, me[0]), Pe(J);
    });
  };
  we();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager"), _ = tinymce.util.Tools.resolve("tinymce.Env");
  const D = (Ne) => (tt) => tt.options.get(Ne), X = (Ne) => {
    const tt = Ne.options.register;
    tt("pagebreak_separator", {
      processor: "string",
      default: "<!-- pagebreak -->"
    }), tt("pagebreak_split_block", {
      processor: "boolean",
      default: !1
    });
  }, _e = D("pagebreak_separator"), Ae = D("pagebreak_split_block"), We = "mce-pagebreak", Ke = (Ne) => {
    const tt = `<img src="${_.transparentSrc}" class="${We}" data-mce-resize="false" data-mce-placeholder />`;
    return Ne ? `<p>${tt}</p>` : tt;
  }, Ee = (Ne) => {
    const tt = _e(Ne), xe = () => Ae(Ne), rt = new RegExp(tt.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, (ae) => "\\" + ae), "gi");
    Ne.on("BeforeSetContent", (ae) => {
      ae.content = ae.content.replace(rt, Ke(xe()));
    }), Ne.on("PreInit", () => {
      Ne.serializer.addNodeFilter("img", (ae) => {
        let ke = ae.length, ge, zt;
        for (; ke--; )
          if (ge = ae[ke], zt = ge.attr("class"), zt && zt.indexOf(We) !== -1) {
            const ot = ge.parent;
            if (Ne.schema.getBlockElements()[ot.name] && xe()) {
              ot.type = 3, ot.value = tt, ot.raw = !0, ge.remove();
              continue;
            }
            ge.type = 3, ge.value = tt, ge.raw = !0;
          }
      });
    });
  }, Ie = (Ne) => {
    Ne.addCommand("mcePageBreak", () => {
      Ne.insertContent(Ke(Ae(Ne)));
    });
  }, pt = (Ne) => {
    Ne.on("ResolveName", (tt) => {
      tt.target.nodeName === "IMG" && Ne.dom.hasClass(tt.target, We) && (tt.name = "pagebreak");
    });
  }, _t = (Ne) => {
    const tt = () => Ne.execCommand("mcePageBreak");
    Ne.ui.registry.addButton("pagebreak", {
      icon: "page-break",
      tooltip: "Page break",
      onAction: tt
    }), Ne.ui.registry.addMenuItem("pagebreak", {
      text: "Page break",
      icon: "page-break",
      onAction: tt
    });
  };
  var $e = () => {
    g.add("pagebreak", (Ne) => {
      X(Ne), Ie(Ne), _t(Ne), Ee(Ne), pt(Ne);
    });
  };
  $e();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (rt) => (ae) => typeof ae === rt, D = _("boolean"), X = _("number"), _e = (rt) => (ae) => ae.options.get(rt), Ae = (rt) => {
    const ae = rt.options.register;
    ae("nonbreaking_force_tab", {
      processor: (ke) => D(ke) ? {
        value: ke ? 3 : 0,
        valid: !0
      } : X(ke) ? {
        value: ke,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean or number."
      },
      default: !1
    }), ae("nonbreaking_wrap", {
      processor: "boolean",
      default: !0
    });
  }, We = _e("nonbreaking_force_tab"), Ke = _e("nonbreaking_wrap"), Ee = (rt, ae) => {
    let ke = "";
    for (let ge = 0; ge < ae; ge++)
      ke += rt;
    return ke;
  }, Ie = (rt) => rt.plugins.visualchars ? rt.plugins.visualchars.isEnabled() : !1, pt = (rt, ae) => {
    const ke = () => Ie(rt) ? "mce-nbsp-wrap mce-nbsp" : "mce-nbsp-wrap", ge = () => `<span class="${ke()}" contenteditable="false">${Ee("&nbsp;", ae)}</span>`, ot = Ke(rt) || rt.plugins.visualchars ? ge() : Ee("&nbsp;", ae);
    rt.undoManager.transact(() => rt.insertContent(ot));
  }, _t = (rt) => {
    rt.addCommand("mceNonBreaking", () => {
      pt(rt, 1);
    });
  };
  var $e = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Ne = (rt) => {
    const ae = We(rt);
    ae > 0 && rt.on("keydown", (ke) => {
      if (ke.keyCode === $e.TAB && !ke.isDefaultPrevented()) {
        if (ke.shiftKey)
          return;
        ke.preventDefault(), ke.stopImmediatePropagation(), pt(rt, ae);
      }
    });
  }, tt = (rt) => {
    const ae = () => rt.execCommand("mceNonBreaking");
    rt.ui.registry.addButton("nonbreaking", {
      icon: "non-breaking",
      tooltip: "Nonbreaking space",
      onAction: ae
    }), rt.ui.registry.addMenuItem("nonbreaking", {
      icon: "non-breaking",
      text: "Nonbreaking space",
      onAction: ae
    });
  };
  var xe = () => {
    g.add("nonbreaking", (rt) => {
      Ae(rt), _t(rt), tt(rt), Ne(rt);
    });
  };
  xe();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager"), _ = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), D = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const X = (Je) => (jt) => jt.options.get(Je), _e = (Je) => {
    const jt = Je.options.register;
    jt("allow_html_in_named_anchor", {
      processor: "boolean",
      default: !1
    });
  }, Ae = X("allow_html_in_named_anchor"), We = "a:not([href])", Ke = (Je) => !Je, Ee = (Je) => Je.getAttribute("id") || Je.getAttribute("name") || "", Ie = (Je) => Je && Je.nodeName.toLowerCase() === "a", pt = (Je) => Ie(Je) && !Je.getAttribute("href") && Ee(Je) !== "", _t = (Je) => pt(Je) && !Je.firstChild, $e = (Je) => {
    const jt = Je.dom;
    _(jt).walk(Je.selection.getRng(), (ye) => {
      D.each(ye, (Ze) => {
        _t(Ze) && jt.remove(Ze, !1);
      });
    });
  }, Ne = (Je) => /^[A-Za-z][A-Za-z0-9\-:._]*$/.test(Je), tt = (Je) => Je.dom.getParent(Je.selection.getStart(), We), xe = (Je) => {
    const jt = tt(Je);
    return jt ? Ee(jt) : "";
  }, rt = (Je, jt) => {
    Je.undoManager.transact(() => {
      Ae(Je) || Je.selection.collapse(!0), Je.selection.isCollapsed() ? Je.insertContent(Je.dom.createHTML("a", { id: jt })) : ($e(Je), Je.formatter.remove("namedAnchor", null, null, !0), Je.formatter.apply("namedAnchor", { value: jt }), Je.addVisual());
    });
  }, ae = (Je, jt, ye) => {
    ye.removeAttribute("name"), ye.id = jt, Je.addVisual(), Je.undoManager.add();
  }, ke = (Je, jt) => {
    const ye = tt(Je);
    ye ? ae(Je, jt, ye) : rt(Je, jt), Je.focus();
  }, ge = (Je, jt) => Ne(jt) ? (ke(Je, jt), !0) : (Je.windowManager.alert("ID should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores."), !1), zt = (Je) => {
    const jt = xe(Je);
    Je.windowManager.open({
      title: "Anchor",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          name: "id",
          type: "input",
          label: "ID",
          placeholder: "example"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { id: jt },
      onSubmit: (ye) => {
        ge(Je, ye.getData().id) && ye.close();
      }
    });
  }, ot = (Je) => {
    Je.addCommand("mceAnchor", () => {
      zt(Je);
    });
  }, le = (Je) => Je && Ke(Je.attr("href")) && !Ke(Je.attr("id") || Je.attr("name")), it = (Je) => le(Je) && !Je.firstChild, ft = (Je) => (jt) => {
    for (let ye = 0; ye < jt.length; ye++) {
      const Ze = jt[ye];
      it(Ze) && Ze.attr("contenteditable", Je);
    }
  }, Le = (Je) => {
    Je.on("PreInit", () => {
      Je.parser.addNodeFilter("a", ft("false")), Je.serializer.addNodeFilter("a", ft(null));
    });
  }, Ve = (Je) => {
    Je.formatter.register("namedAnchor", {
      inline: "a",
      selector: We,
      remove: "all",
      split: !0,
      deep: !0,
      attributes: { id: "%value" },
      onmatch: (jt, ye, Ze) => pt(jt)
    });
  }, L = (Je) => {
    Je.ui.registry.addToggleButton("anchor", {
      icon: "bookmark",
      tooltip: "Anchor",
      onAction: () => Je.execCommand("mceAnchor"),
      onSetup: (jt) => Je.selection.selectorChangedWithUnbind("a:not([href])", jt.setActive).unbind
    }), Je.ui.registry.addMenuItem("anchor", {
      icon: "bookmark",
      text: "Anchor...",
      onAction: () => Je.execCommand("mceAnchor")
    });
  };
  var Wt = () => {
    g.add("anchor", (Je) => {
      _e(Je), Le(Je), ot(Je), L(Je), Je.on("PreInit", () => {
        Ve(Je);
      });
    });
  };
  Wt();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (ot) => (le) => le.options.get(ot), D = (ot) => {
    const le = ot.options.register;
    le("insertdatetime_dateformat", {
      processor: "string",
      default: ot.translate("%Y-%m-%d")
    }), le("insertdatetime_timeformat", {
      processor: "string",
      default: ot.translate("%H:%M:%S")
    }), le("insertdatetime_formats", {
      processor: "string[]",
      default: [
        "%H:%M:%S",
        "%Y-%m-%d",
        "%I:%M:%S %p",
        "%D"
      ]
    }), le("insertdatetime_element", {
      processor: "boolean",
      default: !1
    });
  }, X = _("insertdatetime_dateformat"), _e = _("insertdatetime_timeformat"), Ae = _("insertdatetime_formats"), We = _("insertdatetime_element"), Ke = (ot) => {
    const le = Ae(ot);
    return le.length > 0 ? le[0] : _e(ot);
  }, Ee = "Sun Mon Tue Wed Thu Fri Sat Sun".split(" "), Ie = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" "), pt = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), _t = "January February March April May June July August September October November December".split(" "), $e = (ot, le) => {
    if (ot = "" + ot, ot.length < le)
      for (let it = 0; it < le - ot.length; it++)
        ot = "0" + ot;
    return ot;
  }, Ne = (ot, le, it = new Date()) => (le = le.replace("%D", "%m/%d/%Y"), le = le.replace("%r", "%I:%M:%S %p"), le = le.replace("%Y", "" + it.getFullYear()), le = le.replace("%y", "" + it.getYear()), le = le.replace("%m", $e(it.getMonth() + 1, 2)), le = le.replace("%d", $e(it.getDate(), 2)), le = le.replace("%H", "" + $e(it.getHours(), 2)), le = le.replace("%M", "" + $e(it.getMinutes(), 2)), le = le.replace("%S", "" + $e(it.getSeconds(), 2)), le = le.replace("%I", "" + ((it.getHours() + 11) % 12 + 1)), le = le.replace("%p", it.getHours() < 12 ? "AM" : "PM"), le = le.replace("%B", "" + ot.translate(_t[it.getMonth()])), le = le.replace("%b", "" + ot.translate(pt[it.getMonth()])), le = le.replace("%A", "" + ot.translate(Ie[it.getDay()])), le = le.replace("%a", "" + ot.translate(Ee[it.getDay()])), le = le.replace("%%", "%"), le), tt = (ot, le, it, ft) => {
    const Le = ot.dom.create("time", { datetime: it }, ft);
    le.parentNode.insertBefore(Le, le), ot.dom.remove(le), ot.selection.select(Le, !0), ot.selection.collapse(!1);
  }, xe = (ot, le) => {
    if (We(ot)) {
      const it = Ne(ot, le);
      let ft;
      /%[HMSIp]/.test(le) ? ft = Ne(ot, "%Y-%m-%dT%H:%M") : ft = Ne(ot, "%Y-%m-%d");
      const Le = ot.dom.getParent(ot.selection.getStart(), "time");
      Le ? tt(ot, Le, ft, it) : ot.insertContent('<time datetime="' + ft + '">' + it + "</time>");
    } else
      ot.insertContent(Ne(ot, le));
  }, rt = (ot) => {
    ot.addCommand("mceInsertDate", (le, it) => {
      xe(ot, it != null ? it : X(ot));
    }), ot.addCommand("mceInsertTime", (le, it) => {
      xe(ot, it != null ? it : _e(ot));
    });
  }, ae = (ot) => {
    let le = ot;
    return {
      get: () => le,
      set: (Le) => {
        le = Le;
      }
    };
  };
  var ke = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const ge = (ot) => {
    const le = Ae(ot), it = ae(Ke(ot)), ft = (Ve) => ot.execCommand("mceInsertDate", !1, Ve);
    ot.ui.registry.addSplitButton("insertdatetime", {
      icon: "insert-time",
      tooltip: "Insert date/time",
      select: (Ve) => Ve === it.get(),
      fetch: (Ve) => {
        Ve(ke.map(le, (L) => ({
          type: "choiceitem",
          text: Ne(ot, L),
          value: L
        })));
      },
      onAction: (Ve) => {
        ft(it.get());
      },
      onItemAction: (Ve, L) => {
        it.set(L), ft(L);
      }
    });
    const Le = (Ve) => () => {
      it.set(Ve), ft(Ve);
    };
    ot.ui.registry.addNestedMenuItem("insertdatetime", {
      icon: "insert-time",
      text: "Date/time",
      getSubmenuItems: () => ke.map(le, (Ve) => ({
        type: "menuitem",
        text: Ne(ot, Ve),
        onAction: Le(Ve)
      }))
    });
  };
  var zt = () => {
    g.add("insertdatetime", (ot) => {
      D(ot), rt(ot), ge(ot);
    });
  };
  zt();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (ft, Le, Ve) => {
    const L = Le === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
    ft.execCommand(L, !1, Ve === !1 ? null : { "list-style-type": Ve });
  }, D = (ft) => {
    ft.addCommand("ApplyUnorderedListStyle", (Le, Ve) => {
      _(ft, "UL", Ve["list-style-type"]);
    }), ft.addCommand("ApplyOrderedListStyle", (Le, Ve) => {
      _(ft, "OL", Ve["list-style-type"]);
    });
  }, X = (ft) => (Le) => Le.options.get(ft), _e = (ft) => {
    const Le = ft.options.register;
    Le("advlist_number_styles", {
      processor: "string[]",
      default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
    }), Le("advlist_bullet_styles", {
      processor: "string[]",
      default: "default,circle,square".split(",")
    });
  }, Ae = X("advlist_number_styles"), We = X("advlist_bullet_styles");
  var Ke = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ee = (ft) => ft == null, Ie = (ft) => !Ee(ft);
  class pt {
    constructor(Le, Ve) {
      this.tag = Le, this.value = Ve;
    }
    static some(Le) {
      return new pt(!0, Le);
    }
    static none() {
      return pt.singletonNone;
    }
    fold(Le, Ve) {
      return this.tag ? Ve(this.value) : Le();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Le) {
      return this.tag ? pt.some(Le(this.value)) : pt.none();
    }
    bind(Le) {
      return this.tag ? Le(this.value) : pt.none();
    }
    exists(Le) {
      return this.tag && Le(this.value);
    }
    forall(Le) {
      return !this.tag || Le(this.value);
    }
    filter(Le) {
      return !this.tag || Le(this.value) ? this : pt.none();
    }
    getOr(Le) {
      return this.tag ? this.value : Le;
    }
    or(Le) {
      return this.tag ? this : Le;
    }
    getOrThunk(Le) {
      return this.tag ? this.value : Le();
    }
    orThunk(Le) {
      return this.tag ? this : Le();
    }
    getOrDie(Le) {
      if (this.tag)
        return this.value;
      throw new Error(Le != null ? Le : "Called getOrDie on None");
    }
    static from(Le) {
      return Ie(Le) ? pt.some(Le) : pt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Le) {
      this.tag && Le(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  pt.singletonNone = new pt(!1);
  const _t = (ft, Le) => ft.dom.isChildOf(Le, ft.getBody()), $e = (ft) => ft && /^(TH|TD)$/.test(ft.nodeName), Ne = (ft) => (Le) => Le && /^(OL|UL|DL)$/.test(Le.nodeName) && _t(ft, Le), tt = (ft) => {
    const Le = ft.dom.getParent(ft.selection.getNode(), "ol,ul"), Ve = ft.dom.getStyle(Le, "listStyleType");
    return pt.from(Ve);
  }, xe = (ft, Le) => {
    for (let Ve = 0; Ve < ft.length; Ve++) {
      const L = ft[Ve];
      if (Le(L))
        return Ve;
    }
    return -1;
  }, rt = (ft) => ft.replace(/\-/g, " ").replace(/\b\w/g, (Le) => Le.toUpperCase()), ae = (ft, Le, Ve) => {
    const L = xe(Le.parents, $e), Wt = L !== -1 ? Le.parents.slice(0, L) : Le.parents, Je = Ke.grep(Wt, Ne(ft));
    return Je.length > 0 && Je[0].nodeName === Ve;
  }, ke = (ft, Le) => (Ve) => {
    const L = (Wt) => {
      Ve.setActive(ae(ft, Wt, Le));
    };
    return ft.on("NodeChange", L), () => ft.off("NodeChange", L);
  }, ge = (ft, Le, Ve, L, Wt, Je) => {
    ft.ui.registry.addSplitButton(Le, {
      tooltip: Ve,
      icon: Wt === "OL" ? "ordered-list" : "unordered-list",
      presets: "listpreview",
      columns: 3,
      fetch: (jt) => {
        const ye = Ke.map(Je, (Ze) => {
          const qt = Wt === "OL" ? "num" : "bull", Z = Ze === "disc" || Ze === "decimal" ? "default" : Ze, Pe = Ze === "default" ? "" : Ze, yt = rt(Ze);
          return {
            type: "choiceitem",
            value: Pe,
            icon: "list-" + qt + "-" + Z,
            text: yt
          };
        });
        jt(ye);
      },
      onAction: () => ft.execCommand(L),
      onItemAction: (jt, ye) => {
        _(ft, Wt, ye);
      },
      select: (jt) => tt(ft).map((Ze) => jt === Ze).getOr(!1),
      onSetup: ke(ft, Wt)
    });
  }, zt = (ft, Le, Ve, L, Wt, Je) => {
    ft.ui.registry.addToggleButton(Le, {
      active: !1,
      tooltip: Ve,
      icon: Wt === "OL" ? "ordered-list" : "unordered-list",
      onSetup: ke(ft, Wt),
      onAction: () => ft.execCommand(L)
    });
  }, ot = (ft, Le, Ve, L, Wt, Je) => {
    Je.length > 1 ? ge(ft, Le, Ve, L, Wt, Je) : zt(ft, Le, Ve, L, Wt);
  }, le = (ft) => {
    ot(ft, "numlist", "Numbered list", "InsertOrderedList", "OL", Ae(ft)), ot(ft, "bullist", "Bullet list", "InsertUnorderedList", "UL", We(ft));
  };
  var it = () => {
    g.add("advlist", (ft) => {
      ft.hasPlugin("lists") ? (_e(ft), le(ft), D(ft)) : console.error("Please use the Lists plugin together with the Advanced List plugin.");
    });
  };
  it();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (b, S, A) => {
    var te;
    return A(b, S.prototype) ? !0 : ((te = b.constructor) === null || te === void 0 ? void 0 : te.name) === S.name;
  }, D = (b) => {
    const S = typeof b;
    return b === null ? "null" : S === "object" && Array.isArray(b) ? "array" : S === "object" && _(b, String, (A, te) => te.isPrototypeOf(A)) ? "string" : S;
  }, X = (b) => (S) => D(S) === b, _e = (b) => (S) => typeof S === b, Ae = X("string"), We = X("object"), Ke = X("array"), Ee = _e("boolean"), Ie = (b) => b == null, pt = (b) => !Ie(b), _t = _e("function"), $e = _e("number"), Ne = () => {
  }, tt = (b) => () => b, xe = (b, S) => b === S, rt = (b) => (S) => !b(S), ae = tt(!1);
  class ke {
    constructor(S, A) {
      this.tag = S, this.value = A;
    }
    static some(S) {
      return new ke(!0, S);
    }
    static none() {
      return ke.singletonNone;
    }
    fold(S, A) {
      return this.tag ? A(this.value) : S();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(S) {
      return this.tag ? ke.some(S(this.value)) : ke.none();
    }
    bind(S) {
      return this.tag ? S(this.value) : ke.none();
    }
    exists(S) {
      return this.tag && S(this.value);
    }
    forall(S) {
      return !this.tag || S(this.value);
    }
    filter(S) {
      return !this.tag || S(this.value) ? this : ke.none();
    }
    getOr(S) {
      return this.tag ? this.value : S;
    }
    or(S) {
      return this.tag ? this : S;
    }
    getOrThunk(S) {
      return this.tag ? this.value : S();
    }
    orThunk(S) {
      return this.tag ? this : S();
    }
    getOrDie(S) {
      if (this.tag)
        return this.value;
      throw new Error(S != null ? S : "Called getOrDie on None");
    }
    static from(S) {
      return pt(S) ? ke.some(S) : ke.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(S) {
      this.tag && S(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ke.singletonNone = new ke(!1);
  const ge = Array.prototype.slice, zt = Array.prototype.indexOf, ot = Array.prototype.push, le = (b, S) => zt.call(b, S), it = (b, S) => le(b, S) > -1, ft = (b, S) => {
    for (let A = 0, te = b.length; A < te; A++) {
      const be = b[A];
      if (S(be, A))
        return !0;
    }
    return !1;
  }, Le = (b, S) => {
    const A = b.length, te = new Array(A);
    for (let be = 0; be < A; be++) {
      const $t = b[be];
      te[be] = S($t, be);
    }
    return te;
  }, Ve = (b, S) => {
    for (let A = 0, te = b.length; A < te; A++) {
      const be = b[A];
      S(be, A);
    }
  }, L = (b, S) => {
    const A = [];
    for (let te = 0, be = b.length; te < be; te++) {
      const $t = b[te];
      S($t, te) && A.push($t);
    }
    return A;
  }, Wt = (b, S) => {
    if (b.length === 0)
      return [];
    {
      let A = S(b[0]);
      const te = [];
      let be = [];
      for (let $t = 0, yn = b.length; $t < yn; $t++) {
        const On = b[$t], Hn = S(On);
        Hn !== A && (te.push(be), be = []), A = Hn, be.push(On);
      }
      return be.length !== 0 && te.push(be), te;
    }
  }, Je = (b, S, A) => (Ve(b, (te, be) => {
    A = S(A, te, be);
  }), A), jt = (b, S, A) => {
    for (let te = 0, be = b.length; te < be; te++) {
      const $t = b[te];
      if (S($t, te))
        return ke.some($t);
      if (A($t, te))
        break;
    }
    return ke.none();
  }, ye = (b, S) => jt(b, S, ae), Ze = (b) => {
    const S = [];
    for (let A = 0, te = b.length; A < te; ++A) {
      if (!Ke(b[A]))
        throw new Error("Arr.flatten item " + A + " was not an array, input: " + b);
      ot.apply(S, b[A]);
    }
    return S;
  }, qt = (b, S) => Ze(Le(b, S)), Z = (b) => {
    const S = ge.call(b, 0);
    return S.reverse(), S;
  }, Pe = (b, S) => S >= 0 && S < b.length ? ke.some(b[S]) : ke.none(), yt = (b) => Pe(b, 0), et = (b) => Pe(b, b.length - 1), kn = (b, S) => {
    const A = [], te = _t(S) ? (be) => ft(A, ($t) => S($t, be)) : (be) => it(A, be);
    for (let be = 0, $t = b.length; be < $t; be++) {
      const yn = b[be];
      te(yn) || A.push(yn);
    }
    return A;
  }, Rn = (b, S, A = xe) => b.exists((te) => A(te, S)), an = (b, S, A = xe) => en(b, S, A).getOr(b.isNone() && S.isNone()), en = (b, S, A) => b.isSome() && S.isSome() ? ke.some(A(b.getOrDie(), S.getOrDie())) : ke.none(), cn = 1, wn = (b, S) => {
    const te = (S || document).createElement("div");
    if (te.innerHTML = b, !te.hasChildNodes() || te.childNodes.length > 1) {
      const be = "HTML does not have a single root node";
      throw console.error(be, b), new Error(be);
    }
    return re(te.childNodes[0]);
  }, w = (b, S) => {
    const te = (S || document).createElement(b);
    return re(te);
  }, ie = (b, S) => {
    const te = (S || document).createTextNode(b);
    return re(te);
  }, re = (b) => {
    if (b == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: b };
  }, J = {
    fromHtml: wn,
    fromTag: w,
    fromText: ie,
    fromDom: re,
    fromPoint: (b, S, A) => ke.from(b.dom.elementFromPoint(S, A)).map(re)
  }, me = (b, S) => {
    const A = b.dom;
    if (A.nodeType !== cn)
      return !1;
    {
      const te = A;
      if (te.matches !== void 0)
        return te.matches(S);
      if (te.msMatchesSelector !== void 0)
        return te.msMatchesSelector(S);
      if (te.webkitMatchesSelector !== void 0)
        return te.webkitMatchesSelector(S);
      if (te.mozMatchesSelector !== void 0)
        return te.mozMatchesSelector(S);
      throw new Error("Browser lacks native selectors");
    }
  }, ce = (b, S) => b.dom === S.dom, Ce = (b, S) => {
    const A = b.dom, te = S.dom;
    return A === te ? !1 : A.contains(te);
  }, W = me;
  var M = (b, S, A, te, be) => b(A, te) ? ke.some(A) : _t(be) && be(A) ? ke.none() : S(A, te, be);
  typeof window < "u" || Function("return this;")();
  const Ue = (b) => b.dom.nodeName.toLowerCase(), kt = (b) => b.dom.nodeType, pn = ((b) => (S) => kt(S) === b)(cn), En = (b) => (S) => pn(S) && Ue(S) === b, Eo = (b) => ke.from(b.dom.parentNode).map(J.fromDom), oo = (b) => ke.from(b.dom.nextSibling).map(J.fromDom), Yn = (b) => Le(b.dom.childNodes, J.fromDom), eo = (b, S) => {
    const A = b.dom.childNodes;
    return ke.from(A[S]).map(J.fromDom);
  }, Xt = (b) => eo(b, 0), ro = (b) => eo(b, b.dom.childNodes.length - 1), io = (b, S, A) => {
    let te = b.dom;
    const be = _t(A) ? A : ae;
    for (; te.parentNode; ) {
      te = te.parentNode;
      const $t = J.fromDom(te);
      if (S($t))
        return ke.some($t);
      if (be($t))
        break;
    }
    return ke.none();
  }, Fe = (b, S, A) => M((be, $t) => $t(be), io, b, S, A), st = (b, S) => {
    Eo(b).each((te) => {
      te.dom.insertBefore(S.dom, b.dom);
    });
  }, Qt = (b, S) => {
    oo(b).fold(() => {
      Eo(b).each((be) => {
        Ut(be, S);
      });
    }, (te) => {
      st(te, S);
    });
  }, Ut = (b, S) => {
    b.dom.appendChild(S.dom);
  }, Tn = (b, S) => {
    Ve(S, (A) => {
      st(b, A);
    });
  }, Pn = (b, S) => {
    Ve(S, (A) => {
      Ut(b, A);
    });
  }, ho = (b) => {
    b.dom.textContent = "", Ve(Yn(b), (S) => {
      Bo(S);
    });
  }, Bo = (b) => {
    const S = b.dom;
    S.parentNode !== null && S.parentNode.removeChild(S);
  };
  var ue = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), ze = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), At = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Ot = Object.keys, hn = (b, S) => {
    const A = Ot(b);
    for (let te = 0, be = A.length; te < be; te++) {
      const $t = A[te], yn = b[$t];
      S(yn, $t);
    }
  }, Ao = (b) => (S, A) => {
    b[A] = S;
  }, xs = (b, S, A, te) => {
    const be = {};
    return hn(b, ($t, yn) => {
      (S($t, yn) ? A : te)($t, yn);
    }), be;
  }, zs = (b, S) => {
    const A = {};
    return xs(b, S, Ao(A), Ne), A;
  }, To = (b, S, A) => {
    if (Ae(A) || Ee(A) || $e(A))
      b.setAttribute(S, A + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", S, ":: Value ", A, ":: Element ", b), new Error("Attribute value was not simple");
  }, rs = (b, S) => {
    const A = b.dom;
    hn(S, (te, be) => {
      To(A, be, te);
    });
  }, wo = (b) => Je(b.dom.attributes, (S, A) => (S[A.name] = A.value, S), {}), os = (b, S) => J.fromDom(b.dom.cloneNode(S)), Vn = (b) => os(b, !0), gn = (b, S) => {
    const A = J.fromTag(S), te = wo(b);
    return rs(A, te), A;
  }, qo = (b, S) => {
    const A = gn(b, S);
    Qt(b, A);
    const te = Yn(b);
    return Pn(A, te), Bo(b), A;
  };
  var lo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Io = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ks = (b) => (S) => S && S.nodeName.toLowerCase() === b, As = (b) => (S) => S && b.test(S.nodeName), cs = (b) => b && b.nodeType === 3, Lo = As(/^(OL|UL|DL)$/), Ys = As(/^(OL|UL)$/), O = Ks("ol"), G = As(/^(LI|DT|DD)$/), de = As(/^(DT|DD)$/), dt = As(/^(TH|TD)$/), rn = Ks("br"), Et = (b) => b.parentNode.firstChild === b, An = (b, S) => S && !!b.schema.getTextBlockElements()[S.nodeName], Po = (b, S) => b && b.nodeName in S, ln = (b, S) => rn(S) ? b.isBlock(S.nextSibling) && !rn(S.previousSibling) : !1, jn = (b, S, A) => {
    const te = b.isEmpty(S);
    return A && b.select("span[data-mce-type=bookmark]", S).length > 0 ? !1 : te;
  }, Mo = (b, S) => b.isChildOf(S, b.getRoot()), No = (b) => (S) => S.options.get(b), q = (b) => {
    const S = b.options.register;
    S("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, ee = No("lists_indent_on_tab"), Ge = No("forced_root_block"), St = No("forced_root_block_attrs"), vt = (b, S) => {
    const A = b.dom, te = b.schema.getBlockElements(), be = A.createFragment(), $t = Ge(b), yn = St(b);
    let On, Hn, Mn;
    for (Hn = A.create($t, yn), Po(S.firstChild, te) || be.appendChild(Hn); On = S.firstChild; ) {
      const ts = On.nodeName;
      !Mn && (ts !== "SPAN" || On.getAttribute("data-mce-type") !== "bookmark") && (Mn = !0), Po(On, te) ? (be.appendChild(On), Hn = null) : (Hn || (Hn = A.create($t, yn), be.appendChild(Hn)), Hn.appendChild(On));
    }
    return Mn || Hn.appendChild(A.create("br", { "data-mce-bogus": "1" })), be;
  }, wt = lo.DOM, It = (b, S, A) => {
    const te = (Hn) => {
      Io.each(be, (Mn) => {
        Hn.parentNode.insertBefore(Mn, A.parentNode);
      }), wt.remove(Hn);
    }, be = wt.select('span[data-mce-type="bookmark"]', S), $t = vt(b, A), yn = wt.createRng();
    yn.setStartAfter(A), yn.setEndAfter(S);
    const On = yn.extractContents();
    for (let Hn = On.firstChild; Hn; Hn = Hn.firstChild)
      if (Hn.nodeName === "LI" && b.dom.isEmpty(Hn)) {
        wt.remove(Hn);
        break;
      }
    b.dom.isEmpty(On) || wt.insertAfter(On, S), wt.insertAfter($t, S), jn(b.dom, A.parentNode) && te(A.parentNode), wt.remove(A), jn(b.dom, S) && wt.remove(S);
  }, Lt = En("dd"), un = En("dt"), Xn = (b, S) => {
    Lt(S) ? qo(S, "dt") : un(S) && Eo(S).each((A) => It(b, A.dom, S.dom));
  }, yo = (b) => {
    un(b) && qo(b, "dd");
  }, Dn = (b, S, A) => {
    S === "Indent" ? Ve(A, yo) : Ve(A, (te) => Xn(b, te));
  }, sr = (b, S) => {
    if (cs(b))
      return {
        container: b,
        offset: S
      };
    const A = ue.getNode(b, S);
    return cs(A) ? {
      container: A,
      offset: S >= b.childNodes.length ? A.data.length : 0
    } : A.previousSibling && cs(A.previousSibling) ? {
      container: A.previousSibling,
      offset: A.previousSibling.data.length
    } : A.nextSibling && cs(A.nextSibling) ? {
      container: A.nextSibling,
      offset: 0
    } : {
      container: b,
      offset: S
    };
  }, bs = (b) => {
    const S = b.cloneRange(), A = sr(b.startContainer, b.startOffset);
    S.setStart(A.container, A.offset);
    const te = sr(b.endContainer, b.endOffset);
    return S.setEnd(te.container, te.offset), S;
  }, Bn = [
    "OL",
    "UL",
    "DL"
  ], to = Bn.join(","), Qo = (b, S) => {
    const A = S || b.selection.getStart(!0);
    return b.dom.getParent(A, to, Cr(b, A));
  }, Jo = (b, S) => b && S.length === 1 && S[0] === b, Ns = (b) => L(b.querySelectorAll(to), Lo), Rs = (b) => {
    const S = Qo(b), A = b.selection.getSelectedBlocks();
    return Jo(S, A) ? Ns(S) : L(A, (te) => Lo(te) && S !== te);
  }, Yr = (b, S) => {
    const A = Io.map(S, (te) => {
      const be = b.dom.getParent(te, "li,dd,dt", Cr(b, te));
      return be || te;
    });
    return kn(A);
  }, js = (b) => {
    const S = b.selection.getSelectedBlocks();
    return L(Yr(b, S), G);
  }, vr = (b) => L(js(b), de), rr = (b, S) => {
    const A = b.dom.getParents(S, "TD,TH");
    return A.length > 0 ? A[0] : b.getBody();
  }, Ra = (b, S) => !Lo(S) && !G(S) && ft(Bn, (A) => b.isValidChild(S.nodeName, A)), Cr = (b, S) => {
    const A = b.dom.getParents(S, b.dom.isBlock);
    return ye(A, (be) => Ra(b.schema, be)).getOr(b.getBody());
  }, $r = (b, S) => {
    const A = b.dom.getParents(S, "ol,ul", Cr(b, S));
    return et(A);
  }, Xr = (b) => {
    const S = $r(b, b.selection.getStart()), A = L(b.selection.getSelectedBlocks(), Ys);
    return S.toArray().concat(A);
  }, Fr = (b) => {
    const S = Xr(b);
    return Xs(b, S);
  }, Xs = (b, S) => {
    const A = Le(S, (te) => $r(b, te).getOr(te));
    return kn(A);
  }, Da = (b, S) => {
    const te = (S || document).createDocumentFragment();
    return Ve(b, (be) => {
      te.appendChild(be.dom);
    }), J.fromDom(te);
  }, ar = (b, S, A) => b.dispatch("ListMutation", {
    action: S,
    element: A
  }), Zr = ((b) => (S) => S.replace(b, ""))(/^\s+|\s+$/g), is = (b) => b.length > 0, R = (b) => !is(b), Q = (b) => b.style !== void 0 && _t(b.style.getPropertyValue), fe = (b, S, A) => {
    if (!Ae(A))
      throw console.error("Invalid call to CSS.set. Property ", S, ":: Value ", A, ":: Element ", b), new Error("CSS value must be a string: " + A);
    Q(b) && b.style.setProperty(S, A);
  }, qe = (b, S, A) => {
    const te = b.dom;
    fe(te, S, A);
  }, bt = (b, S) => {
    Ut(b.item, S.list);
  }, Nn = (b) => {
    for (let S = 1; S < b.length; S++)
      bt(b[S - 1], b[S]);
  }, bo = (b, S) => {
    en(et(b), yt(S), bt);
  }, Vo = (b, S) => {
    const A = {
      list: J.fromTag(S, b),
      item: J.fromTag("li", b)
    };
    return Ut(A.list, A.item), A;
  }, po = (b, S, A) => {
    const te = [];
    for (let be = 0; be < A; be++)
      te.push(Vo(b, S.listType));
    return te;
  }, ms = (b, S) => {
    for (let A = 0; A < b.length - 1; A++)
      qe(b[A].item, "list-style-type", "none");
    et(b).each((A) => {
      rs(A.list, S.listAttributes), rs(A.item, S.itemAttributes), Pn(A.item, S.content);
    });
  }, ks = (b, S) => {
    Ue(b.list) !== S.listType && (b.list = qo(b.list, S.listType)), rs(b.list, S.listAttributes);
  }, xr = (b, S, A) => {
    const te = J.fromTag("li", b);
    return rs(te, S), Pn(te, A), te;
  }, Ro = (b, S) => {
    Ut(b.list, S), b.item = S;
  }, Oa = (b, S, A) => {
    const te = S.slice(0, A.depth);
    return et(te).each((be) => {
      const $t = xr(b, A.itemAttributes, A.content);
      Ro(be, $t), ks(be, A);
    }), te;
  }, ya = (b, S, A) => {
    const te = po(b, A, A.depth - S.length);
    return Nn(te), ms(te, A), bo(S, te), S.concat(te);
  }, cr = (b, S) => {
    const A = Je(S, (te, be) => be.depth > te.length ? ya(b, te, be) : Oa(b, te, be), []);
    return yt(A).map((te) => te.list);
  }, ps = (b) => W(b, "OL,UL"), hr = (b) => Xt(b).exists(ps), Er = (b) => ro(b).exists(ps), Gn = (b) => b.depth > 0, Ds = (b) => b.isSelected, Pa = (b) => {
    const S = Yn(b), A = Er(b) ? S.slice(0, -1) : S;
    return Le(A, Vn);
  }, Qr = (b, S, A) => Eo(b).filter(pn).map((te) => ({
    depth: S,
    dirty: !1,
    isSelected: A,
    content: Pa(b),
    itemAttributes: wo(b),
    listAttributes: wo(te),
    listType: Ue(te)
  })), x = (b, S) => {
    switch (b) {
      case "Indent":
        S.depth++;
        break;
      case "Outdent":
        S.depth--;
        break;
      case "Flatten":
        S.depth = 0;
    }
    S.dirty = !0;
  }, B = (b, S) => {
    b.listType = S.listType, b.listAttributes = { ...S.listAttributes };
  }, K = (b) => {
    b.listAttributes = zs(b.listAttributes, (S, A) => A !== "start");
  }, Re = (b, S) => {
    const A = b[S].depth, te = ($t) => $t.depth === A && !$t.dirty, be = ($t) => $t.depth < A;
    return jt(Z(b.slice(0, S)), te, be).orThunk(() => jt(b.slice(S + 1), te, be));
  }, Gt = (b) => (Ve(b, (S, A) => {
    Re(b, A).fold(() => {
      S.dirty && K(S);
    }, (te) => B(S, te));
  }), b), Un = (b) => {
    let S = b;
    return {
      get: () => S,
      set: (be) => {
        S = be;
      }
    };
  }, Zn = (b, S, A, te) => Xt(te).filter(ps).fold(() => {
    S.each((yn) => {
      ce(yn.start, te) && A.set(!0);
    });
    const be = Qr(te, b, A.get());
    S.each((yn) => {
      ce(yn.end, te) && A.set(!1);
    });
    const $t = ro(te).filter(ps).map((yn) => nt(b, S, A, yn)).getOr([]);
    return be.toArray().concat($t);
  }, (be) => nt(b, S, A, be)), nt = (b, S, A, te) => qt(Yn(te), (be) => {
    const $t = ps(be) ? nt : Zn, yn = b + 1;
    return $t(yn, S, A, be);
  }), Xo = (b, S) => {
    const A = Un(!1), te = 0;
    return Le(b, (be) => ({
      sourceList: be,
      entries: nt(te, S, A, be)
    }));
  }, Tr = (b, S) => {
    const A = Gt(S);
    return Le(A, (te) => {
      const be = Da(te.content);
      return J.fromDom(vt(b, be.dom));
    });
  }, zo = (b, S) => {
    const A = Gt(S);
    return cr(b.contentDocument, A).toArray();
  }, zr = (b, S) => qt(Wt(S, Gn), (A) => yt(A).exists(Gn) ? zo(b, A) : Tr(b, A)), gs = (b, S) => {
    Ve(L(b, Ds), (A) => x(S, A));
  }, $ = (b) => {
    const S = Le(js(b), J.fromDom);
    return en(ye(S, rt(hr)), ye(Z(S), rt(hr)), (A, te) => ({
      start: A,
      end: te
    }));
  }, V = (b, S, A) => {
    const te = Xo(S, $(b));
    Ve(te, (be) => {
      gs(be.entries, A);
      const $t = zr(b, be.entries);
      Ve($t, (yn) => {
        ar(b, A === "Indent" ? "IndentList" : "OutdentList", yn.dom);
      }), Tn(be.sourceList, $t), Bo(be.sourceList);
    });
  }, Te = (b, S) => {
    const A = Le(Fr(b), J.fromDom), te = Le(vr(b), J.fromDom);
    let be = !1;
    if (A.length || te.length) {
      const $t = b.selection.getBookmark();
      V(b, A, S), Dn(b, S, te), b.selection.moveToBookmark($t), b.selection.setRng(bs(b.selection.getRng())), b.nodeChanged(), be = !0;
    }
    return be;
  }, He = (b) => Te(b, "Indent"), Zt = (b) => Te(b, "Outdent"), tn = (b) => Te(b, "Flatten");
  var vo = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const jo = lo.DOM, Zs = (b) => {
    const S = {}, A = (te) => {
      let be = b[te ? "startContainer" : "endContainer"], $t = b[te ? "startOffset" : "endOffset"];
      if (be.nodeType === 1) {
        const yn = jo.create("span", { "data-mce-type": "bookmark" });
        be.hasChildNodes() ? ($t = Math.min($t, be.childNodes.length - 1), te ? be.insertBefore(yn, be.childNodes[$t]) : jo.insertAfter(yn, be.childNodes[$t])) : be.appendChild(yn), be = yn, $t = 0;
      }
      S[te ? "startContainer" : "endContainer"] = be, S[te ? "startOffset" : "endOffset"] = $t;
    };
    return A(!0), b.collapsed || A(), S;
  }, qn = (b) => {
    const S = (te) => {
      let be;
      const $t = (Hn) => {
        let Mn = Hn.parentNode.firstChild, ts = 0;
        for (; Mn; ) {
          if (Mn === Hn)
            return ts;
          (Mn.nodeType !== 1 || Mn.getAttribute("data-mce-type") !== "bookmark") && ts++, Mn = Mn.nextSibling;
        }
        return -1;
      };
      let yn = be = b[te ? "startContainer" : "endContainer"], On = b[te ? "startOffset" : "endOffset"];
      !yn || (yn.nodeType === 1 && (On = $t(yn), yn = yn.parentNode, jo.remove(be), !yn.hasChildNodes() && jo.isBlock(yn) && yn.appendChild(jo.create("br"))), b[te ? "startContainer" : "endContainer"] = yn, b[te ? "startOffset" : "endOffset"] = On);
    };
    S(!0), S();
    const A = jo.createRng();
    return A.setStart(b.startContainer, b.startOffset), b.endContainer && A.setEnd(b.endContainer, b.endOffset), bs(A);
  }, ko = (b) => {
    switch (b) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, Qs = (b) => /\btox\-/.test(b.className), Js = (b, S, A) => {
    const te = ($t) => {
      const yn = jt($t.parents, Lo, dt).filter((On) => On.nodeName === S && !Qs(On)).isSome();
      A(yn);
    }, be = b.dom.getParents(b.selection.getNode());
    return te({ parents: be }), b.on("NodeChange", te), () => b.off("NodeChange", te);
  }, Ya = (b, S, A) => {
    const te = A["list-style-type"] ? A["list-style-type"] : null;
    b.setStyle(S, "list-style-type", te);
  }, ir = (b, S) => {
    Io.each(S, (A, te) => {
      b.setAttribute(te, A);
    });
  }, ao = (b, S, A) => {
    ir(S, A["list-attributes"]), Io.each(b.select("li", S), (te) => {
      ir(te, A["list-item-attributes"]);
    });
  }, es = (b, S, A) => {
    Ya(b, S, A), ao(b, S, A);
  }, Os = (b, S, A) => {
    Io.each(A, (te) => b.setStyle(S, te, ""));
  }, Jr = (b, S, A, te) => {
    let be = S[A ? "startContainer" : "endContainer"];
    const $t = S[A ? "startOffset" : "endOffset"];
    for (be.nodeType === 1 && (be = be.childNodes[Math.min($t, be.childNodes.length - 1)] || be), !A && rn(be.nextSibling) && (be = be.nextSibling); be.parentNode !== te; ) {
      if (An(b, be) || /^(TD|TH)$/.test(be.parentNode.nodeName))
        return be;
      be = be.parentNode;
    }
    return be;
  }, Ba = (b, S, A) => {
    const te = [], be = b.dom, $t = Jr(b, S, !0, A), yn = Jr(b, S, !1, A);
    let On;
    const Hn = [];
    for (let Mn = $t; Mn && (Hn.push(Mn), Mn !== yn); Mn = Mn.nextSibling)
      ;
    return Io.each(Hn, (Mn) => {
      if (An(b, Mn)) {
        te.push(Mn), On = null;
        return;
      }
      if (be.isBlock(Mn) || rn(Mn)) {
        rn(Mn) && be.remove(Mn), On = null;
        return;
      }
      const ts = Mn.nextSibling;
      if (vo.isBookmarkNode(Mn) && (Lo(ts) || An(b, ts) || !ts && Mn.parentNode === A)) {
        On = null;
        return;
      }
      On || (On = be.create("p"), Mn.parentNode.insertBefore(On, Mn), te.push(On)), On.appendChild(Mn);
    }), te;
  }, as = (b, S, A) => {
    const te = b.getStyle(S, "list-style-type");
    let be = A ? A["list-style-type"] : "";
    return be = be === null ? "" : be, te === be;
  }, ba = (b, S, A) => {
    const te = b.selection.getRng();
    let be = "LI";
    const $t = Cr(b, b.selection.getStart(!0)), yn = b.dom;
    if (yn.getContentEditable(b.selection.getNode()) === "false")
      return;
    S = S.toUpperCase(), S === "DL" && (be = "DT");
    const On = Zs(te), Hn = Ba(b, te, $t);
    Io.each(Hn, (Mn) => {
      let ts;
      const Ir = Mn.previousSibling, Hs = Mn.parentNode;
      G(Hs) || (Ir && Lo(Ir) && Ir.nodeName === S && as(yn, Ir, A) ? (ts = Ir, Mn = yn.rename(Mn, be), Ir.appendChild(Mn)) : (ts = yn.create(S), Mn.parentNode.insertBefore(ts, Mn), ts.appendChild(Mn), Mn = yn.rename(Mn, be)), Os(yn, Mn, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), es(yn, ts, A), na(b.dom, ts));
    }), b.selection.setRng(qn(On));
  }, ea = (b, S) => b && S && Lo(b) && b.nodeName === S.nodeName, rc = (b, S, A) => {
    const te = b.getStyle(S, "list-style-type", !0), be = b.getStyle(A, "list-style-type", !0);
    return te === be;
  }, Ki = (b, S) => b.className === S.className, ta = (b, S, A) => ea(S, A) && rc(b, S, A) && Ki(S, A), na = (b, S) => {
    let A, te;
    if (A = S.nextSibling, ta(b, S, A)) {
      for (; te = A.firstChild; )
        S.appendChild(te);
      b.remove(A);
    }
    if (A = S.previousSibling, ta(b, S, A)) {
      for (; te = A.lastChild; )
        S.insertBefore(te, S.firstChild);
      b.remove(A);
    }
  }, Xa = (b, S, A, te) => {
    if (S.nodeName !== A) {
      const be = b.dom.rename(S, A);
      es(b.dom, be, te), ar(b, ko(A), be);
    } else
      es(b.dom, S, te), ar(b, ko(A), S);
  }, ac = (b, S, A, te, be) => {
    const $t = Lo(S);
    if ($t && S.nodeName === te && !Us(be))
      tn(b);
    else {
      ba(b, te, be);
      const yn = Zs(b.selection.getRng()), On = $t ? [
        S,
        ...A
      ] : A;
      Io.each(On, (Hn) => {
        Xa(b, Hn, te, be);
      }), b.selection.setRng(qn(yn));
    }
  }, Us = (b) => "list-style-type" in b, Yi = (b, S, A, te) => {
    if (S !== b.getBody())
      if (S)
        if (S.nodeName === A && !Us(te) && !Qs(S))
          tn(b);
        else {
          const be = Zs(b.selection.getRng());
          es(b.dom, S, te);
          const $t = b.dom.rename(S, A);
          na(b.dom, $t), b.selection.setRng(qn(be)), ba(b, A, te), ar(b, ko(A), $t);
        }
      else
        ba(b, A, te), ar(b, ko(A), S);
  }, ka = (b, S, A) => {
    const te = Qo(b), be = Rs(b), $t = We(A) ? A : {};
    be.length > 0 ? ac(b, te, be, S, $t) : Yi(b, te, S, $t);
  }, Sc = lo.DOM, xc = (b, S) => {
    const A = S.parentNode;
    if (A.nodeName === "LI" && A.firstChild === S) {
      const te = A.previousSibling;
      te && te.nodeName === "LI" ? (te.appendChild(S), jn(b, A) && Sc.remove(A)) : Sc.setStyle(A, "listStyleType", "none");
    }
    if (Lo(A)) {
      const te = A.previousSibling;
      te && te.nodeName === "LI" && te.appendChild(S);
    }
  }, ui = (b, S) => {
    const A = Io.grep(b.select("ol,ul", S));
    Io.each(A, (te) => {
      xc(b, te);
    });
  }, Ec = (b, S, A, te) => {
    let be = S.startContainer;
    const $t = S.startOffset;
    if (cs(be) && (A ? $t < be.data.length : $t > 0))
      return be;
    const yn = b.schema.getNonEmptyElements();
    be.nodeType === 1 && (be = ue.getNode(be, $t));
    const On = new ze(be, te);
    A && ln(b.dom, be) && On.next();
    const Hn = A ? On.next.bind(On) : On.prev2.bind(On);
    for (; be = Hn(); )
      if (be.nodeName === "LI" && !be.hasChildNodes() || yn[be.nodeName] || cs(be) && be.data.length > 0)
        return be;
  }, oa = (b, S) => {
    const A = S.childNodes;
    return A.length === 1 && !Lo(A[0]) && b.isBlock(A[0]);
  }, tf = (b, S) => {
    oa(b, S) && b.remove(S.firstChild, !0);
  }, Tc = (b, S, A) => {
    let te;
    const be = oa(b, A) ? A.firstChild : A;
    if (tf(b, S), !jn(b, S, !0))
      for (; te = S.firstChild; )
        be.appendChild(te);
  }, Xi = (b, S, A) => {
    let te;
    const be = S.parentNode;
    if (!Mo(b, S) || !Mo(b, A))
      return;
    Lo(A.lastChild) && (te = A.lastChild), be === A.lastChild && rn(be.previousSibling) && b.remove(be.previousSibling);
    const $t = A.lastChild;
    $t && rn($t) && S.hasChildNodes() && b.remove($t), jn(b, A, !0) && ho(J.fromDom(A)), Tc(b, S, A), te && A.appendChild(te);
    const On = Ce(J.fromDom(A), J.fromDom(S)) ? b.getParents(S, Lo, A) : [];
    b.remove(S), Ve(On, (Hn) => {
      jn(b, Hn) && Hn !== b.getRoot() && b.remove(Hn);
    });
  }, lr = (b, S, A) => {
    ho(J.fromDom(A)), Xi(b.dom, S, A), b.selection.setCursorLocation(A, 0);
  }, Zi = (b, S, A, te) => {
    const be = b.dom;
    if (be.isEmpty(te))
      lr(b, A, te);
    else {
      const $t = Zs(S);
      Xi(be, A, te), b.selection.setRng(qn($t));
    }
  }, ne = (b, S, A, te) => {
    const be = Zs(S);
    Xi(b.dom, A, te);
    const $t = qn(be);
    b.selection.setRng($t);
  }, cc = (b, S) => {
    const A = b.dom, te = b.selection, be = te.getStart(), $t = rr(b, be), yn = A.getParent(te.getStart(), "LI", $t);
    if (yn) {
      const On = yn.parentNode;
      if (On === b.getBody() && jn(A, On))
        return !0;
      const Hn = bs(te.getRng()), Mn = A.getParent(Ec(b, Hn, S, $t), "LI", $t);
      if (Mn && Mn !== yn)
        return b.undoManager.transact(() => {
          S ? Zi(b, Hn, Mn, yn) : Et(yn) ? Zt(b) : ne(b, Hn, yn, Mn);
        }), !0;
      if (!Mn && !S && Hn.startOffset === 0 && Hn.endOffset === 0)
        return b.undoManager.transact(() => {
          tn(b);
        }), !0;
    }
    return !1;
  }, sa = (b, S, A) => {
    const te = b.getParent(S.parentNode, b.isBlock, A);
    b.remove(S), te && b.isEmpty(te) && b.remove(te);
  }, Qi = (b, S) => {
    const A = b.dom, te = b.selection.getStart(), be = rr(b, te), $t = A.getParent(te, A.isBlock, be);
    if ($t && A.isEmpty($t)) {
      const yn = bs(b.selection.getRng()), On = A.getParent(Ec(b, yn, S, be), "LI", be);
      if (On) {
        const Hn = (Hs) => it([
          "td",
          "th",
          "caption"
        ], Ue(Hs)), Mn = (Hs) => Hs.dom === be, ts = Fe(J.fromDom(On), Hn, Mn), Ir = Fe(J.fromDom(yn.startContainer), Hn, Mn);
        return an(ts, Ir, ce) ? (b.undoManager.transact(() => {
          sa(A, $t, be), na(A, On.parentNode), b.selection.select(On, !0), b.selection.collapse(S);
        }), !0) : !1;
      }
    }
    return !1;
  }, nf = (b, S) => cc(b, S) || Qi(b, S), ql = (b) => {
    const S = b.selection.getStart(), A = rr(b, S);
    return b.dom.getParent(S, "LI,DT,DD", A) || js(b).length > 0;
  }, _o = (b) => ql(b) ? (b.undoManager.transact(() => {
    b.execCommand("Delete"), ui(b.dom, b.getBody());
  }), !0) : !1, ws = (b, S) => b.selection.isCollapsed() ? nf(b, S) : _o(b), fi = (b) => {
    b.on("ExecCommand", (S) => {
      const A = S.command.toLowerCase();
      (A === "delete" || A === "forwarddelete") && ql(b) && ui(b.dom, b.getBody());
    }), b.on("keydown", (S) => {
      S.keyCode === At.BACKSPACE ? ws(b, !1) && S.preventDefault() : S.keyCode === At.DELETE && ws(b, !0) && S.preventDefault();
    });
  }, wa = (b) => ({
    backspaceDelete: (S) => {
      ws(b, S);
    }
  }), Vl = (b, S) => {
    const A = Qo(b);
    b.undoManager.transact(() => {
      We(S.styles) && b.dom.setStyles(A, S.styles), We(S.attrs) && hn(S.attrs, (te, be) => b.dom.setAttrib(A, be, te));
    });
  }, $a = (b) => {
    const S = Z(Zr(b).split("")), A = Le(S, (te, be) => {
      const $t = te.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
      return Math.pow(26, be) * $t;
    });
    return Je(A, (te, be) => te + be, 0);
  }, er = (b) => {
    if (b--, b < 0)
      return "";
    {
      const S = b % 26, A = Math.floor(b / 26), te = er(A), be = String.fromCharCode("A".charCodeAt(0) + S);
      return te + be;
    }
  }, Ji = (b) => /^[A-Z]+$/.test(b), Gl = (b) => /^[a-z]+$/.test(b), el = (b) => /^[0-9]+$/.test(b), Fa = (b) => el(b) ? 2 : Ji(b) ? 0 : Gl(b) ? 1 : R(b) ? 3 : 4, di = (b) => {
    switch (Fa(b)) {
      case 2:
        return ke.some({
          listStyleType: ke.none(),
          start: b
        });
      case 0:
        return ke.some({
          listStyleType: ke.some("upper-alpha"),
          start: $a(b).toString()
        });
      case 1:
        return ke.some({
          listStyleType: ke.some("lower-alpha"),
          start: $a(b).toString()
        });
      case 3:
        return ke.some({
          listStyleType: ke.none(),
          start: ""
        });
      case 4:
        return ke.none();
    }
  }, mi = (b) => {
    const S = parseInt(b.start, 10);
    return Rn(b.listStyleType, "upper-alpha") ? er(S) : Rn(b.listStyleType, "lower-alpha") ? er(S).toLowerCase() : b.start;
  }, tl = (b) => {
    const S = Qo(b);
    !O(S) || b.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: mi({
          start: b.dom.getAttrib(S, "start", "1"),
          listStyleType: ke.some(b.dom.getStyle(S, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (A) => {
        const te = A.getData();
        di(te.start).each((be) => {
          b.execCommand("mceListUpdate", !1, {
            attrs: { start: be.start === "1" ? "" : be.start },
            styles: { "list-style-type": be.listStyleType.getOr("") }
          });
        }), A.close();
      }
    });
  }, fs = (b, S) => () => {
    const A = Qo(b);
    return A && A.nodeName === S;
  }, ic = (b) => {
    b.addCommand("mceListProps", () => {
      tl(b);
    });
  }, nl = (b) => {
    b.on("BeforeExecCommand", (S) => {
      const A = S.command.toLowerCase();
      A === "indent" ? He(b) : A === "outdent" && Zt(b);
    }), b.addCommand("InsertUnorderedList", (S, A) => {
      ka(b, "UL", A);
    }), b.addCommand("InsertOrderedList", (S, A) => {
      ka(b, "OL", A);
    }), b.addCommand("InsertDefinitionList", (S, A) => {
      ka(b, "DL", A);
    }), b.addCommand("RemoveList", () => {
      tn(b);
    }), ic(b), b.addCommand("mceListUpdate", (S, A) => {
      We(A) && Vl(b, A);
    }), b.addQueryStateHandler("InsertUnorderedList", fs(b, "UL")), b.addQueryStateHandler("InsertOrderedList", fs(b, "OL")), b.addQueryStateHandler("InsertDefinitionList", fs(b, "DL"));
  }, pi = (b) => {
    b.on("keydown", (S) => {
      S.keyCode !== At.TAB || At.metaKeyPressed(S) || b.undoManager.transact(() => {
        (S.shiftKey ? Zt(b) : He(b)) && S.preventDefault();
      });
    });
  }, ol = (b) => {
    ee(b) && pi(b), fi(b);
  }, Kl = (b) => {
    const S = (A) => () => b.execCommand(A);
    b.hasPlugin("advlist") || (b.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: S("InsertOrderedList"),
      onSetup: (A) => Js(b, "OL", A.setActive)
    }), b.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: S("InsertUnorderedList"),
      onSetup: (A) => Js(b, "UL", A.setActive)
    }));
  }, sl = (b) => {
    const S = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => b.execCommand("mceListProps"),
      onSetup: (A) => Js(b, "OL", A.setEnabled)
    };
    b.ui.registry.addMenuItem("listprops", S), b.ui.registry.addContextMenu("lists", {
      update: (A) => {
        const te = Qo(b, A);
        return O(te) ? ["listprops"] : [];
      }
    });
  };
  var rl = () => {
    g.add("lists", (b) => (q(b), b.hasPlugin("rtc", !0) === !1 ? (ol(b), nl(b)) : ic(b), Kl(b), sl(b), wa(b)));
  };
  rl();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = ((ce) => (Ce) => ce === Ce)(null), X = (ce) => ce, _e = "\uFEFF", Ae = (ce) => ce.replace(/\uFEFF/g, ""), We = (ce, Ce) => {
    const W = ce.length, M = new Array(W);
    for (let Ue = 0; Ue < W; Ue++) {
      const kt = ce[Ue];
      M[Ue] = Ce(kt, Ue);
    }
    return M;
  }, Ee = {
    aletter: "[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F3\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u303B\u303C\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790\uA791\uA7A0-\uA7A9\uA7FA-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]",
    midnumlet: "[-'\\.\u2018\u2019\u2024\uFE52\uFF07\uFF0E]",
    midletter: "[:\xB7\xB7\u05F4\u2027\uFE13\uFE55\uFF1A]",
    midnum: "[\xB1+*/,;;\u0589\u060C\u060D\u066C\u07F8\u2044\uFE10\uFE14\uFE50\uFE54\uFF0C\uFF1B]",
    numeric: "[0-9\u0660-\u0669\u066B\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9]",
    cr: "\\r",
    lf: "\\n",
    newline: "[\v\f\x85\u2028\u2029]",
    extend: "[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B6-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAA\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2\u1DC0-\u1DE6\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\uFF9E\uFF9F]",
    format: "[\xAD\u0600-\u0603\u06DD\u070F\u17B4\u17B5\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB]",
    katakana: "[\u3031-\u3035\u309B\u309C\u30A0-\u30FA\u30FC-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF9D]",
    extendnumlet: "[=_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F\u2200-\u22FF<>]",
    punctuation: "[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]"
  }, Ie = {
    ALETTER: 0,
    MIDNUMLET: 1,
    MIDLETTER: 2,
    MIDNUM: 3,
    NUMERIC: 4,
    CR: 5,
    LF: 6,
    NEWLINE: 7,
    EXTEND: 8,
    FORMAT: 9,
    KATAKANA: 10,
    EXTENDNUMLET: 11,
    AT: 12,
    OTHER: 13
  }, pt = [
    new RegExp(Ee.aletter),
    new RegExp(Ee.midnumlet),
    new RegExp(Ee.midletter),
    new RegExp(Ee.midnum),
    new RegExp(Ee.numeric),
    new RegExp(Ee.cr),
    new RegExp(Ee.lf),
    new RegExp(Ee.newline),
    new RegExp(Ee.extend),
    new RegExp(Ee.format),
    new RegExp(Ee.katakana),
    new RegExp(Ee.extendnumlet),
    new RegExp("@")
  ], _t = "", $e = new RegExp("^" + Ee.punctuation + "$"), Ne = /^\s+$/, tt = pt, xe = Ie.OTHER, rt = (ce) => {
    let Ce = xe;
    const W = tt.length;
    for (let M = 0; M < W; ++M) {
      const Ue = tt[M];
      if (Ue && Ue.test(ce)) {
        Ce = M;
        break;
      }
    }
    return Ce;
  }, ae = (ce) => {
    const Ce = {};
    return (W) => {
      if (Ce[W])
        return Ce[W];
      {
        const M = ce(W);
        return Ce[W] = M, M;
      }
    };
  }, ke = (ce) => {
    const Ce = ae(rt);
    return We(ce, Ce);
  }, ge = (ce, Ce) => {
    const W = ce[Ce], M = ce[Ce + 1];
    if (Ce < 0 || Ce > ce.length - 1 && Ce !== 0 || W === Ie.ALETTER && M === Ie.ALETTER)
      return !1;
    const Ue = ce[Ce + 2];
    if (W === Ie.ALETTER && (M === Ie.MIDLETTER || M === Ie.MIDNUMLET || M === Ie.AT) && Ue === Ie.ALETTER)
      return !1;
    const kt = ce[Ce - 1];
    return (W === Ie.MIDLETTER || W === Ie.MIDNUMLET || M === Ie.AT) && M === Ie.ALETTER && kt === Ie.ALETTER || (W === Ie.NUMERIC || W === Ie.ALETTER) && (M === Ie.NUMERIC || M === Ie.ALETTER) || (W === Ie.MIDNUM || W === Ie.MIDNUMLET) && M === Ie.NUMERIC && kt === Ie.NUMERIC || W === Ie.NUMERIC && (M === Ie.MIDNUM || M === Ie.MIDNUMLET) && Ue === Ie.NUMERIC || W === Ie.EXTEND || W === Ie.FORMAT || kt === Ie.EXTEND || kt === Ie.FORMAT || M === Ie.EXTEND || M === Ie.FORMAT || W === Ie.CR && M === Ie.LF ? !1 : W === Ie.NEWLINE || W === Ie.CR || W === Ie.LF || M === Ie.NEWLINE || M === Ie.CR || M === Ie.LF ? !0 : !(W === Ie.KATAKANA && M === Ie.KATAKANA || M === Ie.EXTENDNUMLET && (W === Ie.ALETTER || W === Ie.NUMERIC || W === Ie.KATAKANA || W === Ie.EXTENDNUMLET) || W === Ie.EXTENDNUMLET && (M === Ie.ALETTER || M === Ie.NUMERIC || M === Ie.KATAKANA) || W === Ie.AT);
  }, zt = _t, ot = Ne, le = $e, it = (ce) => ce === "http" || ce === "https", ft = (ce, Ce) => {
    let W;
    for (W = Ce; W < ce.length && !ot.test(ce[W]); W++)
      ;
    return W;
  }, Le = (ce, Ce) => {
    const W = ft(ce, Ce + 1);
    return ce.slice(Ce + 1, W).join(zt).substr(0, 3) === "://" ? W : Ce;
  }, Ve = (ce, Ce, W, M) => {
    const Ue = [];
    let kt = [];
    for (let Qe = 0; Qe < W.length; ++Qe)
      if (kt.push(ce[Qe]), ge(W, Qe)) {
        const pn = Ce[Qe];
        if ((M.includeWhitespace || !ot.test(pn)) && (M.includePunctuation || !le.test(pn))) {
          const En = Qe - kt.length + 1, Eo = Qe + 1, oo = Ce.slice(En, Eo).join(zt);
          if (it(oo)) {
            const Yn = Le(Ce, Qe), eo = ce.slice(Eo, Yn);
            Array.prototype.push.apply(kt, eo), Qe = Yn;
          }
          Ue.push(kt);
        }
        kt = [];
      }
    return Ue;
  }, L = () => ({
    includeWhitespace: !1,
    includePunctuation: !1
  }), Je = (ce, Ce, W) => {
    W = {
      ...L(),
      ...W
    };
    const M = [], Ue = [];
    for (let Qe = 0; Qe < ce.length; Qe++) {
      const pn = Ce(ce[Qe]);
      pn !== _e && (M.push(ce[Qe]), Ue.push(pn));
    }
    const kt = ke(Ue);
    return Ve(M, Ue, kt, W);
  };
  var jt = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const ye = (ce, Ce) => {
    const W = Ce.getBlockElements(), M = Ce.getVoidElements(), Ue = (En) => W[En.nodeName] || M[En.nodeName], kt = [];
    let Qe = "";
    const pn = new jt(ce, ce);
    for (; ce = pn.next(); )
      ce.nodeType === 3 ? Qe += Ae(ce.data) : Ue(ce) && Qe.length && (kt.push(Qe), Qe = "");
    return Qe.length && kt.push(Qe), kt;
  }, Ze = (ce) => ce.replace(/\u200B/g, ""), qt = (ce) => ce.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length, Z = (ce, Ce) => {
    const W = Ze(ye(ce, Ce).join(`
`));
    return Je(W.split(""), X).length;
  }, Pe = (ce, Ce) => {
    const W = ye(ce, Ce).join("");
    return qt(W);
  }, yt = (ce, Ce) => {
    const W = ye(ce, Ce).join("").replace(/\s/g, "");
    return qt(W);
  }, et = (ce, Ce) => () => Ce(ce.getBody(), ce.schema), kn = (ce, Ce) => () => Ce(ce.selection.getRng().cloneContents(), ce.schema), Rn = (ce) => et(ce, Z), an = (ce) => ({
    body: {
      getWordCount: Rn(ce),
      getCharacterCount: et(ce, Pe),
      getCharacterCountWithoutSpaces: et(ce, yt)
    },
    selection: {
      getWordCount: kn(ce, Z),
      getCharacterCount: kn(ce, Pe),
      getCharacterCountWithoutSpaces: kn(ce, yt)
    },
    getCount: Rn(ce)
  }), en = (ce, Ce) => {
    ce.windowManager.open({
      title: "Word Count",
      body: {
        type: "panel",
        items: [{
          type: "table",
          header: [
            "Count",
            "Document",
            "Selection"
          ],
          cells: [
            [
              "Words",
              String(Ce.body.getWordCount()),
              String(Ce.selection.getWordCount())
            ],
            [
              "Characters (no spaces)",
              String(Ce.body.getCharacterCountWithoutSpaces()),
              String(Ce.selection.getCharacterCountWithoutSpaces())
            ],
            [
              "Characters",
              String(Ce.body.getCharacterCount()),
              String(Ce.selection.getCharacterCount())
            ]
          ]
        }]
      },
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }]
    });
  }, cn = (ce, Ce) => {
    ce.addCommand("mceWordCount", () => en(ce, Ce));
  }, wn = (ce, Ce) => {
    let W = null;
    return {
      cancel: () => {
        D(W) || (clearTimeout(W), W = null);
      },
      throttle: (...kt) => {
        D(W) && (W = setTimeout(() => {
          W = null, ce.apply(null, kt);
        }, Ce));
      }
    };
  };
  var w = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const ie = (ce, Ce) => {
    ce.dispatch("wordCountUpdate", {
      wordCount: {
        words: Ce.body.getWordCount(),
        characters: Ce.body.getCharacterCount(),
        charactersWithoutSpaces: Ce.body.getCharacterCountWithoutSpaces()
      }
    });
  }, re = (ce, Ce) => {
    ie(ce, Ce);
  }, we = (ce, Ce, W) => {
    const M = wn(() => re(ce, Ce), W);
    ce.on("init", () => {
      re(ce, Ce), w.setEditorTimeout(ce, () => {
        ce.on("SetContent BeforeAddUndo Undo Redo ViewUpdate keyup", M.throttle);
      }, 0), ce.on("remove", M.cancel);
    });
  }, J = (ce) => {
    const Ce = () => ce.execCommand("mceWordCount");
    ce.ui.registry.addButton("wordcount", {
      tooltip: "Word count",
      icon: "character-count",
      onAction: Ce
    }), ce.ui.registry.addMenuItem("wordcount", {
      text: "Word count",
      icon: "character-count",
      onAction: Ce
    });
  };
  var me = (ce = 300) => {
    g.add("wordcount", (Ce) => {
      const W = an(Ce);
      return cn(Ce, W), J(Ce), we(Ce, W, ce), W;
    });
  };
  me();
})();
(function() {
  const g = (w) => {
    let ie = w;
    return {
      get: () => ie,
      set: (J) => {
        ie = J;
      }
    };
  };
  var _ = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = (w) => ({ addTab: (re) => {
    const we = w.get();
    we[re.name] = re, w.set(we);
  } }), X = (w, ie) => {
    w.addCommand("mceHelp", ie);
  }, _e = (w) => (ie) => ie.options.get(w), Ae = (w) => {
    const ie = w.options.register;
    ie("help_tabs", { processor: "array" });
  }, We = _e("help_tabs"), Ke = _e("forced_plugins"), Ee = (w, ie) => {
    w.ui.registry.addButton("help", {
      icon: "help",
      tooltip: "Help",
      onAction: ie
    }), w.ui.registry.addMenuItem("help", {
      text: "Help",
      icon: "help",
      shortcut: "Alt+0",
      onAction: ie
    });
  }, pt = ((w) => (ie) => w === ie)(void 0), _t = (w) => w == null, $e = (w) => !_t(w), tt = ((w) => () => w)(!1);
  class xe {
    constructor(ie, re) {
      this.tag = ie, this.value = re;
    }
    static some(ie) {
      return new xe(!0, ie);
    }
    static none() {
      return xe.singletonNone;
    }
    fold(ie, re) {
      return this.tag ? re(this.value) : ie();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ie) {
      return this.tag ? xe.some(ie(this.value)) : xe.none();
    }
    bind(ie) {
      return this.tag ? ie(this.value) : xe.none();
    }
    exists(ie) {
      return this.tag && ie(this.value);
    }
    forall(ie) {
      return !this.tag || ie(this.value);
    }
    filter(ie) {
      return !this.tag || ie(this.value) ? this : xe.none();
    }
    getOr(ie) {
      return this.tag ? this.value : ie;
    }
    or(ie) {
      return this.tag ? this : ie;
    }
    getOrThunk(ie) {
      return this.tag ? this.value : ie();
    }
    orThunk(ie) {
      return this.tag ? this : ie();
    }
    getOrDie(ie) {
      if (this.tag)
        return this.value;
      throw new Error(ie != null ? ie : "Called getOrDie on None");
    }
    static from(ie) {
      return $e(ie) ? xe.some(ie) : xe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ie) {
      this.tag && ie(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  xe.singletonNone = new xe(!1);
  const rt = Array.prototype.indexOf, ae = (w, ie) => rt.call(w, ie), ke = (w, ie) => ae(w, ie) > -1, ge = (w, ie) => {
    const re = w.length, we = new Array(re);
    for (let J = 0; J < re; J++) {
      const me = w[J];
      we[J] = ie(me, J);
    }
    return we;
  }, zt = (w, ie) => {
    const re = [];
    for (let we = 0, J = w.length; we < J; we++) {
      const me = w[we];
      ie(me, we) && re.push(me);
    }
    return re;
  }, ot = (w, ie, re) => {
    for (let we = 0, J = w.length; we < J; we++) {
      const me = w[we];
      if (ie(me, we))
        return xe.some(me);
      if (re(me, we))
        break;
    }
    return xe.none();
  }, le = (w, ie) => ot(w, ie, tt), it = Object.keys, ft = Object.hasOwnProperty, Le = (w, ie) => Ve(w, ie) ? xe.from(w[ie]) : xe.none(), Ve = (w, ie) => ft.call(w, ie), L = (w) => {
    const ie = [], re = (we) => {
      ie.push(we);
    };
    for (let we = 0; we < w.length; we++)
      w[we].each(re);
    return ie;
  }, Wt = `<h1>Editor UI keyboard navigation</h1>

<h2>Activating keyboard navigation</h2>

<p>The sections of the outer UI of the editor - the menubar, toolbar, sidebar and footer - are all keyboard navigable. As such, there are multiple ways to activate keyboard navigation:</p>
<ul>
  <li>Focus the menubar: Alt + F9 (Windows) or &#x2325;F9 (MacOS)</li>
  <li>Focus the toolbar: Alt + F10 (Windows) or &#x2325;F10 (MacOS)</li>
  <li>Focus the footer: Alt + F11 (Windows) or &#x2325;F11 (MacOS)</li>
</ul>

<p>Focusing the menubar or toolbar will start keyboard navigation at the first item in the menubar or toolbar, which will be highlighted with a gray background. Focusing the footer will start keyboard navigation at the first item in the element path, which will be highlighted with an underline. </p>

<h2>Moving between UI sections</h2>

<p>When keyboard navigation is active, pressing tab will move the focus to the next major section of the UI, where applicable. These sections are:</p>
<ul>
  <li>the menubar</li>
  <li>each group of the toolbar </li>
  <li>the sidebar</li>
  <li>the element path in the footer </li>
  <li>the wordcount toggle button in the footer </li>
  <li>the branding link in the footer </li>
  <li>the editor resize handle in the footer</li>
</ul>

<p>Pressing shift + tab will move backwards through the same sections, except when moving from the footer to the toolbar. Focusing the element path then pressing shift + tab will move focus to the first toolbar group, not the last.</p>

<h2>Moving within UI sections</h2>

<p>Keyboard navigation within UI sections can usually be achieved using the left and right arrow keys. This includes:</p>
<ul>
  <li>moving between menus in the menubar</li>
  <li>moving between buttons in a toolbar group</li>
  <li>moving between items in the element path</li>
</ul>

<p>In all these UI sections, keyboard navigation will cycle within the section. For example, focusing the last button in a toolbar group then pressing right arrow will move focus to the first item in the same toolbar group. </p>

<h1>Executing buttons</h1>

<p>To execute a button, navigate the selection to the desired button and hit space or enter.</p>

<h1>Opening, navigating and closing menus</h1>

<p>When focusing a menubar button or a toolbar button with a menu, pressing space, enter or down arrow will open the menu. When the menu opens the first item will be selected. To move up or down the menu, press the up or down arrow key respectively. This is the same for submenus, which can also be opened and closed using the left and right arrow keys.</p>

<p>To close any active menu, hit the escape key. When a menu is closed the selection will be restored to its previous selection. This also works for closing submenus.</p>

<h1>Context toolbars and menus</h1>

<p>To focus an open context toolbar such as the table context toolbar, press Ctrl + F9 (Windows) or &#x2303;F9 (MacOS).</p>

<p>Context toolbar navigation is the same as toolbar navigation, and context menu navigation is the same as standard menu navigation.</p>

<h1>Dialog navigation</h1>

<p>There are two types of dialog UIs in TinyMCE: tabbed dialogs and non-tabbed dialogs.</p>

<p>When a non-tabbed dialog is opened, the first interactive component in the dialog will be focused. Users can navigate between interactive components by pressing tab. This includes any footer buttons. Navigation will cycle back to the first dialog component if tab is pressed while focusing the last component in the dialog. Pressing shift + tab will navigate backwards.</p>

<p>When a tabbed dialog is opened, the first button in the tab menu is focused. Pressing tab will navigate to the first interactive component in that tab, and will cycle through the tab\u2019s components, the footer buttons, then back to the tab button. To switch to another tab, focus the tab button for the current tab, then use the arrow keys to cycle through the tab buttons.</p>`, Je = () => ({
    name: "keyboardnav",
    title: "Keyboard Navigation",
    items: [{
      type: "htmlpanel",
      presets: "document",
      html: Wt
    }]
  });
  var jt = tinymce.util.Tools.resolve("tinymce.Env");
  const ye = (w) => {
    const ie = jt.os.isMacOS() || jt.os.isiOS(), J = ie ? {
      alt: "&#x2325;",
      ctrl: "&#x2303;",
      shift: "&#x21E7;",
      meta: "&#x2318;",
      access: "&#x2303;&#x2325;"
    } : {
      meta: "Ctrl ",
      access: "Shift + Alt "
    }, me = w.split("+"), ce = ge(me, (Ce) => {
      const W = Ce.toLowerCase().trim();
      return Ve(J, W) ? J[W] : Ce;
    });
    return ie ? ce.join("").replace(/\s/, "") : ce.join("+");
  }, Ze = [
    {
      shortcuts: ["Meta + B"],
      action: "Bold"
    },
    {
      shortcuts: ["Meta + I"],
      action: "Italic"
    },
    {
      shortcuts: ["Meta + U"],
      action: "Underline"
    },
    {
      shortcuts: ["Meta + A"],
      action: "Select all"
    },
    {
      shortcuts: [
        "Meta + Y",
        "Meta + Shift + Z"
      ],
      action: "Redo"
    },
    {
      shortcuts: ["Meta + Z"],
      action: "Undo"
    },
    {
      shortcuts: ["Access + 1"],
      action: "Heading 1"
    },
    {
      shortcuts: ["Access + 2"],
      action: "Heading 2"
    },
    {
      shortcuts: ["Access + 3"],
      action: "Heading 3"
    },
    {
      shortcuts: ["Access + 4"],
      action: "Heading 4"
    },
    {
      shortcuts: ["Access + 5"],
      action: "Heading 5"
    },
    {
      shortcuts: ["Access + 6"],
      action: "Heading 6"
    },
    {
      shortcuts: ["Access + 7"],
      action: "Paragraph"
    },
    {
      shortcuts: ["Access + 8"],
      action: "Div"
    },
    {
      shortcuts: ["Access + 9"],
      action: "Address"
    },
    {
      shortcuts: ["Alt + 0"],
      action: "Open help dialog"
    },
    {
      shortcuts: ["Alt + F9"],
      action: "Focus to menubar"
    },
    {
      shortcuts: ["Alt + F10"],
      action: "Focus to toolbar"
    },
    {
      shortcuts: ["Alt + F11"],
      action: "Focus to element path"
    },
    {
      shortcuts: ["Ctrl + F9"],
      action: "Focus to contextual toolbar"
    },
    {
      shortcuts: ["Shift + Enter"],
      action: "Open popup menu for split buttons"
    },
    {
      shortcuts: ["Meta + K"],
      action: "Insert link (if link plugin activated)"
    },
    {
      shortcuts: ["Meta + S"],
      action: "Save (if save plugin activated)"
    },
    {
      shortcuts: ["Meta + F"],
      action: "Find (if searchreplace plugin activated)"
    },
    {
      shortcuts: ["Meta + Shift + F"],
      action: "Switch to or from fullscreen mode"
    }
  ], qt = () => {
    const w = ge(Ze, (re) => {
      const we = ge(re.shortcuts, ye).join(" or ");
      return [
        re.action,
        we
      ];
    });
    return {
      name: "shortcuts",
      title: "Handy Shortcuts",
      items: [{
        type: "table",
        header: [
          "Action",
          "Shortcut"
        ],
        cells: w
      }]
    };
  };
  var Z = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const Pe = ge([
    {
      key: "advlist",
      name: "Advanced List"
    },
    {
      key: "anchor",
      name: "Anchor"
    },
    {
      key: "autolink",
      name: "Autolink"
    },
    {
      key: "autoresize",
      name: "Autoresize"
    },
    {
      key: "autosave",
      name: "Autosave"
    },
    {
      key: "charmap",
      name: "Character Map"
    },
    {
      key: "code",
      name: "Code"
    },
    {
      key: "codesample",
      name: "Code Sample"
    },
    {
      key: "colorpicker",
      name: "Color Picker"
    },
    {
      key: "directionality",
      name: "Directionality"
    },
    {
      key: "emoticons",
      name: "Emoticons"
    },
    {
      key: "fullscreen",
      name: "Full Screen"
    },
    {
      key: "help",
      name: "Help"
    },
    {
      key: "image",
      name: "Image"
    },
    {
      key: "importcss",
      name: "Import CSS"
    },
    {
      key: "insertdatetime",
      name: "Insert Date/Time"
    },
    {
      key: "link",
      name: "Link"
    },
    {
      key: "lists",
      name: "Lists"
    },
    {
      key: "media",
      name: "Media"
    },
    {
      key: "nonbreaking",
      name: "Nonbreaking"
    },
    {
      key: "pagebreak",
      name: "Page Break"
    },
    {
      key: "preview",
      name: "Preview"
    },
    {
      key: "quickbars",
      name: "Quick Toolbars"
    },
    {
      key: "save",
      name: "Save"
    },
    {
      key: "searchreplace",
      name: "Search and Replace"
    },
    {
      key: "table",
      name: "Table"
    },
    {
      key: "template",
      name: "Template"
    },
    {
      key: "textcolor",
      name: "Text Color"
    },
    {
      key: "visualblocks",
      name: "Visual Blocks"
    },
    {
      key: "visualchars",
      name: "Visual Characters"
    },
    {
      key: "wordcount",
      name: "Word Count"
    },
    {
      key: "a11ychecker",
      name: "Accessibility Checker",
      type: "premium"
    },
    {
      key: "advcode",
      name: "Advanced Code Editor",
      type: "premium"
    },
    {
      key: "advtable",
      name: "Advanced Tables",
      type: "premium"
    },
    {
      key: "autocorrect",
      name: "Autocorrect",
      type: "premium"
    },
    {
      key: "casechange",
      name: "Case Change",
      type: "premium"
    },
    {
      key: "checklist",
      name: "Checklist",
      type: "premium"
    },
    {
      key: "editimage",
      name: "Enhanced Image Editing",
      type: "premium"
    },
    {
      key: "mediaembed",
      name: "Enhanced Media Embed",
      type: "premium",
      slug: "introduction-to-mediaembed"
    },
    {
      key: "export",
      name: "Export",
      type: "premium"
    },
    {
      key: "formatpainter",
      name: "Format Painter",
      type: "premium"
    },
    {
      key: "linkchecker",
      name: "Link Checker",
      type: "premium"
    },
    {
      key: "mentions",
      name: "Mentions",
      type: "premium"
    },
    {
      key: "pageembed",
      name: "Page Embed",
      type: "premium"
    },
    {
      key: "permanentpen",
      name: "Permanent Pen",
      type: "premium"
    },
    {
      key: "powerpaste",
      name: "PowerPaste",
      type: "premium",
      slug: "introduction-to-powerpaste"
    },
    {
      key: "rtc",
      name: "Real-Time Collaboration",
      type: "premium",
      slug: "rtc-introduction"
    },
    {
      key: "tinymcespellchecker",
      name: "Spell Checker Pro",
      type: "premium",
      slug: "introduction-to-tiny-spellchecker"
    },
    {
      key: "tinycomments",
      name: "Tiny Comments",
      type: "premium",
      slug: "introduction-to-tiny-comments"
    },
    {
      key: "tinydrive",
      name: "Tiny Drive",
      type: "premium",
      slug: "tinydrive-introduction"
    },
    {
      key: "tableofcontents",
      name: "Table of Contents",
      type: "premium"
    }
  ], (w) => ({
    ...w,
    type: w.type || "opensource",
    slug: w.slug || w.key
  })), yt = (w) => {
    const ie = () => {
      const W = zt(Pe, ({ key: Ue, type: kt }) => Ue !== "autocorrect" && kt === "premium"), M = ge(W, (Ue) => "<li>" + Z.translate(Ue.name) + "</li>").join("");
      return '<div data-mce-tabstop="1" tabindex="-1"><p><b>' + Z.translate("Premium plugins:") + "</b></p><ul>" + M + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" rel="noopener" target="_blank">' + Z.translate("Learn more...") + "</a></li></ul></div>";
    }, re = (W) => `<a href="${W.url}" target="_blank" rel="noopener">${W.name}</a>`, we = (W, M) => le(Pe, (Ue) => Ue.key === M).fold(() => {
      const Ue = W.plugins[M].getMetadata;
      return typeof Ue == "function" ? re(Ue()) : M;
    }, (Ue) => {
      const kt = Ue.type === "premium" ? `${Ue.name}*` : Ue.name;
      return re({
        name: kt,
        url: `https://www.tiny.cloud/docs/tinymce/6/${Ue.slug}/`
      });
    }), J = (W) => {
      const M = it(W.plugins), Ue = Ke(W);
      return pt(Ue) ? M : zt(M, (kt) => !ke(Ue, kt));
    }, me = (W) => {
      const M = J(W), Ue = ge(M, (En) => "<li>" + we(W, En) + "</li>"), kt = Ue.length, Qe = Ue.join("");
      return "<p><b>" + Z.translate([
        "Plugins installed ({0}):",
        kt
      ]) + "</b></p><ul>" + Qe + "</ul>";
    }, Ce = {
      type: "htmlpanel",
      presets: "document",
      html: [
        ((W) => W == null ? "" : '<div data-mce-tabstop="1" tabindex="-1">' + me(W) + "</div>")(w),
        ie()
      ].join("")
    };
    return {
      name: "plugins",
      title: "Plugins",
      items: [Ce]
    };
  };
  var et = tinymce.util.Tools.resolve("tinymce.EditorManager");
  const kn = () => {
    const ie = ((J, me) => J.indexOf("@") === 0 ? "X.X.X" : J + "." + me)(et.majorVersion, et.minorVersion), re = '<a href="https://www.tiny.cloud/docs/tinymce/6/changelog/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" rel="noopener" target="_blank">TinyMCE ' + ie + "</a>", we = {
      type: "htmlpanel",
      html: "<p>" + Z.translate([
        "You are using {0}",
        re
      ]) + "</p>",
      presets: "document"
    };
    return {
      name: "versions",
      title: "Version",
      items: [we]
    };
  }, Rn = (w, ie) => {
    const re = {}, we = ge(w, (J) => typeof J == "string" ? (Ve(ie, J) && (re[J] = ie[J]), J) : (re[J.name] = J, J.name));
    return {
      tabs: re,
      names: we
    };
  }, an = (w) => {
    const ie = it(w), re = ie.indexOf("versions");
    return re !== -1 && (ie.splice(re, 1), ie.push("versions")), {
      tabs: w,
      names: ie
    };
  }, en = (w, ie) => {
    const re = qt(), we = Je(), J = yt(w), me = kn(), ce = {
      [re.name]: re,
      [we.name]: we,
      [J.name]: J,
      [me.name]: me,
      ...ie.get()
    };
    return xe.from(We(w)).fold(() => an(ce), (Ce) => Rn(Ce, ce));
  }, cn = (w, ie) => () => {
    const { tabs: re, names: we } = en(w, ie), J = ge(we, (Ce) => Le(re, Ce)), me = L(J), ce = {
      type: "tabpanel",
      tabs: me
    };
    w.windowManager.open({
      title: "Help",
      size: "medium",
      body: ce,
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: {}
    });
  };
  var wn = () => {
    _.add("help", (w) => {
      const ie = g({}), re = D(ie);
      Ae(w);
      const we = cn(w, ie);
      return Ee(w, we), X(w, we), w.shortcuts.add("Alt+0", "Open help dialog", "mceHelp"), re;
    });
  };
  wn();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = ((W) => (M) => W === M)(null), X = (W) => W == null, _e = (W) => !X(W), Ae = () => {
  }, Ke = ((W) => () => W)(!1);
  class Ee {
    constructor(M, Ue) {
      this.tag = M, this.value = Ue;
    }
    static some(M) {
      return new Ee(!0, M);
    }
    static none() {
      return Ee.singletonNone;
    }
    fold(M, Ue) {
      return this.tag ? Ue(this.value) : M();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(M) {
      return this.tag ? Ee.some(M(this.value)) : Ee.none();
    }
    bind(M) {
      return this.tag ? M(this.value) : Ee.none();
    }
    exists(M) {
      return this.tag && M(this.value);
    }
    forall(M) {
      return !this.tag || M(this.value);
    }
    filter(M) {
      return !this.tag || M(this.value) ? this : Ee.none();
    }
    getOr(M) {
      return this.tag ? this.value : M;
    }
    or(M) {
      return this.tag ? this : M;
    }
    getOrThunk(M) {
      return this.tag ? this.value : M();
    }
    orThunk(M) {
      return this.tag ? this : M();
    }
    getOrDie(M) {
      if (this.tag)
        return this.value;
      throw new Error(M != null ? M : "Called getOrDie on None");
    }
    static from(M) {
      return _e(M) ? Ee.some(M) : Ee.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(M) {
      this.tag && M(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ee.singletonNone = new Ee(!1);
  const Ie = (W, M) => {
    for (let Ue = 0, kt = W.length; Ue < kt; Ue++) {
      const Qe = W[Ue];
      if (M(Qe, Ue))
        return !0;
    }
    return !1;
  }, pt = (W, M) => {
    const Ue = W.length, kt = new Array(Ue);
    for (let Qe = 0; Qe < Ue; Qe++) {
      const pn = W[Qe];
      kt[Qe] = M(pn, Qe);
    }
    return kt;
  }, _t = (W, M) => {
    for (let Ue = 0, kt = W.length; Ue < kt; Ue++) {
      const Qe = W[Ue];
      M(Qe, Ue);
    }
  }, $e = (W) => {
    let M = W;
    return {
      get: () => M,
      set: (Qe) => {
        M = Qe;
      }
    };
  }, Ne = (W, M) => {
    let Ue = null;
    const kt = () => {
      D(Ue) || (clearTimeout(Ue), Ue = null);
    };
    return {
      cancel: kt,
      throttle: (...pn) => {
        kt(), Ue = setTimeout(() => {
          Ue = null, W.apply(null, pn);
        }, M);
      }
    };
  }, tt = (W, M) => {
    W.insertContent(M);
  }, xe = Object.keys, rt = Object.hasOwnProperty, ae = (W, M) => {
    const Ue = xe(W);
    for (let kt = 0, Qe = Ue.length; kt < Qe; kt++) {
      const pn = Ue[kt], En = W[pn];
      M(En, pn);
    }
  }, ke = (W, M) => ge(W, (Ue, kt) => ({
    k: kt,
    v: M(Ue, kt)
  })), ge = (W, M) => {
    const Ue = {};
    return ae(W, (kt, Qe) => {
      const pn = M(kt, Qe);
      Ue[pn.k] = pn.v;
    }), Ue;
  }, zt = (W, M) => rt.call(W, M), it = ((W) => (...M) => {
    if (M.length === 0)
      throw new Error("Can't merge zero objects");
    const Ue = {};
    for (let kt = 0; kt < M.length; kt++) {
      const Qe = M[kt];
      for (const pn in Qe)
        zt(Qe, pn) && (Ue[pn] = W(Ue[pn], Qe[pn]));
    }
    return Ue;
  })((W, M) => M), ft = (W) => {
    const M = $e(Ee.none()), Ue = () => M.get().each(W);
    return {
      clear: () => {
        Ue(), M.set(Ee.none());
      },
      isSet: () => M.get().isSome(),
      get: () => M.get(),
      set: (Eo) => {
        Ue(), M.set(Ee.some(Eo));
      }
    };
  }, Le = () => {
    const W = ft(Ae);
    return {
      ...W,
      on: (Ue) => W.get().each(Ue)
    };
  }, Ve = (W, M, Ue) => M === "" || W.length >= M.length && W.substr(Ue, Ue + M.length) === M, L = (W, M) => W.indexOf(M) !== -1, Wt = (W, M) => Ve(W, M, 0);
  var Je = tinymce.util.Tools.resolve("tinymce.Resource");
  const jt = "tinymce.plugins.emoticons", ye = (W) => (M) => M.options.get(W), Ze = (W, M) => {
    const Ue = W.options.register;
    Ue("emoticons_database", {
      processor: "string",
      default: "emojis"
    }), Ue("emoticons_database_url", {
      processor: "string",
      default: `${M}/js/${qt(W)}${W.suffix}.js`
    }), Ue("emoticons_database_id", {
      processor: "string",
      default: jt
    }), Ue("emoticons_append", {
      processor: "object",
      default: {}
    }), Ue("emoticons_images_url", {
      processor: "string",
      default: "https://twemoji.maxcdn.com/v/13.0.1/72x72/"
    });
  }, qt = ye("emoticons_database"), Z = ye("emoticons_database_url"), Pe = ye("emoticons_database_id"), yt = ye("emoticons_append"), et = ye("emoticons_images_url"), kn = "All", Rn = {
    symbols: "Symbols",
    people: "People",
    animals_and_nature: "Animals and Nature",
    food_and_drink: "Food and Drink",
    activity: "Activity",
    travel_and_places: "Travel and Places",
    objects: "Objects",
    flags: "Flags",
    user: "User Defined"
  }, an = (W, M) => zt(W, M) ? W[M] : M, en = (W) => {
    const M = yt(W);
    return ke(M, (Ue) => ({
      keywords: [],
      category: "user",
      ...Ue
    }));
  }, cn = (W, M, Ue) => {
    const kt = Le(), Qe = Le(), pn = et(W), En = (io) => Wt(io.char, "<img") ? io.char.replace(/src="([^"]+)"/, (Fe, st) => `src="${pn}${st}"`) : io.char, Eo = (io) => {
      const Fe = {}, st = [];
      ae(io, (Qt, Ut) => {
        const Tn = {
          title: Ut,
          keywords: Qt.keywords,
          char: En(Qt),
          category: an(Rn, Qt.category)
        }, Pn = Fe[Tn.category] !== void 0 ? Fe[Tn.category] : [];
        Fe[Tn.category] = Pn.concat([Tn]), st.push(Tn);
      }), kt.set(Fe), Qe.set(st);
    };
    W.on("init", () => {
      Je.load(Ue, M).then((io) => {
        const Fe = en(W);
        Eo(it(io, Fe));
      }, (io) => {
        console.log(`Failed to load emojis: ${io}`), kt.set({}), Qe.set([]);
      });
    });
    const oo = (io) => io === kn ? Yn() : kt.get().bind((Fe) => Ee.from(Fe[io])).getOr([]), Yn = () => Qe.get().getOr([]), eo = () => [kn].concat(xe(kt.get().getOr({}))), Xt = () => ro() ? Promise.resolve(!0) : new Promise((io, Fe) => {
      let st = 15;
      const Qt = setInterval(() => {
        ro() ? (clearInterval(Qt), io(!0)) : (st--, st < 0 && (console.log("Could not load emojis from url: " + M), clearInterval(Qt), Fe(!1)));
      }, 100);
    }), ro = () => kt.isSet() && Qe.isSet();
    return {
      listCategories: eo,
      hasLoaded: ro,
      waitForLoad: Xt,
      listAll: Yn,
      listCategory: oo
    };
  }, wn = (W, M) => L(W.title.toLowerCase(), M) || Ie(W.keywords, (Ue) => L(Ue.toLowerCase(), M)), w = (W, M, Ue) => {
    const kt = [], Qe = M.toLowerCase(), pn = Ue.fold(() => Ke, (En) => (Eo) => Eo >= En);
    for (let En = 0; En < W.length && !((M.length === 0 || wn(W[En], Qe)) && (kt.push({
      value: W[En].char,
      text: W[En].title,
      icon: W[En].char
    }), pn(kt.length))); En++)
      ;
    return kt;
  }, ie = "pattern", re = (W, M) => {
    const Ue = {
      pattern: "",
      results: w(M.listAll(), "", Ee.some(300))
    }, kt = $e(kn), Qe = (eo) => {
      const Xt = eo.getData(), ro = kt.get(), io = M.listCategory(ro), Fe = w(io, Xt[ie], ro === kn ? Ee.some(300) : Ee.none());
      eo.setData({ results: Fe });
    }, pn = Ne((eo) => {
      Qe(eo);
    }, 200), En = {
      label: "Search",
      type: "input",
      name: ie
    }, Eo = {
      type: "collection",
      name: "results"
    }, oo = () => {
      const eo = {
        type: "tabpanel",
        tabs: pt(M.listCategories(), (Xt) => ({
          title: Xt,
          name: Xt,
          items: [
            En,
            Eo
          ]
        }))
      };
      return {
        title: "Emojis",
        size: "normal",
        body: eo,
        initialData: Ue,
        onTabChange: (Xt, ro) => {
          kt.set(ro.newTabName), pn.throttle(Xt);
        },
        onChange: pn.throttle,
        onAction: (Xt, ro) => {
          ro.name === "results" && (tt(W, ro.value), Xt.close());
        },
        buttons: [{
          type: "cancel",
          text: "Close",
          primary: !0
        }]
      };
    }, Yn = W.windowManager.open(oo());
    Yn.focus(ie), M.hasLoaded() || (Yn.block("Loading emojis..."), M.waitForLoad().then(() => {
      Yn.redial(oo()), pn.throttle(Yn), Yn.focus(ie), Yn.unblock();
    }).catch((eo) => {
      Yn.redial({
        title: "Emojis",
        body: {
          type: "panel",
          items: [{
            type: "alertbanner",
            level: "error",
            icon: "warning",
            text: "Could not load emojis"
          }]
        },
        buttons: [{
          type: "cancel",
          text: "Close",
          primary: !0
        }],
        initialData: {
          pattern: "",
          results: []
        }
      }), Yn.focus(ie), Yn.unblock();
    }));
  }, we = (W, M) => {
    W.addCommand("mceEmoticons", () => re(W, M));
  }, J = (W) => {
    W.on("PreInit", () => {
      W.parser.addAttributeFilter("data-emoticon", (M) => {
        _t(M, (Ue) => {
          Ue.attr("data-mce-resize", "false"), Ue.attr("data-mce-placeholder", "1");
        });
      });
    });
  }, me = (W, M) => {
    W.ui.registry.addAutocompleter("emoticons", {
      ch: ":",
      columns: "auto",
      minChars: 2,
      fetch: (Ue, kt) => M.waitForLoad().then(() => {
        const Qe = M.listAll();
        return w(Qe, Ue, Ee.some(kt));
      }),
      onAction: (Ue, kt, Qe) => {
        W.selection.setRng(kt), W.insertContent(Qe), Ue.hide();
      }
    });
  }, ce = (W) => {
    const M = () => W.execCommand("mceEmoticons");
    W.ui.registry.addButton("emoticons", {
      tooltip: "Emojis",
      icon: "emoji",
      onAction: M
    }), W.ui.registry.addMenuItem("emoticons", {
      text: "Emojis...",
      icon: "emoji",
      onAction: M
    });
  };
  var Ce = () => {
    g.add("emoticons", (W, M) => {
      Ze(W, M);
      const Ue = Z(W), kt = Pe(W), Qe = cn(W, Ue, kt);
      we(W, Qe), ce(W), me(W, Qe), J(W);
    });
  };
  Ce();
})();
window.tinymce.Resource.add("tinymce.plugins.emoticons", { grinning: { keywords: ["face", "smile", "happy", "joy", ":D", "grin"], char: "\u{1F600}", fitzpatrick_scale: !1, category: "people" }, grimacing: { keywords: ["face", "grimace", "teeth"], char: "\u{1F62C}", fitzpatrick_scale: !1, category: "people" }, grin: { keywords: ["face", "happy", "smile", "joy", "kawaii"], char: "\u{1F601}", fitzpatrick_scale: !1, category: "people" }, joy: { keywords: ["face", "cry", "tears", "weep", "happy", "happytears", "haha"], char: "\u{1F602}", fitzpatrick_scale: !1, category: "people" }, rofl: { keywords: ["face", "rolling", "floor", "laughing", "lol", "haha"], char: "\u{1F923}", fitzpatrick_scale: !1, category: "people" }, partying: { keywords: ["face", "celebration", "woohoo"], char: "\u{1F973}", fitzpatrick_scale: !1, category: "people" }, smiley: { keywords: ["face", "happy", "joy", "haha", ":D", ":)", "smile", "funny"], char: "\u{1F603}", fitzpatrick_scale: !1, category: "people" }, smile: { keywords: ["face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"], char: "\u{1F604}", fitzpatrick_scale: !1, category: "people" }, sweat_smile: { keywords: ["face", "hot", "happy", "laugh", "sweat", "smile", "relief"], char: "\u{1F605}", fitzpatrick_scale: !1, category: "people" }, laughing: { keywords: ["happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh"], char: "\u{1F606}", fitzpatrick_scale: !1, category: "people" }, innocent: { keywords: ["face", "angel", "heaven", "halo"], char: "\u{1F607}", fitzpatrick_scale: !1, category: "people" }, wink: { keywords: ["face", "happy", "mischievous", "secret", ";)", "smile", "eye"], char: "\u{1F609}", fitzpatrick_scale: !1, category: "people" }, blush: { keywords: ["face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"], char: "\u{1F60A}", fitzpatrick_scale: !1, category: "people" }, slightly_smiling_face: { keywords: ["face", "smile"], char: "\u{1F642}", fitzpatrick_scale: !1, category: "people" }, upside_down_face: { keywords: ["face", "flipped", "silly", "smile"], char: "\u{1F643}", fitzpatrick_scale: !1, category: "people" }, relaxed: { keywords: ["face", "blush", "massage", "happiness"], char: "\u263A\uFE0F", fitzpatrick_scale: !1, category: "people" }, yum: { keywords: ["happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring"], char: "\u{1F60B}", fitzpatrick_scale: !1, category: "people" }, relieved: { keywords: ["face", "relaxed", "phew", "massage", "happiness"], char: "\u{1F60C}", fitzpatrick_scale: !1, category: "people" }, heart_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart"], char: "\u{1F60D}", fitzpatrick_scale: !1, category: "people" }, smiling_face_with_three_hearts: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore"], char: "\u{1F970}", fitzpatrick_scale: !1, category: "people" }, kissing_heart: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F618}", fitzpatrick_scale: !1, category: "people" }, kissing: { keywords: ["love", "like", "face", "3", "valentines", "infatuation", "kiss"], char: "\u{1F617}", fitzpatrick_scale: !1, category: "people" }, kissing_smiling_eyes: { keywords: ["face", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F619}", fitzpatrick_scale: !1, category: "people" }, kissing_closed_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F61A}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_winking_eye: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue"], char: "\u{1F61C}", fitzpatrick_scale: !1, category: "people" }, zany: { keywords: ["face", "goofy", "crazy"], char: "\u{1F92A}", fitzpatrick_scale: !1, category: "people" }, raised_eyebrow: { keywords: ["face", "distrust", "scepticism", "disapproval", "disbelief", "surprise"], char: "\u{1F928}", fitzpatrick_scale: !1, category: "people" }, monocle: { keywords: ["face", "stuffy", "wealthy"], char: "\u{1F9D0}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_closed_eyes: { keywords: ["face", "prank", "playful", "mischievous", "smile", "tongue"], char: "\u{1F61D}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "tongue"], char: "\u{1F61B}", fitzpatrick_scale: !1, category: "people" }, money_mouth_face: { keywords: ["face", "rich", "dollar", "money"], char: "\u{1F911}", fitzpatrick_scale: !1, category: "people" }, nerd_face: { keywords: ["face", "nerdy", "geek", "dork"], char: "\u{1F913}", fitzpatrick_scale: !1, category: "people" }, sunglasses: { keywords: ["face", "cool", "smile", "summer", "beach", "sunglass"], char: "\u{1F60E}", fitzpatrick_scale: !1, category: "people" }, star_struck: { keywords: ["face", "smile", "starry", "eyes", "grinning"], char: "\u{1F929}", fitzpatrick_scale: !1, category: "people" }, clown_face: { keywords: ["face"], char: "\u{1F921}", fitzpatrick_scale: !1, category: "people" }, cowboy_hat_face: { keywords: ["face", "cowgirl", "hat"], char: "\u{1F920}", fitzpatrick_scale: !1, category: "people" }, hugs: { keywords: ["face", "smile", "hug"], char: "\u{1F917}", fitzpatrick_scale: !1, category: "people" }, smirk: { keywords: ["face", "smile", "mean", "prank", "smug", "sarcasm"], char: "\u{1F60F}", fitzpatrick_scale: !1, category: "people" }, no_mouth: { keywords: ["face", "hellokitty"], char: "\u{1F636}", fitzpatrick_scale: !1, category: "people" }, neutral_face: { keywords: ["indifference", "meh", ":|", "neutral"], char: "\u{1F610}", fitzpatrick_scale: !1, category: "people" }, expressionless: { keywords: ["face", "indifferent", "-_-", "meh", "deadpan"], char: "\u{1F611}", fitzpatrick_scale: !1, category: "people" }, unamused: { keywords: ["indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye"], char: "\u{1F612}", fitzpatrick_scale: !1, category: "people" }, roll_eyes: { keywords: ["face", "eyeroll", "frustrated"], char: "\u{1F644}", fitzpatrick_scale: !1, category: "people" }, thinking: { keywords: ["face", "hmmm", "think", "consider"], char: "\u{1F914}", fitzpatrick_scale: !1, category: "people" }, lying_face: { keywords: ["face", "lie", "pinocchio"], char: "\u{1F925}", fitzpatrick_scale: !1, category: "people" }, hand_over_mouth: { keywords: ["face", "whoops", "shock", "surprise"], char: "\u{1F92D}", fitzpatrick_scale: !1, category: "people" }, shushing: { keywords: ["face", "quiet", "shhh"], char: "\u{1F92B}", fitzpatrick_scale: !1, category: "people" }, symbols_over_mouth: { keywords: ["face", "swearing", "cursing", "cussing", "profanity", "expletive"], char: "\u{1F92C}", fitzpatrick_scale: !1, category: "people" }, exploding_head: { keywords: ["face", "shocked", "mind", "blown"], char: "\u{1F92F}", fitzpatrick_scale: !1, category: "people" }, flushed: { keywords: ["face", "blush", "shy", "flattered"], char: "\u{1F633}", fitzpatrick_scale: !1, category: "people" }, disappointed: { keywords: ["face", "sad", "upset", "depressed", ":("], char: "\u{1F61E}", fitzpatrick_scale: !1, category: "people" }, worried: { keywords: ["face", "concern", "nervous", ":("], char: "\u{1F61F}", fitzpatrick_scale: !1, category: "people" }, angry: { keywords: ["mad", "face", "annoyed", "frustrated"], char: "\u{1F620}", fitzpatrick_scale: !1, category: "people" }, rage: { keywords: ["angry", "mad", "hate", "despise"], char: "\u{1F621}", fitzpatrick_scale: !1, category: "people" }, pensive: { keywords: ["face", "sad", "depressed", "upset"], char: "\u{1F614}", fitzpatrick_scale: !1, category: "people" }, confused: { keywords: ["face", "indifference", "huh", "weird", "hmmm", ":/"], char: "\u{1F615}", fitzpatrick_scale: !1, category: "people" }, slightly_frowning_face: { keywords: ["face", "frowning", "disappointed", "sad", "upset"], char: "\u{1F641}", fitzpatrick_scale: !1, category: "people" }, frowning_face: { keywords: ["face", "sad", "upset", "frown"], char: "\u2639", fitzpatrick_scale: !1, category: "people" }, persevere: { keywords: ["face", "sick", "no", "upset", "oops"], char: "\u{1F623}", fitzpatrick_scale: !1, category: "people" }, confounded: { keywords: ["face", "confused", "sick", "unwell", "oops", ":S"], char: "\u{1F616}", fitzpatrick_scale: !1, category: "people" }, tired_face: { keywords: ["sick", "whine", "upset", "frustrated"], char: "\u{1F62B}", fitzpatrick_scale: !1, category: "people" }, weary: { keywords: ["face", "tired", "sleepy", "sad", "frustrated", "upset"], char: "\u{1F629}", fitzpatrick_scale: !1, category: "people" }, pleading: { keywords: ["face", "begging", "mercy"], char: "\u{1F97A}", fitzpatrick_scale: !1, category: "people" }, triumph: { keywords: ["face", "gas", "phew", "proud", "pride"], char: "\u{1F624}", fitzpatrick_scale: !1, category: "people" }, open_mouth: { keywords: ["face", "surprise", "impressed", "wow", "whoa", ":O"], char: "\u{1F62E}", fitzpatrick_scale: !1, category: "people" }, scream: { keywords: ["face", "munch", "scared", "omg"], char: "\u{1F631}", fitzpatrick_scale: !1, category: "people" }, fearful: { keywords: ["face", "scared", "terrified", "nervous", "oops", "huh"], char: "\u{1F628}", fitzpatrick_scale: !1, category: "people" }, cold_sweat: { keywords: ["face", "nervous", "sweat"], char: "\u{1F630}", fitzpatrick_scale: !1, category: "people" }, hushed: { keywords: ["face", "woo", "shh"], char: "\u{1F62F}", fitzpatrick_scale: !1, category: "people" }, frowning: { keywords: ["face", "aw", "what"], char: "\u{1F626}", fitzpatrick_scale: !1, category: "people" }, anguished: { keywords: ["face", "stunned", "nervous"], char: "\u{1F627}", fitzpatrick_scale: !1, category: "people" }, cry: { keywords: ["face", "tears", "sad", "depressed", "upset", ":'("], char: "\u{1F622}", fitzpatrick_scale: !1, category: "people" }, disappointed_relieved: { keywords: ["face", "phew", "sweat", "nervous"], char: "\u{1F625}", fitzpatrick_scale: !1, category: "people" }, drooling_face: { keywords: ["face"], char: "\u{1F924}", fitzpatrick_scale: !1, category: "people" }, sleepy: { keywords: ["face", "tired", "rest", "nap"], char: "\u{1F62A}", fitzpatrick_scale: !1, category: "people" }, sweat: { keywords: ["face", "hot", "sad", "tired", "exercise"], char: "\u{1F613}", fitzpatrick_scale: !1, category: "people" }, hot: { keywords: ["face", "feverish", "heat", "red", "sweating"], char: "\u{1F975}", fitzpatrick_scale: !1, category: "people" }, cold: { keywords: ["face", "blue", "freezing", "frozen", "frostbite", "icicles"], char: "\u{1F976}", fitzpatrick_scale: !1, category: "people" }, sob: { keywords: ["face", "cry", "tears", "sad", "upset", "depressed"], char: "\u{1F62D}", fitzpatrick_scale: !1, category: "people" }, dizzy_face: { keywords: ["spent", "unconscious", "xox", "dizzy"], char: "\u{1F635}", fitzpatrick_scale: !1, category: "people" }, astonished: { keywords: ["face", "xox", "surprised", "poisoned"], char: "\u{1F632}", fitzpatrick_scale: !1, category: "people" }, zipper_mouth_face: { keywords: ["face", "sealed", "zipper", "secret"], char: "\u{1F910}", fitzpatrick_scale: !1, category: "people" }, nauseated_face: { keywords: ["face", "vomit", "gross", "green", "sick", "throw up", "ill"], char: "\u{1F922}", fitzpatrick_scale: !1, category: "people" }, sneezing_face: { keywords: ["face", "gesundheit", "sneeze", "sick", "allergy"], char: "\u{1F927}", fitzpatrick_scale: !1, category: "people" }, vomiting: { keywords: ["face", "sick"], char: "\u{1F92E}", fitzpatrick_scale: !1, category: "people" }, mask: { keywords: ["face", "sick", "ill", "disease"], char: "\u{1F637}", fitzpatrick_scale: !1, category: "people" }, face_with_thermometer: { keywords: ["sick", "temperature", "thermometer", "cold", "fever"], char: "\u{1F912}", fitzpatrick_scale: !1, category: "people" }, face_with_head_bandage: { keywords: ["injured", "clumsy", "bandage", "hurt"], char: "\u{1F915}", fitzpatrick_scale: !1, category: "people" }, woozy: { keywords: ["face", "dizzy", "intoxicated", "tipsy", "wavy"], char: "\u{1F974}", fitzpatrick_scale: !1, category: "people" }, sleeping: { keywords: ["face", "tired", "sleepy", "night", "zzz"], char: "\u{1F634}", fitzpatrick_scale: !1, category: "people" }, zzz: { keywords: ["sleepy", "tired", "dream"], char: "\u{1F4A4}", fitzpatrick_scale: !1, category: "people" }, poop: { keywords: ["hankey", "shitface", "fail", "turd", "shit"], char: "\u{1F4A9}", fitzpatrick_scale: !1, category: "people" }, smiling_imp: { keywords: ["devil", "horns"], char: "\u{1F608}", fitzpatrick_scale: !1, category: "people" }, imp: { keywords: ["devil", "angry", "horns"], char: "\u{1F47F}", fitzpatrick_scale: !1, category: "people" }, japanese_ogre: { keywords: ["monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre"], char: "\u{1F479}", fitzpatrick_scale: !1, category: "people" }, japanese_goblin: { keywords: ["red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin"], char: "\u{1F47A}", fitzpatrick_scale: !1, category: "people" }, skull: { keywords: ["dead", "skeleton", "creepy", "death"], char: "\u{1F480}", fitzpatrick_scale: !1, category: "people" }, ghost: { keywords: ["halloween", "spooky", "scary"], char: "\u{1F47B}", fitzpatrick_scale: !1, category: "people" }, alien: { keywords: ["UFO", "paul", "weird", "outer_space"], char: "\u{1F47D}", fitzpatrick_scale: !1, category: "people" }, robot: { keywords: ["computer", "machine", "bot"], char: "\u{1F916}", fitzpatrick_scale: !1, category: "people" }, smiley_cat: { keywords: ["animal", "cats", "happy", "smile"], char: "\u{1F63A}", fitzpatrick_scale: !1, category: "people" }, smile_cat: { keywords: ["animal", "cats", "smile"], char: "\u{1F638}", fitzpatrick_scale: !1, category: "people" }, joy_cat: { keywords: ["animal", "cats", "haha", "happy", "tears"], char: "\u{1F639}", fitzpatrick_scale: !1, category: "people" }, heart_eyes_cat: { keywords: ["animal", "love", "like", "affection", "cats", "valentines", "heart"], char: "\u{1F63B}", fitzpatrick_scale: !1, category: "people" }, smirk_cat: { keywords: ["animal", "cats", "smirk"], char: "\u{1F63C}", fitzpatrick_scale: !1, category: "people" }, kissing_cat: { keywords: ["animal", "cats", "kiss"], char: "\u{1F63D}", fitzpatrick_scale: !1, category: "people" }, scream_cat: { keywords: ["animal", "cats", "munch", "scared", "scream"], char: "\u{1F640}", fitzpatrick_scale: !1, category: "people" }, crying_cat_face: { keywords: ["animal", "tears", "weep", "sad", "cats", "upset", "cry"], char: "\u{1F63F}", fitzpatrick_scale: !1, category: "people" }, pouting_cat: { keywords: ["animal", "cats"], char: "\u{1F63E}", fitzpatrick_scale: !1, category: "people" }, palms_up: { keywords: ["hands", "gesture", "cupped", "prayer"], char: "\u{1F932}", fitzpatrick_scale: !0, category: "people" }, raised_hands: { keywords: ["gesture", "hooray", "yea", "celebration", "hands"], char: "\u{1F64C}", fitzpatrick_scale: !0, category: "people" }, clap: { keywords: ["hands", "praise", "applause", "congrats", "yay"], char: "\u{1F44F}", fitzpatrick_scale: !0, category: "people" }, wave: { keywords: ["hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"], char: "\u{1F44B}", fitzpatrick_scale: !0, category: "people" }, call_me_hand: { keywords: ["hands", "gesture"], char: "\u{1F919}", fitzpatrick_scale: !0, category: "people" }, "+1": { keywords: ["thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"], char: "\u{1F44D}", fitzpatrick_scale: !0, category: "people" }, "-1": { keywords: ["thumbsdown", "no", "dislike", "hand"], char: "\u{1F44E}", fitzpatrick_scale: !0, category: "people" }, facepunch: { keywords: ["angry", "violence", "fist", "hit", "attack", "hand"], char: "\u{1F44A}", fitzpatrick_scale: !0, category: "people" }, fist: { keywords: ["fingers", "hand", "grasp"], char: "\u270A", fitzpatrick_scale: !0, category: "people" }, fist_left: { keywords: ["hand", "fistbump"], char: "\u{1F91B}", fitzpatrick_scale: !0, category: "people" }, fist_right: { keywords: ["hand", "fistbump"], char: "\u{1F91C}", fitzpatrick_scale: !0, category: "people" }, v: { keywords: ["fingers", "ohyeah", "hand", "peace", "victory", "two"], char: "\u270C", fitzpatrick_scale: !0, category: "people" }, ok_hand: { keywords: ["fingers", "limbs", "perfect", "ok", "okay"], char: "\u{1F44C}", fitzpatrick_scale: !0, category: "people" }, raised_hand: { keywords: ["fingers", "stop", "highfive", "palm", "ban"], char: "\u270B", fitzpatrick_scale: !0, category: "people" }, raised_back_of_hand: { keywords: ["fingers", "raised", "backhand"], char: "\u{1F91A}", fitzpatrick_scale: !0, category: "people" }, open_hands: { keywords: ["fingers", "butterfly", "hands", "open"], char: "\u{1F450}", fitzpatrick_scale: !0, category: "people" }, muscle: { keywords: ["arm", "flex", "hand", "summer", "strong", "biceps"], char: "\u{1F4AA}", fitzpatrick_scale: !0, category: "people" }, pray: { keywords: ["please", "hope", "wish", "namaste", "highfive"], char: "\u{1F64F}", fitzpatrick_scale: !0, category: "people" }, foot: { keywords: ["kick", "stomp"], char: "\u{1F9B6}", fitzpatrick_scale: !0, category: "people" }, leg: { keywords: ["kick", "limb"], char: "\u{1F9B5}", fitzpatrick_scale: !0, category: "people" }, handshake: { keywords: ["agreement", "shake"], char: "\u{1F91D}", fitzpatrick_scale: !1, category: "people" }, point_up: { keywords: ["hand", "fingers", "direction", "up"], char: "\u261D", fitzpatrick_scale: !0, category: "people" }, point_up_2: { keywords: ["fingers", "hand", "direction", "up"], char: "\u{1F446}", fitzpatrick_scale: !0, category: "people" }, point_down: { keywords: ["fingers", "hand", "direction", "down"], char: "\u{1F447}", fitzpatrick_scale: !0, category: "people" }, point_left: { keywords: ["direction", "fingers", "hand", "left"], char: "\u{1F448}", fitzpatrick_scale: !0, category: "people" }, point_right: { keywords: ["fingers", "hand", "direction", "right"], char: "\u{1F449}", fitzpatrick_scale: !0, category: "people" }, fu: { keywords: ["hand", "fingers", "rude", "middle", "flipping"], char: "\u{1F595}", fitzpatrick_scale: !0, category: "people" }, raised_hand_with_fingers_splayed: { keywords: ["hand", "fingers", "palm"], char: "\u{1F590}", fitzpatrick_scale: !0, category: "people" }, love_you: { keywords: ["hand", "fingers", "gesture"], char: "\u{1F91F}", fitzpatrick_scale: !0, category: "people" }, metal: { keywords: ["hand", "fingers", "evil_eye", "sign_of_horns", "rock_on"], char: "\u{1F918}", fitzpatrick_scale: !0, category: "people" }, crossed_fingers: { keywords: ["good", "lucky"], char: "\u{1F91E}", fitzpatrick_scale: !0, category: "people" }, vulcan_salute: { keywords: ["hand", "fingers", "spock", "star trek"], char: "\u{1F596}", fitzpatrick_scale: !0, category: "people" }, writing_hand: { keywords: ["lower_left_ballpoint_pen", "stationery", "write", "compose"], char: "\u270D", fitzpatrick_scale: !0, category: "people" }, selfie: { keywords: ["camera", "phone"], char: "\u{1F933}", fitzpatrick_scale: !0, category: "people" }, nail_care: { keywords: ["beauty", "manicure", "finger", "fashion", "nail"], char: "\u{1F485}", fitzpatrick_scale: !0, category: "people" }, lips: { keywords: ["mouth", "kiss"], char: "\u{1F444}", fitzpatrick_scale: !1, category: "people" }, tooth: { keywords: ["teeth", "dentist"], char: "\u{1F9B7}", fitzpatrick_scale: !1, category: "people" }, tongue: { keywords: ["mouth", "playful"], char: "\u{1F445}", fitzpatrick_scale: !1, category: "people" }, ear: { keywords: ["face", "hear", "sound", "listen"], char: "\u{1F442}", fitzpatrick_scale: !0, category: "people" }, nose: { keywords: ["smell", "sniff"], char: "\u{1F443}", fitzpatrick_scale: !0, category: "people" }, eye: { keywords: ["face", "look", "see", "watch", "stare"], char: "\u{1F441}", fitzpatrick_scale: !1, category: "people" }, eyes: { keywords: ["look", "watch", "stalk", "peek", "see"], char: "\u{1F440}", fitzpatrick_scale: !1, category: "people" }, brain: { keywords: ["smart", "intelligent"], char: "\u{1F9E0}", fitzpatrick_scale: !1, category: "people" }, bust_in_silhouette: { keywords: ["user", "person", "human"], char: "\u{1F464}", fitzpatrick_scale: !1, category: "people" }, busts_in_silhouette: { keywords: ["user", "person", "human", "group", "team"], char: "\u{1F465}", fitzpatrick_scale: !1, category: "people" }, speaking_head: { keywords: ["user", "person", "human", "sing", "say", "talk"], char: "\u{1F5E3}", fitzpatrick_scale: !1, category: "people" }, baby: { keywords: ["child", "boy", "girl", "toddler"], char: "\u{1F476}", fitzpatrick_scale: !0, category: "people" }, child: { keywords: ["gender-neutral", "young"], char: "\u{1F9D2}", fitzpatrick_scale: !0, category: "people" }, boy: { keywords: ["man", "male", "guy", "teenager"], char: "\u{1F466}", fitzpatrick_scale: !0, category: "people" }, girl: { keywords: ["female", "woman", "teenager"], char: "\u{1F467}", fitzpatrick_scale: !0, category: "people" }, adult: { keywords: ["gender-neutral", "person"], char: "\u{1F9D1}", fitzpatrick_scale: !0, category: "people" }, man: { keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"], char: "\u{1F468}", fitzpatrick_scale: !0, category: "people" }, woman: { keywords: ["female", "girls", "lady"], char: "\u{1F469}", fitzpatrick_scale: !0, category: "people" }, blonde_woman: { keywords: ["woman", "female", "girl", "blonde", "person"], char: "\u{1F471}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, blonde_man: { keywords: ["man", "male", "boy", "blonde", "guy", "person"], char: "\u{1F471}", fitzpatrick_scale: !0, category: "people" }, bearded_person: { keywords: ["person", "bewhiskered"], char: "\u{1F9D4}", fitzpatrick_scale: !0, category: "people" }, older_adult: { keywords: ["human", "elder", "senior", "gender-neutral"], char: "\u{1F9D3}", fitzpatrick_scale: !0, category: "people" }, older_man: { keywords: ["human", "male", "men", "old", "elder", "senior"], char: "\u{1F474}", fitzpatrick_scale: !0, category: "people" }, older_woman: { keywords: ["human", "female", "women", "lady", "old", "elder", "senior"], char: "\u{1F475}", fitzpatrick_scale: !0, category: "people" }, man_with_gua_pi_mao: { keywords: ["male", "boy", "chinese"], char: "\u{1F472}", fitzpatrick_scale: !0, category: "people" }, woman_with_headscarf: { keywords: ["female", "hijab", "mantilla", "tichel"], char: "\u{1F9D5}", fitzpatrick_scale: !0, category: "people" }, woman_with_turban: { keywords: ["female", "indian", "hinduism", "arabs", "woman"], char: "\u{1F473}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_with_turban: { keywords: ["male", "indian", "hinduism", "arabs"], char: "\u{1F473}", fitzpatrick_scale: !0, category: "people" }, policewoman: { keywords: ["woman", "police", "law", "legal", "enforcement", "arrest", "911", "female"], char: "\u{1F46E}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, policeman: { keywords: ["man", "police", "law", "legal", "enforcement", "arrest", "911"], char: "\u{1F46E}", fitzpatrick_scale: !0, category: "people" }, construction_worker_woman: { keywords: ["female", "human", "wip", "build", "construction", "worker", "labor", "woman"], char: "\u{1F477}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, construction_worker_man: { keywords: ["male", "human", "wip", "guy", "build", "construction", "worker", "labor"], char: "\u{1F477}", fitzpatrick_scale: !0, category: "people" }, guardswoman: { keywords: ["uk", "gb", "british", "female", "royal", "woman"], char: "\u{1F482}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, guardsman: { keywords: ["uk", "gb", "british", "male", "guy", "royal"], char: "\u{1F482}", fitzpatrick_scale: !0, category: "people" }, female_detective: { keywords: ["human", "spy", "detective", "female", "woman"], char: "\u{1F575}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, male_detective: { keywords: ["human", "spy", "detective"], char: "\u{1F575}", fitzpatrick_scale: !0, category: "people" }, woman_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "woman", "human"], char: "\u{1F469}\u200D\u2695\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "man", "human"], char: "\u{1F468}\u200D\u2695\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_farmer: { keywords: ["rancher", "gardener", "woman", "human"], char: "\u{1F469}\u200D\u{1F33E}", fitzpatrick_scale: !0, category: "people" }, man_farmer: { keywords: ["rancher", "gardener", "man", "human"], char: "\u{1F468}\u200D\u{1F33E}", fitzpatrick_scale: !0, category: "people" }, woman_cook: { keywords: ["chef", "woman", "human"], char: "\u{1F469}\u200D\u{1F373}", fitzpatrick_scale: !0, category: "people" }, man_cook: { keywords: ["chef", "man", "human"], char: "\u{1F468}\u200D\u{1F373}", fitzpatrick_scale: !0, category: "people" }, woman_student: { keywords: ["graduate", "woman", "human"], char: "\u{1F469}\u200D\u{1F393}", fitzpatrick_scale: !0, category: "people" }, man_student: { keywords: ["graduate", "man", "human"], char: "\u{1F468}\u200D\u{1F393}", fitzpatrick_scale: !0, category: "people" }, woman_singer: { keywords: ["rockstar", "entertainer", "woman", "human"], char: "\u{1F469}\u200D\u{1F3A4}", fitzpatrick_scale: !0, category: "people" }, man_singer: { keywords: ["rockstar", "entertainer", "man", "human"], char: "\u{1F468}\u200D\u{1F3A4}", fitzpatrick_scale: !0, category: "people" }, woman_teacher: { keywords: ["instructor", "professor", "woman", "human"], char: "\u{1F469}\u200D\u{1F3EB}", fitzpatrick_scale: !0, category: "people" }, man_teacher: { keywords: ["instructor", "professor", "man", "human"], char: "\u{1F468}\u200D\u{1F3EB}", fitzpatrick_scale: !0, category: "people" }, woman_factory_worker: { keywords: ["assembly", "industrial", "woman", "human"], char: "\u{1F469}\u200D\u{1F3ED}", fitzpatrick_scale: !0, category: "people" }, man_factory_worker: { keywords: ["assembly", "industrial", "man", "human"], char: "\u{1F468}\u200D\u{1F3ED}", fitzpatrick_scale: !0, category: "people" }, woman_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer"], char: "\u{1F469}\u200D\u{1F4BB}", fitzpatrick_scale: !0, category: "people" }, man_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer"], char: "\u{1F468}\u200D\u{1F4BB}", fitzpatrick_scale: !0, category: "people" }, woman_office_worker: { keywords: ["business", "manager", "woman", "human"], char: "\u{1F469}\u200D\u{1F4BC}", fitzpatrick_scale: !0, category: "people" }, man_office_worker: { keywords: ["business", "manager", "man", "human"], char: "\u{1F468}\u200D\u{1F4BC}", fitzpatrick_scale: !0, category: "people" }, woman_mechanic: { keywords: ["plumber", "woman", "human", "wrench"], char: "\u{1F469}\u200D\u{1F527}", fitzpatrick_scale: !0, category: "people" }, man_mechanic: { keywords: ["plumber", "man", "human", "wrench"], char: "\u{1F468}\u200D\u{1F527}", fitzpatrick_scale: !0, category: "people" }, woman_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "woman", "human"], char: "\u{1F469}\u200D\u{1F52C}", fitzpatrick_scale: !0, category: "people" }, man_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "man", "human"], char: "\u{1F468}\u200D\u{1F52C}", fitzpatrick_scale: !0, category: "people" }, woman_artist: { keywords: ["painter", "woman", "human"], char: "\u{1F469}\u200D\u{1F3A8}", fitzpatrick_scale: !0, category: "people" }, man_artist: { keywords: ["painter", "man", "human"], char: "\u{1F468}\u200D\u{1F3A8}", fitzpatrick_scale: !0, category: "people" }, woman_firefighter: { keywords: ["fireman", "woman", "human"], char: "\u{1F469}\u200D\u{1F692}", fitzpatrick_scale: !0, category: "people" }, man_firefighter: { keywords: ["fireman", "man", "human"], char: "\u{1F468}\u200D\u{1F692}", fitzpatrick_scale: !0, category: "people" }, woman_pilot: { keywords: ["aviator", "plane", "woman", "human"], char: "\u{1F469}\u200D\u2708\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_pilot: { keywords: ["aviator", "plane", "man", "human"], char: "\u{1F468}\u200D\u2708\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_astronaut: { keywords: ["space", "rocket", "woman", "human"], char: "\u{1F469}\u200D\u{1F680}", fitzpatrick_scale: !0, category: "people" }, man_astronaut: { keywords: ["space", "rocket", "man", "human"], char: "\u{1F468}\u200D\u{1F680}", fitzpatrick_scale: !0, category: "people" }, woman_judge: { keywords: ["justice", "court", "woman", "human"], char: "\u{1F469}\u200D\u2696\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_judge: { keywords: ["justice", "court", "man", "human"], char: "\u{1F468}\u200D\u2696\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_superhero: { keywords: ["woman", "female", "good", "heroine", "superpowers"], char: "\u{1F9B8}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_superhero: { keywords: ["man", "male", "good", "hero", "superpowers"], char: "\u{1F9B8}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_supervillain: { keywords: ["woman", "female", "evil", "bad", "criminal", "heroine", "superpowers"], char: "\u{1F9B9}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_supervillain: { keywords: ["man", "male", "evil", "bad", "criminal", "hero", "superpowers"], char: "\u{1F9B9}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, mrs_claus: { keywords: ["woman", "female", "xmas", "mother christmas"], char: "\u{1F936}", fitzpatrick_scale: !0, category: "people" }, santa: { keywords: ["festival", "man", "male", "xmas", "father christmas"], char: "\u{1F385}", fitzpatrick_scale: !0, category: "people" }, sorceress: { keywords: ["woman", "female", "mage", "witch"], char: "\u{1F9D9}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, wizard: { keywords: ["man", "male", "mage", "sorcerer"], char: "\u{1F9D9}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_elf: { keywords: ["woman", "female"], char: "\u{1F9DD}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_elf: { keywords: ["man", "male"], char: "\u{1F9DD}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_vampire: { keywords: ["woman", "female"], char: "\u{1F9DB}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_vampire: { keywords: ["man", "male", "dracula"], char: "\u{1F9DB}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_zombie: { keywords: ["woman", "female", "undead", "walking dead"], char: "\u{1F9DF}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "people" }, man_zombie: { keywords: ["man", "male", "dracula", "undead", "walking dead"], char: "\u{1F9DF}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, woman_genie: { keywords: ["woman", "female"], char: "\u{1F9DE}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "people" }, man_genie: { keywords: ["man", "male"], char: "\u{1F9DE}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, mermaid: { keywords: ["woman", "female", "merwoman", "ariel"], char: "\u{1F9DC}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, merman: { keywords: ["man", "male", "triton"], char: "\u{1F9DC}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_fairy: { keywords: ["woman", "female"], char: "\u{1F9DA}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_fairy: { keywords: ["man", "male"], char: "\u{1F9DA}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, angel: { keywords: ["heaven", "wings", "halo"], char: "\u{1F47C}", fitzpatrick_scale: !0, category: "people" }, pregnant_woman: { keywords: ["baby"], char: "\u{1F930}", fitzpatrick_scale: !0, category: "people" }, breastfeeding: { keywords: ["nursing", "baby"], char: "\u{1F931}", fitzpatrick_scale: !0, category: "people" }, princess: { keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"], char: "\u{1F478}", fitzpatrick_scale: !0, category: "people" }, prince: { keywords: ["boy", "man", "male", "crown", "royal", "king"], char: "\u{1F934}", fitzpatrick_scale: !0, category: "people" }, bride_with_veil: { keywords: ["couple", "marriage", "wedding", "woman", "bride"], char: "\u{1F470}", fitzpatrick_scale: !0, category: "people" }, man_in_tuxedo: { keywords: ["couple", "marriage", "wedding", "groom"], char: "\u{1F935}", fitzpatrick_scale: !0, category: "people" }, running_woman: { keywords: ["woman", "walking", "exercise", "race", "running", "female"], char: "\u{1F3C3}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, running_man: { keywords: ["man", "walking", "exercise", "race", "running"], char: "\u{1F3C3}", fitzpatrick_scale: !0, category: "people" }, walking_woman: { keywords: ["human", "feet", "steps", "woman", "female"], char: "\u{1F6B6}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, walking_man: { keywords: ["human", "feet", "steps"], char: "\u{1F6B6}", fitzpatrick_scale: !0, category: "people" }, dancer: { keywords: ["female", "girl", "woman", "fun"], char: "\u{1F483}", fitzpatrick_scale: !0, category: "people" }, man_dancing: { keywords: ["male", "boy", "fun", "dancer"], char: "\u{1F57A}", fitzpatrick_scale: !0, category: "people" }, dancing_women: { keywords: ["female", "bunny", "women", "girls"], char: "\u{1F46F}", fitzpatrick_scale: !1, category: "people" }, dancing_men: { keywords: ["male", "bunny", "men", "boys"], char: "\u{1F46F}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, couple: { keywords: ["pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"], char: "\u{1F46B}", fitzpatrick_scale: !1, category: "people" }, two_men_holding_hands: { keywords: ["pair", "couple", "love", "like", "bromance", "friendship", "people", "human"], char: "\u{1F46C}", fitzpatrick_scale: !1, category: "people" }, two_women_holding_hands: { keywords: ["pair", "friendship", "couple", "love", "like", "female", "people", "human"], char: "\u{1F46D}", fitzpatrick_scale: !1, category: "people" }, bowing_woman: { keywords: ["woman", "female", "girl"], char: "\u{1F647}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, bowing_man: { keywords: ["man", "male", "boy"], char: "\u{1F647}", fitzpatrick_scale: !0, category: "people" }, man_facepalming: { keywords: ["man", "male", "boy", "disbelief"], char: "\u{1F926}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_facepalming: { keywords: ["woman", "female", "girl", "disbelief"], char: "\u{1F926}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_shrugging: { keywords: ["woman", "female", "girl", "confused", "indifferent", "doubt"], char: "\u{1F937}", fitzpatrick_scale: !0, category: "people" }, man_shrugging: { keywords: ["man", "male", "boy", "confused", "indifferent", "doubt"], char: "\u{1F937}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, tipping_hand_woman: { keywords: ["female", "girl", "woman", "human", "information"], char: "\u{1F481}", fitzpatrick_scale: !0, category: "people" }, tipping_hand_man: { keywords: ["male", "boy", "man", "human", "information"], char: "\u{1F481}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, no_good_woman: { keywords: ["female", "girl", "woman", "nope"], char: "\u{1F645}", fitzpatrick_scale: !0, category: "people" }, no_good_man: { keywords: ["male", "boy", "man", "nope"], char: "\u{1F645}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, ok_woman: { keywords: ["women", "girl", "female", "pink", "human", "woman"], char: "\u{1F646}", fitzpatrick_scale: !0, category: "people" }, ok_man: { keywords: ["men", "boy", "male", "blue", "human", "man"], char: "\u{1F646}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, raising_hand_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F64B}", fitzpatrick_scale: !0, category: "people" }, raising_hand_man: { keywords: ["male", "boy", "man"], char: "\u{1F64B}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, pouting_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F64E}", fitzpatrick_scale: !0, category: "people" }, pouting_man: { keywords: ["male", "boy", "man"], char: "\u{1F64E}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, frowning_woman: { keywords: ["female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy"], char: "\u{1F64D}", fitzpatrick_scale: !0, category: "people" }, frowning_man: { keywords: ["male", "boy", "man", "sad", "depressed", "discouraged", "unhappy"], char: "\u{1F64D}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, haircut_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F487}", fitzpatrick_scale: !0, category: "people" }, haircut_man: { keywords: ["male", "boy", "man"], char: "\u{1F487}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, massage_woman: { keywords: ["female", "girl", "woman", "head"], char: "\u{1F486}", fitzpatrick_scale: !0, category: "people" }, massage_man: { keywords: ["male", "boy", "man", "head"], char: "\u{1F486}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_in_steamy_room: { keywords: ["female", "woman", "spa", "steamroom", "sauna"], char: "\u{1F9D6}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_in_steamy_room: { keywords: ["male", "man", "spa", "steamroom", "sauna"], char: "\u{1F9D6}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, couple_with_heart_woman_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F491}", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_woman_woman: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_man_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F48F}", fitzpatrick_scale: !1, category: "people" }, couplekiss_woman_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_man: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy: { keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"], char: "\u{1F46A}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl: { keywords: ["home", "parents", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F469}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, yarn: { keywords: ["ball", "crochet", "knit"], char: "\u{1F9F6}", fitzpatrick_scale: !1, category: "people" }, thread: { keywords: ["needle", "sewing", "spool", "string"], char: "\u{1F9F5}", fitzpatrick_scale: !1, category: "people" }, coat: { keywords: ["jacket"], char: "\u{1F9E5}", fitzpatrick_scale: !1, category: "people" }, labcoat: { keywords: ["doctor", "experiment", "scientist", "chemist"], char: "\u{1F97C}", fitzpatrick_scale: !1, category: "people" }, womans_clothes: { keywords: ["fashion", "shopping_bags", "female"], char: "\u{1F45A}", fitzpatrick_scale: !1, category: "people" }, tshirt: { keywords: ["fashion", "cloth", "casual", "shirt", "tee"], char: "\u{1F455}", fitzpatrick_scale: !1, category: "people" }, jeans: { keywords: ["fashion", "shopping"], char: "\u{1F456}", fitzpatrick_scale: !1, category: "people" }, necktie: { keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"], char: "\u{1F454}", fitzpatrick_scale: !1, category: "people" }, dress: { keywords: ["clothes", "fashion", "shopping"], char: "\u{1F457}", fitzpatrick_scale: !1, category: "people" }, bikini: { keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"], char: "\u{1F459}", fitzpatrick_scale: !1, category: "people" }, kimono: { keywords: ["dress", "fashion", "women", "female", "japanese"], char: "\u{1F458}", fitzpatrick_scale: !1, category: "people" }, lipstick: { keywords: ["female", "girl", "fashion", "woman"], char: "\u{1F484}", fitzpatrick_scale: !1, category: "people" }, kiss: { keywords: ["face", "lips", "love", "like", "affection", "valentines"], char: "\u{1F48B}", fitzpatrick_scale: !1, category: "people" }, footprints: { keywords: ["feet", "tracking", "walking", "beach"], char: "\u{1F463}", fitzpatrick_scale: !1, category: "people" }, flat_shoe: { keywords: ["ballet", "slip-on", "slipper"], char: "\u{1F97F}", fitzpatrick_scale: !1, category: "people" }, high_heel: { keywords: ["fashion", "shoes", "female", "pumps", "stiletto"], char: "\u{1F460}", fitzpatrick_scale: !1, category: "people" }, sandal: { keywords: ["shoes", "fashion", "flip flops"], char: "\u{1F461}", fitzpatrick_scale: !1, category: "people" }, boot: { keywords: ["shoes", "fashion"], char: "\u{1F462}", fitzpatrick_scale: !1, category: "people" }, mans_shoe: { keywords: ["fashion", "male"], char: "\u{1F45E}", fitzpatrick_scale: !1, category: "people" }, athletic_shoe: { keywords: ["shoes", "sports", "sneakers"], char: "\u{1F45F}", fitzpatrick_scale: !1, category: "people" }, hiking_boot: { keywords: ["backpacking", "camping", "hiking"], char: "\u{1F97E}", fitzpatrick_scale: !1, category: "people" }, socks: { keywords: ["stockings", "clothes"], char: "\u{1F9E6}", fitzpatrick_scale: !1, category: "people" }, gloves: { keywords: ["hands", "winter", "clothes"], char: "\u{1F9E4}", fitzpatrick_scale: !1, category: "people" }, scarf: { keywords: ["neck", "winter", "clothes"], char: "\u{1F9E3}", fitzpatrick_scale: !1, category: "people" }, womans_hat: { keywords: ["fashion", "accessories", "female", "lady", "spring"], char: "\u{1F452}", fitzpatrick_scale: !1, category: "people" }, tophat: { keywords: ["magic", "gentleman", "classy", "circus"], char: "\u{1F3A9}", fitzpatrick_scale: !1, category: "people" }, billed_hat: { keywords: ["cap", "baseball"], char: "\u{1F9E2}", fitzpatrick_scale: !1, category: "people" }, rescue_worker_helmet: { keywords: ["construction", "build"], char: "\u26D1", fitzpatrick_scale: !1, category: "people" }, mortar_board: { keywords: ["school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education"], char: "\u{1F393}", fitzpatrick_scale: !1, category: "people" }, crown: { keywords: ["king", "kod", "leader", "royalty", "lord"], char: "\u{1F451}", fitzpatrick_scale: !1, category: "people" }, school_satchel: { keywords: ["student", "education", "bag", "backpack"], char: "\u{1F392}", fitzpatrick_scale: !1, category: "people" }, luggage: { keywords: ["packing", "travel"], char: "\u{1F9F3}", fitzpatrick_scale: !1, category: "people" }, pouch: { keywords: ["bag", "accessories", "shopping"], char: "\u{1F45D}", fitzpatrick_scale: !1, category: "people" }, purse: { keywords: ["fashion", "accessories", "money", "sales", "shopping"], char: "\u{1F45B}", fitzpatrick_scale: !1, category: "people" }, handbag: { keywords: ["fashion", "accessory", "accessories", "shopping"], char: "\u{1F45C}", fitzpatrick_scale: !1, category: "people" }, briefcase: { keywords: ["business", "documents", "work", "law", "legal", "job", "career"], char: "\u{1F4BC}", fitzpatrick_scale: !1, category: "people" }, eyeglasses: { keywords: ["fashion", "accessories", "eyesight", "nerdy", "dork", "geek"], char: "\u{1F453}", fitzpatrick_scale: !1, category: "people" }, dark_sunglasses: { keywords: ["face", "cool", "accessories"], char: "\u{1F576}", fitzpatrick_scale: !1, category: "people" }, goggles: { keywords: ["eyes", "protection", "safety"], char: "\u{1F97D}", fitzpatrick_scale: !1, category: "people" }, ring: { keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"], char: "\u{1F48D}", fitzpatrick_scale: !1, category: "people" }, closed_umbrella: { keywords: ["weather", "rain", "drizzle"], char: "\u{1F302}", fitzpatrick_scale: !1, category: "people" }, dog: { keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"], char: "\u{1F436}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat: { keywords: ["animal", "meow", "nature", "pet", "kitten"], char: "\u{1F431}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse: { keywords: ["animal", "nature", "cheese_wedge", "rodent"], char: "\u{1F42D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hamster: { keywords: ["animal", "nature"], char: "\u{1F439}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit: { keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"], char: "\u{1F430}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fox_face: { keywords: ["animal", "nature", "face"], char: "\u{1F98A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bear: { keywords: ["animal", "nature", "wild"], char: "\u{1F43B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, panda_face: { keywords: ["animal", "nature", "panda"], char: "\u{1F43C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, koala: { keywords: ["animal", "nature"], char: "\u{1F428}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger: { keywords: ["animal", "cat", "danger", "wild", "nature", "roar"], char: "\u{1F42F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lion: { keywords: ["animal", "nature"], char: "\u{1F981}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "\u{1F42E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig: { keywords: ["animal", "oink", "nature"], char: "\u{1F437}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig_nose: { keywords: ["animal", "oink"], char: "\u{1F43D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, frog: { keywords: ["animal", "nature", "croak", "toad"], char: "\u{1F438}", fitzpatrick_scale: !1, category: "animals_and_nature" }, squid: { keywords: ["animal", "nature", "ocean", "sea"], char: "\u{1F991}", fitzpatrick_scale: !1, category: "animals_and_nature" }, octopus: { keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"], char: "\u{1F419}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shrimp: { keywords: ["animal", "ocean", "nature", "seafood"], char: "\u{1F990}", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey_face: { keywords: ["animal", "nature", "circus"], char: "\u{1F435}", fitzpatrick_scale: !1, category: "animals_and_nature" }, gorilla: { keywords: ["animal", "nature", "circus"], char: "\u{1F98D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, see_no_evil: { keywords: ["monkey", "animal", "nature", "haha"], char: "\u{1F648}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hear_no_evil: { keywords: ["animal", "monkey", "nature"], char: "\u{1F649}", fitzpatrick_scale: !1, category: "animals_and_nature" }, speak_no_evil: { keywords: ["monkey", "animal", "nature", "omg"], char: "\u{1F64A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey: { keywords: ["animal", "nature", "banana", "circus"], char: "\u{1F412}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chicken: { keywords: ["animal", "cluck", "nature", "bird"], char: "\u{1F414}", fitzpatrick_scale: !1, category: "animals_and_nature" }, penguin: { keywords: ["animal", "nature"], char: "\u{1F427}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bird: { keywords: ["animal", "nature", "fly", "tweet", "spring"], char: "\u{1F426}", fitzpatrick_scale: !1, category: "animals_and_nature" }, baby_chick: { keywords: ["animal", "chicken", "bird"], char: "\u{1F424}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatching_chick: { keywords: ["animal", "chicken", "egg", "born", "baby", "bird"], char: "\u{1F423}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatched_chick: { keywords: ["animal", "chicken", "baby", "bird"], char: "\u{1F425}", fitzpatrick_scale: !1, category: "animals_and_nature" }, duck: { keywords: ["animal", "nature", "bird", "mallard"], char: "\u{1F986}", fitzpatrick_scale: !1, category: "animals_and_nature" }, eagle: { keywords: ["animal", "nature", "bird"], char: "\u{1F985}", fitzpatrick_scale: !1, category: "animals_and_nature" }, owl: { keywords: ["animal", "nature", "bird", "hoot"], char: "\u{1F989}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bat: { keywords: ["animal", "nature", "blind", "vampire"], char: "\u{1F987}", fitzpatrick_scale: !1, category: "animals_and_nature" }, wolf: { keywords: ["animal", "nature", "wild"], char: "\u{1F43A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, boar: { keywords: ["animal", "nature"], char: "\u{1F417}", fitzpatrick_scale: !1, category: "animals_and_nature" }, horse: { keywords: ["animal", "brown", "nature"], char: "\u{1F434}", fitzpatrick_scale: !1, category: "animals_and_nature" }, unicorn: { keywords: ["animal", "nature", "mystical"], char: "\u{1F984}", fitzpatrick_scale: !1, category: "animals_and_nature" }, honeybee: { keywords: ["animal", "insect", "nature", "bug", "spring", "honey"], char: "\u{1F41D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bug: { keywords: ["animal", "insect", "nature", "worm"], char: "\u{1F41B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, butterfly: { keywords: ["animal", "insect", "nature", "caterpillar"], char: "\u{1F98B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snail: { keywords: ["slow", "animal", "shell"], char: "\u{1F40C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, beetle: { keywords: ["animal", "insect", "nature", "ladybug"], char: "\u{1F41E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ant: { keywords: ["animal", "insect", "nature", "bug"], char: "\u{1F41C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, grasshopper: { keywords: ["animal", "cricket", "chirp"], char: "\u{1F997}", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider: { keywords: ["animal", "arachnid"], char: "\u{1F577}", fitzpatrick_scale: !1, category: "animals_and_nature" }, scorpion: { keywords: ["animal", "arachnid"], char: "\u{1F982}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crab: { keywords: ["animal", "crustacean"], char: "\u{1F980}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snake: { keywords: ["animal", "evil", "nature", "hiss", "python"], char: "\u{1F40D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lizard: { keywords: ["animal", "nature", "reptile"], char: "\u{1F98E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, "t-rex": { keywords: ["animal", "nature", "dinosaur", "tyrannosaurus", "extinct"], char: "\u{1F996}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sauropod: { keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"], char: "\u{1F995}", fitzpatrick_scale: !1, category: "animals_and_nature" }, turtle: { keywords: ["animal", "slow", "nature", "tortoise"], char: "\u{1F422}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tropical_fish: { keywords: ["animal", "swim", "ocean", "beach", "nemo"], char: "\u{1F420}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fish: { keywords: ["animal", "food", "nature"], char: "\u{1F41F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, blowfish: { keywords: ["animal", "nature", "food", "sea", "ocean"], char: "\u{1F421}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dolphin: { keywords: ["animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach"], char: "\u{1F42C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shark: { keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"], char: "\u{1F988}", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale: { keywords: ["animal", "nature", "sea", "ocean"], char: "\u{1F433}", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale2: { keywords: ["animal", "nature", "sea", "ocean"], char: "\u{1F40B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crocodile: { keywords: ["animal", "nature", "reptile", "lizard", "alligator"], char: "\u{1F40A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, leopard: { keywords: ["animal", "nature"], char: "\u{1F406}", fitzpatrick_scale: !1, category: "animals_and_nature" }, zebra: { keywords: ["animal", "nature", "stripes", "safari"], char: "\u{1F993}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger2: { keywords: ["animal", "nature", "roar"], char: "\u{1F405}", fitzpatrick_scale: !1, category: "animals_and_nature" }, water_buffalo: { keywords: ["animal", "nature", "ox", "cow"], char: "\u{1F403}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ox: { keywords: ["animal", "cow", "beef"], char: "\u{1F402}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow2: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "\u{1F404}", fitzpatrick_scale: !1, category: "animals_and_nature" }, deer: { keywords: ["animal", "nature", "horns", "venison"], char: "\u{1F98C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dromedary_camel: { keywords: ["animal", "hot", "desert", "hump"], char: "\u{1F42A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, camel: { keywords: ["animal", "nature", "hot", "desert", "hump"], char: "\u{1F42B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, giraffe: { keywords: ["animal", "nature", "spots", "safari"], char: "\u{1F992}", fitzpatrick_scale: !1, category: "animals_and_nature" }, elephant: { keywords: ["animal", "nature", "nose", "th", "circus"], char: "\u{1F418}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rhinoceros: { keywords: ["animal", "nature", "horn"], char: "\u{1F98F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, goat: { keywords: ["animal", "nature"], char: "\u{1F410}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ram: { keywords: ["animal", "sheep", "nature"], char: "\u{1F40F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sheep: { keywords: ["animal", "nature", "wool", "shipit"], char: "\u{1F411}", fitzpatrick_scale: !1, category: "animals_and_nature" }, racehorse: { keywords: ["animal", "gamble", "luck"], char: "\u{1F40E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig2: { keywords: ["animal", "nature"], char: "\u{1F416}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rat: { keywords: ["animal", "mouse", "rodent"], char: "\u{1F400}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse2: { keywords: ["animal", "nature", "rodent"], char: "\u{1F401}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rooster: { keywords: ["animal", "nature", "chicken"], char: "\u{1F413}", fitzpatrick_scale: !1, category: "animals_and_nature" }, turkey: { keywords: ["animal", "bird"], char: "\u{1F983}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dove: { keywords: ["animal", "bird"], char: "\u{1F54A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dog2: { keywords: ["animal", "nature", "friend", "doge", "pet", "faithful"], char: "\u{1F415}", fitzpatrick_scale: !1, category: "animals_and_nature" }, poodle: { keywords: ["dog", "animal", "101", "nature", "pet"], char: "\u{1F429}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat2: { keywords: ["animal", "meow", "pet", "cats"], char: "\u{1F408}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit2: { keywords: ["animal", "nature", "pet", "magic", "spring"], char: "\u{1F407}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chipmunk: { keywords: ["animal", "nature", "rodent", "squirrel"], char: "\u{1F43F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hedgehog: { keywords: ["animal", "nature", "spiny"], char: "\u{1F994}", fitzpatrick_scale: !1, category: "animals_and_nature" }, raccoon: { keywords: ["animal", "nature"], char: "\u{1F99D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, llama: { keywords: ["animal", "nature", "alpaca"], char: "\u{1F999}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hippopotamus: { keywords: ["animal", "nature"], char: "\u{1F99B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, kangaroo: { keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"], char: "\u{1F998}", fitzpatrick_scale: !1, category: "animals_and_nature" }, badger: { keywords: ["animal", "nature", "honey"], char: "\u{1F9A1}", fitzpatrick_scale: !1, category: "animals_and_nature" }, swan: { keywords: ["animal", "nature", "bird"], char: "\u{1F9A2}", fitzpatrick_scale: !1, category: "animals_and_nature" }, peacock: { keywords: ["animal", "nature", "peahen", "bird"], char: "\u{1F99A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, parrot: { keywords: ["animal", "nature", "bird", "pirate", "talk"], char: "\u{1F99C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lobster: { keywords: ["animal", "nature", "bisque", "claws", "seafood"], char: "\u{1F99E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mosquito: { keywords: ["animal", "nature", "insect", "malaria"], char: "\u{1F99F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, paw_prints: { keywords: ["animal", "tracking", "footprints", "dog", "cat", "pet", "feet"], char: "\u{1F43E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "\u{1F409}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon_face: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "\u{1F432}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cactus: { keywords: ["vegetable", "plant", "nature"], char: "\u{1F335}", fitzpatrick_scale: !1, category: "animals_and_nature" }, christmas_tree: { keywords: ["festival", "vacation", "december", "xmas", "celebration"], char: "\u{1F384}", fitzpatrick_scale: !1, category: "animals_and_nature" }, evergreen_tree: { keywords: ["plant", "nature"], char: "\u{1F332}", fitzpatrick_scale: !1, category: "animals_and_nature" }, deciduous_tree: { keywords: ["plant", "nature"], char: "\u{1F333}", fitzpatrick_scale: !1, category: "animals_and_nature" }, palm_tree: { keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"], char: "\u{1F334}", fitzpatrick_scale: !1, category: "animals_and_nature" }, seedling: { keywords: ["plant", "nature", "grass", "lawn", "spring"], char: "\u{1F331}", fitzpatrick_scale: !1, category: "animals_and_nature" }, herb: { keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"], char: "\u{1F33F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shamrock: { keywords: ["vegetable", "plant", "nature", "irish", "clover"], char: "\u2618", fitzpatrick_scale: !1, category: "animals_and_nature" }, four_leaf_clover: { keywords: ["vegetable", "plant", "nature", "lucky", "irish"], char: "\u{1F340}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bamboo: { keywords: ["plant", "nature", "vegetable", "panda", "pine_decoration"], char: "\u{1F38D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tanabata_tree: { keywords: ["plant", "nature", "branch", "summer"], char: "\u{1F38B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, leaves: { keywords: ["nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"], char: "\u{1F343}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fallen_leaf: { keywords: ["nature", "plant", "vegetable", "leaves"], char: "\u{1F342}", fitzpatrick_scale: !1, category: "animals_and_nature" }, maple_leaf: { keywords: ["nature", "plant", "vegetable", "ca", "fall"], char: "\u{1F341}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ear_of_rice: { keywords: ["nature", "plant"], char: "\u{1F33E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hibiscus: { keywords: ["plant", "vegetable", "flowers", "beach"], char: "\u{1F33A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunflower: { keywords: ["nature", "plant", "fall"], char: "\u{1F33B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rose: { keywords: ["flowers", "valentines", "love", "spring"], char: "\u{1F339}", fitzpatrick_scale: !1, category: "animals_and_nature" }, wilted_flower: { keywords: ["plant", "nature", "flower"], char: "\u{1F940}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tulip: { keywords: ["flowers", "plant", "nature", "summer", "spring"], char: "\u{1F337}", fitzpatrick_scale: !1, category: "animals_and_nature" }, blossom: { keywords: ["nature", "flowers", "yellow"], char: "\u{1F33C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cherry_blossom: { keywords: ["nature", "plant", "spring", "flower"], char: "\u{1F338}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bouquet: { keywords: ["flowers", "nature", "spring"], char: "\u{1F490}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mushroom: { keywords: ["plant", "vegetable"], char: "\u{1F344}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chestnut: { keywords: ["food", "squirrel"], char: "\u{1F330}", fitzpatrick_scale: !1, category: "animals_and_nature" }, jack_o_lantern: { keywords: ["halloween", "light", "pumpkin", "creepy", "fall"], char: "\u{1F383}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shell: { keywords: ["nature", "sea", "beach"], char: "\u{1F41A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider_web: { keywords: ["animal", "insect", "arachnid", "silk"], char: "\u{1F578}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_americas: { keywords: ["globe", "world", "USA", "international"], char: "\u{1F30E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_africa: { keywords: ["globe", "world", "international"], char: "\u{1F30D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_asia: { keywords: ["globe", "world", "east", "international"], char: "\u{1F30F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon: { keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F315}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_gibbous_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon"], char: "\u{1F316}", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F317}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F318}", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F311}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F312}", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F313}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_gibbous_moon: { keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"], char: "\u{1F314}", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_with_face: { keywords: ["nature", "morning", "sky"], char: "\u{1F31E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crescent_moon: { keywords: ["night", "sleep", "sky", "evening", "magic"], char: "\u{1F319}", fitzpatrick_scale: !1, category: "animals_and_nature" }, star: { keywords: ["night", "yellow"], char: "\u2B50", fitzpatrick_scale: !1, category: "animals_and_nature" }, star2: { keywords: ["night", "sparkle", "awesome", "good", "magic"], char: "\u{1F31F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dizzy: { keywords: ["star", "sparkle", "shoot", "magic"], char: "\u{1F4AB}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sparkles: { keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"], char: "\u2728", fitzpatrick_scale: !1, category: "animals_and_nature" }, comet: { keywords: ["space"], char: "\u2604", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunny: { keywords: ["weather", "nature", "brightness", "summer", "beach", "spring"], char: "\u2600\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_small_cloud: { keywords: ["weather"], char: "\u{1F324}", fitzpatrick_scale: !1, category: "animals_and_nature" }, partly_sunny: { keywords: ["weather", "nature", "cloudy", "morning", "fall", "spring"], char: "\u26C5", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_large_cloud: { keywords: ["weather"], char: "\u{1F325}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_rain_cloud: { keywords: ["weather"], char: "\u{1F326}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud: { keywords: ["weather", "sky"], char: "\u2601\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_rain: { keywords: ["weather"], char: "\u{1F327}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning_and_rain: { keywords: ["weather", "lightning"], char: "\u26C8", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning: { keywords: ["weather", "thunder"], char: "\u{1F329}", fitzpatrick_scale: !1, category: "animals_and_nature" }, zap: { keywords: ["thunder", "weather", "lightning bolt", "fast"], char: "\u26A1", fitzpatrick_scale: !1, category: "animals_and_nature" }, fire: { keywords: ["hot", "cook", "flame"], char: "\u{1F525}", fitzpatrick_scale: !1, category: "animals_and_nature" }, boom: { keywords: ["bomb", "explode", "explosion", "collision", "blown"], char: "\u{1F4A5}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowflake: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"], char: "\u2744\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_snow: { keywords: ["weather"], char: "\u{1F328}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow"], char: "\u26C4", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman_with_snow: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"], char: "\u2603", fitzpatrick_scale: !1, category: "animals_and_nature" }, wind_face: { keywords: ["gust", "air"], char: "\u{1F32C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dash: { keywords: ["wind", "air", "fast", "shoo", "fart", "smoke", "puff"], char: "\u{1F4A8}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tornado: { keywords: ["weather", "cyclone", "twister"], char: "\u{1F32A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fog: { keywords: ["weather"], char: "\u{1F32B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, open_umbrella: { keywords: ["weather", "spring"], char: "\u2602", fitzpatrick_scale: !1, category: "animals_and_nature" }, umbrella: { keywords: ["rainy", "weather", "spring"], char: "\u2614", fitzpatrick_scale: !1, category: "animals_and_nature" }, droplet: { keywords: ["water", "drip", "faucet", "spring"], char: "\u{1F4A7}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sweat_drops: { keywords: ["water", "drip", "oops"], char: "\u{1F4A6}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ocean: { keywords: ["sea", "water", "wave", "nature", "tsunami", "disaster"], char: "\u{1F30A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, green_apple: { keywords: ["fruit", "nature"], char: "\u{1F34F}", fitzpatrick_scale: !1, category: "food_and_drink" }, apple: { keywords: ["fruit", "mac", "school"], char: "\u{1F34E}", fitzpatrick_scale: !1, category: "food_and_drink" }, pear: { keywords: ["fruit", "nature", "food"], char: "\u{1F350}", fitzpatrick_scale: !1, category: "food_and_drink" }, tangerine: { keywords: ["food", "fruit", "nature", "orange"], char: "\u{1F34A}", fitzpatrick_scale: !1, category: "food_and_drink" }, lemon: { keywords: ["fruit", "nature"], char: "\u{1F34B}", fitzpatrick_scale: !1, category: "food_and_drink" }, banana: { keywords: ["fruit", "food", "monkey"], char: "\u{1F34C}", fitzpatrick_scale: !1, category: "food_and_drink" }, watermelon: { keywords: ["fruit", "food", "picnic", "summer"], char: "\u{1F349}", fitzpatrick_scale: !1, category: "food_and_drink" }, grapes: { keywords: ["fruit", "food", "wine"], char: "\u{1F347}", fitzpatrick_scale: !1, category: "food_and_drink" }, strawberry: { keywords: ["fruit", "food", "nature"], char: "\u{1F353}", fitzpatrick_scale: !1, category: "food_and_drink" }, melon: { keywords: ["fruit", "nature", "food"], char: "\u{1F348}", fitzpatrick_scale: !1, category: "food_and_drink" }, cherries: { keywords: ["food", "fruit"], char: "\u{1F352}", fitzpatrick_scale: !1, category: "food_and_drink" }, peach: { keywords: ["fruit", "nature", "food"], char: "\u{1F351}", fitzpatrick_scale: !1, category: "food_and_drink" }, pineapple: { keywords: ["fruit", "nature", "food"], char: "\u{1F34D}", fitzpatrick_scale: !1, category: "food_and_drink" }, coconut: { keywords: ["fruit", "nature", "food", "palm"], char: "\u{1F965}", fitzpatrick_scale: !1, category: "food_and_drink" }, kiwi_fruit: { keywords: ["fruit", "food"], char: "\u{1F95D}", fitzpatrick_scale: !1, category: "food_and_drink" }, mango: { keywords: ["fruit", "food", "tropical"], char: "\u{1F96D}", fitzpatrick_scale: !1, category: "food_and_drink" }, avocado: { keywords: ["fruit", "food"], char: "\u{1F951}", fitzpatrick_scale: !1, category: "food_and_drink" }, broccoli: { keywords: ["fruit", "food", "vegetable"], char: "\u{1F966}", fitzpatrick_scale: !1, category: "food_and_drink" }, tomato: { keywords: ["fruit", "vegetable", "nature", "food"], char: "\u{1F345}", fitzpatrick_scale: !1, category: "food_and_drink" }, eggplant: { keywords: ["vegetable", "nature", "food", "aubergine"], char: "\u{1F346}", fitzpatrick_scale: !1, category: "food_and_drink" }, cucumber: { keywords: ["fruit", "food", "pickle"], char: "\u{1F952}", fitzpatrick_scale: !1, category: "food_and_drink" }, carrot: { keywords: ["vegetable", "food", "orange"], char: "\u{1F955}", fitzpatrick_scale: !1, category: "food_and_drink" }, hot_pepper: { keywords: ["food", "spicy", "chilli", "chili"], char: "\u{1F336}", fitzpatrick_scale: !1, category: "food_and_drink" }, potato: { keywords: ["food", "tuber", "vegatable", "starch"], char: "\u{1F954}", fitzpatrick_scale: !1, category: "food_and_drink" }, corn: { keywords: ["food", "vegetable", "plant"], char: "\u{1F33D}", fitzpatrick_scale: !1, category: "food_and_drink" }, leafy_greens: { keywords: ["food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce"], char: "\u{1F96C}", fitzpatrick_scale: !1, category: "food_and_drink" }, sweet_potato: { keywords: ["food", "nature"], char: "\u{1F360}", fitzpatrick_scale: !1, category: "food_and_drink" }, peanuts: { keywords: ["food", "nut"], char: "\u{1F95C}", fitzpatrick_scale: !1, category: "food_and_drink" }, honey_pot: { keywords: ["bees", "sweet", "kitchen"], char: "\u{1F36F}", fitzpatrick_scale: !1, category: "food_and_drink" }, croissant: { keywords: ["food", "bread", "french"], char: "\u{1F950}", fitzpatrick_scale: !1, category: "food_and_drink" }, bread: { keywords: ["food", "wheat", "breakfast", "toast"], char: "\u{1F35E}", fitzpatrick_scale: !1, category: "food_and_drink" }, baguette_bread: { keywords: ["food", "bread", "french"], char: "\u{1F956}", fitzpatrick_scale: !1, category: "food_and_drink" }, bagel: { keywords: ["food", "bread", "bakery", "schmear"], char: "\u{1F96F}", fitzpatrick_scale: !1, category: "food_and_drink" }, pretzel: { keywords: ["food", "bread", "twisted"], char: "\u{1F968}", fitzpatrick_scale: !1, category: "food_and_drink" }, cheese: { keywords: ["food", "chadder"], char: "\u{1F9C0}", fitzpatrick_scale: !1, category: "food_and_drink" }, egg: { keywords: ["food", "chicken", "breakfast"], char: "\u{1F95A}", fitzpatrick_scale: !1, category: "food_and_drink" }, bacon: { keywords: ["food", "breakfast", "pork", "pig", "meat"], char: "\u{1F953}", fitzpatrick_scale: !1, category: "food_and_drink" }, steak: { keywords: ["food", "cow", "meat", "cut", "chop", "lambchop", "porkchop"], char: "\u{1F969}", fitzpatrick_scale: !1, category: "food_and_drink" }, pancakes: { keywords: ["food", "breakfast", "flapjacks", "hotcakes"], char: "\u{1F95E}", fitzpatrick_scale: !1, category: "food_and_drink" }, poultry_leg: { keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"], char: "\u{1F357}", fitzpatrick_scale: !1, category: "food_and_drink" }, meat_on_bone: { keywords: ["good", "food", "drumstick"], char: "\u{1F356}", fitzpatrick_scale: !1, category: "food_and_drink" }, bone: { keywords: ["skeleton"], char: "\u{1F9B4}", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_shrimp: { keywords: ["food", "animal", "appetizer", "summer"], char: "\u{1F364}", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_egg: { keywords: ["food", "breakfast", "kitchen", "egg"], char: "\u{1F373}", fitzpatrick_scale: !1, category: "food_and_drink" }, hamburger: { keywords: ["meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king"], char: "\u{1F354}", fitzpatrick_scale: !1, category: "food_and_drink" }, fries: { keywords: ["chips", "snack", "fast food"], char: "\u{1F35F}", fitzpatrick_scale: !1, category: "food_and_drink" }, stuffed_flatbread: { keywords: ["food", "flatbread", "stuffed", "gyro"], char: "\u{1F959}", fitzpatrick_scale: !1, category: "food_and_drink" }, hotdog: { keywords: ["food", "frankfurter"], char: "\u{1F32D}", fitzpatrick_scale: !1, category: "food_and_drink" }, pizza: { keywords: ["food", "party"], char: "\u{1F355}", fitzpatrick_scale: !1, category: "food_and_drink" }, sandwich: { keywords: ["food", "lunch", "bread"], char: "\u{1F96A}", fitzpatrick_scale: !1, category: "food_and_drink" }, canned_food: { keywords: ["food", "soup"], char: "\u{1F96B}", fitzpatrick_scale: !1, category: "food_and_drink" }, spaghetti: { keywords: ["food", "italian", "noodle"], char: "\u{1F35D}", fitzpatrick_scale: !1, category: "food_and_drink" }, taco: { keywords: ["food", "mexican"], char: "\u{1F32E}", fitzpatrick_scale: !1, category: "food_and_drink" }, burrito: { keywords: ["food", "mexican"], char: "\u{1F32F}", fitzpatrick_scale: !1, category: "food_and_drink" }, green_salad: { keywords: ["food", "healthy", "lettuce"], char: "\u{1F957}", fitzpatrick_scale: !1, category: "food_and_drink" }, shallow_pan_of_food: { keywords: ["food", "cooking", "casserole", "paella"], char: "\u{1F958}", fitzpatrick_scale: !1, category: "food_and_drink" }, ramen: { keywords: ["food", "japanese", "noodle", "chopsticks"], char: "\u{1F35C}", fitzpatrick_scale: !1, category: "food_and_drink" }, stew: { keywords: ["food", "meat", "soup"], char: "\u{1F372}", fitzpatrick_scale: !1, category: "food_and_drink" }, fish_cake: { keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen"], char: "\u{1F365}", fitzpatrick_scale: !1, category: "food_and_drink" }, fortune_cookie: { keywords: ["food", "prophecy"], char: "\u{1F960}", fitzpatrick_scale: !1, category: "food_and_drink" }, sushi: { keywords: ["food", "fish", "japanese", "rice"], char: "\u{1F363}", fitzpatrick_scale: !1, category: "food_and_drink" }, bento: { keywords: ["food", "japanese", "box"], char: "\u{1F371}", fitzpatrick_scale: !1, category: "food_and_drink" }, curry: { keywords: ["food", "spicy", "hot", "indian"], char: "\u{1F35B}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_ball: { keywords: ["food", "japanese"], char: "\u{1F359}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice: { keywords: ["food", "china", "asian"], char: "\u{1F35A}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_cracker: { keywords: ["food", "japanese"], char: "\u{1F358}", fitzpatrick_scale: !1, category: "food_and_drink" }, oden: { keywords: ["food", "japanese"], char: "\u{1F362}", fitzpatrick_scale: !1, category: "food_and_drink" }, dango: { keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"], char: "\u{1F361}", fitzpatrick_scale: !1, category: "food_and_drink" }, shaved_ice: { keywords: ["hot", "dessert", "summer"], char: "\u{1F367}", fitzpatrick_scale: !1, category: "food_and_drink" }, ice_cream: { keywords: ["food", "hot", "dessert"], char: "\u{1F368}", fitzpatrick_scale: !1, category: "food_and_drink" }, icecream: { keywords: ["food", "hot", "dessert", "summer"], char: "\u{1F366}", fitzpatrick_scale: !1, category: "food_and_drink" }, pie: { keywords: ["food", "dessert", "pastry"], char: "\u{1F967}", fitzpatrick_scale: !1, category: "food_and_drink" }, cake: { keywords: ["food", "dessert"], char: "\u{1F370}", fitzpatrick_scale: !1, category: "food_and_drink" }, cupcake: { keywords: ["food", "dessert", "bakery", "sweet"], char: "\u{1F9C1}", fitzpatrick_scale: !1, category: "food_and_drink" }, moon_cake: { keywords: ["food", "autumn"], char: "\u{1F96E}", fitzpatrick_scale: !1, category: "food_and_drink" }, birthday: { keywords: ["food", "dessert", "cake"], char: "\u{1F382}", fitzpatrick_scale: !1, category: "food_and_drink" }, custard: { keywords: ["dessert", "food"], char: "\u{1F36E}", fitzpatrick_scale: !1, category: "food_and_drink" }, candy: { keywords: ["snack", "dessert", "sweet", "lolly"], char: "\u{1F36C}", fitzpatrick_scale: !1, category: "food_and_drink" }, lollipop: { keywords: ["food", "snack", "candy", "sweet"], char: "\u{1F36D}", fitzpatrick_scale: !1, category: "food_and_drink" }, chocolate_bar: { keywords: ["food", "snack", "dessert", "sweet"], char: "\u{1F36B}", fitzpatrick_scale: !1, category: "food_and_drink" }, popcorn: { keywords: ["food", "movie theater", "films", "snack"], char: "\u{1F37F}", fitzpatrick_scale: !1, category: "food_and_drink" }, dumpling: { keywords: ["food", "empanada", "pierogi", "potsticker"], char: "\u{1F95F}", fitzpatrick_scale: !1, category: "food_and_drink" }, doughnut: { keywords: ["food", "dessert", "snack", "sweet", "donut"], char: "\u{1F369}", fitzpatrick_scale: !1, category: "food_and_drink" }, cookie: { keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"], char: "\u{1F36A}", fitzpatrick_scale: !1, category: "food_and_drink" }, milk_glass: { keywords: ["beverage", "drink", "cow"], char: "\u{1F95B}", fitzpatrick_scale: !1, category: "food_and_drink" }, beer: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "\u{1F37A}", fitzpatrick_scale: !1, category: "food_and_drink" }, beers: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "\u{1F37B}", fitzpatrick_scale: !1, category: "food_and_drink" }, clinking_glasses: { keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"], char: "\u{1F942}", fitzpatrick_scale: !1, category: "food_and_drink" }, wine_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "booze"], char: "\u{1F377}", fitzpatrick_scale: !1, category: "food_and_drink" }, tumbler_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot"], char: "\u{1F943}", fitzpatrick_scale: !1, category: "food_and_drink" }, cocktail: { keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"], char: "\u{1F378}", fitzpatrick_scale: !1, category: "food_and_drink" }, tropical_drink: { keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"], char: "\u{1F379}", fitzpatrick_scale: !1, category: "food_and_drink" }, champagne: { keywords: ["drink", "wine", "bottle", "celebration"], char: "\u{1F37E}", fitzpatrick_scale: !1, category: "food_and_drink" }, sake: { keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"], char: "\u{1F376}", fitzpatrick_scale: !1, category: "food_and_drink" }, tea: { keywords: ["drink", "bowl", "breakfast", "green", "british"], char: "\u{1F375}", fitzpatrick_scale: !1, category: "food_and_drink" }, cup_with_straw: { keywords: ["drink", "soda"], char: "\u{1F964}", fitzpatrick_scale: !1, category: "food_and_drink" }, coffee: { keywords: ["beverage", "caffeine", "latte", "espresso"], char: "\u2615", fitzpatrick_scale: !1, category: "food_and_drink" }, baby_bottle: { keywords: ["food", "container", "milk"], char: "\u{1F37C}", fitzpatrick_scale: !1, category: "food_and_drink" }, salt: { keywords: ["condiment", "shaker"], char: "\u{1F9C2}", fitzpatrick_scale: !1, category: "food_and_drink" }, spoon: { keywords: ["cutlery", "kitchen", "tableware"], char: "\u{1F944}", fitzpatrick_scale: !1, category: "food_and_drink" }, fork_and_knife: { keywords: ["cutlery", "kitchen"], char: "\u{1F374}", fitzpatrick_scale: !1, category: "food_and_drink" }, plate_with_cutlery: { keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"], char: "\u{1F37D}", fitzpatrick_scale: !1, category: "food_and_drink" }, bowl_with_spoon: { keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"], char: "\u{1F963}", fitzpatrick_scale: !1, category: "food_and_drink" }, takeout_box: { keywords: ["food", "leftovers"], char: "\u{1F961}", fitzpatrick_scale: !1, category: "food_and_drink" }, chopsticks: { keywords: ["food"], char: "\u{1F962}", fitzpatrick_scale: !1, category: "food_and_drink" }, soccer: { keywords: ["sports", "football"], char: "\u26BD", fitzpatrick_scale: !1, category: "activity" }, basketball: { keywords: ["sports", "balls", "NBA"], char: "\u{1F3C0}", fitzpatrick_scale: !1, category: "activity" }, football: { keywords: ["sports", "balls", "NFL"], char: "\u{1F3C8}", fitzpatrick_scale: !1, category: "activity" }, baseball: { keywords: ["sports", "balls"], char: "\u26BE", fitzpatrick_scale: !1, category: "activity" }, softball: { keywords: ["sports", "balls"], char: "\u{1F94E}", fitzpatrick_scale: !1, category: "activity" }, tennis: { keywords: ["sports", "balls", "green"], char: "\u{1F3BE}", fitzpatrick_scale: !1, category: "activity" }, volleyball: { keywords: ["sports", "balls"], char: "\u{1F3D0}", fitzpatrick_scale: !1, category: "activity" }, rugby_football: { keywords: ["sports", "team"], char: "\u{1F3C9}", fitzpatrick_scale: !1, category: "activity" }, flying_disc: { keywords: ["sports", "frisbee", "ultimate"], char: "\u{1F94F}", fitzpatrick_scale: !1, category: "activity" }, "8ball": { keywords: ["pool", "hobby", "game", "luck", "magic"], char: "\u{1F3B1}", fitzpatrick_scale: !1, category: "activity" }, golf: { keywords: ["sports", "business", "flag", "hole", "summer"], char: "\u26F3", fitzpatrick_scale: !1, category: "activity" }, golfing_woman: { keywords: ["sports", "business", "woman", "female"], char: "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "activity" }, golfing_man: { keywords: ["sports", "business"], char: "\u{1F3CC}", fitzpatrick_scale: !0, category: "activity" }, ping_pong: { keywords: ["sports", "pingpong"], char: "\u{1F3D3}", fitzpatrick_scale: !1, category: "activity" }, badminton: { keywords: ["sports"], char: "\u{1F3F8}", fitzpatrick_scale: !1, category: "activity" }, goal_net: { keywords: ["sports"], char: "\u{1F945}", fitzpatrick_scale: !1, category: "activity" }, ice_hockey: { keywords: ["sports"], char: "\u{1F3D2}", fitzpatrick_scale: !1, category: "activity" }, field_hockey: { keywords: ["sports"], char: "\u{1F3D1}", fitzpatrick_scale: !1, category: "activity" }, lacrosse: { keywords: ["sports", "ball", "stick"], char: "\u{1F94D}", fitzpatrick_scale: !1, category: "activity" }, cricket: { keywords: ["sports"], char: "\u{1F3CF}", fitzpatrick_scale: !1, category: "activity" }, ski: { keywords: ["sports", "winter", "cold", "snow"], char: "\u{1F3BF}", fitzpatrick_scale: !1, category: "activity" }, skier: { keywords: ["sports", "winter", "snow"], char: "\u26F7", fitzpatrick_scale: !1, category: "activity" }, snowboarder: { keywords: ["sports", "winter"], char: "\u{1F3C2}", fitzpatrick_scale: !0, category: "activity" }, person_fencing: { keywords: ["sports", "fencing", "sword"], char: "\u{1F93A}", fitzpatrick_scale: !1, category: "activity" }, women_wrestling: { keywords: ["sports", "wrestlers"], char: "\u{1F93C}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "activity" }, men_wrestling: { keywords: ["sports", "wrestlers"], char: "\u{1F93C}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "activity" }, woman_cartwheeling: { keywords: ["gymnastics"], char: "\u{1F938}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_cartwheeling: { keywords: ["gymnastics"], char: "\u{1F938}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, woman_playing_handball: { keywords: ["sports"], char: "\u{1F93E}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_playing_handball: { keywords: ["sports"], char: "\u{1F93E}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, ice_skate: { keywords: ["sports"], char: "\u26F8", fitzpatrick_scale: !1, category: "activity" }, curling_stone: { keywords: ["sports"], char: "\u{1F94C}", fitzpatrick_scale: !1, category: "activity" }, skateboard: { keywords: ["board"], char: "\u{1F6F9}", fitzpatrick_scale: !1, category: "activity" }, sled: { keywords: ["sleigh", "luge", "toboggan"], char: "\u{1F6F7}", fitzpatrick_scale: !1, category: "activity" }, bow_and_arrow: { keywords: ["sports"], char: "\u{1F3F9}", fitzpatrick_scale: !1, category: "activity" }, fishing_pole_and_fish: { keywords: ["food", "hobby", "summer"], char: "\u{1F3A3}", fitzpatrick_scale: !1, category: "activity" }, boxing_glove: { keywords: ["sports", "fighting"], char: "\u{1F94A}", fitzpatrick_scale: !1, category: "activity" }, martial_arts_uniform: { keywords: ["judo", "karate", "taekwondo"], char: "\u{1F94B}", fitzpatrick_scale: !1, category: "activity" }, rowing_woman: { keywords: ["sports", "hobby", "water", "ship", "woman", "female"], char: "\u{1F6A3}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, rowing_man: { keywords: ["sports", "hobby", "water", "ship"], char: "\u{1F6A3}", fitzpatrick_scale: !0, category: "activity" }, climbing_woman: { keywords: ["sports", "hobby", "woman", "female", "rock"], char: "\u{1F9D7}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, climbing_man: { keywords: ["sports", "hobby", "man", "male", "rock"], char: "\u{1F9D7}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, swimming_woman: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "woman", "female"], char: "\u{1F3CA}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, swimming_man: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer"], char: "\u{1F3CA}", fitzpatrick_scale: !0, category: "activity" }, woman_playing_water_polo: { keywords: ["sports", "pool"], char: "\u{1F93D}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_playing_water_polo: { keywords: ["sports", "pool"], char: "\u{1F93D}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, woman_in_lotus_position: { keywords: ["woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "\u{1F9D8}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_in_lotus_position: { keywords: ["man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "\u{1F9D8}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, surfing_woman: { keywords: ["sports", "ocean", "sea", "summer", "beach", "woman", "female"], char: "\u{1F3C4}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, surfing_man: { keywords: ["sports", "ocean", "sea", "summer", "beach"], char: "\u{1F3C4}", fitzpatrick_scale: !0, category: "activity" }, bath: { keywords: ["clean", "shower", "bathroom"], char: "\u{1F6C0}", fitzpatrick_scale: !0, category: "activity" }, basketball_woman: { keywords: ["sports", "human", "woman", "female"], char: "\u26F9\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, basketball_man: { keywords: ["sports", "human"], char: "\u26F9", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_woman: { keywords: ["sports", "training", "exercise", "woman", "female"], char: "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_man: { keywords: ["sports", "training", "exercise"], char: "\u{1F3CB}", fitzpatrick_scale: !0, category: "activity" }, biking_woman: { keywords: ["sports", "bike", "exercise", "hipster", "woman", "female"], char: "\u{1F6B4}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, biking_man: { keywords: ["sports", "bike", "exercise", "hipster"], char: "\u{1F6B4}", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_woman: { keywords: ["transportation", "sports", "human", "race", "bike", "woman", "female"], char: "\u{1F6B5}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_man: { keywords: ["transportation", "sports", "human", "race", "bike"], char: "\u{1F6B5}", fitzpatrick_scale: !0, category: "activity" }, horse_racing: { keywords: ["animal", "betting", "competition", "gambling", "luck"], char: "\u{1F3C7}", fitzpatrick_scale: !0, category: "activity" }, business_suit_levitating: { keywords: ["suit", "business", "levitate", "hover", "jump"], char: "\u{1F574}", fitzpatrick_scale: !0, category: "activity" }, trophy: { keywords: ["win", "award", "contest", "place", "ftw", "ceremony"], char: "\u{1F3C6}", fitzpatrick_scale: !1, category: "activity" }, running_shirt_with_sash: { keywords: ["play", "pageant"], char: "\u{1F3BD}", fitzpatrick_scale: !1, category: "activity" }, medal_sports: { keywords: ["award", "winning"], char: "\u{1F3C5}", fitzpatrick_scale: !1, category: "activity" }, medal_military: { keywords: ["award", "winning", "army"], char: "\u{1F396}", fitzpatrick_scale: !1, category: "activity" }, "1st_place_medal": { keywords: ["award", "winning", "first"], char: "\u{1F947}", fitzpatrick_scale: !1, category: "activity" }, "2nd_place_medal": { keywords: ["award", "second"], char: "\u{1F948}", fitzpatrick_scale: !1, category: "activity" }, "3rd_place_medal": { keywords: ["award", "third"], char: "\u{1F949}", fitzpatrick_scale: !1, category: "activity" }, reminder_ribbon: { keywords: ["sports", "cause", "support", "awareness"], char: "\u{1F397}", fitzpatrick_scale: !1, category: "activity" }, rosette: { keywords: ["flower", "decoration", "military"], char: "\u{1F3F5}", fitzpatrick_scale: !1, category: "activity" }, ticket: { keywords: ["event", "concert", "pass"], char: "\u{1F3AB}", fitzpatrick_scale: !1, category: "activity" }, tickets: { keywords: ["sports", "concert", "entrance"], char: "\u{1F39F}", fitzpatrick_scale: !1, category: "activity" }, performing_arts: { keywords: ["acting", "theater", "drama"], char: "\u{1F3AD}", fitzpatrick_scale: !1, category: "activity" }, art: { keywords: ["design", "paint", "draw", "colors"], char: "\u{1F3A8}", fitzpatrick_scale: !1, category: "activity" }, circus_tent: { keywords: ["festival", "carnival", "party"], char: "\u{1F3AA}", fitzpatrick_scale: !1, category: "activity" }, woman_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "\u{1F939}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "\u{1F939}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, microphone: { keywords: ["sound", "music", "PA", "sing", "talkshow"], char: "\u{1F3A4}", fitzpatrick_scale: !1, category: "activity" }, headphones: { keywords: ["music", "score", "gadgets"], char: "\u{1F3A7}", fitzpatrick_scale: !1, category: "activity" }, musical_score: { keywords: ["treble", "clef", "compose"], char: "\u{1F3BC}", fitzpatrick_scale: !1, category: "activity" }, musical_keyboard: { keywords: ["piano", "instrument", "compose"], char: "\u{1F3B9}", fitzpatrick_scale: !1, category: "activity" }, drum: { keywords: ["music", "instrument", "drumsticks", "snare"], char: "\u{1F941}", fitzpatrick_scale: !1, category: "activity" }, saxophone: { keywords: ["music", "instrument", "jazz", "blues"], char: "\u{1F3B7}", fitzpatrick_scale: !1, category: "activity" }, trumpet: { keywords: ["music", "brass"], char: "\u{1F3BA}", fitzpatrick_scale: !1, category: "activity" }, guitar: { keywords: ["music", "instrument"], char: "\u{1F3B8}", fitzpatrick_scale: !1, category: "activity" }, violin: { keywords: ["music", "instrument", "orchestra", "symphony"], char: "\u{1F3BB}", fitzpatrick_scale: !1, category: "activity" }, clapper: { keywords: ["movie", "film", "record"], char: "\u{1F3AC}", fitzpatrick_scale: !1, category: "activity" }, video_game: { keywords: ["play", "console", "PS4", "controller"], char: "\u{1F3AE}", fitzpatrick_scale: !1, category: "activity" }, space_invader: { keywords: ["game", "arcade", "play"], char: "\u{1F47E}", fitzpatrick_scale: !1, category: "activity" }, dart: { keywords: ["game", "play", "bar", "target", "bullseye"], char: "\u{1F3AF}", fitzpatrick_scale: !1, category: "activity" }, game_die: { keywords: ["dice", "random", "tabletop", "play", "luck"], char: "\u{1F3B2}", fitzpatrick_scale: !1, category: "activity" }, chess_pawn: { keywords: ["expendable"], char: "\u265F", fitzpatrick_scale: !1, category: "activity" }, slot_machine: { keywords: ["bet", "gamble", "vegas", "fruit machine", "luck", "casino"], char: "\u{1F3B0}", fitzpatrick_scale: !1, category: "activity" }, jigsaw: { keywords: ["interlocking", "puzzle", "piece"], char: "\u{1F9E9}", fitzpatrick_scale: !1, category: "activity" }, bowling: { keywords: ["sports", "fun", "play"], char: "\u{1F3B3}", fitzpatrick_scale: !1, category: "activity" }, red_car: { keywords: ["red", "transportation", "vehicle"], char: "\u{1F697}", fitzpatrick_scale: !1, category: "travel_and_places" }, taxi: { keywords: ["uber", "vehicle", "cars", "transportation"], char: "\u{1F695}", fitzpatrick_scale: !1, category: "travel_and_places" }, blue_car: { keywords: ["transportation", "vehicle"], char: "\u{1F699}", fitzpatrick_scale: !1, category: "travel_and_places" }, bus: { keywords: ["car", "vehicle", "transportation"], char: "\u{1F68C}", fitzpatrick_scale: !1, category: "travel_and_places" }, trolleybus: { keywords: ["bart", "transportation", "vehicle"], char: "\u{1F68E}", fitzpatrick_scale: !1, category: "travel_and_places" }, racing_car: { keywords: ["sports", "race", "fast", "formula", "f1"], char: "\u{1F3CE}", fitzpatrick_scale: !1, category: "travel_and_places" }, police_car: { keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"], char: "\u{1F693}", fitzpatrick_scale: !1, category: "travel_and_places" }, ambulance: { keywords: ["health", "911", "hospital"], char: "\u{1F691}", fitzpatrick_scale: !1, category: "travel_and_places" }, fire_engine: { keywords: ["transportation", "cars", "vehicle"], char: "\u{1F692}", fitzpatrick_scale: !1, category: "travel_and_places" }, minibus: { keywords: ["vehicle", "car", "transportation"], char: "\u{1F690}", fitzpatrick_scale: !1, category: "travel_and_places" }, truck: { keywords: ["cars", "transportation"], char: "\u{1F69A}", fitzpatrick_scale: !1, category: "travel_and_places" }, articulated_lorry: { keywords: ["vehicle", "cars", "transportation", "express"], char: "\u{1F69B}", fitzpatrick_scale: !1, category: "travel_and_places" }, tractor: { keywords: ["vehicle", "car", "farming", "agriculture"], char: "\u{1F69C}", fitzpatrick_scale: !1, category: "travel_and_places" }, kick_scooter: { keywords: ["vehicle", "kick", "razor"], char: "\u{1F6F4}", fitzpatrick_scale: !1, category: "travel_and_places" }, motorcycle: { keywords: ["race", "sports", "fast"], char: "\u{1F3CD}", fitzpatrick_scale: !1, category: "travel_and_places" }, bike: { keywords: ["sports", "bicycle", "exercise", "hipster"], char: "\u{1F6B2}", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_scooter: { keywords: ["vehicle", "vespa", "sasha"], char: "\u{1F6F5}", fitzpatrick_scale: !1, category: "travel_and_places" }, rotating_light: { keywords: ["police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"], char: "\u{1F6A8}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_police_car: { keywords: ["vehicle", "law", "legal", "enforcement", "911"], char: "\u{1F694}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_bus: { keywords: ["vehicle", "transportation"], char: "\u{1F68D}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_automobile: { keywords: ["car", "vehicle", "transportation"], char: "\u{1F698}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_taxi: { keywords: ["vehicle", "cars", "uber"], char: "\u{1F696}", fitzpatrick_scale: !1, category: "travel_and_places" }, aerial_tramway: { keywords: ["transportation", "vehicle", "ski"], char: "\u{1F6A1}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_cableway: { keywords: ["transportation", "vehicle", "ski"], char: "\u{1F6A0}", fitzpatrick_scale: !1, category: "travel_and_places" }, suspension_railway: { keywords: ["vehicle", "transportation"], char: "\u{1F69F}", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_car: { keywords: ["transportation", "vehicle"], char: "\u{1F683}", fitzpatrick_scale: !1, category: "travel_and_places" }, train: { keywords: ["transportation", "vehicle", "carriage", "public", "travel"], char: "\u{1F68B}", fitzpatrick_scale: !1, category: "travel_and_places" }, monorail: { keywords: ["transportation", "vehicle"], char: "\u{1F69D}", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_side: { keywords: ["transportation", "vehicle"], char: "\u{1F684}", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_front: { keywords: ["transportation", "vehicle", "speed", "fast", "public", "travel"], char: "\u{1F685}", fitzpatrick_scale: !1, category: "travel_and_places" }, light_rail: { keywords: ["transportation", "vehicle"], char: "\u{1F688}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_railway: { keywords: ["transportation", "vehicle"], char: "\u{1F69E}", fitzpatrick_scale: !1, category: "travel_and_places" }, steam_locomotive: { keywords: ["transportation", "vehicle", "train"], char: "\u{1F682}", fitzpatrick_scale: !1, category: "travel_and_places" }, train2: { keywords: ["transportation", "vehicle"], char: "\u{1F686}", fitzpatrick_scale: !1, category: "travel_and_places" }, metro: { keywords: ["transportation", "blue-square", "mrt", "underground", "tube"], char: "\u{1F687}", fitzpatrick_scale: !1, category: "travel_and_places" }, tram: { keywords: ["transportation", "vehicle"], char: "\u{1F68A}", fitzpatrick_scale: !1, category: "travel_and_places" }, station: { keywords: ["transportation", "vehicle", "public"], char: "\u{1F689}", fitzpatrick_scale: !1, category: "travel_and_places" }, flying_saucer: { keywords: ["transportation", "vehicle", "ufo"], char: "\u{1F6F8}", fitzpatrick_scale: !1, category: "travel_and_places" }, helicopter: { keywords: ["transportation", "vehicle", "fly"], char: "\u{1F681}", fitzpatrick_scale: !1, category: "travel_and_places" }, small_airplane: { keywords: ["flight", "transportation", "fly", "vehicle"], char: "\u{1F6E9}", fitzpatrick_scale: !1, category: "travel_and_places" }, airplane: { keywords: ["vehicle", "transportation", "flight", "fly"], char: "\u2708\uFE0F", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_departure: { keywords: ["airport", "flight", "landing"], char: "\u{1F6EB}", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_arrival: { keywords: ["airport", "flight", "boarding"], char: "\u{1F6EC}", fitzpatrick_scale: !1, category: "travel_and_places" }, sailboat: { keywords: ["ship", "summer", "transportation", "water", "sailing"], char: "\u26F5", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_boat: { keywords: ["ship"], char: "\u{1F6E5}", fitzpatrick_scale: !1, category: "travel_and_places" }, speedboat: { keywords: ["ship", "transportation", "vehicle", "summer"], char: "\u{1F6A4}", fitzpatrick_scale: !1, category: "travel_and_places" }, ferry: { keywords: ["boat", "ship", "yacht"], char: "\u26F4", fitzpatrick_scale: !1, category: "travel_and_places" }, passenger_ship: { keywords: ["yacht", "cruise", "ferry"], char: "\u{1F6F3}", fitzpatrick_scale: !1, category: "travel_and_places" }, rocket: { keywords: ["launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly"], char: "\u{1F680}", fitzpatrick_scale: !1, category: "travel_and_places" }, artificial_satellite: { keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"], char: "\u{1F6F0}", fitzpatrick_scale: !1, category: "travel_and_places" }, seat: { keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"], char: "\u{1F4BA}", fitzpatrick_scale: !1, category: "travel_and_places" }, canoe: { keywords: ["boat", "paddle", "water", "ship"], char: "\u{1F6F6}", fitzpatrick_scale: !1, category: "travel_and_places" }, anchor: { keywords: ["ship", "ferry", "sea", "boat"], char: "\u2693", fitzpatrick_scale: !1, category: "travel_and_places" }, construction: { keywords: ["wip", "progress", "caution", "warning"], char: "\u{1F6A7}", fitzpatrick_scale: !1, category: "travel_and_places" }, fuelpump: { keywords: ["gas station", "petroleum"], char: "\u26FD", fitzpatrick_scale: !1, category: "travel_and_places" }, busstop: { keywords: ["transportation", "wait"], char: "\u{1F68F}", fitzpatrick_scale: !1, category: "travel_and_places" }, vertical_traffic_light: { keywords: ["transportation", "driving"], char: "\u{1F6A6}", fitzpatrick_scale: !1, category: "travel_and_places" }, traffic_light: { keywords: ["transportation", "signal"], char: "\u{1F6A5}", fitzpatrick_scale: !1, category: "travel_and_places" }, checkered_flag: { keywords: ["contest", "finishline", "race", "gokart"], char: "\u{1F3C1}", fitzpatrick_scale: !1, category: "travel_and_places" }, ship: { keywords: ["transportation", "titanic", "deploy"], char: "\u{1F6A2}", fitzpatrick_scale: !1, category: "travel_and_places" }, ferris_wheel: { keywords: ["photo", "carnival", "londoneye"], char: "\u{1F3A1}", fitzpatrick_scale: !1, category: "travel_and_places" }, roller_coaster: { keywords: ["carnival", "playground", "photo", "fun"], char: "\u{1F3A2}", fitzpatrick_scale: !1, category: "travel_and_places" }, carousel_horse: { keywords: ["photo", "carnival"], char: "\u{1F3A0}", fitzpatrick_scale: !1, category: "travel_and_places" }, building_construction: { keywords: ["wip", "working", "progress"], char: "\u{1F3D7}", fitzpatrick_scale: !1, category: "travel_and_places" }, foggy: { keywords: ["photo", "mountain"], char: "\u{1F301}", fitzpatrick_scale: !1, category: "travel_and_places" }, tokyo_tower: { keywords: ["photo", "japanese"], char: "\u{1F5FC}", fitzpatrick_scale: !1, category: "travel_and_places" }, factory: { keywords: ["building", "industry", "pollution", "smoke"], char: "\u{1F3ED}", fitzpatrick_scale: !1, category: "travel_and_places" }, fountain: { keywords: ["photo", "summer", "water", "fresh"], char: "\u26F2", fitzpatrick_scale: !1, category: "travel_and_places" }, rice_scene: { keywords: ["photo", "japan", "asia", "tsukimi"], char: "\u{1F391}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain: { keywords: ["photo", "nature", "environment"], char: "\u26F0", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_snow: { keywords: ["photo", "nature", "environment", "winter", "cold"], char: "\u{1F3D4}", fitzpatrick_scale: !1, category: "travel_and_places" }, mount_fuji: { keywords: ["photo", "mountain", "nature", "japanese"], char: "\u{1F5FB}", fitzpatrick_scale: !1, category: "travel_and_places" }, volcano: { keywords: ["photo", "nature", "disaster"], char: "\u{1F30B}", fitzpatrick_scale: !1, category: "travel_and_places" }, japan: { keywords: ["nation", "country", "japanese", "asia"], char: "\u{1F5FE}", fitzpatrick_scale: !1, category: "travel_and_places" }, camping: { keywords: ["photo", "outdoors", "tent"], char: "\u{1F3D5}", fitzpatrick_scale: !1, category: "travel_and_places" }, tent: { keywords: ["photo", "camping", "outdoors"], char: "\u26FA", fitzpatrick_scale: !1, category: "travel_and_places" }, national_park: { keywords: ["photo", "environment", "nature"], char: "\u{1F3DE}", fitzpatrick_scale: !1, category: "travel_and_places" }, motorway: { keywords: ["road", "cupertino", "interstate", "highway"], char: "\u{1F6E3}", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_track: { keywords: ["train", "transportation"], char: "\u{1F6E4}", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise: { keywords: ["morning", "view", "vacation", "photo"], char: "\u{1F305}", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise_over_mountains: { keywords: ["view", "vacation", "photo"], char: "\u{1F304}", fitzpatrick_scale: !1, category: "travel_and_places" }, desert: { keywords: ["photo", "warm", "saharah"], char: "\u{1F3DC}", fitzpatrick_scale: !1, category: "travel_and_places" }, beach_umbrella: { keywords: ["weather", "summer", "sunny", "sand", "mojito"], char: "\u{1F3D6}", fitzpatrick_scale: !1, category: "travel_and_places" }, desert_island: { keywords: ["photo", "tropical", "mojito"], char: "\u{1F3DD}", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunrise: { keywords: ["photo", "good morning", "dawn"], char: "\u{1F307}", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunset: { keywords: ["photo", "evening", "sky", "buildings"], char: "\u{1F306}", fitzpatrick_scale: !1, category: "travel_and_places" }, cityscape: { keywords: ["photo", "night life", "urban"], char: "\u{1F3D9}", fitzpatrick_scale: !1, category: "travel_and_places" }, night_with_stars: { keywords: ["evening", "city", "downtown"], char: "\u{1F303}", fitzpatrick_scale: !1, category: "travel_and_places" }, bridge_at_night: { keywords: ["photo", "sanfrancisco"], char: "\u{1F309}", fitzpatrick_scale: !1, category: "travel_and_places" }, milky_way: { keywords: ["photo", "space", "stars"], char: "\u{1F30C}", fitzpatrick_scale: !1, category: "travel_and_places" }, stars: { keywords: ["night", "photo"], char: "\u{1F320}", fitzpatrick_scale: !1, category: "travel_and_places" }, sparkler: { keywords: ["stars", "night", "shine"], char: "\u{1F387}", fitzpatrick_scale: !1, category: "travel_and_places" }, fireworks: { keywords: ["photo", "festival", "carnival", "congratulations"], char: "\u{1F386}", fitzpatrick_scale: !1, category: "travel_and_places" }, rainbow: { keywords: ["nature", "happy", "unicorn_face", "photo", "sky", "spring"], char: "\u{1F308}", fitzpatrick_scale: !1, category: "travel_and_places" }, houses: { keywords: ["buildings", "photo"], char: "\u{1F3D8}", fitzpatrick_scale: !1, category: "travel_and_places" }, european_castle: { keywords: ["building", "royalty", "history"], char: "\u{1F3F0}", fitzpatrick_scale: !1, category: "travel_and_places" }, japanese_castle: { keywords: ["photo", "building"], char: "\u{1F3EF}", fitzpatrick_scale: !1, category: "travel_and_places" }, stadium: { keywords: ["photo", "place", "sports", "concert", "venue"], char: "\u{1F3DF}", fitzpatrick_scale: !1, category: "travel_and_places" }, statue_of_liberty: { keywords: ["american", "newyork"], char: "\u{1F5FD}", fitzpatrick_scale: !1, category: "travel_and_places" }, house: { keywords: ["building", "home"], char: "\u{1F3E0}", fitzpatrick_scale: !1, category: "travel_and_places" }, house_with_garden: { keywords: ["home", "plant", "nature"], char: "\u{1F3E1}", fitzpatrick_scale: !1, category: "travel_and_places" }, derelict_house: { keywords: ["abandon", "evict", "broken", "building"], char: "\u{1F3DA}", fitzpatrick_scale: !1, category: "travel_and_places" }, office: { keywords: ["building", "bureau", "work"], char: "\u{1F3E2}", fitzpatrick_scale: !1, category: "travel_and_places" }, department_store: { keywords: ["building", "shopping", "mall"], char: "\u{1F3EC}", fitzpatrick_scale: !1, category: "travel_and_places" }, post_office: { keywords: ["building", "envelope", "communication"], char: "\u{1F3E3}", fitzpatrick_scale: !1, category: "travel_and_places" }, european_post_office: { keywords: ["building", "email"], char: "\u{1F3E4}", fitzpatrick_scale: !1, category: "travel_and_places" }, hospital: { keywords: ["building", "health", "surgery", "doctor"], char: "\u{1F3E5}", fitzpatrick_scale: !1, category: "travel_and_places" }, bank: { keywords: ["building", "money", "sales", "cash", "business", "enterprise"], char: "\u{1F3E6}", fitzpatrick_scale: !1, category: "travel_and_places" }, hotel: { keywords: ["building", "accomodation", "checkin"], char: "\u{1F3E8}", fitzpatrick_scale: !1, category: "travel_and_places" }, convenience_store: { keywords: ["building", "shopping", "groceries"], char: "\u{1F3EA}", fitzpatrick_scale: !1, category: "travel_and_places" }, school: { keywords: ["building", "student", "education", "learn", "teach"], char: "\u{1F3EB}", fitzpatrick_scale: !1, category: "travel_and_places" }, love_hotel: { keywords: ["like", "affection", "dating"], char: "\u{1F3E9}", fitzpatrick_scale: !1, category: "travel_and_places" }, wedding: { keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"], char: "\u{1F492}", fitzpatrick_scale: !1, category: "travel_and_places" }, classical_building: { keywords: ["art", "culture", "history"], char: "\u{1F3DB}", fitzpatrick_scale: !1, category: "travel_and_places" }, church: { keywords: ["building", "religion", "christ"], char: "\u26EA", fitzpatrick_scale: !1, category: "travel_and_places" }, mosque: { keywords: ["islam", "worship", "minaret"], char: "\u{1F54C}", fitzpatrick_scale: !1, category: "travel_and_places" }, synagogue: { keywords: ["judaism", "worship", "temple", "jewish"], char: "\u{1F54D}", fitzpatrick_scale: !1, category: "travel_and_places" }, kaaba: { keywords: ["mecca", "mosque", "islam"], char: "\u{1F54B}", fitzpatrick_scale: !1, category: "travel_and_places" }, shinto_shrine: { keywords: ["temple", "japan", "kyoto"], char: "\u26E9", fitzpatrick_scale: !1, category: "travel_and_places" }, watch: { keywords: ["time", "accessories"], char: "\u231A", fitzpatrick_scale: !1, category: "objects" }, iphone: { keywords: ["technology", "apple", "gadgets", "dial"], char: "\u{1F4F1}", fitzpatrick_scale: !1, category: "objects" }, calling: { keywords: ["iphone", "incoming"], char: "\u{1F4F2}", fitzpatrick_scale: !1, category: "objects" }, computer: { keywords: ["technology", "laptop", "screen", "display", "monitor"], char: "\u{1F4BB}", fitzpatrick_scale: !1, category: "objects" }, keyboard: { keywords: ["technology", "computer", "type", "input", "text"], char: "\u2328", fitzpatrick_scale: !1, category: "objects" }, desktop_computer: { keywords: ["technology", "computing", "screen"], char: "\u{1F5A5}", fitzpatrick_scale: !1, category: "objects" }, printer: { keywords: ["paper", "ink"], char: "\u{1F5A8}", fitzpatrick_scale: !1, category: "objects" }, computer_mouse: { keywords: ["click"], char: "\u{1F5B1}", fitzpatrick_scale: !1, category: "objects" }, trackball: { keywords: ["technology", "trackpad"], char: "\u{1F5B2}", fitzpatrick_scale: !1, category: "objects" }, joystick: { keywords: ["game", "play"], char: "\u{1F579}", fitzpatrick_scale: !1, category: "objects" }, clamp: { keywords: ["tool"], char: "\u{1F5DC}", fitzpatrick_scale: !1, category: "objects" }, minidisc: { keywords: ["technology", "record", "data", "disk", "90s"], char: "\u{1F4BD}", fitzpatrick_scale: !1, category: "objects" }, floppy_disk: { keywords: ["oldschool", "technology", "save", "90s", "80s"], char: "\u{1F4BE}", fitzpatrick_scale: !1, category: "objects" }, cd: { keywords: ["technology", "dvd", "disk", "disc", "90s"], char: "\u{1F4BF}", fitzpatrick_scale: !1, category: "objects" }, dvd: { keywords: ["cd", "disk", "disc"], char: "\u{1F4C0}", fitzpatrick_scale: !1, category: "objects" }, vhs: { keywords: ["record", "video", "oldschool", "90s", "80s"], char: "\u{1F4FC}", fitzpatrick_scale: !1, category: "objects" }, camera: { keywords: ["gadgets", "photography"], char: "\u{1F4F7}", fitzpatrick_scale: !1, category: "objects" }, camera_flash: { keywords: ["photography", "gadgets"], char: "\u{1F4F8}", fitzpatrick_scale: !1, category: "objects" }, video_camera: { keywords: ["film", "record"], char: "\u{1F4F9}", fitzpatrick_scale: !1, category: "objects" }, movie_camera: { keywords: ["film", "record"], char: "\u{1F3A5}", fitzpatrick_scale: !1, category: "objects" }, film_projector: { keywords: ["video", "tape", "record", "movie"], char: "\u{1F4FD}", fitzpatrick_scale: !1, category: "objects" }, film_strip: { keywords: ["movie"], char: "\u{1F39E}", fitzpatrick_scale: !1, category: "objects" }, telephone_receiver: { keywords: ["technology", "communication", "dial"], char: "\u{1F4DE}", fitzpatrick_scale: !1, category: "objects" }, phone: { keywords: ["technology", "communication", "dial", "telephone"], char: "\u260E\uFE0F", fitzpatrick_scale: !1, category: "objects" }, pager: { keywords: ["bbcall", "oldschool", "90s"], char: "\u{1F4DF}", fitzpatrick_scale: !1, category: "objects" }, fax: { keywords: ["communication", "technology"], char: "\u{1F4E0}", fitzpatrick_scale: !1, category: "objects" }, tv: { keywords: ["technology", "program", "oldschool", "show", "television"], char: "\u{1F4FA}", fitzpatrick_scale: !1, category: "objects" }, radio: { keywords: ["communication", "music", "podcast", "program"], char: "\u{1F4FB}", fitzpatrick_scale: !1, category: "objects" }, studio_microphone: { keywords: ["sing", "recording", "artist", "talkshow"], char: "\u{1F399}", fitzpatrick_scale: !1, category: "objects" }, level_slider: { keywords: ["scale"], char: "\u{1F39A}", fitzpatrick_scale: !1, category: "objects" }, control_knobs: { keywords: ["dial"], char: "\u{1F39B}", fitzpatrick_scale: !1, category: "objects" }, compass: { keywords: ["magnetic", "navigation", "orienteering"], char: "\u{1F9ED}", fitzpatrick_scale: !1, category: "objects" }, stopwatch: { keywords: ["time", "deadline"], char: "\u23F1", fitzpatrick_scale: !1, category: "objects" }, timer_clock: { keywords: ["alarm"], char: "\u23F2", fitzpatrick_scale: !1, category: "objects" }, alarm_clock: { keywords: ["time", "wake"], char: "\u23F0", fitzpatrick_scale: !1, category: "objects" }, mantelpiece_clock: { keywords: ["time"], char: "\u{1F570}", fitzpatrick_scale: !1, category: "objects" }, hourglass_flowing_sand: { keywords: ["oldschool", "time", "countdown"], char: "\u23F3", fitzpatrick_scale: !1, category: "objects" }, hourglass: { keywords: ["time", "clock", "oldschool", "limit", "exam", "quiz", "test"], char: "\u231B", fitzpatrick_scale: !1, category: "objects" }, satellite: { keywords: ["communication", "future", "radio", "space"], char: "\u{1F4E1}", fitzpatrick_scale: !1, category: "objects" }, battery: { keywords: ["power", "energy", "sustain"], char: "\u{1F50B}", fitzpatrick_scale: !1, category: "objects" }, electric_plug: { keywords: ["charger", "power"], char: "\u{1F50C}", fitzpatrick_scale: !1, category: "objects" }, bulb: { keywords: ["light", "electricity", "idea"], char: "\u{1F4A1}", fitzpatrick_scale: !1, category: "objects" }, flashlight: { keywords: ["dark", "camping", "sight", "night"], char: "\u{1F526}", fitzpatrick_scale: !1, category: "objects" }, candle: { keywords: ["fire", "wax"], char: "\u{1F56F}", fitzpatrick_scale: !1, category: "objects" }, fire_extinguisher: { keywords: ["quench"], char: "\u{1F9EF}", fitzpatrick_scale: !1, category: "objects" }, wastebasket: { keywords: ["bin", "trash", "rubbish", "garbage", "toss"], char: "\u{1F5D1}", fitzpatrick_scale: !1, category: "objects" }, oil_drum: { keywords: ["barrell"], char: "\u{1F6E2}", fitzpatrick_scale: !1, category: "objects" }, money_with_wings: { keywords: ["dollar", "bills", "payment", "sale"], char: "\u{1F4B8}", fitzpatrick_scale: !1, category: "objects" }, dollar: { keywords: ["money", "sales", "bill", "currency"], char: "\u{1F4B5}", fitzpatrick_scale: !1, category: "objects" }, yen: { keywords: ["money", "sales", "japanese", "dollar", "currency"], char: "\u{1F4B4}", fitzpatrick_scale: !1, category: "objects" }, euro: { keywords: ["money", "sales", "dollar", "currency"], char: "\u{1F4B6}", fitzpatrick_scale: !1, category: "objects" }, pound: { keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"], char: "\u{1F4B7}", fitzpatrick_scale: !1, category: "objects" }, moneybag: { keywords: ["dollar", "payment", "coins", "sale"], char: "\u{1F4B0}", fitzpatrick_scale: !1, category: "objects" }, credit_card: { keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"], char: "\u{1F4B3}", fitzpatrick_scale: !1, category: "objects" }, gem: { keywords: ["blue", "ruby", "diamond", "jewelry"], char: "\u{1F48E}", fitzpatrick_scale: !1, category: "objects" }, balance_scale: { keywords: ["law", "fairness", "weight"], char: "\u2696", fitzpatrick_scale: !1, category: "objects" }, toolbox: { keywords: ["tools", "diy", "fix", "maintainer", "mechanic"], char: "\u{1F9F0}", fitzpatrick_scale: !1, category: "objects" }, wrench: { keywords: ["tools", "diy", "ikea", "fix", "maintainer"], char: "\u{1F527}", fitzpatrick_scale: !1, category: "objects" }, hammer: { keywords: ["tools", "build", "create"], char: "\u{1F528}", fitzpatrick_scale: !1, category: "objects" }, hammer_and_pick: { keywords: ["tools", "build", "create"], char: "\u2692", fitzpatrick_scale: !1, category: "objects" }, hammer_and_wrench: { keywords: ["tools", "build", "create"], char: "\u{1F6E0}", fitzpatrick_scale: !1, category: "objects" }, pick: { keywords: ["tools", "dig"], char: "\u26CF", fitzpatrick_scale: !1, category: "objects" }, nut_and_bolt: { keywords: ["handy", "tools", "fix"], char: "\u{1F529}", fitzpatrick_scale: !1, category: "objects" }, gear: { keywords: ["cog"], char: "\u2699", fitzpatrick_scale: !1, category: "objects" }, brick: { keywords: ["bricks"], char: "\u{1F9F1}", fitzpatrick_scale: !1, category: "objects" }, chains: { keywords: ["lock", "arrest"], char: "\u26D3", fitzpatrick_scale: !1, category: "objects" }, magnet: { keywords: ["attraction", "magnetic"], char: "\u{1F9F2}", fitzpatrick_scale: !1, category: "objects" }, gun: { keywords: ["violence", "weapon", "pistol", "revolver"], char: "\u{1F52B}", fitzpatrick_scale: !1, category: "objects" }, bomb: { keywords: ["boom", "explode", "explosion", "terrorism"], char: "\u{1F4A3}", fitzpatrick_scale: !1, category: "objects" }, firecracker: { keywords: ["dynamite", "boom", "explode", "explosion", "explosive"], char: "\u{1F9E8}", fitzpatrick_scale: !1, category: "objects" }, hocho: { keywords: ["knife", "blade", "cutlery", "kitchen", "weapon"], char: "\u{1F52A}", fitzpatrick_scale: !1, category: "objects" }, dagger: { keywords: ["weapon"], char: "\u{1F5E1}", fitzpatrick_scale: !1, category: "objects" }, crossed_swords: { keywords: ["weapon"], char: "\u2694", fitzpatrick_scale: !1, category: "objects" }, shield: { keywords: ["protection", "security"], char: "\u{1F6E1}", fitzpatrick_scale: !1, category: "objects" }, smoking: { keywords: ["kills", "tobacco", "cigarette", "joint", "smoke"], char: "\u{1F6AC}", fitzpatrick_scale: !1, category: "objects" }, skull_and_crossbones: { keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"], char: "\u2620", fitzpatrick_scale: !1, category: "objects" }, coffin: { keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"], char: "\u26B0", fitzpatrick_scale: !1, category: "objects" }, funeral_urn: { keywords: ["dead", "die", "death", "rip", "ashes"], char: "\u26B1", fitzpatrick_scale: !1, category: "objects" }, amphora: { keywords: ["vase", "jar"], char: "\u{1F3FA}", fitzpatrick_scale: !1, category: "objects" }, crystal_ball: { keywords: ["disco", "party", "magic", "circus", "fortune_teller"], char: "\u{1F52E}", fitzpatrick_scale: !1, category: "objects" }, prayer_beads: { keywords: ["dhikr", "religious"], char: "\u{1F4FF}", fitzpatrick_scale: !1, category: "objects" }, nazar_amulet: { keywords: ["bead", "charm"], char: "\u{1F9FF}", fitzpatrick_scale: !1, category: "objects" }, barber: { keywords: ["hair", "salon", "style"], char: "\u{1F488}", fitzpatrick_scale: !1, category: "objects" }, alembic: { keywords: ["distilling", "science", "experiment", "chemistry"], char: "\u2697", fitzpatrick_scale: !1, category: "objects" }, telescope: { keywords: ["stars", "space", "zoom", "science", "astronomy"], char: "\u{1F52D}", fitzpatrick_scale: !1, category: "objects" }, microscope: { keywords: ["laboratory", "experiment", "zoomin", "science", "study"], char: "\u{1F52C}", fitzpatrick_scale: !1, category: "objects" }, hole: { keywords: ["embarrassing"], char: "\u{1F573}", fitzpatrick_scale: !1, category: "objects" }, pill: { keywords: ["health", "medicine", "doctor", "pharmacy", "drug"], char: "\u{1F48A}", fitzpatrick_scale: !1, category: "objects" }, syringe: { keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"], char: "\u{1F489}", fitzpatrick_scale: !1, category: "objects" }, dna: { keywords: ["biologist", "genetics", "life"], char: "\u{1F9EC}", fitzpatrick_scale: !1, category: "objects" }, microbe: { keywords: ["amoeba", "bacteria", "germs"], char: "\u{1F9A0}", fitzpatrick_scale: !1, category: "objects" }, petri_dish: { keywords: ["bacteria", "biology", "culture", "lab"], char: "\u{1F9EB}", fitzpatrick_scale: !1, category: "objects" }, test_tube: { keywords: ["chemistry", "experiment", "lab", "science"], char: "\u{1F9EA}", fitzpatrick_scale: !1, category: "objects" }, thermometer: { keywords: ["weather", "temperature", "hot", "cold"], char: "\u{1F321}", fitzpatrick_scale: !1, category: "objects" }, broom: { keywords: ["cleaning", "sweeping", "witch"], char: "\u{1F9F9}", fitzpatrick_scale: !1, category: "objects" }, basket: { keywords: ["laundry"], char: "\u{1F9FA}", fitzpatrick_scale: !1, category: "objects" }, toilet_paper: { keywords: ["roll"], char: "\u{1F9FB}", fitzpatrick_scale: !1, category: "objects" }, label: { keywords: ["sale", "tag"], char: "\u{1F3F7}", fitzpatrick_scale: !1, category: "objects" }, bookmark: { keywords: ["favorite", "label", "save"], char: "\u{1F516}", fitzpatrick_scale: !1, category: "objects" }, toilet: { keywords: ["restroom", "wc", "washroom", "bathroom", "potty"], char: "\u{1F6BD}", fitzpatrick_scale: !1, category: "objects" }, shower: { keywords: ["clean", "water", "bathroom"], char: "\u{1F6BF}", fitzpatrick_scale: !1, category: "objects" }, bathtub: { keywords: ["clean", "shower", "bathroom"], char: "\u{1F6C1}", fitzpatrick_scale: !1, category: "objects" }, soap: { keywords: ["bar", "bathing", "cleaning", "lather"], char: "\u{1F9FC}", fitzpatrick_scale: !1, category: "objects" }, sponge: { keywords: ["absorbing", "cleaning", "porous"], char: "\u{1F9FD}", fitzpatrick_scale: !1, category: "objects" }, lotion_bottle: { keywords: ["moisturizer", "sunscreen"], char: "\u{1F9F4}", fitzpatrick_scale: !1, category: "objects" }, key: { keywords: ["lock", "door", "password"], char: "\u{1F511}", fitzpatrick_scale: !1, category: "objects" }, old_key: { keywords: ["lock", "door", "password"], char: "\u{1F5DD}", fitzpatrick_scale: !1, category: "objects" }, couch_and_lamp: { keywords: ["read", "chill"], char: "\u{1F6CB}", fitzpatrick_scale: !1, category: "objects" }, sleeping_bed: { keywords: ["bed", "rest"], char: "\u{1F6CC}", fitzpatrick_scale: !0, category: "objects" }, bed: { keywords: ["sleep", "rest"], char: "\u{1F6CF}", fitzpatrick_scale: !1, category: "objects" }, door: { keywords: ["house", "entry", "exit"], char: "\u{1F6AA}", fitzpatrick_scale: !1, category: "objects" }, bellhop_bell: { keywords: ["service"], char: "\u{1F6CE}", fitzpatrick_scale: !1, category: "objects" }, teddy_bear: { keywords: ["plush", "stuffed"], char: "\u{1F9F8}", fitzpatrick_scale: !1, category: "objects" }, framed_picture: { keywords: ["photography"], char: "\u{1F5BC}", fitzpatrick_scale: !1, category: "objects" }, world_map: { keywords: ["location", "direction"], char: "\u{1F5FA}", fitzpatrick_scale: !1, category: "objects" }, parasol_on_ground: { keywords: ["weather", "summer"], char: "\u26F1", fitzpatrick_scale: !1, category: "objects" }, moyai: { keywords: ["rock", "easter island", "moai"], char: "\u{1F5FF}", fitzpatrick_scale: !1, category: "objects" }, shopping: { keywords: ["mall", "buy", "purchase"], char: "\u{1F6CD}", fitzpatrick_scale: !1, category: "objects" }, shopping_cart: { keywords: ["trolley"], char: "\u{1F6D2}", fitzpatrick_scale: !1, category: "objects" }, balloon: { keywords: ["party", "celebration", "birthday", "circus"], char: "\u{1F388}", fitzpatrick_scale: !1, category: "objects" }, flags: { keywords: ["fish", "japanese", "koinobori", "carp", "banner"], char: "\u{1F38F}", fitzpatrick_scale: !1, category: "objects" }, ribbon: { keywords: ["decoration", "pink", "girl", "bowtie"], char: "\u{1F380}", fitzpatrick_scale: !1, category: "objects" }, gift: { keywords: ["present", "birthday", "christmas", "xmas"], char: "\u{1F381}", fitzpatrick_scale: !1, category: "objects" }, confetti_ball: { keywords: ["festival", "party", "birthday", "circus"], char: "\u{1F38A}", fitzpatrick_scale: !1, category: "objects" }, tada: { keywords: ["party", "congratulations", "birthday", "magic", "circus", "celebration"], char: "\u{1F389}", fitzpatrick_scale: !1, category: "objects" }, dolls: { keywords: ["japanese", "toy", "kimono"], char: "\u{1F38E}", fitzpatrick_scale: !1, category: "objects" }, wind_chime: { keywords: ["nature", "ding", "spring", "bell"], char: "\u{1F390}", fitzpatrick_scale: !1, category: "objects" }, crossed_flags: { keywords: ["japanese", "nation", "country", "border"], char: "\u{1F38C}", fitzpatrick_scale: !1, category: "objects" }, izakaya_lantern: { keywords: ["light", "paper", "halloween", "spooky"], char: "\u{1F3EE}", fitzpatrick_scale: !1, category: "objects" }, red_envelope: { keywords: ["gift"], char: "\u{1F9E7}", fitzpatrick_scale: !1, category: "objects" }, email: { keywords: ["letter", "postal", "inbox", "communication"], char: "\u2709\uFE0F", fitzpatrick_scale: !1, category: "objects" }, envelope_with_arrow: { keywords: ["email", "communication"], char: "\u{1F4E9}", fitzpatrick_scale: !1, category: "objects" }, incoming_envelope: { keywords: ["email", "inbox"], char: "\u{1F4E8}", fitzpatrick_scale: !1, category: "objects" }, "e-mail": { keywords: ["communication", "inbox"], char: "\u{1F4E7}", fitzpatrick_scale: !1, category: "objects" }, love_letter: { keywords: ["email", "like", "affection", "envelope", "valentines"], char: "\u{1F48C}", fitzpatrick_scale: !1, category: "objects" }, postbox: { keywords: ["email", "letter", "envelope"], char: "\u{1F4EE}", fitzpatrick_scale: !1, category: "objects" }, mailbox_closed: { keywords: ["email", "communication", "inbox"], char: "\u{1F4EA}", fitzpatrick_scale: !1, category: "objects" }, mailbox: { keywords: ["email", "inbox", "communication"], char: "\u{1F4EB}", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_mail: { keywords: ["email", "inbox", "communication"], char: "\u{1F4EC}", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_no_mail: { keywords: ["email", "inbox"], char: "\u{1F4ED}", fitzpatrick_scale: !1, category: "objects" }, package: { keywords: ["mail", "gift", "cardboard", "box", "moving"], char: "\u{1F4E6}", fitzpatrick_scale: !1, category: "objects" }, postal_horn: { keywords: ["instrument", "music"], char: "\u{1F4EF}", fitzpatrick_scale: !1, category: "objects" }, inbox_tray: { keywords: ["email", "documents"], char: "\u{1F4E5}", fitzpatrick_scale: !1, category: "objects" }, outbox_tray: { keywords: ["inbox", "email"], char: "\u{1F4E4}", fitzpatrick_scale: !1, category: "objects" }, scroll: { keywords: ["documents", "ancient", "history", "paper"], char: "\u{1F4DC}", fitzpatrick_scale: !1, category: "objects" }, page_with_curl: { keywords: ["documents", "office", "paper"], char: "\u{1F4C3}", fitzpatrick_scale: !1, category: "objects" }, bookmark_tabs: { keywords: ["favorite", "save", "order", "tidy"], char: "\u{1F4D1}", fitzpatrick_scale: !1, category: "objects" }, receipt: { keywords: ["accounting", "expenses"], char: "\u{1F9FE}", fitzpatrick_scale: !1, category: "objects" }, bar_chart: { keywords: ["graph", "presentation", "stats"], char: "\u{1F4CA}", fitzpatrick_scale: !1, category: "objects" }, chart_with_upwards_trend: { keywords: ["graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"], char: "\u{1F4C8}", fitzpatrick_scale: !1, category: "objects" }, chart_with_downwards_trend: { keywords: ["graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"], char: "\u{1F4C9}", fitzpatrick_scale: !1, category: "objects" }, page_facing_up: { keywords: ["documents", "office", "paper", "information"], char: "\u{1F4C4}", fitzpatrick_scale: !1, category: "objects" }, date: { keywords: ["calendar", "schedule"], char: "\u{1F4C5}", fitzpatrick_scale: !1, category: "objects" }, calendar: { keywords: ["schedule", "date", "planning"], char: "\u{1F4C6}", fitzpatrick_scale: !1, category: "objects" }, spiral_calendar: { keywords: ["date", "schedule", "planning"], char: "\u{1F5D3}", fitzpatrick_scale: !1, category: "objects" }, card_index: { keywords: ["business", "stationery"], char: "\u{1F4C7}", fitzpatrick_scale: !1, category: "objects" }, card_file_box: { keywords: ["business", "stationery"], char: "\u{1F5C3}", fitzpatrick_scale: !1, category: "objects" }, ballot_box: { keywords: ["election", "vote"], char: "\u{1F5F3}", fitzpatrick_scale: !1, category: "objects" }, file_cabinet: { keywords: ["filing", "organizing"], char: "\u{1F5C4}", fitzpatrick_scale: !1, category: "objects" }, clipboard: { keywords: ["stationery", "documents"], char: "\u{1F4CB}", fitzpatrick_scale: !1, category: "objects" }, spiral_notepad: { keywords: ["memo", "stationery"], char: "\u{1F5D2}", fitzpatrick_scale: !1, category: "objects" }, file_folder: { keywords: ["documents", "business", "office"], char: "\u{1F4C1}", fitzpatrick_scale: !1, category: "objects" }, open_file_folder: { keywords: ["documents", "load"], char: "\u{1F4C2}", fitzpatrick_scale: !1, category: "objects" }, card_index_dividers: { keywords: ["organizing", "business", "stationery"], char: "\u{1F5C2}", fitzpatrick_scale: !1, category: "objects" }, newspaper_roll: { keywords: ["press", "headline"], char: "\u{1F5DE}", fitzpatrick_scale: !1, category: "objects" }, newspaper: { keywords: ["press", "headline"], char: "\u{1F4F0}", fitzpatrick_scale: !1, category: "objects" }, notebook: { keywords: ["stationery", "record", "notes", "paper", "study"], char: "\u{1F4D3}", fitzpatrick_scale: !1, category: "objects" }, closed_book: { keywords: ["read", "library", "knowledge", "textbook", "learn"], char: "\u{1F4D5}", fitzpatrick_scale: !1, category: "objects" }, green_book: { keywords: ["read", "library", "knowledge", "study"], char: "\u{1F4D7}", fitzpatrick_scale: !1, category: "objects" }, blue_book: { keywords: ["read", "library", "knowledge", "learn", "study"], char: "\u{1F4D8}", fitzpatrick_scale: !1, category: "objects" }, orange_book: { keywords: ["read", "library", "knowledge", "textbook", "study"], char: "\u{1F4D9}", fitzpatrick_scale: !1, category: "objects" }, notebook_with_decorative_cover: { keywords: ["classroom", "notes", "record", "paper", "study"], char: "\u{1F4D4}", fitzpatrick_scale: !1, category: "objects" }, ledger: { keywords: ["notes", "paper"], char: "\u{1F4D2}", fitzpatrick_scale: !1, category: "objects" }, books: { keywords: ["literature", "library", "study"], char: "\u{1F4DA}", fitzpatrick_scale: !1, category: "objects" }, open_book: { keywords: ["book", "read", "library", "knowledge", "literature", "learn", "study"], char: "\u{1F4D6}", fitzpatrick_scale: !1, category: "objects" }, safety_pin: { keywords: ["diaper"], char: "\u{1F9F7}", fitzpatrick_scale: !1, category: "objects" }, link: { keywords: ["rings", "url"], char: "\u{1F517}", fitzpatrick_scale: !1, category: "objects" }, paperclip: { keywords: ["documents", "stationery"], char: "\u{1F4CE}", fitzpatrick_scale: !1, category: "objects" }, paperclips: { keywords: ["documents", "stationery"], char: "\u{1F587}", fitzpatrick_scale: !1, category: "objects" }, scissors: { keywords: ["stationery", "cut"], char: "\u2702\uFE0F", fitzpatrick_scale: !1, category: "objects" }, triangular_ruler: { keywords: ["stationery", "math", "architect", "sketch"], char: "\u{1F4D0}", fitzpatrick_scale: !1, category: "objects" }, straight_ruler: { keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"], char: "\u{1F4CF}", fitzpatrick_scale: !1, category: "objects" }, abacus: { keywords: ["calculation"], char: "\u{1F9EE}", fitzpatrick_scale: !1, category: "objects" }, pushpin: { keywords: ["stationery", "mark", "here"], char: "\u{1F4CC}", fitzpatrick_scale: !1, category: "objects" }, round_pushpin: { keywords: ["stationery", "location", "map", "here"], char: "\u{1F4CD}", fitzpatrick_scale: !1, category: "objects" }, triangular_flag_on_post: { keywords: ["mark", "milestone", "place"], char: "\u{1F6A9}", fitzpatrick_scale: !1, category: "objects" }, white_flag: { keywords: ["losing", "loser", "lost", "surrender", "give up", "fail"], char: "\u{1F3F3}", fitzpatrick_scale: !1, category: "objects" }, black_flag: { keywords: ["pirate"], char: "\u{1F3F4}", fitzpatrick_scale: !1, category: "objects" }, rainbow_flag: { keywords: ["flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"], char: "\u{1F3F3}\uFE0F\u200D\u{1F308}", fitzpatrick_scale: !1, category: "objects" }, closed_lock_with_key: { keywords: ["security", "privacy"], char: "\u{1F510}", fitzpatrick_scale: !1, category: "objects" }, lock: { keywords: ["security", "password", "padlock"], char: "\u{1F512}", fitzpatrick_scale: !1, category: "objects" }, unlock: { keywords: ["privacy", "security"], char: "\u{1F513}", fitzpatrick_scale: !1, category: "objects" }, lock_with_ink_pen: { keywords: ["security", "secret"], char: "\u{1F50F}", fitzpatrick_scale: !1, category: "objects" }, pen: { keywords: ["stationery", "writing", "write"], char: "\u{1F58A}", fitzpatrick_scale: !1, category: "objects" }, fountain_pen: { keywords: ["stationery", "writing", "write"], char: "\u{1F58B}", fitzpatrick_scale: !1, category: "objects" }, black_nib: { keywords: ["pen", "stationery", "writing", "write"], char: "\u2712\uFE0F", fitzpatrick_scale: !1, category: "objects" }, memo: { keywords: ["write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"], char: "\u{1F4DD}", fitzpatrick_scale: !1, category: "objects" }, pencil2: { keywords: ["stationery", "write", "paper", "writing", "school", "study"], char: "\u270F\uFE0F", fitzpatrick_scale: !1, category: "objects" }, crayon: { keywords: ["drawing", "creativity"], char: "\u{1F58D}", fitzpatrick_scale: !1, category: "objects" }, paintbrush: { keywords: ["drawing", "creativity", "art"], char: "\u{1F58C}", fitzpatrick_scale: !1, category: "objects" }, mag: { keywords: ["search", "zoom", "find", "detective"], char: "\u{1F50D}", fitzpatrick_scale: !1, category: "objects" }, mag_right: { keywords: ["search", "zoom", "find", "detective"], char: "\u{1F50E}", fitzpatrick_scale: !1, category: "objects" }, heart: { keywords: ["love", "like", "valentines"], char: "\u2764\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, orange_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F9E1}", fitzpatrick_scale: !1, category: "symbols" }, yellow_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49B}", fitzpatrick_scale: !1, category: "symbols" }, green_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49A}", fitzpatrick_scale: !1, category: "symbols" }, blue_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F499}", fitzpatrick_scale: !1, category: "symbols" }, purple_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49C}", fitzpatrick_scale: !1, category: "symbols" }, black_heart: { keywords: ["evil"], char: "\u{1F5A4}", fitzpatrick_scale: !1, category: "symbols" }, broken_heart: { keywords: ["sad", "sorry", "break", "heart", "heartbreak"], char: "\u{1F494}", fitzpatrick_scale: !1, category: "symbols" }, heavy_heart_exclamation: { keywords: ["decoration", "love"], char: "\u2763", fitzpatrick_scale: !1, category: "symbols" }, two_hearts: { keywords: ["love", "like", "affection", "valentines", "heart"], char: "\u{1F495}", fitzpatrick_scale: !1, category: "symbols" }, revolving_hearts: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49E}", fitzpatrick_scale: !1, category: "symbols" }, heartbeat: { keywords: ["love", "like", "affection", "valentines", "pink", "heart"], char: "\u{1F493}", fitzpatrick_scale: !1, category: "symbols" }, heartpulse: { keywords: ["like", "love", "affection", "valentines", "pink"], char: "\u{1F497}", fitzpatrick_scale: !1, category: "symbols" }, sparkling_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F496}", fitzpatrick_scale: !1, category: "symbols" }, cupid: { keywords: ["love", "like", "heart", "affection", "valentines"], char: "\u{1F498}", fitzpatrick_scale: !1, category: "symbols" }, gift_heart: { keywords: ["love", "valentines"], char: "\u{1F49D}", fitzpatrick_scale: !1, category: "symbols" }, heart_decoration: { keywords: ["purple-square", "love", "like"], char: "\u{1F49F}", fitzpatrick_scale: !1, category: "symbols" }, peace_symbol: { keywords: ["hippie"], char: "\u262E", fitzpatrick_scale: !1, category: "symbols" }, latin_cross: { keywords: ["christianity"], char: "\u271D", fitzpatrick_scale: !1, category: "symbols" }, star_and_crescent: { keywords: ["islam"], char: "\u262A", fitzpatrick_scale: !1, category: "symbols" }, om: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "\u{1F549}", fitzpatrick_scale: !1, category: "symbols" }, wheel_of_dharma: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "\u2638", fitzpatrick_scale: !1, category: "symbols" }, star_of_david: { keywords: ["judaism"], char: "\u2721", fitzpatrick_scale: !1, category: "symbols" }, six_pointed_star: { keywords: ["purple-square", "religion", "jewish", "hexagram"], char: "\u{1F52F}", fitzpatrick_scale: !1, category: "symbols" }, menorah: { keywords: ["hanukkah", "candles", "jewish"], char: "\u{1F54E}", fitzpatrick_scale: !1, category: "symbols" }, yin_yang: { keywords: ["balance"], char: "\u262F", fitzpatrick_scale: !1, category: "symbols" }, orthodox_cross: { keywords: ["suppedaneum", "religion"], char: "\u2626", fitzpatrick_scale: !1, category: "symbols" }, place_of_worship: { keywords: ["religion", "church", "temple", "prayer"], char: "\u{1F6D0}", fitzpatrick_scale: !1, category: "symbols" }, ophiuchus: { keywords: ["sign", "purple-square", "constellation", "astrology"], char: "\u26CE", fitzpatrick_scale: !1, category: "symbols" }, aries: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u2648", fitzpatrick_scale: !1, category: "symbols" }, taurus: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "\u2649", fitzpatrick_scale: !1, category: "symbols" }, gemini: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264A", fitzpatrick_scale: !1, category: "symbols" }, cancer: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264B", fitzpatrick_scale: !1, category: "symbols" }, leo: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u264C", fitzpatrick_scale: !1, category: "symbols" }, virgo: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264D", fitzpatrick_scale: !1, category: "symbols" }, libra: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u264E", fitzpatrick_scale: !1, category: "symbols" }, scorpius: { keywords: ["sign", "zodiac", "purple-square", "astrology", "scorpio"], char: "\u264F", fitzpatrick_scale: !1, category: "symbols" }, sagittarius: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u2650", fitzpatrick_scale: !1, category: "symbols" }, capricorn: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u2651", fitzpatrick_scale: !1, category: "symbols" }, aquarius: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u2652", fitzpatrick_scale: !1, category: "symbols" }, pisces: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "\u2653", fitzpatrick_scale: !1, category: "symbols" }, id: { keywords: ["purple-square", "words"], char: "\u{1F194}", fitzpatrick_scale: !1, category: "symbols" }, atom_symbol: { keywords: ["science", "physics", "chemistry"], char: "\u269B", fitzpatrick_scale: !1, category: "symbols" }, u7a7a: { keywords: ["kanji", "japanese", "chinese", "empty", "sky", "blue-square"], char: "\u{1F233}", fitzpatrick_scale: !1, category: "symbols" }, u5272: { keywords: ["cut", "divide", "chinese", "kanji", "pink-square"], char: "\u{1F239}", fitzpatrick_scale: !1, category: "symbols" }, radioactive: { keywords: ["nuclear", "danger"], char: "\u2622", fitzpatrick_scale: !1, category: "symbols" }, biohazard: { keywords: ["danger"], char: "\u2623", fitzpatrick_scale: !1, category: "symbols" }, mobile_phone_off: { keywords: ["mute", "orange-square", "silence", "quiet"], char: "\u{1F4F4}", fitzpatrick_scale: !1, category: "symbols" }, vibration_mode: { keywords: ["orange-square", "phone"], char: "\u{1F4F3}", fitzpatrick_scale: !1, category: "symbols" }, u6709: { keywords: ["orange-square", "chinese", "have", "kanji"], char: "\u{1F236}", fitzpatrick_scale: !1, category: "symbols" }, u7121: { keywords: ["nothing", "chinese", "kanji", "japanese", "orange-square"], char: "\u{1F21A}", fitzpatrick_scale: !1, category: "symbols" }, u7533: { keywords: ["chinese", "japanese", "kanji", "orange-square"], char: "\u{1F238}", fitzpatrick_scale: !1, category: "symbols" }, u55b6: { keywords: ["japanese", "opening hours", "orange-square"], char: "\u{1F23A}", fitzpatrick_scale: !1, category: "symbols" }, u6708: { keywords: ["chinese", "month", "moon", "japanese", "orange-square", "kanji"], char: "\u{1F237}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, eight_pointed_black_star: { keywords: ["orange-square", "shape", "polygon"], char: "\u2734\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, vs: { keywords: ["words", "orange-square"], char: "\u{1F19A}", fitzpatrick_scale: !1, category: "symbols" }, accept: { keywords: ["ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle"], char: "\u{1F251}", fitzpatrick_scale: !1, category: "symbols" }, white_flower: { keywords: ["japanese", "spring"], char: "\u{1F4AE}", fitzpatrick_scale: !1, category: "symbols" }, ideograph_advantage: { keywords: ["chinese", "kanji", "obtain", "get", "circle"], char: "\u{1F250}", fitzpatrick_scale: !1, category: "symbols" }, secret: { keywords: ["privacy", "chinese", "sshh", "kanji", "red-circle"], char: "\u3299\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, congratulations: { keywords: ["chinese", "kanji", "japanese", "red-circle"], char: "\u3297\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, u5408: { keywords: ["japanese", "chinese", "join", "kanji", "red-square"], char: "\u{1F234}", fitzpatrick_scale: !1, category: "symbols" }, u6e80: { keywords: ["full", "chinese", "japanese", "red-square", "kanji"], char: "\u{1F235}", fitzpatrick_scale: !1, category: "symbols" }, u7981: { keywords: ["kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square"], char: "\u{1F232}", fitzpatrick_scale: !1, category: "symbols" }, a: { keywords: ["red-square", "alphabet", "letter"], char: "\u{1F170}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, b: { keywords: ["red-square", "alphabet", "letter"], char: "\u{1F171}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, ab: { keywords: ["red-square", "alphabet"], char: "\u{1F18E}", fitzpatrick_scale: !1, category: "symbols" }, cl: { keywords: ["alphabet", "words", "red-square"], char: "\u{1F191}", fitzpatrick_scale: !1, category: "symbols" }, o2: { keywords: ["alphabet", "red-square", "letter"], char: "\u{1F17E}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, sos: { keywords: ["help", "red-square", "words", "emergency", "911"], char: "\u{1F198}", fitzpatrick_scale: !1, category: "symbols" }, no_entry: { keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"], char: "\u26D4", fitzpatrick_scale: !1, category: "symbols" }, name_badge: { keywords: ["fire", "forbid"], char: "\u{1F4DB}", fitzpatrick_scale: !1, category: "symbols" }, no_entry_sign: { keywords: ["forbid", "stop", "limit", "denied", "disallow", "circle"], char: "\u{1F6AB}", fitzpatrick_scale: !1, category: "symbols" }, x: { keywords: ["no", "delete", "remove", "cancel", "red"], char: "\u274C", fitzpatrick_scale: !1, category: "symbols" }, o: { keywords: ["circle", "round"], char: "\u2B55", fitzpatrick_scale: !1, category: "symbols" }, stop_sign: { keywords: ["stop"], char: "\u{1F6D1}", fitzpatrick_scale: !1, category: "symbols" }, anger: { keywords: ["angry", "mad"], char: "\u{1F4A2}", fitzpatrick_scale: !1, category: "symbols" }, hotsprings: { keywords: ["bath", "warm", "relax"], char: "\u2668\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, no_pedestrians: { keywords: ["rules", "crossing", "walking", "circle"], char: "\u{1F6B7}", fitzpatrick_scale: !1, category: "symbols" }, do_not_litter: { keywords: ["trash", "bin", "garbage", "circle"], char: "\u{1F6AF}", fitzpatrick_scale: !1, category: "symbols" }, no_bicycles: { keywords: ["cyclist", "prohibited", "circle"], char: "\u{1F6B3}", fitzpatrick_scale: !1, category: "symbols" }, "non-potable_water": { keywords: ["drink", "faucet", "tap", "circle"], char: "\u{1F6B1}", fitzpatrick_scale: !1, category: "symbols" }, underage: { keywords: ["18", "drink", "pub", "night", "minor", "circle"], char: "\u{1F51E}", fitzpatrick_scale: !1, category: "symbols" }, no_mobile_phones: { keywords: ["iphone", "mute", "circle"], char: "\u{1F4F5}", fitzpatrick_scale: !1, category: "symbols" }, exclamation: { keywords: ["heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning"], char: "\u2757", fitzpatrick_scale: !1, category: "symbols" }, grey_exclamation: { keywords: ["surprise", "punctuation", "gray", "wow", "warning"], char: "\u2755", fitzpatrick_scale: !1, category: "symbols" }, question: { keywords: ["doubt", "confused"], char: "\u2753", fitzpatrick_scale: !1, category: "symbols" }, grey_question: { keywords: ["doubts", "gray", "huh", "confused"], char: "\u2754", fitzpatrick_scale: !1, category: "symbols" }, bangbang: { keywords: ["exclamation", "surprise"], char: "\u203C\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, interrobang: { keywords: ["wat", "punctuation", "surprise"], char: "\u2049\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, 100: { keywords: ["score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred"], char: "\u{1F4AF}", fitzpatrick_scale: !1, category: "symbols" }, low_brightness: { keywords: ["sun", "afternoon", "warm", "summer"], char: "\u{1F505}", fitzpatrick_scale: !1, category: "symbols" }, high_brightness: { keywords: ["sun", "light"], char: "\u{1F506}", fitzpatrick_scale: !1, category: "symbols" }, trident: { keywords: ["weapon", "spear"], char: "\u{1F531}", fitzpatrick_scale: !1, category: "symbols" }, fleur_de_lis: { keywords: ["decorative", "scout"], char: "\u269C", fitzpatrick_scale: !1, category: "symbols" }, part_alternation_mark: { keywords: ["graph", "presentation", "stats", "business", "economics", "bad"], char: "\u303D\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, warning: { keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"], char: "\u26A0\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, children_crossing: { keywords: ["school", "warning", "danger", "sign", "driving", "yellow-diamond"], char: "\u{1F6B8}", fitzpatrick_scale: !1, category: "symbols" }, beginner: { keywords: ["badge", "shield"], char: "\u{1F530}", fitzpatrick_scale: !1, category: "symbols" }, recycle: { keywords: ["arrow", "environment", "garbage", "trash"], char: "\u267B\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, u6307: { keywords: ["chinese", "point", "green-square", "kanji"], char: "\u{1F22F}", fitzpatrick_scale: !1, category: "symbols" }, chart: { keywords: ["green-square", "graph", "presentation", "stats"], char: "\u{1F4B9}", fitzpatrick_scale: !1, category: "symbols" }, sparkle: { keywords: ["stars", "green-square", "awesome", "good", "fireworks"], char: "\u2747\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, eight_spoked_asterisk: { keywords: ["star", "sparkle", "green-square"], char: "\u2733\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, negative_squared_cross_mark: { keywords: ["x", "green-square", "no", "deny"], char: "\u274E", fitzpatrick_scale: !1, category: "symbols" }, white_check_mark: { keywords: ["green-square", "ok", "agree", "vote", "election", "answer", "tick"], char: "\u2705", fitzpatrick_scale: !1, category: "symbols" }, diamond_shape_with_a_dot_inside: { keywords: ["jewel", "blue", "gem", "crystal", "fancy"], char: "\u{1F4A0}", fitzpatrick_scale: !1, category: "symbols" }, cyclone: { keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"], char: "\u{1F300}", fitzpatrick_scale: !1, category: "symbols" }, loop: { keywords: ["tape", "cassette"], char: "\u27BF", fitzpatrick_scale: !1, category: "symbols" }, globe_with_meridians: { keywords: ["earth", "international", "world", "internet", "interweb", "i18n"], char: "\u{1F310}", fitzpatrick_scale: !1, category: "symbols" }, m: { keywords: ["alphabet", "blue-circle", "letter"], char: "\u24C2\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, atm: { keywords: ["money", "sales", "cash", "blue-square", "payment", "bank"], char: "\u{1F3E7}", fitzpatrick_scale: !1, category: "symbols" }, sa: { keywords: ["japanese", "blue-square", "katakana"], char: "\u{1F202}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, passport_control: { keywords: ["custom", "blue-square"], char: "\u{1F6C2}", fitzpatrick_scale: !1, category: "symbols" }, customs: { keywords: ["passport", "border", "blue-square"], char: "\u{1F6C3}", fitzpatrick_scale: !1, category: "symbols" }, baggage_claim: { keywords: ["blue-square", "airport", "transport"], char: "\u{1F6C4}", fitzpatrick_scale: !1, category: "symbols" }, left_luggage: { keywords: ["blue-square", "travel"], char: "\u{1F6C5}", fitzpatrick_scale: !1, category: "symbols" }, wheelchair: { keywords: ["blue-square", "disabled", "a11y", "accessibility"], char: "\u267F", fitzpatrick_scale: !1, category: "symbols" }, no_smoking: { keywords: ["cigarette", "blue-square", "smell", "smoke"], char: "\u{1F6AD}", fitzpatrick_scale: !1, category: "symbols" }, wc: { keywords: ["toilet", "restroom", "blue-square"], char: "\u{1F6BE}", fitzpatrick_scale: !1, category: "symbols" }, parking: { keywords: ["cars", "blue-square", "alphabet", "letter"], char: "\u{1F17F}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, potable_water: { keywords: ["blue-square", "liquid", "restroom", "cleaning", "faucet"], char: "\u{1F6B0}", fitzpatrick_scale: !1, category: "symbols" }, mens: { keywords: ["toilet", "restroom", "wc", "blue-square", "gender", "male"], char: "\u{1F6B9}", fitzpatrick_scale: !1, category: "symbols" }, womens: { keywords: ["purple-square", "woman", "female", "toilet", "loo", "restroom", "gender"], char: "\u{1F6BA}", fitzpatrick_scale: !1, category: "symbols" }, baby_symbol: { keywords: ["orange-square", "child"], char: "\u{1F6BC}", fitzpatrick_scale: !1, category: "symbols" }, restroom: { keywords: ["blue-square", "toilet", "refresh", "wc", "gender"], char: "\u{1F6BB}", fitzpatrick_scale: !1, category: "symbols" }, put_litter_in_its_place: { keywords: ["blue-square", "sign", "human", "info"], char: "\u{1F6AE}", fitzpatrick_scale: !1, category: "symbols" }, cinema: { keywords: ["blue-square", "record", "film", "movie", "curtain", "stage", "theater"], char: "\u{1F3A6}", fitzpatrick_scale: !1, category: "symbols" }, signal_strength: { keywords: ["blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars"], char: "\u{1F4F6}", fitzpatrick_scale: !1, category: "symbols" }, koko: { keywords: ["blue-square", "here", "katakana", "japanese", "destination"], char: "\u{1F201}", fitzpatrick_scale: !1, category: "symbols" }, ng: { keywords: ["blue-square", "words", "shape", "icon"], char: "\u{1F196}", fitzpatrick_scale: !1, category: "symbols" }, ok: { keywords: ["good", "agree", "yes", "blue-square"], char: "\u{1F197}", fitzpatrick_scale: !1, category: "symbols" }, up: { keywords: ["blue-square", "above", "high"], char: "\u{1F199}", fitzpatrick_scale: !1, category: "symbols" }, cool: { keywords: ["words", "blue-square"], char: "\u{1F192}", fitzpatrick_scale: !1, category: "symbols" }, new: { keywords: ["blue-square", "words", "start"], char: "\u{1F195}", fitzpatrick_scale: !1, category: "symbols" }, free: { keywords: ["blue-square", "words"], char: "\u{1F193}", fitzpatrick_scale: !1, category: "symbols" }, zero: { keywords: ["0", "numbers", "blue-square", "null"], char: "0\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, one: { keywords: ["blue-square", "numbers", "1"], char: "1\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, two: { keywords: ["numbers", "2", "prime", "blue-square"], char: "2\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, three: { keywords: ["3", "numbers", "prime", "blue-square"], char: "3\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, four: { keywords: ["4", "numbers", "blue-square"], char: "4\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, five: { keywords: ["5", "numbers", "blue-square", "prime"], char: "5\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, six: { keywords: ["6", "numbers", "blue-square"], char: "6\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, seven: { keywords: ["7", "numbers", "blue-square", "prime"], char: "7\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, eight: { keywords: ["8", "blue-square", "numbers"], char: "8\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, nine: { keywords: ["blue-square", "numbers", "9"], char: "9\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, keycap_ten: { keywords: ["numbers", "10", "blue-square"], char: "\u{1F51F}", fitzpatrick_scale: !1, category: "symbols" }, asterisk: { keywords: ["star", "keycap"], char: "*\u20E3", fitzpatrick_scale: !1, category: "symbols" }, 1234: { keywords: ["numbers", "blue-square"], char: "\u{1F522}", fitzpatrick_scale: !1, category: "symbols" }, eject_button: { keywords: ["blue-square"], char: "\u23CF\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_forward: { keywords: ["blue-square", "right", "direction", "play"], char: "\u25B6\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, pause_button: { keywords: ["pause", "blue-square"], char: "\u23F8", fitzpatrick_scale: !1, category: "symbols" }, next_track_button: { keywords: ["forward", "next", "blue-square"], char: "\u23ED", fitzpatrick_scale: !1, category: "symbols" }, stop_button: { keywords: ["blue-square"], char: "\u23F9", fitzpatrick_scale: !1, category: "symbols" }, record_button: { keywords: ["blue-square"], char: "\u23FA", fitzpatrick_scale: !1, category: "symbols" }, play_or_pause_button: { keywords: ["blue-square", "play", "pause"], char: "\u23EF", fitzpatrick_scale: !1, category: "symbols" }, previous_track_button: { keywords: ["backward"], char: "\u23EE", fitzpatrick_scale: !1, category: "symbols" }, fast_forward: { keywords: ["blue-square", "play", "speed", "continue"], char: "\u23E9", fitzpatrick_scale: !1, category: "symbols" }, rewind: { keywords: ["play", "blue-square"], char: "\u23EA", fitzpatrick_scale: !1, category: "symbols" }, twisted_rightwards_arrows: { keywords: ["blue-square", "shuffle", "music", "random"], char: "\u{1F500}", fitzpatrick_scale: !1, category: "symbols" }, repeat: { keywords: ["loop", "record"], char: "\u{1F501}", fitzpatrick_scale: !1, category: "symbols" }, repeat_one: { keywords: ["blue-square", "loop"], char: "\u{1F502}", fitzpatrick_scale: !1, category: "symbols" }, arrow_backward: { keywords: ["blue-square", "left", "direction"], char: "\u25C0\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_small: { keywords: ["blue-square", "triangle", "direction", "point", "forward", "top"], char: "\u{1F53C}", fitzpatrick_scale: !1, category: "symbols" }, arrow_down_small: { keywords: ["blue-square", "direction", "bottom"], char: "\u{1F53D}", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_up: { keywords: ["blue-square", "direction", "top"], char: "\u23EB", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u23EC", fitzpatrick_scale: !1, category: "symbols" }, arrow_right: { keywords: ["blue-square", "next"], char: "\u27A1\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_left: { keywords: ["blue-square", "previous", "back"], char: "\u2B05\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up: { keywords: ["blue-square", "continue", "top", "direction"], char: "\u2B06\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u2B07\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_right: { keywords: ["blue-square", "point", "direction", "diagonal", "northeast"], char: "\u2197\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_right: { keywords: ["blue-square", "direction", "diagonal", "southeast"], char: "\u2198\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_left: { keywords: ["blue-square", "direction", "diagonal", "southwest"], char: "\u2199\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_left: { keywords: ["blue-square", "point", "direction", "diagonal", "northwest"], char: "\u2196\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_down: { keywords: ["blue-square", "direction", "way", "vertical"], char: "\u2195\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, left_right_arrow: { keywords: ["shape", "direction", "horizontal", "sideways"], char: "\u2194\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrows_counterclockwise: { keywords: ["blue-square", "sync", "cycle"], char: "\u{1F504}", fitzpatrick_scale: !1, category: "symbols" }, arrow_right_hook: { keywords: ["blue-square", "return", "rotate", "direction"], char: "\u21AA\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, leftwards_arrow_with_hook: { keywords: ["back", "return", "blue-square", "undo", "enter"], char: "\u21A9\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_up: { keywords: ["blue-square", "direction", "top"], char: "\u2934\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u2935\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, hash: { keywords: ["symbol", "blue-square", "twitter"], char: "#\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, information_source: { keywords: ["blue-square", "alphabet", "letter"], char: "\u2139\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, abc: { keywords: ["blue-square", "alphabet"], char: "\u{1F524}", fitzpatrick_scale: !1, category: "symbols" }, abcd: { keywords: ["blue-square", "alphabet"], char: "\u{1F521}", fitzpatrick_scale: !1, category: "symbols" }, capital_abcd: { keywords: ["alphabet", "words", "blue-square"], char: "\u{1F520}", fitzpatrick_scale: !1, category: "symbols" }, symbols: { keywords: ["blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters"], char: "\u{1F523}", fitzpatrick_scale: !1, category: "symbols" }, musical_note: { keywords: ["score", "tone", "sound"], char: "\u{1F3B5}", fitzpatrick_scale: !1, category: "symbols" }, notes: { keywords: ["music", "score"], char: "\u{1F3B6}", fitzpatrick_scale: !1, category: "symbols" }, wavy_dash: { keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"], char: "\u3030\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, curly_loop: { keywords: ["scribble", "draw", "shape", "squiggle"], char: "\u27B0", fitzpatrick_scale: !1, category: "symbols" }, heavy_check_mark: { keywords: ["ok", "nike", "answer", "yes", "tick"], char: "\u2714\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrows_clockwise: { keywords: ["sync", "cycle", "round", "repeat"], char: "\u{1F503}", fitzpatrick_scale: !1, category: "symbols" }, heavy_plus_sign: { keywords: ["math", "calculation", "addition", "more", "increase"], char: "\u2795", fitzpatrick_scale: !1, category: "symbols" }, heavy_minus_sign: { keywords: ["math", "calculation", "subtract", "less"], char: "\u2796", fitzpatrick_scale: !1, category: "symbols" }, heavy_division_sign: { keywords: ["divide", "math", "calculation"], char: "\u2797", fitzpatrick_scale: !1, category: "symbols" }, heavy_multiplication_x: { keywords: ["math", "calculation"], char: "\u2716\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, infinity: { keywords: ["forever"], char: "\u267E", fitzpatrick_scale: !1, category: "symbols" }, heavy_dollar_sign: { keywords: ["money", "sales", "payment", "currency", "buck"], char: "\u{1F4B2}", fitzpatrick_scale: !1, category: "symbols" }, currency_exchange: { keywords: ["money", "sales", "dollar", "travel"], char: "\u{1F4B1}", fitzpatrick_scale: !1, category: "symbols" }, copyright: { keywords: ["ip", "license", "circle", "law", "legal"], char: "\xA9\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, registered: { keywords: ["alphabet", "circle"], char: "\xAE\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, tm: { keywords: ["trademark", "brand", "law", "legal"], char: "\u2122\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, end: { keywords: ["words", "arrow"], char: "\u{1F51A}", fitzpatrick_scale: !1, category: "symbols" }, back: { keywords: ["arrow", "words", "return"], char: "\u{1F519}", fitzpatrick_scale: !1, category: "symbols" }, on: { keywords: ["arrow", "words"], char: "\u{1F51B}", fitzpatrick_scale: !1, category: "symbols" }, top: { keywords: ["words", "blue-square"], char: "\u{1F51D}", fitzpatrick_scale: !1, category: "symbols" }, soon: { keywords: ["arrow", "words"], char: "\u{1F51C}", fitzpatrick_scale: !1, category: "symbols" }, ballot_box_with_check: { keywords: ["ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick"], char: "\u2611\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, radio_button: { keywords: ["input", "old", "music", "circle"], char: "\u{1F518}", fitzpatrick_scale: !1, category: "symbols" }, white_circle: { keywords: ["shape", "round"], char: "\u26AA", fitzpatrick_scale: !1, category: "symbols" }, black_circle: { keywords: ["shape", "button", "round"], char: "\u26AB", fitzpatrick_scale: !1, category: "symbols" }, red_circle: { keywords: ["shape", "error", "danger"], char: "\u{1F534}", fitzpatrick_scale: !1, category: "symbols" }, large_blue_circle: { keywords: ["shape", "icon", "button"], char: "\u{1F535}", fitzpatrick_scale: !1, category: "symbols" }, small_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F538}", fitzpatrick_scale: !1, category: "symbols" }, small_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F539}", fitzpatrick_scale: !1, category: "symbols" }, large_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F536}", fitzpatrick_scale: !1, category: "symbols" }, large_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F537}", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle: { keywords: ["shape", "direction", "up", "top"], char: "\u{1F53A}", fitzpatrick_scale: !1, category: "symbols" }, black_small_square: { keywords: ["shape", "icon"], char: "\u25AA\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, white_small_square: { keywords: ["shape", "icon"], char: "\u25AB\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, black_large_square: { keywords: ["shape", "icon", "button"], char: "\u2B1B", fitzpatrick_scale: !1, category: "symbols" }, white_large_square: { keywords: ["shape", "icon", "stone", "button"], char: "\u2B1C", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle_down: { keywords: ["shape", "direction", "bottom"], char: "\u{1F53B}", fitzpatrick_scale: !1, category: "symbols" }, black_medium_square: { keywords: ["shape", "button", "icon"], char: "\u25FC\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, white_medium_square: { keywords: ["shape", "stone", "icon"], char: "\u25FB\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, black_medium_small_square: { keywords: ["icon", "shape", "button"], char: "\u25FE", fitzpatrick_scale: !1, category: "symbols" }, white_medium_small_square: { keywords: ["shape", "stone", "icon", "button"], char: "\u25FD", fitzpatrick_scale: !1, category: "symbols" }, black_square_button: { keywords: ["shape", "input", "frame"], char: "\u{1F532}", fitzpatrick_scale: !1, category: "symbols" }, white_square_button: { keywords: ["shape", "input"], char: "\u{1F533}", fitzpatrick_scale: !1, category: "symbols" }, speaker: { keywords: ["sound", "volume", "silence", "broadcast"], char: "\u{1F508}", fitzpatrick_scale: !1, category: "symbols" }, sound: { keywords: ["volume", "speaker", "broadcast"], char: "\u{1F509}", fitzpatrick_scale: !1, category: "symbols" }, loud_sound: { keywords: ["volume", "noise", "noisy", "speaker", "broadcast"], char: "\u{1F50A}", fitzpatrick_scale: !1, category: "symbols" }, mute: { keywords: ["sound", "volume", "silence", "quiet"], char: "\u{1F507}", fitzpatrick_scale: !1, category: "symbols" }, mega: { keywords: ["sound", "speaker", "volume"], char: "\u{1F4E3}", fitzpatrick_scale: !1, category: "symbols" }, loudspeaker: { keywords: ["volume", "sound"], char: "\u{1F4E2}", fitzpatrick_scale: !1, category: "symbols" }, bell: { keywords: ["sound", "notification", "christmas", "xmas", "chime"], char: "\u{1F514}", fitzpatrick_scale: !1, category: "symbols" }, no_bell: { keywords: ["sound", "volume", "mute", "quiet", "silent"], char: "\u{1F515}", fitzpatrick_scale: !1, category: "symbols" }, black_joker: { keywords: ["poker", "cards", "game", "play", "magic"], char: "\u{1F0CF}", fitzpatrick_scale: !1, category: "symbols" }, mahjong: { keywords: ["game", "play", "chinese", "kanji"], char: "\u{1F004}", fitzpatrick_scale: !1, category: "symbols" }, spades: { keywords: ["poker", "cards", "suits", "magic"], char: "\u2660\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, clubs: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2663\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, hearts: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2665\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, diamonds: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2666\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, flower_playing_cards: { keywords: ["game", "sunset", "red"], char: "\u{1F3B4}", fitzpatrick_scale: !1, category: "symbols" }, thought_balloon: { keywords: ["bubble", "cloud", "speech", "thinking", "dream"], char: "\u{1F4AD}", fitzpatrick_scale: !1, category: "symbols" }, right_anger_bubble: { keywords: ["caption", "speech", "thinking", "mad"], char: "\u{1F5EF}", fitzpatrick_scale: !1, category: "symbols" }, speech_balloon: { keywords: ["bubble", "words", "message", "talk", "chatting"], char: "\u{1F4AC}", fitzpatrick_scale: !1, category: "symbols" }, left_speech_bubble: { keywords: ["words", "message", "talk", "chatting"], char: "\u{1F5E8}", fitzpatrick_scale: !1, category: "symbols" }, clock1: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F550}", fitzpatrick_scale: !1, category: "symbols" }, clock2: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F551}", fitzpatrick_scale: !1, category: "symbols" }, clock3: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F552}", fitzpatrick_scale: !1, category: "symbols" }, clock4: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F553}", fitzpatrick_scale: !1, category: "symbols" }, clock5: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F554}", fitzpatrick_scale: !1, category: "symbols" }, clock6: { keywords: ["time", "late", "early", "schedule", "dawn", "dusk"], char: "\u{1F555}", fitzpatrick_scale: !1, category: "symbols" }, clock7: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F556}", fitzpatrick_scale: !1, category: "symbols" }, clock8: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F557}", fitzpatrick_scale: !1, category: "symbols" }, clock9: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F558}", fitzpatrick_scale: !1, category: "symbols" }, clock10: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F559}", fitzpatrick_scale: !1, category: "symbols" }, clock11: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55A}", fitzpatrick_scale: !1, category: "symbols" }, clock12: { keywords: ["time", "noon", "midnight", "midday", "late", "early", "schedule"], char: "\u{1F55B}", fitzpatrick_scale: !1, category: "symbols" }, clock130: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55C}", fitzpatrick_scale: !1, category: "symbols" }, clock230: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55D}", fitzpatrick_scale: !1, category: "symbols" }, clock330: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55E}", fitzpatrick_scale: !1, category: "symbols" }, clock430: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55F}", fitzpatrick_scale: !1, category: "symbols" }, clock530: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F560}", fitzpatrick_scale: !1, category: "symbols" }, clock630: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F561}", fitzpatrick_scale: !1, category: "symbols" }, clock730: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F562}", fitzpatrick_scale: !1, category: "symbols" }, clock830: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F563}", fitzpatrick_scale: !1, category: "symbols" }, clock930: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F564}", fitzpatrick_scale: !1, category: "symbols" }, clock1030: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F565}", fitzpatrick_scale: !1, category: "symbols" }, clock1130: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F566}", fitzpatrick_scale: !1, category: "symbols" }, clock1230: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F567}", fitzpatrick_scale: !1, category: "symbols" }, afghanistan: { keywords: ["af", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, aland_islands: { keywords: ["\xC5land", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, albania: { keywords: ["al", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, algeria: { keywords: ["dz", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, american_samoa: { keywords: ["american", "ws", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, andorra: { keywords: ["ad", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, angola: { keywords: ["ao", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, anguilla: { keywords: ["ai", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, antarctica: { keywords: ["aq", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, antigua_barbuda: { keywords: ["antigua", "barbuda", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, argentina: { keywords: ["ar", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, armenia: { keywords: ["am", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, aruba: { keywords: ["aw", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, australia: { keywords: ["au", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, austria: { keywords: ["at", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, azerbaijan: { keywords: ["az", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, bahamas: { keywords: ["bs", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, bahrain: { keywords: ["bh", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, bangladesh: { keywords: ["bd", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, barbados: { keywords: ["bb", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, belarus: { keywords: ["by", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, belgium: { keywords: ["be", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, belize: { keywords: ["bz", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, benin: { keywords: ["bj", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, bermuda: { keywords: ["bm", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, bhutan: { keywords: ["bt", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, bolivia: { keywords: ["bo", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, caribbean_netherlands: { keywords: ["bonaire", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, bosnia_herzegovina: { keywords: ["bosnia", "herzegovina", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, botswana: { keywords: ["bw", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, brazil: { keywords: ["br", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, british_indian_ocean_territory: { keywords: ["british", "indian", "ocean", "territory", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, british_virgin_islands: { keywords: ["british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, brunei: { keywords: ["bn", "darussalam", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, bulgaria: { keywords: ["bg", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, burkina_faso: { keywords: ["burkina", "faso", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, burundi: { keywords: ["bi", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, cape_verde: { keywords: ["cabo", "verde", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, cambodia: { keywords: ["kh", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, cameroon: { keywords: ["cm", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, canada: { keywords: ["ca", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, canary_islands: { keywords: ["canary", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, cayman_islands: { keywords: ["cayman", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, central_african_republic: { keywords: ["central", "african", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, chad: { keywords: ["td", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, chile: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, cn: { keywords: ["china", "chinese", "prc", "flag", "country", "nation", "banner"], char: "\u{1F1E8}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, christmas_island: { keywords: ["christmas", "island", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, cocos_islands: { keywords: ["cocos", "keeling", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, colombia: { keywords: ["co", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, comoros: { keywords: ["km", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, congo_brazzaville: { keywords: ["congo", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, congo_kinshasa: { keywords: ["congo", "democratic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, cook_islands: { keywords: ["cook", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, costa_rica: { keywords: ["costa", "rica", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, croatia: { keywords: ["hr", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, cuba: { keywords: ["cu", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, curacao: { keywords: ["cura\xE7ao", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, cyprus: { keywords: ["cy", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, czech_republic: { keywords: ["cz", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, denmark: { keywords: ["dk", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, djibouti: { keywords: ["dj", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, dominica: { keywords: ["dm", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, dominican_republic: { keywords: ["dominican", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, ecuador: { keywords: ["ec", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, egypt: { keywords: ["eg", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, el_salvador: { keywords: ["el", "salvador", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, equatorial_guinea: { keywords: ["equatorial", "gn", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, eritrea: { keywords: ["er", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, estonia: { keywords: ["ee", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, ethiopia: { keywords: ["et", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, eu: { keywords: ["european", "union", "flag", "banner"], char: "\u{1F1EA}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, falkland_islands: { keywords: ["falkland", "islands", "malvinas", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, faroe_islands: { keywords: ["faroe", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, fiji: { keywords: ["fj", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, finland: { keywords: ["fi", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, fr: { keywords: ["banner", "flag", "nation", "france", "french", "country"], char: "\u{1F1EB}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, french_guiana: { keywords: ["french", "guiana", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, french_polynesia: { keywords: ["french", "polynesia", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, french_southern_territories: { keywords: ["french", "southern", "territories", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, gabon: { keywords: ["ga", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, gambia: { keywords: ["gm", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, georgia: { keywords: ["ge", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, de: { keywords: ["german", "nation", "flag", "country", "banner"], char: "\u{1F1E9}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, ghana: { keywords: ["gh", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, gibraltar: { keywords: ["gi", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, greece: { keywords: ["gr", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, greenland: { keywords: ["gl", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, grenada: { keywords: ["gd", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, guadeloupe: { keywords: ["gp", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, guam: { keywords: ["gu", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, guatemala: { keywords: ["gt", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, guernsey: { keywords: ["gg", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, guinea: { keywords: ["gn", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, guinea_bissau: { keywords: ["gw", "bissau", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, guyana: { keywords: ["gy", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, haiti: { keywords: ["ht", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, honduras: { keywords: ["hn", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, hong_kong: { keywords: ["hong", "kong", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, hungary: { keywords: ["hu", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, iceland: { keywords: ["is", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, india: { keywords: ["in", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, indonesia: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, iran: { keywords: ["iran,", "islamic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, iraq: { keywords: ["iq", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, ireland: { keywords: ["ie", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, isle_of_man: { keywords: ["isle", "man", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, israel: { keywords: ["il", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, it: { keywords: ["italy", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, cote_divoire: { keywords: ["ivory", "coast", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, jamaica: { keywords: ["jm", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, jp: { keywords: ["japanese", "nation", "flag", "country", "banner"], char: "\u{1F1EF}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, jersey: { keywords: ["je", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, jordan: { keywords: ["jo", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, kazakhstan: { keywords: ["kz", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, kenya: { keywords: ["ke", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, kiribati: { keywords: ["ki", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, kosovo: { keywords: ["xk", "flag", "nation", "country", "banner"], char: "\u{1F1FD}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, kuwait: { keywords: ["kw", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, kyrgyzstan: { keywords: ["kg", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, laos: { keywords: ["lao", "democratic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, latvia: { keywords: ["lv", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, lebanon: { keywords: ["lb", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, lesotho: { keywords: ["ls", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, liberia: { keywords: ["lr", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, libya: { keywords: ["ly", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, liechtenstein: { keywords: ["li", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, lithuania: { keywords: ["lt", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, luxembourg: { keywords: ["lu", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, macau: { keywords: ["macao", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, macedonia: { keywords: ["macedonia,", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, madagascar: { keywords: ["mg", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, malawi: { keywords: ["mw", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, malaysia: { keywords: ["my", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, maldives: { keywords: ["mv", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, mali: { keywords: ["ml", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, malta: { keywords: ["mt", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, marshall_islands: { keywords: ["marshall", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, martinique: { keywords: ["mq", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, mauritania: { keywords: ["mr", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, mauritius: { keywords: ["mu", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, mayotte: { keywords: ["yt", "flag", "nation", "country", "banner"], char: "\u{1F1FE}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, mexico: { keywords: ["mx", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, micronesia: { keywords: ["micronesia,", "federated", "states", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, moldova: { keywords: ["moldova,", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, monaco: { keywords: ["mc", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, mongolia: { keywords: ["mn", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, montenegro: { keywords: ["me", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, montserrat: { keywords: ["ms", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, morocco: { keywords: ["ma", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, mozambique: { keywords: ["mz", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, myanmar: { keywords: ["mm", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, namibia: { keywords: ["na", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, nauru: { keywords: ["nr", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, nepal: { keywords: ["np", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, netherlands: { keywords: ["nl", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, new_caledonia: { keywords: ["new", "caledonia", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, new_zealand: { keywords: ["new", "zealand", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, nicaragua: { keywords: ["ni", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, niger: { keywords: ["ne", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, nigeria: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, niue: { keywords: ["nu", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, norfolk_island: { keywords: ["norfolk", "island", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, northern_mariana_islands: { keywords: ["northern", "mariana", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, north_korea: { keywords: ["north", "korea", "nation", "flag", "country", "banner"], char: "\u{1F1F0}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, norway: { keywords: ["no", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, oman: { keywords: ["om_symbol", "flag", "nation", "country", "banner"], char: "\u{1F1F4}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, pakistan: { keywords: ["pk", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, palau: { keywords: ["pw", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, palestinian_territories: { keywords: ["palestine", "palestinian", "territories", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, panama: { keywords: ["pa", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, papua_new_guinea: { keywords: ["papua", "new", "guinea", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, paraguay: { keywords: ["py", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, peru: { keywords: ["pe", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, philippines: { keywords: ["ph", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, pitcairn_islands: { keywords: ["pitcairn", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, poland: { keywords: ["pl", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, portugal: { keywords: ["pt", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, puerto_rico: { keywords: ["puerto", "rico", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, qatar: { keywords: ["qa", "flag", "nation", "country", "banner"], char: "\u{1F1F6}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, reunion: { keywords: ["r\xE9union", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, romania: { keywords: ["ro", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, ru: { keywords: ["russian", "federation", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, rwanda: { keywords: ["rw", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, st_barthelemy: { keywords: ["saint", "barth\xE9lemy", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, st_helena: { keywords: ["saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, st_kitts_nevis: { keywords: ["saint", "kitts", "nevis", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, st_lucia: { keywords: ["saint", "lucia", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, st_pierre_miquelon: { keywords: ["saint", "pierre", "miquelon", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, st_vincent_grenadines: { keywords: ["saint", "vincent", "grenadines", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, samoa: { keywords: ["ws", "flag", "nation", "country", "banner"], char: "\u{1F1FC}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, san_marino: { keywords: ["san", "marino", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, sao_tome_principe: { keywords: ["sao", "tome", "principe", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, saudi_arabia: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, senegal: { keywords: ["sn", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, serbia: { keywords: ["rs", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, seychelles: { keywords: ["sc", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, sierra_leone: { keywords: ["sierra", "leone", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, singapore: { keywords: ["sg", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, sint_maarten: { keywords: ["sint", "maarten", "dutch", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, slovakia: { keywords: ["sk", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, slovenia: { keywords: ["si", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, solomon_islands: { keywords: ["solomon", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, somalia: { keywords: ["so", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, south_africa: { keywords: ["south", "africa", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, south_georgia_south_sandwich_islands: { keywords: ["south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, kr: { keywords: ["south", "korea", "nation", "flag", "country", "banner"], char: "\u{1F1F0}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, south_sudan: { keywords: ["south", "sd", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, es: { keywords: ["spain", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, sri_lanka: { keywords: ["sri", "lanka", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, sudan: { keywords: ["sd", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, suriname: { keywords: ["sr", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, swaziland: { keywords: ["sz", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, sweden: { keywords: ["se", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, switzerland: { keywords: ["ch", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, syria: { keywords: ["syrian", "arab", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, taiwan: { keywords: ["tw", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, tajikistan: { keywords: ["tj", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, tanzania: { keywords: ["tanzania,", "united", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, thailand: { keywords: ["th", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, timor_leste: { keywords: ["timor", "leste", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, togo: { keywords: ["tg", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, tokelau: { keywords: ["tk", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, tonga: { keywords: ["to", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, trinidad_tobago: { keywords: ["trinidad", "tobago", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, tunisia: { keywords: ["tn", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, tr: { keywords: ["turkey", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, turkmenistan: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, turks_caicos_islands: { keywords: ["turks", "caicos", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, tuvalu: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, uganda: { keywords: ["ug", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, ukraine: { keywords: ["ua", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, united_arab_emirates: { keywords: ["united", "arab", "emirates", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, uk: { keywords: ["united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack"], char: "\u{1F1EC}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, england: { keywords: ["flag", "english"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, scotland: { keywords: ["flag", "scottish"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, wales: { keywords: ["flag", "welsh"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, us: { keywords: ["united", "states", "america", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, us_virgin_islands: { keywords: ["virgin", "islands", "us", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, uruguay: { keywords: ["uy", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, uzbekistan: { keywords: ["uz", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, vanuatu: { keywords: ["vu", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, vatican_city: { keywords: ["vatican", "city", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, venezuela: { keywords: ["ve", "bolivarian", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, vietnam: { keywords: ["viet", "nam", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, wallis_futuna: { keywords: ["wallis", "futuna", "flag", "nation", "country", "banner"], char: "\u{1F1FC}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, western_sahara: { keywords: ["western", "sahara", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, yemen: { keywords: ["ye", "flag", "nation", "country", "banner"], char: "\u{1F1FE}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, zambia: { keywords: ["zm", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, zimbabwe: { keywords: ["zw", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, united_nations: { keywords: ["un", "flag", "banner"], char: "\u{1F1FA}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, pirate_flag: { keywords: ["skull", "crossbones", "flag", "banner"], char: "\u{1F3F4}\u200D\u2620\uFE0F", fitzpatrick_scale: !1, category: "flags" } });
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const D = ((ae) => (ke) => typeof ke === ae)("function");
  var X = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), _e = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ae = (ae) => (ke) => ke.options.get(ae), We = (ae) => {
    const ke = ae.options.register;
    ke("save_enablewhendirty", {
      processor: "boolean",
      default: !0
    }), ke("save_onsavecallback", { processor: "function" }), ke("save_oncancelcallback", { processor: "function" });
  }, Ke = Ae("save_enablewhendirty"), Ee = Ae("save_onsavecallback"), Ie = Ae("save_oncancelcallback"), pt = (ae, ke) => {
    ae.notificationManager.open({
      text: ke,
      type: "error"
    });
  }, _t = (ae) => {
    const ke = X.DOM.getParent(ae.id, "form");
    if (Ke(ae) && !ae.isDirty())
      return;
    ae.save();
    const ge = Ee(ae);
    if (D(ge)) {
      ge.call(ae, ae), ae.nodeChanged();
      return;
    }
    ke ? (ae.setDirty(!1), (!ke.onsubmit || ke.onsubmit()) && (typeof ke.submit == "function" ? ke.submit() : pt(ae, "Error: Form submit field collision.")), ae.nodeChanged()) : pt(ae, "Error: No form element found.");
  }, $e = (ae) => {
    const ke = _e.trim(ae.startContent), ge = Ie(ae);
    if (D(ge)) {
      ge.call(ae, ae);
      return;
    }
    ae.resetContent(ke);
  }, Ne = (ae) => {
    ae.addCommand("mceSave", () => {
      _t(ae);
    }), ae.addCommand("mceCancel", () => {
      $e(ae);
    });
  }, tt = (ae) => (ke) => {
    const ge = () => {
      ke.setEnabled(!Ke(ae) || ae.isDirty());
    };
    return ge(), ae.on("NodeChange dirty", ge), () => ae.off("NodeChange dirty", ge);
  }, xe = (ae) => {
    ae.ui.registry.addButton("save", {
      icon: "save",
      tooltip: "Save",
      enabled: !1,
      onAction: () => ae.execCommand("mceSave"),
      onSetup: tt(ae)
    }), ae.ui.registry.addButton("cancel", {
      icon: "cancel",
      tooltip: "Cancel",
      enabled: !1,
      onAction: () => ae.execCommand("mceCancel"),
      onSetup: tt(ae)
    }), ae.addShortcut("Meta+S", "", "mceSave");
  };
  var rt = () => {
    g.add("save", (ae) => {
      We(ae), xe(ae), Ne(ae);
    });
  };
  rt();
})();
(function() {
  var g = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const _ = (w, ie, re) => {
    var we;
    return re(w, ie.prototype) ? !0 : ((we = w.constructor) === null || we === void 0 ? void 0 : we.name) === ie.name;
  }, D = (w) => {
    const ie = typeof w;
    return w === null ? "null" : ie === "object" && Array.isArray(w) ? "array" : ie === "object" && _(w, String, (re, we) => we.isPrototypeOf(re)) ? "string" : ie;
  }, X = (w) => (ie) => D(ie) === w, _e = (w) => (ie) => typeof ie === w, Ae = X("string"), We = _e("boolean"), Ke = (w) => w == null, Ee = (w) => !Ke(w), Ie = _e("function"), pt = (w) => (ie) => ie.options.get(w), _t = (w) => {
    const ie = w.options.register, re = (ce) => (Ce) => {
      const W = We(Ce) || Ae(Ce);
      return W ? We(Ce) ? {
        value: Ce ? ce : "",
        valid: W
      } : {
        value: Ce.trim(),
        valid: W
      } : {
        valid: !1,
        message: "Must be a boolean or string."
      };
    }, we = "bold italic | quicklink h2 h3 blockquote";
    ie("quickbars_selection_toolbar", {
      processor: re(we),
      default: we
    });
    const J = "quickimage quicktable";
    ie("quickbars_insert_toolbar", {
      processor: re(J),
      default: J
    });
    const me = "alignleft aligncenter alignright";
    ie("quickbars_image_toolbar", {
      processor: re(me),
      default: me
    });
  }, $e = pt("quickbars_selection_toolbar"), Ne = pt("quickbars_insert_toolbar"), tt = pt("quickbars_image_toolbar");
  let xe = 0;
  const rt = (w) => {
    const re = new Date().getTime(), we = Math.floor(Math.random() * 1e9);
    return xe++, w + "_" + we + xe + String(re);
  }, ae = (w, ie, re) => {
    w.execCommand("mceInsertTable", !1, {
      rows: re,
      columns: ie
    });
  }, ke = (w, ie, re) => {
    const we = w.editorUpload.blobCache, J = we.create(rt("mceu"), re, ie);
    we.add(J), w.insertContent(w.dom.createHTML("img", { src: J.blobUri() }));
  }, ge = (w) => new Promise((ie) => {
    const re = new FileReader();
    re.onloadend = () => {
      ie(re.result.split(",")[1]);
    }, re.readAsDataURL(w);
  });
  var zt = tinymce.util.Tools.resolve("tinymce.Env"), ot = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const le = (w) => new Promise((ie) => {
    const re = document.createElement("input");
    re.type = "file", re.accept = "image/*", re.style.position = "fixed", re.style.left = "0", re.style.top = "0", re.style.opacity = "0.001", document.body.appendChild(re);
    const we = (me) => {
      ie(Array.prototype.slice.call(me.target.files));
    };
    re.addEventListener("change", we);
    const J = (me) => {
      const ce = () => {
        ie([]), re.parentNode.removeChild(re);
      };
      zt.os.isAndroid() && me.type !== "remove" ? ot.setEditorTimeout(w, ce, 0) : ce(), w.off("focusin remove", J);
    };
    w.on("focusin remove", J), re.click();
  }), it = (w) => {
    w.ui.registry.addButton("quickimage", {
      icon: "image",
      tooltip: "Insert image",
      onAction: () => {
        le(w).then((ie) => {
          if (ie.length > 0) {
            const re = ie[0];
            ge(re).then((we) => {
              ke(w, we, re);
            });
          }
        });
      }
    }), w.ui.registry.addButton("quicktable", {
      icon: "table",
      tooltip: "Insert table",
      onAction: () => {
        ae(w, 2, 2);
      }
    });
  }, Le = ((w) => () => w)(!1);
  class Ve {
    constructor(ie, re) {
      this.tag = ie, this.value = re;
    }
    static some(ie) {
      return new Ve(!0, ie);
    }
    static none() {
      return Ve.singletonNone;
    }
    fold(ie, re) {
      return this.tag ? re(this.value) : ie();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ie) {
      return this.tag ? Ve.some(ie(this.value)) : Ve.none();
    }
    bind(ie) {
      return this.tag ? ie(this.value) : Ve.none();
    }
    exists(ie) {
      return this.tag && ie(this.value);
    }
    forall(ie) {
      return !this.tag || ie(this.value);
    }
    filter(ie) {
      return !this.tag || ie(this.value) ? this : Ve.none();
    }
    getOr(ie) {
      return this.tag ? this.value : ie;
    }
    or(ie) {
      return this.tag ? this : ie;
    }
    getOrThunk(ie) {
      return this.tag ? this.value : ie();
    }
    orThunk(ie) {
      return this.tag ? this : ie();
    }
    getOrDie(ie) {
      if (this.tag)
        return this.value;
      throw new Error(ie != null ? ie : "Called getOrDie on None");
    }
    static from(ie) {
      return Ee(ie) ? Ve.some(ie) : Ve.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ie) {
      this.tag && ie(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ve.singletonNone = new Ve(!1);
  var L = (w, ie, re, we, J) => w(re, we) ? Ve.some(re) : Ie(J) && J(re) ? Ve.none() : ie(re, we, J);
  const Wt = 1, Je = (w, ie) => {
    const we = (ie || document).createElement("div");
    if (we.innerHTML = w, !we.hasChildNodes() || we.childNodes.length > 1) {
      const J = "HTML does not have a single root node";
      throw console.error(J, w), new Error(J);
    }
    return Ze(we.childNodes[0]);
  }, jt = (w, ie) => {
    const we = (ie || document).createElement(w);
    return Ze(we);
  }, ye = (w, ie) => {
    const we = (ie || document).createTextNode(w);
    return Ze(we);
  }, Ze = (w) => {
    if (w == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: w };
  }, Z = {
    fromHtml: Je,
    fromTag: jt,
    fromText: ye,
    fromDom: Ze,
    fromPoint: (w, ie, re) => Ve.from(w.dom.elementFromPoint(ie, re)).map(Ze)
  }, Pe = (w, ie) => {
    const re = w.dom;
    if (re.nodeType !== Wt)
      return !1;
    {
      const we = re;
      if (we.matches !== void 0)
        return we.matches(ie);
      if (we.msMatchesSelector !== void 0)
        return we.msMatchesSelector(ie);
      if (we.webkitMatchesSelector !== void 0)
        return we.webkitMatchesSelector(ie);
      if (we.mozMatchesSelector !== void 0)
        return we.mozMatchesSelector(ie);
      throw new Error("Browser lacks native selectors");
    }
  };
  typeof window < "u" || Function("return this;")();
  const yt = (w) => w.dom.nodeName.toLowerCase(), et = (w, ie, re) => {
    let we = w.dom;
    const J = Ie(re) ? re : Le;
    for (; we.parentNode; ) {
      we = we.parentNode;
      const me = Z.fromDom(we);
      if (ie(me))
        return Ve.some(me);
      if (J(me))
        break;
    }
    return Ve.none();
  }, kn = (w, ie, re) => L((J, me) => me(J), et, w, ie, re), Rn = (w, ie, re) => et(w, (we) => Pe(we, ie), re), an = (w, ie, re) => L((J, me) => Pe(J, me), Rn, w, ie, re), en = (w) => {
    const ie = Ne(w);
    ie.length > 0 && w.ui.registry.addContextToolbar("quickblock", {
      predicate: (re) => {
        const we = Z.fromDom(re), J = w.schema.getTextBlockElements(), me = (ce) => ce.dom === w.getBody();
        return an(we, "table", me).fold(() => kn(we, (ce) => yt(ce) in J && w.dom.isEmpty(ce.dom), me).isSome(), Le);
      },
      items: ie,
      position: "line",
      scope: "editor"
    });
  }, cn = (w) => {
    const ie = (me) => w.dom.getContentEditableParent(me) !== "false", re = (me) => me.nodeName === "IMG" || me.nodeName === "FIGURE" && /image/i.test(me.className), we = tt(w);
    we.length > 0 && w.ui.registry.addContextToolbar("imageselection", {
      predicate: re,
      items: we,
      position: "node"
    });
    const J = $e(w);
    J.length > 0 && w.ui.registry.addContextToolbar("textselection", {
      predicate: (me) => !re(me) && !w.selection.isCollapsed() && ie(me),
      items: J,
      position: "selection",
      scope: "editor"
    });
  };
  var wn = () => {
    g.add("quickbars", (w) => {
      _t(w), it(w), en(w), cn(w);
    });
  };
  wn();
})();
const ef = z6({
  name: "MiniMCE",
  props: {
    ...pp ? {
      modelValue: String
    } : {
      value: String
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    outputFormat: {},
    options: {}
  },
  setup(g, { expose: _, emit: D }) {
    const X = Tk(!0), _e = Tk(`minimce-${IK()}`), Ae = Tk(!1), We = Tk(!1), Ke = qS(
      () => Rk([g.disabled, Dk.disabled], {
        type: Boolean
      })
    ), Ee = qS(
      () => Rk([g.outputFormat, Dk.outputFormat], {
        type: String
      })
    ), Ie = qS(
      () => Rk(
        [
          g.options,
          Dk.options,
          {
            selector: `#${_e.value}`,
            plugins: "preview importcss searchreplace autolink autosave save directionality visualblocks visualchars fullscreen image link media table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons",
            menubar: "file edit view insert format tools table help",
            toolbar: "undo redo | bold italic underline strikethrough | fontfamily fontsize blocks | alignleft aligncenter alignright alignjustify | outdent indent |  numlist bullist | forecolor backcolor removeformat | pagebreak | charmap emoticons | fullscreen  preview save print | insertfile image media template link anchor codesample | ltr rtl",
            quickbars_selection_toolbar: "bold italic | quicklink h2 h3 blockquote quickimage quicktable",
            contextmenu: "link image table",
            branding: !1,
            quickbars_insert_toolbar: !1,
            invalid_elements: "iframe,frame",
            skin: !1,
            content_css: !1,
            autosave_ask_before_unload: !1,
            autosave_interval: "30s",
            autosave_prefix: "{path}{query}-{id}-",
            autosave_restore_when_empty: !1,
            autosave_retention: "2m",
            height: 500,
            relative_urls: !1,
            convert_urls: !1,
            image_advtab: !0,
            image_caption: !0,
            media_live_embeds: !1,
            toolbar_mode: "sliding",
            init_instance_callback: (pt) => {
              VN(
                Ke,
                (Ne) => {
                  pt.mode.set(Ne ? "readonly" : "design");
                },
                {
                  immediate: !0
                }
              );
              const _t = pp ? "update:modelValue" : "input", $e = pY(() => {
                if (We.value) {
                  We.value = !1;
                  return;
                }
                Ae.value = !0, D(
                  _t,
                  pt.getContent({ format: Ee.value })
                );
              }, 100);
              pt.on("change input SetContent", $e), VN(
                () => pp ? g.modelValue : g.value,
                (Ne) => {
                  if (Ae.value) {
                    Ae.value = !1;
                    return;
                  }
                  We.value = !0, pt.setContent(Ne || "");
                },
                {
                  immediate: !0
                }
              ), D("init", pt), X.value = !1;
            }
          }
        ],
        {
          camelCase: !1,
          mergeFunction: (pt, _t) => (...$e) => {
            pt(...$e), _t(...$e);
          },
          type: Object
        }
      )
    );
    return qU(() => {
      const pt = document.querySelector(`#${_e.value}`), _t = new IntersectionObserver(($e) => {
        $e[0].isIntersecting && (_t.unobserve(pt), gY.init(Ie.value));
      });
      _t.observe(pt);
    }), pp && _({ id: _e }), {
      loading: X,
      id: _e
    };
  },
  render(g) {
    return pp ? ha(
      "div",
      {
        style: {
          height: "500px",
          position: "relative"
        }
      },
      [
        ha(T6, {
          style: {
            display: g.loading ? void 0 : "none"
          }
        }),
        ha("textarea", {
          id: g.id
        })
      ]
    ) : ha(
      "div",
      {
        style: {
          height: "500px",
          position: "relative"
        }
      },
      [
        ha(T6, {
          directives: [{ name: "show", value: GN(this.loading) }]
        }),
        ha("textarea", {
          attrs: {
            id: GN(this.id)
          },
          on: {
            input: (_) => {
              this.$emit("input", _);
            }
          }
        })
      ]
    );
  }
});
let Dk = {}, hY = {}, yY = {}, bY = {};
ef.install = (g, _ = {}) => {
  if (ef.name) {
    if (ef.install.installed) {
      console.warn(`${ef.name} has been registered.`);
      return;
    }
  } else
    throw Error("Name is required for a global component.");
  const { props: D, attrs: X, listeners: _e, hooks: Ae } = VU(_, ef.props);
  Dk = D, hY = X, yY = _e, bY = Ae, g.component(ef.name, ef), ef.install.installed = !0;
};
export {
  ef as default,
  hY as globalAttrs,
  bY as globalHooks,
  yY as globalListeners,
  Dk as globalProps
};

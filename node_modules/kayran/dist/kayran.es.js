var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { isPlainObject, identity, cloneDeep, mergeWith, assignInWith, mapKeys } from "lodash-es";
var waitFor = (promise) => promise.then((res) => [res]).catch((err) => [void 0, err]);
var isEllipsis = (dom) => {
  let checkDom = dom.cloneNode(), parent, flag;
  checkDom.style.width = dom.offsetWidth + "px";
  checkDom.style.height = dom.offsetHeight + "px";
  checkDom.style.overflow = "auto";
  checkDom.style.position = "absolute";
  checkDom.style.zIndex = "-1";
  checkDom.style.opacity = "0";
  checkDom.style.whiteSpace = "nowrap";
  checkDom.innerHTML = dom.innerHTML;
  parent = dom.parentNode;
  parent.appendChild(checkDom);
  flag = checkDom.scrollWidth > checkDom.offsetWidth;
  parent.removeChild(checkDom);
  return flag;
};
var isEmpty = (value) => {
  return {
    object: () => value === null || Array.isArray(value) && value.length === 0 || isPlainObject(value) && Object.getOwnPropertyNames(value).length === 0,
    number: () => Number.isNaN(value),
    string: () => value === "",
    undefined: () => true,
    boolean: () => value === false,
    symbol: () => false,
    bigint: () => false
  }[typeof value]();
};
var notEmpty = (value) => {
  return !isEmpty(value);
};
function typeOf(variate) {
  return {}.toString.call(variate).slice(8, -1).toLowerCase();
}
var jsonToFormData = (json, mapFn = identity) => {
  const formData = new FormData();
  let valid = true;
  for (let k in json) {
    const value = mapFn(json[k], k);
    if (!["string", "blob", "file"].includes(typeOf(value))) {
      valid = false;
    }
    if (value !== void 0) {
      formData.append(k, value);
    }
  }
  if (!valid) {
    console.warn(`${"[Kayran] "}FormData \u7684 value \u7C7B\u578B\u4EC5\u80FD\u4E3A string \u6216 blob`);
  }
  return formData;
};
function loadLink(href) {
  return new Promise((resolve, reject) => {
    if (!href || typeof href === "object" && !href.href) {
      reject("href\u4E3A\u7A7A");
    }
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.onerror = reject;
    if (typeof href === "string") {
      link.href = href;
    } else {
      let props = href;
      for (let k in props) {
        link[k] = props[k];
      }
    }
    link.onload = () => resolve(link);
    document.head.appendChild(link);
  });
}
function loadScript(src) {
  return new Promise((resolve, reject) => {
    if (!src || typeof src === "object" && !src.src) {
      reject("src\u4E3A\u7A7A");
    }
    const script = document.createElement("script");
    script.onload = () => resolve(script);
    script.onerror = reject;
    if (typeof src === "string") {
      script.src = src;
    } else {
      let props = src;
      for (let k in props) {
        script[k] = props[k];
      }
    }
    document.body.appendChild(script);
  });
}
function loadStyle(arg) {
  return new Promise((resolve, reject) => {
    if (!arg || typeof arg === "object" && !arg.innerText) {
      reject("innerText\u4E3A\u7A7A");
    }
    let style;
    if (arg instanceof HTMLElement) {
      if (arg.tagName === "STYLE") {
        style = arg;
      } else {
        reject("\u4EC5\u652F\u6301style\u5143\u7D20");
      }
    } else {
      style = document.createElement("style");
      if (typeof arg === "string") {
        style.appendChild(document.createTextNode(arg));
      } else {
        let props = arg;
        for (let k in props) {
          if (k === "innerText") {
            style.appendChild(document.createTextNode(props[k]));
          } else {
            style[k] = props[k];
          }
        }
      }
    }
    style.onload = () => resolve(style);
    style.onerror = reject;
    document.head.appendChild(style);
  });
}
var pickDeepBy = (object, predicate) => {
  if (isPlainObject(object)) {
    let newObj = cloneDeep(object);
    const recursion = (obj) => {
      for (const k in obj) {
        if (!predicate(obj[k], k)) {
          delete obj[k];
        } else if (isPlainObject(obj[k])) {
          recursion(obj[k]);
        } else if (Array.isArray(obj[k])) {
          for (const v of obj[k]) {
            recursion(v);
          }
        }
      }
    };
    recursion(newObj);
    return newObj;
  } else {
    if (typeOf(object) === "object") {
      console.warn(`${"[Kayran] "}pickDeepBy \u4EC5\u652F\u6301 plain-object \u7C7B\u578B`);
    }
    return object;
  }
};
var replace$1 = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace$1.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
};
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$1 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var stringify$1 = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset) {
  var obj = object;
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    var value = typeof key === "object" && key.value !== void 0 ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  var formatter = formats$1.formatters[format];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$1(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, "value");
      });
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$1 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse = parse$1;
var formats = formats$3;
var lib = {
  formats,
  parse,
  stringify: stringify2
};
var Mode = /* @__PURE__ */ ((Mode2) => {
  Mode2["history"] = "history";
  Mode2["hash"] = "hash";
  return Mode2;
})(Mode || {});
function parseQueryString(config) {
  let key, mode, del, search, hash;
  if (typeof config === "object") {
    key = config.key;
    del = config.del;
    mode = config.mode;
    search = config.search;
    hash = config.hash;
    if (mode) {
      let pass = false;
      for (let k in Mode) {
        if (mode === Mode[k]) {
          pass = true;
        }
      }
      if (!pass) {
        throw Error("[parseQueryString] mode\u4EC5\u80FD\u4E3A'history'\u6216'hash'");
      }
    }
  } else {
    key = config;
  }
  mode = mode || "hash";
  search = search || window.location.search;
  hash = hash || window.location.hash;
  function parseSearch() {
    return lib.parse(search, { ignoreQueryPrefix: true });
  }
  function parseHash() {
    const questionMarkIndex = hash.indexOf("?");
    hash = hash.substring(questionMarkIndex);
    if (hash) {
      let result = lib.parse(hash, { ignoreQueryPrefix: true });
      if (search.includes("code=")) {
        result.code = parseSearch().code;
      }
      return result;
    }
  }
  let obj = (mode === "history" ? parseSearch() : parseHash()) || {};
  if (key) {
    if (del) {
      if ((mode === "history" || key === "code") && search.includes(`${key}=`)) {
        window.location.replace(window.location.href.replace(search, search.replace(`${key}=${obj[key]}`, "")));
      }
      if ((mode === "hash" || key === "code") && hash.includes(`${key}=`)) {
        window.location.hash = hash.replace(`${key}=${obj[key]}`, "");
      }
    }
    return obj[key] || "";
  } else {
    if (del) {
      let newHref;
      if (mode === "hash") {
        if (obj.code && search.includes("code=")) {
          newHref = window.location.href.replace(hash, "");
          newHref = newHref.replace("code=", "");
          window.location.replace(newHref);
        } else {
          window.location.hash = "";
        }
      } else {
        newHref = window.location.href.replace(search, "");
        window.location.replace(newHref);
      }
    }
    return obj;
  }
}
const name = "kayran";
const errPrefix$1 = `[${name}] `;
const lng = (value) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (/^-?(\d+|\d+\.\d+)$/.test(value)) {
      value = Number(value);
      if (value > 180 || value < -180) {
        errInfo = "\u7ECF\u5EA6\u7684\u8303\u56F4\u4E3A[-180, 180]";
      }
    } else {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const lat = (value) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (/^-?(\d+|\d+\.\d+)$/.test(value)) {
      value = Number(value);
      if (value > 90 || value < -90) {
        errInfo = "\u7EAC\u5EA6\u7684\u8303\u56F4\u4E3A[-90, 90]";
      }
    } else {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const phone = (value) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (!/^(?:(?:\+|00)86)?1[3-9]\d{9}$/.test(value)) {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const url = (value) => {
  let errInfo = "";
  if (notEmpty(value)) {
    if (!/^(((ht|f)tps?):\/\/)?[\w-]+(\.[\w-]+)+([\w.,@?^=%&:/~+#-]*[\w@?^=%&/~+#-])?$/.test(value)) {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const base64 = (value, { mediaType = "", scheme = true } = {}) => {
  let errInfo = "";
  if (notEmpty(value)) {
    if (scheme && !value.startsWith(`data:${mediaType}`)) {
      errInfo = "\u7F3A\u5931scheme";
    } else {
      const data = scheme ? value.split(",")[1] : value;
      if (!(data && /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/.test(data))) {
        errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
      }
    }
  }
  return errInfo;
};
const idCard = (value) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (!/^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d{3}[\dXx]$/.test(value)) {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const postcode = (value) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (!/^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d{4}$/.test(value)) {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
    }
  }
  return errInfo;
};
const tel = (value, { multiple = true } = {}) => {
  const regex = multiple ? /^((?:\d{3}-)?\d{8};?)+$|^((?:\d{4}-)?\d{7,8};?)+$/ : /^(?:\d{3}-)?\d{8}$|^(?:\d{4}-)?\d{7,8}$/;
  const maxLen = 50;
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    value = value.toString();
    if (value.length > maxLen) {
      errInfo = "\u4E0D\u80FD\u8D85\u8FC7" + maxLen + "\u4E2A\u5B57\u7B26";
    } else if (!regex.test(value)) {
      errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E" + (multiple ? "\uFF0C\u5982\u6709\u591A\u4E2A\u8BF7\u7528\u82F1\u6587\u5206\u53F7\u9694\u5F00" : "");
    }
  }
  return errInfo;
};
const email = (value) => {
  let errInfo = "";
  if (!/^[\u4e00-\u9fa5\dA-Za-z_-]+@[\dA-Za-z_-]+(\.[\dA-Za-z_-]+)+$/.test(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  }
  return errInfo;
};
const ipv4 = (value) => {
  let errInfo = "";
  if (!/^((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$/.test(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  }
  return errInfo;
};
const ipv6 = (value) => {
  let errInfo = "";
  if (!/^(?:(?:(?:[0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))|\[(?:(?:(?:[0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))\](?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$/i.test(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  }
  return errInfo;
};
const len = (value, options) => {
  let errInfo = "", target, min, max;
  if (typeof options === "number") {
    if (Number.isNaN(options)) {
      throw Error(errPrefix$1 + "options\u4E0D\u80FD\u4E3ANaN");
    }
    target = options;
  } else if (Array.isArray(options)) {
    min = options[0];
    max = options[1];
  } else if (options && typeof options === "object") {
    min = options.min;
    max = options.max;
  }
  if (Number.isNaN(min)) {
    throw Error(errPrefix$1 + "min\u4E0D\u80FD\u4E3ANaN");
  }
  if (Number.isNaN(max)) {
    throw Error(errPrefix$1 + "max\u4E0D\u80FD\u4E3ANaN");
  }
  if (max < 0) {
    throw Error(errPrefix$1 + "max\u4E0D\u80FD\u4E3A\u8D1F");
  }
  if (min < 0) {
    throw Error(errPrefix$1 + "min\u4E0D\u80FD\u4E3A\u8D1F");
  }
  if (max < min) {
    throw Error(errPrefix$1 + "max\u4E0D\u80FD\u5C0F\u4E8Emin");
  }
  if (isEmpty(target) && isEmpty(min) && isEmpty(max)) {
    throw Error(errPrefix$1 + "\u672A\u6307\u5B9A\u4EFB\u4F55\u6821\u9A8C\u6761\u4EF6");
  }
  if (value === "" || notEmpty(value)) {
    if (value.length > max) {
      errInfo = "\u4E0D\u80FD\u8D85\u8FC7" + max + "\u4E2A\u5B57\u7B26";
    } else if (min && value.length < min) {
      errInfo = "\u4E0D\u80FD\u4F4E\u4E8E" + min + "\u4E2A\u5B57\u7B26";
    } else if (notEmpty(target) && value.length !== target) {
      errInfo = "\u5B57\u7B26\u6570\u9700\u4E3A" + min;
    }
  }
  return errInfo;
};
const int = (value, options) => {
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    let min, max, greaterThan, lessThan, range, positiveSign;
    if (typeof options === "object") {
      range = options.range;
      positiveSign = options.positiveSign;
    } else {
      range = options;
    }
    if (!positiveSign && typeof value === "number") {
      console.warn(errPrefix$1 + "positiveSign \u4EC5\u5BF9\u5B57\u7B26\u4E32\u751F\u6548");
    }
    if (range) {
      if (!/^[\[(](-?\d*|-∞),(-?\d*|\+∞)[\])]$/.test(range)) {
        throw Error(errPrefix$1 + "range\u53C2\u6570\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      const [start, end] = range.substr(1, range.length - 2).split(",");
      if (!["", "-\u221E"].includes(start)) {
        if (range.startsWith("(")) {
          greaterThan = start;
        } else {
          min = start;
        }
      }
      if (!["", "+\u221E"].includes(end)) {
        if (range.endsWith(")")) {
          lessThan = end;
        } else {
          max = end;
        }
      }
    }
    const numberValue = Number(value);
    const stringValue = value.toString();
    switch (true) {
      case !(positiveSign ? /^[+\-]?\d+$/ : /^\-?\d+$/).test(stringValue):
        errInfo = "\u9700\u4E3A\u6574\u6570";
        break;
      case (notEmpty(min) && numberValue < min):
        errInfo = "\u4E0D\u80FD\u5C0F\u4E8E" + min;
        break;
      case (notEmpty(max) && numberValue > max):
        errInfo = "\u4E0D\u80FD\u5927\u4E8E" + max;
        break;
      case (notEmpty(greaterThan) && numberValue <= greaterThan):
        errInfo = "\u9700\u5927\u4E8E" + greaterThan;
        break;
      case (notEmpty(lessThan) && numberValue >= lessThan):
        errInfo = "\u9700\u5C0F\u4E8E" + lessThan;
        break;
    }
  }
  return errInfo;
};
const decimal = (value, options) => {
  var _a, _b, _c, _d, _e;
  let errInfo = "";
  if (typeof value === "number" && Number.isNaN(value)) {
    errInfo = "\u683C\u5F0F\u4E0D\u6B63\u786E";
  } else if (notEmpty(value)) {
    let range, decimalPlaces, min, max, greaterThan, lessThan;
    if (typeof options === "object") {
      range = options.range;
      decimalPlaces = options.decimalPlaces;
    } else {
      range = options;
    }
    if (range) {
      if (!/^[\[(](-?\d*\.?\d*|-∞),(-?\d*\.?\d*|\+∞)[\])]$/.test(range)) {
        throw Error(errPrefix$1 + "range\u53C2\u6570\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      const [start, end] = range.substr(1, range.length - 2).split(",");
      if (!["", "-\u221E"].includes(start)) {
        if (range.startsWith("(")) {
          greaterThan = start;
        } else {
          min = start;
        }
      }
      if (!["", "+\u221E"].includes(end)) {
        if (range.endsWith(")")) {
          lessThan = end;
        } else {
          max = end;
        }
      }
    }
    const numberValue = Number(value);
    const stringValue = value.toString();
    switch (true) {
      case !/^-?(\d+|\d+\.\d+)$/.test(stringValue):
        errInfo = "\u9700\u4E3A\u6570\u5B57";
        break;
      case (notEmpty(min) && numberValue < min):
        errInfo = "\u4E0D\u80FD\u5C0F\u4E8E" + min;
        break;
      case (notEmpty(max) && numberValue > max):
        errInfo = "\u4E0D\u80FD\u5927\u4E8E" + max;
        break;
      case (notEmpty(greaterThan) && numberValue <= greaterThan):
        errInfo = "\u9700\u5927\u4E8E" + greaterThan;
        break;
      case (notEmpty(lessThan) && numberValue >= lessThan):
        errInfo = "\u9700\u5C0F\u4E8E" + lessThan;
        break;
      default:
        const decimalPart = stringValue.split(".");
        if (typeof decimalPlaces === "number") {
          switch (true) {
            case decimalPlaces < 0:
              throw Error("decimalPlaces\u4E0D\u80FD\u5C0F\u4E8E0");
            case decimalPlaces === 0:
              if (notEmpty(decimalPart[1])) {
                errInfo = "\u9700\u4E3A\u6574\u6570";
              }
              break;
            default:
              if (((_a = decimalPart[1]) == null ? void 0 : _a.length) !== decimalPlaces) {
                errInfo = "\u5C0F\u6570\u4F4D\u6570\u9700\u4E3A" + decimalPlaces + "\u4F4D";
              }
          }
        } else if (Array.isArray(decimalPlaces)) {
          const [minDecimalPlaces, maxDecimalPlaces] = decimalPlaces;
          if (maxDecimalPlaces < minDecimalPlaces) {
            throw Error(errPrefix$1 + "decimalPlaces\u7684\u4E0A\u9650\u4E0D\u80FD\u5C0F\u4E8E\u4E0B\u9650");
          }
          if (Number.isNaN(maxDecimalPlaces)) {
            throw Error(errPrefix$1 + "decimalPlaces[1]\u4E0D\u80FD\u4E3ANaN");
          } else {
            if (maxDecimalPlaces < 0) {
              throw Error(errPrefix$1 + "decimalPlaces\u7684\u4E0A\u9650\u4E0D\u80FD\u4E3A\u8D1F");
            }
            if (((_c = (_b = decimalPart[1]) == null ? void 0 : _b.length) != null ? _c : 0) > maxDecimalPlaces) {
              errInfo = "\u6700\u591A" + maxDecimalPlaces + "\u4F4D\u5C0F\u6570";
            }
          }
          if (Number.isNaN(minDecimalPlaces)) {
            throw Error(errPrefix$1 + "decimalPlaces[0]\u4E0D\u80FD\u4E3ANaN");
          } else {
            if (minDecimalPlaces < 0) {
              throw Error(errPrefix$1 + "decimalPlaces[0]\u4E0D\u80FD\u4E3A\u8D1F");
            }
            if (((_e = (_d = decimalPart[1]) == null ? void 0 : _d.length) != null ? _e : 0) < minDecimalPlaces) {
              errInfo = "\u6700\u5C11" + minDecimalPlaces + "\u4F4D\u5C0F\u6570";
            }
          }
        }
    }
  }
  return errInfo;
};
var validator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  lng,
  lat,
  int,
  decimal,
  len,
  phone,
  tel,
  email,
  idCard,
  ipv4,
  ipv6,
  url,
  postcode,
  base64
}, Symbol.toStringTag, { value: "Module" }));
const errPrefix = `[${name}] `;
var getMediaDuration = (file) => {
  let src;
  if (file instanceof File) {
    src = URL.createObjectURL(file);
  } else if (!url(file)) {
    src = file;
  } else {
    console.error(`${errPrefix}\u83B7\u53D6\u5A92\u4F53\u65F6\u957F\u5931\u8D25\uFF1A`, file);
    return;
  }
  return new Promise((resolve, reject) => {
    const media = document.createElement("video");
    media.preload = "metadata";
    media.onloadedmetadata = () => {
      window.URL.revokeObjectURL(media.src);
      resolve(media.duration);
    };
    media.src = src;
  });
};
function isRelativePath(path) {
  return path.startsWith(".") || path.startsWith("/") && !path.startsWith("//");
}
var isSameOrigin = (url2) => {
  if (url2) {
    return window.origin === (isRelativePath(url2) ? window.origin : new URL(url2).origin);
  } else {
    return false;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function lowerCase(str) {
  return str.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
function pascalCaseTransform(input, index) {
  var firstChar = input.charAt(0);
  var lowerChars = input.substr(1).toLowerCase();
  if (index > 0 && firstChar >= "0" && firstChar <= "9") {
    return "_" + firstChar + lowerChars;
  }
  return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
}
function camelCaseTransform(input, index) {
  if (index === 0)
    return input.toLowerCase();
  return pascalCaseTransform(input, index);
}
function camelCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
}
function validateProp({
  type,
  name: name2,
  prop,
  validator: validator2
}) {
  if (type) {
    if (typeOf(type) === "string") {
      type = [type];
    }
    const actualType = typeOf(prop);
    if (!type.includes(actualType)) {
      throw Error(`${name2}\u9700\u4E3A${type.toString()}\u7C7B\u578B\uFF08\u5F97\u5230${actualType}\uFF09`);
    }
  }
  if (validator2 && !validator2(prop)) {
    throw Error(`${name2}\u4E0D\u5408\u6CD5`);
  }
}
function MergeObject(sources, {
  mergeObject,
  mergeFunction
}) {
  const customizer = mergeFunction ? (objValue, srcValue) => typeOf(objValue) === "function" || typeOf(srcValue) === "function" ? mergeFunction(srcValue, objValue) : void 0 : void 0;
  return mergeObject === "deep" ? mergeWith(...sources, customizer) : assignInWith(...sources, customizer);
}
function MergeFunction(sources, {
  mergeFunction
}) {
  return sources.reduce(mergeFunction, () => {
  });
}
function getFinalProp(propSequence, config = {}) {
  let {
    name: name2 = "",
    type,
    default: defaultValue,
    defaultIsDynamic = false,
    required = false,
    validator: validator2,
    camelCase: camelCase$1 = true,
    mergeObject = "deep",
    mergeObjectApplyOnlyToDefault = false,
    mergeFunction = false,
    mergeFunctionApplyOnlyToDefault = true
  } = config;
  let propSequenceCopy;
  if (defaultIsDynamic) {
    if (typeOf(defaultValue) !== "function") {
      throw Error(`${name2}\u52A8\u6001\u751F\u6210\u9ED8\u8BA4\u503C\u65F6\uFF0C\u9ED8\u8BA4\u503C\u9700\u4E3A\u51FD\u6570\u7C7B\u578B`);
    }
    propSequenceCopy = [...propSequence];
  } else {
    propSequenceCopy = [...propSequence, defaultValue];
  }
  let result, isPlainObjectArray = false, isFunctionArray = false;
  for (let i = 0; i < propSequenceCopy.length; i++) {
    const v = propSequenceCopy[i];
    if (v !== void 0) {
      validateProp({
        type,
        name: name2,
        prop: v,
        validator: validator2
      });
      const itemIsPlainObject = isPlainObject(v);
      const itemIsFunction = typeOf(v) === "function";
      isPlainObjectArray = itemIsPlainObject;
      isFunctionArray = itemIsFunction;
      if (!itemIsPlainObject && !itemIsFunction) {
        break;
      }
    }
  }
  if (isPlainObjectArray) {
    propSequenceCopy = cloneDeep(propSequenceCopy);
  } else {
    mergeObject = false;
    if (!isFunctionArray) {
      mergeFunction = false;
    }
  }
  for (let i = 0; i < propSequenceCopy.length; i++) {
    const prop = propSequenceCopy[i];
    if (prop !== void 0) {
      if (i === propSequenceCopy.length - 1) {
        result = prop;
      } else if (mergeObject) {
        result = MergeObject(mergeObjectApplyOnlyToDefault ? [defaultValue, prop] : [...propSequenceCopy].reverse(), {
          mergeObject,
          mergeFunction
        });
      } else if (mergeFunction) {
        result = MergeFunction(mergeFunctionApplyOnlyToDefault ? [prop, defaultValue] : propSequenceCopy, {
          mergeFunction
        });
      } else {
        result = prop;
      }
      break;
    }
  }
  if (required && result === void 0) {
    throw Error(`${name2}\u53C2\u6570\u4E0D\u80FD\u4E3A\u7A7A`);
  }
  if (defaultIsDynamic) {
    return getFinalProp(propSequence, __spreadProps(__spreadValues({}, config), {
      default: defaultValue(result),
      defaultIsDynamic: false
    }));
  } else {
    return camelCase$1 && isPlainObject(result) ? mapKeys(result, (v, k) => camelCase(k, {
      stripRegexp: new RegExp()
    })) : result;
  }
}
function getGlobalAttrs(globalConfig, $props) {
  let result = {};
  Object.keys(globalConfig).filter((v) => !Object.keys($props).includes(v)).map((v) => {
    result[v] = globalConfig[v];
  });
  return result;
}
export { getFinalProp, getGlobalAttrs, getMediaDuration, isEllipsis, isEmpty, isSameOrigin, jsonToFormData, loadLink, loadScript, loadStyle, notEmpty, parseQueryString, pickDeepBy, typeOf, validator, waitFor };
